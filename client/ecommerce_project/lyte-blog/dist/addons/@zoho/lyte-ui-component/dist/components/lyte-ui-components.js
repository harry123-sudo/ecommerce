Lyte.Component.register("lyte-layout", {
_template:"<template tag-name=\"lyte-layout\"> <template is=\"for\" items=\"{{ltPropDivision}}\" item=\"row\" index=\"rowindex\"> <lyte-layout-row lt-prop-colarray=\"{{row}}\" class=\"lyte-row\" lt-prop-colsize=\"{{ltPropSize}}\"> <template is=\"registerYield\" yield-name=\"col\"> <template is=\"for\" items=\"{{row}}\" item=\"col\" index=\"colindex\"><template is=\"if\" value=\"{{expHandlers(colIndex,'==',colindex)}}\"><template case=\"true\"> <lyte-yield yield-name=\"lyte-row{{rowindex}}-col{{colindex}}\" class=\"lytecol-yield\"></lyte-yield> </template></template> </template> </template> </lyte-layout-row> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}]},{"type":"componentDynamic","position":[1]}]}],
_observedAttributes :["ltPropDivision","ltPropSize","ltPropContainerClass"],
	data : function(){
		return {
			
			'ltPropDivision' : Lyte.attr('array',{'default' : [] }),
			'ltPropSize' : Lyte.attr('string',{'default':'small'}),
			'ltPropContainerClass' : Lyte.attr('object',{'default':{'small':'lyte-container-sm','medium':'lyte-container-md','large':'lyte-container-lg','xlarge':'lyte-container-xl','fluid':'lyte-container-fluid'}})		
		}		
	},
	init : function(){
		
		this.$node.style.display = 'block';
		

	},
	onChangeSize: function(){
		var size =  this.getData('ltPropSize');
		this.removesizeclass();
		if(size === "fluid"){
			this.$node.classList.add('lyte-container-fluid');
		}else if(size === 'medium'){
			this.$node.classList.add('lyte-container-md');
		}else if(size === 'large'){
			this.$node.classList.add('lyte-container-lg');
		}else if(size === 'xlarge'){
			this.$node.classList.add('lyte-container-xl');
		}else if(size === 'small'){
			this.$node.classList.add('lyte-container-sm');
		}else{
			this.$node.classList.add('lyte-container');
			this.setData('ltPropSize','default');
		}
	}.observes('ltPropSize').on('init'),
	removesizeclass : function(){
		var sizeclass = this.$node.className;
		var regex =  /lyte-container-(lg|md|fuild|md|xl|sm)/i;
		var size = sizeclass.match(regex) || [];
		switch(size[size.length-1]){
			case 'fuild':
				this.$node.classList.remove('lyte-container-fluid');
				break;
			case 'lg':
				this.$node.classList.remove('lyte-container-lg');
				break;
			case 'md':
				this.$node.classList.remove('lyte-container-md');
				break;
			case 'sm':
				this.$node.classList.remove('lyte-container-sm');
				break;
			case 'xl':
				this.$node.classList.remove('lyte-container-xl');
				break;
			default:
				this.$node.classList.remove('lyte-container');
		}
	}
	
});



Lyte.Component.register("lyte-layout-row", {
_template:"<template tag-name=\"lyte-layout-row\"> <template is=\"for\" items=\"{{ltPropColarray}}\" item=\"col\" index=\"index\"> <template is=\"if\" value=\"{{lyteUiRowLength(col)}}\"><template case=\"true\"> <div class=\"lyte-{{ltPropDivsize[ltPropColsize]}}-{{col}} lyterow-yield\"> <lyte-yield yield-name=\"col\" col-index=\"{{index}}\" class=\"lytecol-yield\"> </lyte-yield> </div> </template><template case=\"false\"> <div class=\"lyte-col lyterow-yield\"> <lyte-yield yield-name=\"col\" col-index=\"{{index}}\" style=\"width: 100%;\"> </lyte-yield> </div> </template></template> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"insertYield","position":[1,1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"insertYield","position":[1,1]}]}},"default":{}}]}],
_observedAttributes :["ltPropColarray","ltPropDivision","sum","ltPropColsize","ltPropDivsize"],
	data : function(){
		return {
			'ltPropColarray' : Lyte.attr('array',{'default':[]}),
			'ltPropDivision' : Lyte.attr('array'),
			'sum' : Lyte.attr('number',{'default':0}),
			'ltPropColsize' : Lyte.attr('string',{'default':'fluid'}),
			'ltPropDivsize' : Lyte.attr('object',{'default':{'fluid':'col','small':'smcol','medium':'mdcol','large':'lgcol','xlarge':'xlcol','default':'col'}})
		}		
	}


});
window._lyteUiUtils = window._lyteUiUtils || { version : "3.35.1" };

( function() {
	var defaultValueCache = {};

	_lyteUiUtils.resolveDefaultValue = function( componentName, propertyName, componentDefaultValue ) {
		var valueMap = defaultValueCache[ componentName ] || {};

		if( propertyName in valueMap ) {
			return clone( valueMap[ propertyName ] );
		}

		return componentDefaultValue;
	}

	_lyteUiUtils.registerDefaultValues = function( obj ) {
		for( var componentName in obj ) {
			var defaultValueMap = obj[ componentName ];

			defaultValueCache[ componentName ] = defaultValueMap;
		}
	}

	var clone = function( org ) {
		var type = typeof org, result = {};

		if( type !== 'object' ) {
			return org;
		}

		// TODO: This can break. Need to deep clone.
		for( var key in org ) {
			result[ key ] = org[ key ];
		}

		return result;
	}

} )();

_lyteUiUtils.getVisibleDropdowns = function() {
	var dropboxes = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' ), res = [], dropdown;

	for( var i = 0; i < dropboxes.length; i++ ) {
		dropdown = dropboxes[ i ].origindd;

		if( dropdown ) {
			res.push( dropdown );
		}
	}

	return res;
}

_lyteUiUtils.closeDropdowns = function() {
	var dropdowns = _lyteUiUtils.getVisibleDropdowns() || [];

	for( var i = 0; i < dropdowns.length; i++ ) {
		dropdowns[ i ].close();
	}
}



_lyteUiUtils.i18n = function(key,componentName) {
	var keyName=(componentName?("lyte."+componentName+"."+key):key),
	ret =  _lyteUiComponentsLocale[ !keyName? '':keyName ];
	return ret? ret: key;
}

_lyteUiUtils.getRTL = function(){
	if( this.Rtl != undefined && this.Rtl != null ) {
		return this.Rtl;
	}
	return this.Rtl = ( window.getComputedStyle( document.body ).getPropertyValue( 'direction' ) == 'rtl' );
}

_lyteUiUtils.isIos = /ip(hone|ad|od)/i.test( navigator.userAgent ) || ( /macintosh/i.test( navigator.userAgent ) && 'ontouchend' in document );

_lyteUiUtils.isAndroid = /android/i.test( navigator.userAgent );

_lyteUiUtils.isMobile =  _lyteUiUtils.isIos || _lyteUiUtils.isAndroid;


_lyteUiUtils.escape = function( str ){
	return ( str || '' ).replace(/(\\|\'|\"|\?)/g, '\\$1');
}

_lyteUiUtils.appendChild = function( outlet, component ){
	if(Lyte.Component && Lyte.Component.appendChild){
		return Lyte.Component.appendChild( outlet, component );
	}
	else {
		return LyteComponent.appendChild( outlet, component );
	}
}

_lyteUiUtils.insertBefore = function( outlet, component ){
	if(Lyte.Component && Lyte.Component.insertBefore){
		return Lyte.Component.insertBefore( outlet, component );
	}
	else {
		return LyteComponent.insertBefore( outlet, component );
	}
}

_lyteUiUtils.insertAfter = function( outlet, component ){
	if(Lyte.Component && Lyte.Component.insertAfter){
		return Lyte.Component.insertAfter( outlet, component );
	}
	else {
		return LyteComponent.insertAfter( outlet, component );
	}
}
_lyteUiUtils.getScrollBarWidth = function( ){
	if( this._scrollwidth != undefined ){
		return this._scrollwidth;
	}
	var e = document.createElement("p");
    e.style.width = "100%";
    e.style.height = "200px";
    var t = document.createElement("div");
    t.style.position = "absolute";
    t.style.top = "0px"
    t.style.left = "0px"
    t.style.visibility = "hidden"
    t.style.width = "200px"
    t.style.height = "150px"
    t.style.overflow = "hidden"
    t.appendChild(e)
    document.body.appendChild(t);
    var a = e.offsetWidth;
    t.style.overflow = "scroll";
    var i = e.offsetWidth;
    a == i && (i = t.clientWidth)
    document.body.removeChild(t)
    this._scrollwidth = a - i;
    return this._scrollwidth;
}

_lyteUiUtils.replaceWith = function( outlet, component ){
	if(Lyte.Component && Lyte.Component.replaceWith){
		return Lyte.Component.replaceWith( outlet, component );
	}
	else {
		return LyteComponent.replaceWith( outlet, component );
	}
}

_lyteUiUtils.registeredCustomElements =  _lyteUiUtils.registeredCustomElements || {};

_lyteUiUtils.mergeObjects = function( oldObj, newObj ) {
	var result = {};

	for( var key in newObj ) {
		result[ key ] = newObj[ key ];
	}

	for( var key in oldObj ) {
		if( !( key in newObj ) ) {
			result[ key ] = false;
		}
	}

	return result;
}

_lyteUiUtils.setAttribute = function( element, newAria, oldAria ){
	var attributeList = _lyteUiUtils.mergeObjects( oldAria, newAria );

	for( var attribute in attributeList ) {
		if( attributeList[ attribute ] === false ) {
			element.removeAttribute( attribute )
		}
		else {
			element.setAttribute( attribute, attributeList[ attribute ] );
		}
	}
}

_lyteUiUtils.trapFocus = function( evt, node ){
    var focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex]:not([tabindex="-1"]), *[contenteditable]';
    var parent = node || LytePopup.components[LytePopup.components.length-1].actualModalDiv;

    // get list of focusable items
    var focusableItems;
    focusableItems = $L(parent.querySelectorAll(focusableElementsString)).filter(function(ind, item){ return $L(item).is(':visible') && (item.tabIndex != -1) && !(item.disabled) });

    if(focusableItems.length == 0){
        return;
    }
    if(node){
        if(focusableItems.length > 1 && (focusableItems[0].classList.contains('lyteModalClose') || focusableItems[0].classList.contains('lytePopoverClose'))){
            focusableItems[1].focus();
        }
        else{
            focusableItems[0].focus();
        }
        return;
    }

    // get currently focused item
    var focusedItem = document.activeElement;

    if(!(parent.contains(focusedItem))){
        // LytePopup.initializeFocus(parent);

        //Initialize Focus
        if(parent.classList.contains('lyteModal') || parent.classList.contains('lytePopover')){
            _lyteUiUtils.trapFocus(null, parent);
        }
        else if(parent.classList.contains('alertPopup')){
            var buttons = parent._callee.ltProp('buttons');
            for(var i = 0; i<buttons.length; i++){
                if(buttons[i].type == "accept"){
                    parent.querySelectorAll('button')[i].focus();
                    break;;
                }
            }
        }
        return;
    }

    // get the number of focusable items
    var numberOfFocusableItems = focusableItems.length;

    // get the index of the currently focused item
    var focusedItemIndex;
    for(var i = 0; i < focusableItems.length; i++){
        if(focusableItems[i] == focusedItem){
            focusedItemIndex = i;
            break;
        }
    }

    if (evt.shiftKey) {
        //back tab
        // if focused on first item and user preses back-tab, go to the last focusable item
        if (focusedItemIndex == 0) {
            focusableItems.get(numberOfFocusableItems - 1).focus();
            evt.preventDefault();
        }

    } else {
        //forward tab
        // if focused on the last item and user preses tab, go to the first focusable item
        if (focusedItemIndex == numberOfFocusableItems - 1) {
            focusableItems.get(0).focus();
            evt.preventDefault();
        }
    }
}

_lyteUiUtils.getBrowser = function(){
	//Check if browser is IE11
    if (navigator.userAgent.search("rv:11") >= 0) {
        return "ie";
    }
    //Check if browser is Edge
    if (navigator.userAgent.search("Edge") >= 0) {
        return "edge";
    }
    //Check if browser is Chrome || Opera
    else if (navigator.userAgent.search("Chrome") >= 0) {
        return "chrome";
    }
    //Check if browser is Firefox
    else if (navigator.userAgent.search("Firefox") >= 0) {
        return "firefox";
    }
    //Check if browser is Safari
    else if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
        return "safari";
    }
};

_lyteUiUtils.isNegativeScroll = function() {

    if( this._negativeScrollChrome != undefined ){
        return this._negativeScrollChrome;
    }

    var element =
    document.body.appendChild( $L( "<div style='position: absolute; left: 0; top: 0; overflow: hidden; width: 10px;height: 1px;'><div style='width: 20px; height: 1px;'></div></div>" ).get( 0 ) ),
    newChrome;

    element.scrollLeft = -5;
    newChrome = element.scrollLeft < 0;
    document.body.removeChild( element );
    this._negativeScrollChrome = newChrome;
    return newChrome;
}

_lyteUiUtils.getCorrectNumberCode = function( code ){
    if( code >= 96 && code <= 105 ){
        return code - 48;
    }
    return code;
}

_lyteUiUtils.capitalize = function( str ){
	return ( str || '' ).replace( /^./, function( match ){
		    return match.toUpperCase();
	});
}

Lyte.Component.registerHelper("lyteUiReturnOnlyKey",function(item){
	var objectkeys = Object.keys(item)
	if(objectkeys)
		{
			return objectkeys[0]
		}
	else
		{
			return false
		}
});
Lyte.Component.registerHelper("lyteUiReturnOnlyValue",function(item){
	var objectkeys = Object.keys(item)
	return item[objectkeys[0]]
});

/**
 * Helper to return url when flag is true
 * @param {string} url - The url to return
 * @param {boolean} flag - True returns the URL , false returns an empty string
 *
 */

Lyte.Component.registerHelper( 'lyteUiSetURL', function( url, flag ) {

	if( flag ) {
		return url;
	} else {
		return '';
	}

} );


/**
 * Helper to check if an entire row in the calendar is empty or not
 * @param {object} vector - an array of objects where each object contains a particular date
 *
 */

Lyte.Component.registerHelper( 'lyteUiCheckEmpty', function( vector ) {
	return vector && vector[ 0 ].emptyBlock && vector[ 6 ].emptyBlock;
} );

Lyte.Component.registerHelper( 'lyteUiDisableCalendarNav', function( viewDate, dir ) {
	var viewYear = viewDate.getFullYear(),
	viewMonth = viewDate.getMonth(),
	isYY = this.component.isYYFormat(),
	isHavingTimezone = this.component.isHavingTimezone,
	currentYear = isHavingTimezone ? Number( $L.moment().format( 'YYYY' ) ) : new Date().getFullYear(),
	max, bounds;

	if( isYY ) {
		max = isHavingTimezone ? $L.moment() : { uL: 19, lL: 80 };
		bounds = { minYear: currentYear - max.lL, maxYear: currentYear + max.uL };
	}
	else {
		bounds = { minYear: 1900, maxYear: 2100 };
	}

	if( ( dir === 'previous' && viewYear === bounds.minYear && viewMonth === 0 ) || ( dir === 'next' && viewYear === bounds.maxYear && viewMonth === 11 ) ) {
		return 'lyteCalDisableNav';
	}
} );


Lyte.Component.registerHelper("lyteUiI18n",function(key,componentName){
	return _lyteUiUtils.i18n(key,componentName);
});

Lyte.Component.registerHelper("lyteUiOptGroupCheck", function(content){
		if(content.constructor == Object)
            {
              if(Object.keys(content).length == 1)
	              {
	              	var value = content[Object.keys(content)[0]]
	              	if(value.constructor == Object || value.constructor == Array)
	                  {
	                      return true
	                  }
	               }
            }
        return false
});
Lyte.Component.registerHelper("lyteUiCheckForType",function(item,ltPropUserValue,ltPropSystemValue,section){
	if(section){
		var count = 0;
		var tcount = 0;
		for(var key in item){
			tcount++;
			if(key == ltPropUserValue){
				count++;
			}
			if(key == ltPropSystemValue){
				count++;
			}
		}
		if(count == 2 || tcount != 1){
			return false;
		}
		else{
			return true
		}
	}
	else{
		if(typeof item == "object"){
			return true
		}
		else{
			return false
		}
	}
});
Lyte.Component.registerHelper("lyteListBoxIndex" , function(ind,parentInd){
// Created by suren to use in lyte-listbox
	if(parentInd || parentInd === 0){
		return parentInd +" "+ ind;
	}
	return ind;

});
Lyte.Component.registerHelper("lyteListBoxParentIndex" , function(th,data,name){
// Created by suren to use in lyte-listbox
	if(data[name]){
		return data[name];
	}
	return '';

});
Lyte.Component.registerHelper("lyteUiChildPadding", function(treeIcon) {

	if ( treeIcon === 'Arrow' ) {
		return "padding-left:20px;";
	} else if (treeIcon === 'Plus') {
		return "padding-left:25px;";
	} else {
		return "padding-left:27px;";
	}
});
Lyte.Component.registerHelper("lyteUiHaveChildren", function(treeData,key) {

	if ( treeData[key] && treeData[key].length > 0 ) {

		return true;
	}
	return false;
});
Lyte.Component.registerHelper("lyteUiIsObject", function(obj) {

	if ( Object.prototype.toString.call(obj) === "[object Object]" ) {
		return true;
	} else {
		return false;
	}
});
Lyte.Component.registerHelper("lyteUiIsArray", function(obj) {

	if ( Object.prototype.toString.call(obj) === "[object Array]") {
		return true;
	} else {
		return false;
	}
});
Lyte.Component.registerHelper('lyteUiGiveProper',function(full,val){
	var returnval = []
	for(var i=0;i<full.length;i++){
		if(full[i].menu == val){
			returnval.push(full[i])
		}
	}
	return returnval
});
Lyte.Component.registerHelper('lyteUiAddClassModal',function(className,show,drag){
	var resp = className;
	if(drag){
		resp += " draggable";
	}
	if(show){
		resp += " "+className+"Show";
	}
	return resp;
});


Lyte.Component.registerHelper('lyteUiAddShowClass',function(a,b,c){		//Used in alert and colorbox thumbnail
	if(a === true){
		return b+" "+c;
	}
	return b;
});


Lyte.Component.registerHelper('lyteUiCatwise',function(a,b){
    if(a==b[this.get('ltPropCategory')]){
        return true
    }
      else {
        return false
    }
});

Lyte.Component.registerHelper('lyteUiCheckClassForDate',function(val){
	if(!val){
		return false;
	}
	if(val.indexOf('lyteCalGray') != -1){
		return true
	}
	return false
});


Lyte.Component.registerHelper('lyteUiConcat',function(){	//Used in ProgressBar
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
});


Lyte.Component.registerHelper('lyteUiConcatTypeClass',function(a,b,c){	//Used in Alert
	if(a!==""){
		return a+b+" "+c;
	}
	return c;
});

Lyte.Component.registerHelper('lyteUiGetContainerClass',function(setselect,classval){
	var toRet=''
	if(!classval){
		classval = ''
	}
    if(setselect==true){
    	toRet = 'lyteDropdownContainer tick-selection ' + classval
    }
    else{
    	toRet = 'lyteDropdownContainer ' + classval
    }
    return toRet

});

Lyte.Component.registerHelper('lyteUiGetDropdownClass',function(arg1){
	if(arg1 && arg1.toString().toLowerCase()  == "true"){
		return 'lyteDropdownElement1 lyteDropdown-disabled'
	}
	else{
		return 'lyteDropdownElement1'
	}
});


Lyte.Component.registerHelper('lyteUiIfEquals',function(a,b){	//Used in alert,messagebox,progressbar,rating
	return a === b;
});

Lyte.Component.registerHelper('lyteUiLabelCheck',function(a,b){
	if(a==b){
		return true;
	}
	else {
		return false
	}
});

Lyte.Component.registerHelper('lyteUiObjectCheck',function(a){
    if(typeof a==='string'){
        return true;
    }
    else {
        return false
    }
});

Lyte.Component.registerHelper('lyteUiReturnValueBy',function(content,key){
	if(key || key == 0){
		return content[key]
	}
	else{
		return content
	}
});
// Lyte.Component.registerHelper('lyteUiHeaderCheck',function(value){
// 	if(value)
// 		{
// 			return true;
// 		}
// 	else
// 		{
// 		return false;
// 		}
// });

Lyte.Component.registerHelper('lyteUiSetWH',function(radius){	//Used in progressbar
	return parseInt(radius) * 2;
});
Lyte.Component.registerHelper('lyteUiSetRadius',function(radius,stroke){	//Used in progressbar
	return parseInt(radius)-parseInt(stroke)/2;
});
Lyte.Component.registerHelper('lyteUiSetDashArray',function(radius,stroke){		//Used in progressbar
	var r = parseInt(radius)-parseInt(stroke)/2;
	return  2 * 3.14159 * r;
});
Lyte.Component.registerHelper('lyteUiSetOffset',function(radius,stroke,value){	//Used in progressbar
	var r = parseInt(radius)-parseInt(stroke)/2;
	var strokeDash =  2 * 3.14159 * r;
	return strokeDash * (1 - parseInt(value)/100);
});

Lyte.Component.registerHelper('lyteUiTextTransform',function(radius){	//Used in progressbar
	return 'translate(0,-'+parseInt(radius) * 2+'px)';
});
Lyte.Component.registerHelper('lyteUiMakeSortable',function(elementId){
	console.log(elementId);
	document.getElementById(elementId).classList.add('sortable');
	return true;
});
Lyte.Component.registerHelper("lyteUiCheckTabPosition",function(position){
	if(position.pos === "bottom"){
		return false;
	}
	else{
		return true;
	}
});

Lyte.Component.registerHelper('lyteUiGetValue',function(object, key){
	return object[key]
});


Lyte.Component.registerHelper('lyteUiIsEmptyArray',function(obj){	//Used in alert
     return obj.length == 0;
});

Lyte.Component.registerHelper("lyteUiRgbToHex",function(item){	//Used in colorpicker
	var hexValue = "#";
	if(/rgba/.test(item)){
		var valArray = item.substring(5,item.length-1).split(",");
		for(var i=0;i<3;i++){
			var val = parseInt(valArray[i]).toString(16).toUpperCase();
			if(val.length < 2){
				val = "0"+val;
			}
			hexValue += val;
		}
		var alpha = Math.round(parseFloat(valArray[3]) * 255);
		hexValue += (alpha + 0x10000).toString(16).substr(-2).toUpperCase();
	}
	else if(/rgb/.test(item)){
		var valArray = item.substring(4,item.length-1).split(",");
		for(var i=0;i<3;i++){
			var val = parseInt(valArray[i]).toString(16).toUpperCase();
			if(val.length < 2){
				val = "0"+val;
			}
			hexValue += val;
		}
	}
	return hexValue;
});

Lyte.Component.registerHelper("lyteUiCPInsertBreak",function(index){	//Used in colorpicker
	if((index + 1)%10 == 0){
		return true;
	}
	return false;
});
Lyte.Component.registerHelper("lyteUiCheckInRange",function(start,end,current,form){
	var comp = this.component;

	start = start || '';
	end = end || '';

	if(start === '' && end === ''){
		return true;
	}
	else if(start !== '' && end === ''){
		var startDate = comp.stringToDate( start, form )
		var currentDate = comp.stringToDate( current, form )
		if(currentDate >= startDate){
			return true
		}
	}
	else if(start !== '' && end !== ''){
		var startDate = comp.stringToDate( start, form )
		var endDate = comp.stringToDate( end, form )
		var currentDate = comp.stringToDate( current, form )
		if(currentDate >= startDate && currentDate <= endDate){
			return true
		}
	}
	else {
		var endDate = comp.stringToDate( end, form )
		var currentDate = comp.stringToDate( current, form )
		if(currentDate <= endDate){
			return true
		}
	}
	return false
});

Lyte.Component.registerHelper("lyteUiIsEmptyObject",function(item){		//Used in dropdown,popover
	for(var key in item) {
        if(item.hasOwnProperty(key)){
            return false;
        }
    }
    return true;
});
Lyte.Component.registerHelper("lyteUiCheckDisabled",function(list,value){
	for(var i = 0; i<list.length; i++){
		if(value === list[i]){
			return "true";
		}
	}
    return "false";
});

Lyte.Component.registerHelper("lyteUiTreeLevelHelp",function(varr,index){
	if(varr !== ""){
		var level = varr + " " + index++;
		var arr = level.split(' ')
		return arr.length-1;
	}
	return 0;
});

Lyte.Component.registerHelper("lyteUiTreeMaxLevelHelp" , function(varr , index , maxLevel){
	var level = varr + " " + index++;
	var arr = level.split(' ')
	if(arr.length <= maxLevel){
		return true;
	}
	return false;
})

Lyte.Component.registerHelper("lyteUiTreeClassHelp",function(state,col,open,close){
	if((state === "open")||!col){
		return open;
	} else {
		return close;
	}
});

Lyte.Component.registerHelper("lyteTreeMaxChild" , function(varr,index,maxLevel){
	var level = varr + " " + index++;
	var arr = level.split(' ')
	if(arr.length-1 >= maxLevel){
		return "lyteTreeMaxedChild";
	}
	return '';
}),

Lyte.Component.registerHelper("lyteUiTreeIndexHelp",function(varr,index){
	return (varr + " " + index++).trim() ;
});

Lyte.Component.registerHelper("lyteUiTreeHasChildHelp",function(val){
	if(val.hasChild){
		return 'lyteTreeHasChild'
	}
	return "";
});

Lyte.Component.registerHelper("lyteUiTreeChildHelp",function(val,className,child){

	if(((val[child] === undefined)||(val[child].length === 0)) && !val.hasChild){
		return className;
	}

	return '';

});

Lyte.Component.registerHelper( 'stringify', function( obj ){
	return JSON.stringify( obj );
});

Lyte.Component.registerHelper("lyteUiConcatAlertClass",function(val,Aclass){		//Used in alert
	return (val == "center" ? "lyteAlertCenterContent" : "") +" "+Aclass;
});

Lyte.Component.registerHelper( 'lyteUiSetIndexString', function( index, total ) {	//Used in colorbox
	return (index+1)+" of "+total;
} );

Lyte.Component.registerHelper("lyteUiRTL",function(){
	return _lyteUiUtils.getRTL();
});
// LyteComponent.registerHelper("lyteIsIos",function(){
// 	return _lyteUiUtils.isIos();
// });


Lyte.Component.registerHelper("lyteIsIos",function(){
	return _lyteUiUtils.isIos;
});

Lyte.Component.registerHelper("lyteIsAndroid",function(){
	return _lyteUiUtils.isAndroid;
});

Lyte.Component.registerHelper("lyteUiGetMonthOrYear",function(header, cond){
	if(cond == "M"){
		return header.split(" ")[0];
	}
	else{
		return header.split(" ")[1];
	}
});
Lyte.Component.registerHelper("lyteUiDisplayOrHide",function(color){
	if(color == "rgba(0, 0, 0, 0)"){
		return "lyteColorPicker__colorpan lyteColorPicker__hide";
	}
	else{
		return "lyteColorPicker__colorpan";
	}
});

Lyte.Component.registerHelper('lyteUiMsgBoxConcatClass',function(a,b,c,d){	//Used in messagebox
	if(b!==""){
		return a+" "+b+c+" "+d;
	}
	return a+" "+d;
});

Lyte.Component.registerHelper( 'lyteUiFileSize', function( curr, def, dgt ){
	var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], idx = 0;
	if( def ) {
		idx = Math.max( idx, sizes.indexOf( def ) );
	} else {
		idx = Math.floor( Math.log( curr ) / Math.log( 1000 ) )
	}
	if( idx == 0 && curr == 1 ){
		return "1 Byte";
	}
	return ( parseInt( curr / Math.pow( 1000 , idx ) * Math.pow( 10, dgt ) ) / Math.pow( 10, dgt ) ) + ' ' + sizes[ idx ];

});

Lyte.Component.registerHelper('lyteUiAddClassRating',function(node,wrapper,readOnly){		//Used in rating\
	var resp = "";
	if(node.className != "{{dummy}}"){
		resp = node.className;
	}
	if(wrapper){
		resp += " " + wrapper;
	}
	if(readOnly){
		if(resp.indexOf("lyteRatingReadOnly") == -1){
			resp += " lyteRatingReadOnly";
		}
		// return "lyteRatingReadOnly";
	}
	else{
		if(resp.indexOf("lyteRatingReadOnly") != -1){
			resp = resp.replace("lyteRatingReadOnly","");
		}
	}
	return resp;
});


Lyte.Component.registerHelper('lyteUiGetArrayValueByIndex',function(array,index){	//Used in rating
	return array[index%array.length];
});
Lyte.Component.registerHelper('lyteUiIfEqualsAny',function(){	//Used in rating
	var value = arguments[0];
	for(i = 1; i < arguments.length; i++){
		if(value == arguments[i]){
			return true;
		}
	}
	return false;
});
Lyte.Component.registerHelper('lyteUiGetNextArrayValueByIndex',function(array,index){ //used in drawer
	return array[index+1];
});
Lyte.Component.registerHelper('lyteUiArrayLastIndex',function(array){ //used in drawer
 	return array.length-1;
});
Lyte.Component.registerHelper('lyteUiGetViewBox',function(type){ //used in rating
 	if(type === "heart"){
 		return "1.5 0.5 20 20";
 	}
 	if(type === "star"){
 		return "5.5 2.5 23 23";
 	}
 	return "0 0 21 21";
});
Lyte.Component.registerHelper('lyteUiGetFillOrStroke',function(type,color,stroke){ //used in rating
 	if(type === "heart" || type === "star"){
 		return "; fill:"+color+";";
 	}
 	if(type === "lineStar" || type === "lineHeart"){
 		return "; fill:transparent"+";"+"; stroke:"+ (stroke ? stroke : color) +";";
 	}
 	return "; stroke:"+ (stroke ? stroke : color) +";";
});
Lyte.Component.registerHelper('lyteUiCheckHalfRatingSvg',function(halfRating,precision){ //used in rating
 	if(halfRating && precision > 0 && precision < 1){
 		return true;
 	}
 	return false;
});
Lyte.Component.registerHelper('lyteUiProgressbarLabel',function(label,percentage,showPercentage){ //used in progressbar
 	if(label){
 		return label;
 	}
 	return (percentage + (showPercentage ? "%" : ""));
});

Lyte.Component.registerHelper('lyteUiGetStackValue',function(stack,index,prop){
	return index < stack.length && stack[index][prop];
});

Lyte.Component.registerHelper( 'lyteUiAttribute', function( value, aria ){
	if( aria ){
		return value ? value : false;
	}
	return false
} )

Lyte.Component.registerHelper('lyteUiAddPE', function(val){	//used to add pointer events none for no colors
	if(val === 'noColor'){
		return 'lyteColorPicker__pe'
	}
	return "";
});

Lyte.Component.registerHelper('lyteUiClockPairNumber', function(val) {
    if(val.length == 1) {
        val = (0 + val);
    }
    return val;
})

Lyte.Component.registerHelper( 'lyteUiDateRPHeaderClass', function( value ){
	if( value != "dropdown" ){
		return "lyteDateRPMonthHeader lyteDateRPStringHeader" ;
	}
	return "lyteDateRPMonthHeader";
} );

Lyte.Component.registerHelper( 'lyteUiSetAlphaLabel', function( value ){
	if( value ){
		return value ;
	}
	return _lyteUiUtils.i18n("Alpha");
} );
//lyte-layout
//lyte-layout-row
Lyte.Component.registerHelper( "lyteUiRowLength" , function( col_div ){
	var sum = this.getData('sum');
	col_div = parseInt(col_div ,10);
	this.setData('sum' , sum+col_div)
	return (col_div  && col_div < 12 && col_div > 0 && sum <= 12);

});

Lyte.Component.registerHelper( 'lyteUiImageFile', function( file ){
	if(file.src && file.fileType === "image" ) {
		return true;
	}
	return false;
});

Lyte.Component.registerHelper( 'lyteUiIsInArray', function( item, selected, sysValue ) {

	selected = selected || [];

	for( var i = 0; i < selected.length; i++ ) {
		if( selected[ i ][ sysValue ] === item[ sysValue ] ) {
			return true;
		}
	}

	return false;
} );

Lyte.Component.registerHelper('lyteUiCapitalizeName', function(name){
	return _lyteUiUtils.capitalize(name);
});

if(!LytePopup){
    var LytePopup = {
        components:[],
        bodywrapperCount:0,
        onEscape : function(evt){
            evt = evt || window.event;
            var isEscape = false;
            var isTabPressed = false;
            var isEnter = false;
            var activeElement = document.activeElement;
            if ("key" in evt) {
                isEscape = (evt.key == "Escape" || evt.key == "Esc");
                isTabPressed = (evt.key == "Tab");
                isEnter = (evt.key == "Enter");
            } else {
                isEscape = (evt.keyCode == 27);
                isTabPressed = (evt.keyCode == 9);
                isEnter = (evt.keyCode == 13);
            }
            if (isEscape) {
                LytePopup.closePopup(undefined,true);
            }
            if(isTabPressed && LytePopup.components.length > 0) {
                LytePopup.trapFocus(evt);
            }
            if(isEnter && activeElement && ( activeElement.classList.contains('alertClose') || activeElement.classList.contains('lyteModalClose') || activeElement.classList.contains('lytePopoverClose') )){
                activeElement.click();
            }
        },
        bindDocumentKeydown : function(){
            document.addEventListener('keydown',LytePopup.onEscape,true);
        },
        checkAndRemoveWrapper : function(){
            var elements = Array.from(document.querySelectorAll('.lyteAlertOpened')).concat(Array.from(document.querySelectorAll('.lyteModalOpened')), Array.from(document.querySelectorAll('.lytePopoverOpened')));
            if(elements.length == 0){
                document.body.classList.remove('bodyWrapper');
            }
            else{
                for(var i = 0; i < elements.length; i++){
                    if(elements[i].ltProp('freeze')){
                        return;
                    }
                }
                document.body.classList.remove('bodyWrapper');
            }
        },
        hideOrShowFreeze : function(cond, currComp, removedFromDom){
            var prevEleFreeze = '',val, currEleFreeze = '', prevElem = '', currElem = '';
            if(cond == "open" && LytePopup.components.length > 1){
                for(var i = LytePopup.components.length - 2 ; i >= 0; i--){
                    if(LytePopup.components[i].$node.tagName == "LYTE-MODAL"){
                        prevEleFreeze = 'lyte-modal-freeze';
                    }
                    else if(LytePopup.components[i].$node.tagName == "LYTE-POPOVER"){
                        prevEleFreeze = 'lyte-popover-freeze';
                    }
                    else{
                        prevEleFreeze = '.alertFreezeLayer';
                    }
                    if(currComp.$node.tagName == "LYTE-MODAL"){
                        currEleFreeze = 'lyte-modal-freeze';
                    }
                    else if(currComp.$node.tagName == "LYTE-POPOVER"){
                        currEleFreeze = 'lyte-popover-freeze';
                    }
                    else{
                        currEleFreeze = '.alertFreezeLayer';
                    }
                    prevElem = LytePopup.components[i].childComp.querySelector(prevEleFreeze);
                    currElem = currComp.childComp.querySelector(currEleFreeze);
                    val = currComp.getData('ltPropDimmer') && currComp.getData('ltPropDimmer').opacity ? currComp.getData('ltPropDimmer').opacity : "";
                    if(prevElem && currElem){
                        prevElem.style.transition = "none";
                        currElem.style.transition = "none";
                        prevElem.style.zIndex = 15;
                        prevElem.style.opacity = 0;
                        currElem.style.visibility = 'visible';
                        currElem.style.opacity = val;
                        setTimeout(LytePopup.removeTransition, 100, currElem, prevElem);
                        prevElem.style.zIndex = "";
                        currComp.addedFreezeDetails = true;
                        break;
                    }
                }
            }
            else if(cond == "close" && LytePopup.components.length > 1 && LytePopup.components[LytePopup.components.length-1] === currComp){
                for(var i = LytePopup.components.length - 2 ; i >= 0; i--){
                    if(LytePopup.components[i].$node.tagName == "LYTE-MODAL"){
                        prevEleFreeze = 'lyte-modal-freeze';
                    }
                    else if(LytePopup.components[i].$node.tagName == "LYTE-POPOVER"){
                        prevEleFreeze = 'lyte-popover-freeze';
                    }
                    else{
                        prevEleFreeze = '.alertFreezeLayer';
                    }
                    if(currComp.$node.tagName == "LYTE-MODAL"){
                        currEleFreeze = 'lyte-modal-freeze';
                    }
                    else if(currComp.$node.tagName == "LYTE-POPOVER"){
                        currEleFreeze = 'lyte-popover-freeze';
                    }
                    else{
                        currEleFreeze = '.alertFreezeLayer';
                    }
                    prevElem = LytePopup.components[i].childComp.querySelector(prevEleFreeze);
                    currElem = currComp.childComp.querySelector(currEleFreeze);
                    val = LytePopup.components[i].getData('ltPropDimmer') && LytePopup.components[i].getData('ltPropDimmer').opacity ? LytePopup.components[i].getData('ltPropDimmer').opacity : "";
                    if(prevElem && currElem){
                        currElem.style.transition = "none";
                        prevElem.style.transition = "none";
                        prevElem.style.zIndex = 15;
                        currElem.style.opacity = 0;
                        prevElem.style.visibility = "visible";
                        prevElem.style.opacity = val;
                        setTimeout(LytePopup.removeTransition, 100, currElem, prevElem);
                        prevElem.style.zIndex = '';
                        currElem.style.visibility = "";
                        break;
                    }
                    else{
                        if(prevElem && removedFromDom){
                            prevElem.style.transition = "none";
                            prevElem.style.zIndex = 15;
                            prevElem.style.visibility = "visible";
                            prevElem.style.opacity = val;
                            setTimeout(LytePopup.removeTransition, 100, currElem, prevElem);
                            prevElem.style.zIndex = '';
                            break;
                        }
                    }
                }
            }
        },
        removeTransition : function(currElem, prevElem){
            if(currElem){
                currElem.style.transition = "";
            }
            if(prevElem){
                prevElem.style.transition = "";
            }
        },
        addPopup : function(component) {
            LytePopup.closePopup();
            var compLengh = LytePopup.components.length;
            if(compLengh>0){
                var prevZIndex = 0;
                var prePopup = '', thisPopup = '';
                if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-MODAL"){
                    prePopup = '.modalWrapper';
                }
                else if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-POPOVER"){
                    prePopup = '.popoverWrapper';
                }
                else{
                    prePopup = '.alertWrapper';
                }

                if(component.$node.tagName == "LYTE-MODAL"){
                    thisPopup = '.modalWrapper';
                }
                else if(component.$node.tagName == "LYTE-POPOVER"){
                    thisPopup = '.popoverWrapper';
                }
                else{
                    thisPopup = '.alertWrapper';
                }
                var node = component.childComp.querySelector(thisPopup);
                prevZIndex = Number(document.defaultView.getComputedStyle(LytePopup.components[LytePopup.components.length-1].childComp.querySelector(prePopup),null).getPropertyValue('z-index'));
                if(prevZIndex+2 > Number(document.defaultView.getComputedStyle(node,null).getPropertyValue('z-index'))){
                    node.style.zIndex = prevZIndex+2;
                }
                // component.childComp.querySelector(thisPopup).style.zIndex = prevZIndex+2;
                // if(component.$node.ltProp('freeze') && component.childComp.querySelector(thisFreeze)){
                //     component.childComp.querySelector(thisFreeze).style.zIndex = prevZIndex+1;
                // }
            }
            LytePopup.components[compLengh] = component;
            if(component.getData('ltPropFreeze') || component.$node.tagName == "LYTE-ALERT"){
                LytePopup.hideOrShowFreeze("open", component)
            }
        },
        closePopup : function(component,fromEscape){
            if(fromEscape){
                var lastPop = LytePopup.components[LytePopup.components.length-1];
                if(lastPop && lastPop.$node.ltProp("closeOnEscape")){
                    lastPop.$node.ltProp("show",false);
                }
            }
            else{
                if(component){
                    var index = LytePopup.components.indexOf(component);
                    if(index > -1){
                        LytePopup.components.splice(index,1);
                    }
                }
                else{
                    for(var i=LytePopup.components.length-1;i>=0;i--){
                        if(LytePopup.components[i].$node && !LytePopup.components[i].$node.ltProp("allowMultiple")){
                            var comp = LytePopup.components[i];
                            // if(comp.$node.tagName == "LYTE-MODAL"){
                            //     LytePopup.components.splice(i,1);
                            // }
                            comp.$node.ltProp("show",false);
                        }
                    }
                }
            }
        },
        getScrollParent : function(node) {
            var isElement = node instanceof HTMLElement,
                overflowY = isElement && window.getComputedStyle(node).overflowY,
                isScrollable = overflowY !== 'visible' && overflowY !== 'hidden',
                scrollHeight = node && isScrollable ? node.scrollHeight : 0,
                clientHeight = node && isScrollable ? node.clientHeight : 0;

            if (!node) {
                return null;
            } else if (isScrollable && scrollHeight > clientHeight) {
                return node;
            }

            return LytePopup.getScrollParent(node.parentNode) || document.body;
        },
        trapFocus : function( evt, node ){
            var focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex]:not([tabindex="-1"]), *[contenteditable]';
            var parent = node || LytePopup.components[LytePopup.components.length-1].actualModalDiv;

            // get list of focusable items
            var focusableItems;
            focusableItems = $L(parent.querySelectorAll(focusableElementsString)).filter(function(ind, item){ return $L(item).is(':visible') && (item.tabIndex != -1) && !(item.disabled)});

            if(focusableItems.length == 0){
                return;
            }
            if(node){
                if(focusableItems.length > 1 && (focusableItems[0].classList.contains('lyteModalClose') || focusableItems[0].classList.contains('lytePopoverClose'))){
                    focusableItems[1].focus();
                }
                else{
                    focusableItems[0].focus();
                }
                return;
            }

            // get currently focused item
            var focusedItem = document.activeElement;
            var focusedParent;

            if(!(parent.contains(focusedItem))){
              focusedParent = $L(focusedItem).closest('lyte-drop-box')[0]
              if(focusedParent){
                focusedParent = focusedParent.origindd
              }
              if(!(parent.contains(focusedParent))){
                LytePopup.initializeFocus(parent);
                evt && evt.preventDefault();
                return;
              }
            }

            // get the number of focusable items
            var numberOfFocusableItems = focusableItems.length;

            // get the index of the currently focused item
            var focusedItemIndex;
            for(var i = 0; i < focusableItems.length; i++){
                if(focusableItems[i] == focusedItem){
                    focusedItemIndex = i;
                    break;
                }
            }

            if (evt.shiftKey) {
                //back tab
                // if focused on first item and user preses back-tab, go to the last focusable item
                if (focusedItemIndex == 0) {
                    focusableItems.get(numberOfFocusableItems - 1).focus();
                    evt.preventDefault();
                }

            } else {
                //forward tab
                // if focused on the last item and user preses tab, go to the first focusable item
                if (focusedItemIndex == numberOfFocusableItems - 1) {
                    focusableItems.get(0).focus();
                    evt.preventDefault();
                }
            }
        },
        initializeFocus : function(node){
            if(node.classList.contains('lyteModal') || node.classList.contains('lytePopover')){
                LytePopup.trapFocus(null, node);
            }
            else if(node.classList.contains('alertPopup')){
                var buttons = node._callee.ltProp('buttons');
                for(var i = 0; i<buttons.length; i++){
                    if(buttons[i].type == "accept"){
                        node.querySelectorAll('button')[i].focus();
                        break;;
                    }
                }
            }
        },
        transitionEnd : function(evt){
            if(evt.target == this && LytePopup.components.length > 0){
                var comp = LytePopup.components[LytePopup.components.length-1];
                var element = comp.actualModalDiv;
                !(comp.getData('ltPropPreventFocus')) && LytePopup.initializeFocus(element);
                this.removeEventListener( 'transitionend', LytePopup.transitionEnd );
            }
        },
        bindTransitionEnd : function(node){
            node && node.addEventListener( 'transitionend', LytePopup.transitionEnd );
        }
    };
    LytePopup.bindDocumentKeydown();
};

var ratingNum = 0;

_lyteUiUtils.convert_diacritics = function( str ){
    var diacritics = [
        { value : 'A',  regex : /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g },
        { value : 'AA', regex : /[\uA732]/g },
        { value : 'AE', regex : /[\u00C6\u01FC\u01E2]/g },
        { value : 'AO', regex : /[\uA734]/g },
        { value : 'AU', regex : /[\uA736]/g },
        { value : 'AV', regex : /[\uA738\uA73A]/g },
        { value : 'AY', regex : /[\uA73C]/g },
        { value : 'B',  regex : /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g },
        { value : 'C',  regex : /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g },
        { value : 'D',  regex : /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g },
        { value : 'DZ', regex : /[\u01F1\u01C4]/g },
        { value : 'Dz', regex : /[\u01F2\u01C5]/g },
        { value : 'E',  regex : /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g },
        { value : 'F',  regex : /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g },
        { value : 'G',  regex : /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g },
        { value : 'H',  regex : /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g },
        { value : 'I',  regex : /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g },
        { value : 'J',  regex : /[\u004A\u24BF\uFF2A\u0134\u0248]/g },
        { value : 'K',  regex : /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g },
        { value : 'L',  regex : /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g },
        { value : 'LJ', regex : /[\u01C7]/g },
        { value : 'Lj', regex : /[\u01C8]/g },
        { value : 'M',  regex : /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g },
        { value : 'N',  regex : /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g },
        { value : 'NJ', regex : /[\u01CA]/g },
        { value : 'Nj', regex : /[\u01CB]/g },
        { value : 'O',  regex : /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g },
        { value : 'OI', regex : /[\u01A2]/g },
        { value : 'OO', regex : /[\uA74E]/g },
        { value : 'OU', regex : /[\u0222]/g },
        { value : 'P',  regex : /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g },
        { value : 'Q',  regex : /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g },
        { value : 'R',  regex : /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g },
        { value : 'S',  regex : /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g },
        { value : 'T',  regex : /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g },
        { value : 'TZ', regex : /[\uA728]/g },
        { value : 'U',  regex : /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g },
        { value : 'V',  regex : /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g },
        { value : 'VY', regex : /[\uA760]/g },
        { value : 'W',  regex : /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g },
        { value : 'X',  regex : /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g },
        { value : 'Y',  regex : /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g },
        { value : 'Z',  regex : /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g },
        { value : 'a',  regex : /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g },
        { value : 'aa', regex : /[\uA733]/g },
        { value : 'ae', regex : /[\u00E6\u01FD\u01E3]/g },
        { value : 'ao', regex : /[\uA735]/g },
        { value : 'au', regex : /[\uA737]/g },
        { value : 'av', regex : /[\uA739\uA73B]/g },
        { value : 'ay', regex : /[\uA73D]/g },
        { value : 'b',  regex : /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g },
        { value : 'c',  regex : /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g },
        { value : 'd',  regex : /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g },
        { value : 'dz', regex : /[\u01F3\u01C6]/g },
        { value : 'e',  regex : /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g },
        { value : 'f',  regex : /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g },
        { value : 'g',  regex : /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g },
        { value : 'h',  regex : /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g },
        { value : 'hv', regex : /[\u0195]/g },
        { value : 'i',  regex : /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g },
        { value : 'j',  regex : /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g },
        { value : 'k',  regex : /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g },
        { value : 'l',  regex : /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g },
        { value : 'lj', regex : /[\u01C9]/g },
        { value : 'm',  regex : /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g },
        { value : 'n',  regex : /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g },
        { value : 'nj', regex : /[\u01CC]/g },
        { value : 'o',  regex : /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g },
        { value : 'oi', regex : /[\u01A3]/g },
        { value : 'ou', regex : /[\u0223]/g },
        { value : 'oo', regex : /[\uA74F]/g },
        { value : 'p', regex : /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g },
        { value : 'q', regex : /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g },
        { value : 'r', regex : /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g },
        { value : 's', regex : /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g },
        { value : 't', regex : /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g },
        { value : 'tz', regex : /[\uA729]/g },
        { value : 'u', regex : /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g },
        { value : 'v', regex : /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g },
        { value : 'vy', regex : /[\uA761]/g },
        { value : 'w', regex : /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g },
        { value : 'x', regex : /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g },
        { value : 'y', regex : /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g }
  ];

  diacritics.forEach( function( item ){
    str = str.replace( item.regex, item.value );
  });

  return str;
}

/**
 * Renders an accordion
 * @component lyte-accordion
 * @version 1.0.0
 * @methods onChanged,onOpen,onClose,onBeforeClose,onBeforeOpen,afterRender
 */

Lyte.Component.register( 'lyte-accordion', {
_template:"<template tag-name=\"lyte-accordion\"> <lyte-yield yield-name=\"yield\"> </lyte-yield> </template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropDuration","ltPropHeight","ltPropExclusive","ltPropYield","ltPropDynamic","ltPropNested"],
	data: function() {
		return {
			/**
			 * @componentProperty {string} ltPropDuration=0.2s
			 * @suffix s,ms
			 */

			'ltPropDuration': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'duration', '0.2s' ) 
			} ),

			/**
			 * @componentProperty {string} ltPropHeight
			 * @suffix px,pt,cm,mm,vh,vm,em
			 */

			'ltPropHeight': Lyte.attr( 'string' ),

			/**
			 * @componentProperty {boolean} ltPropExclusive=true
			 */

			'ltPropExclusive': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'exclusive', true ) 
			} ),

			'ltPropYield': Lyte.attr( 'boolean', { 
				'default': true 
			} ),

			/**
			 * @componentProperty {boolean} ltPropDynamic=false
			 * @version 2.2.0
			 */

			'ltPropDynamic': Lyte.attr( 'boolean', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'dynamic', false ) 
			} ),

			/**
			 * @componentProperty {boolean} ltPropNested=false
			 * @version 3.12.0
			 */

			'ltPropNested': Lyte.attr( 'boolean', {
				'default': false
			} )
		}
	},

	toggleCurrentPanel: function( header ) {
		header.click();
	},

	moveToNextPanel: function() {
		var headers = this.getAllHeaders(),
		totalHeaders = headers.length,
		currentIndex = this.getCurrentIndex( headers ),
		nextIndex = ( ( currentIndex + 1 ) === totalHeaders ) ? 0 : currentIndex + 1;

		headers[ nextIndex ].focus();
	},

	moveToPreviousPanel: function() {
		var headers = this.getAllHeaders(),
		totalHeaders = headers.length,
		currentIndex = this.getCurrentIndex( headers ),
		previousIndex = ( ( currentIndex - 1 ) < 0 ) ? totalHeaders - 1 : currentIndex - 1;

		headers[ previousIndex ].focus();
	},

	getCurrentIndex: function( headers ) {
		return headers.indexOf( document.activeElement );
	},

	getAllHeaders: function() {
		var item = this.$node.querySelector( 'lyte-yield' ),
		children = item.children, body, result = [];

		for( var i = 0; i < children.length; i++ ) {
			if( children[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {
				continue; 
			}

			body = children[ i ].querySelector( 'lyte-accordion-header' );

			if( body ) {
				result.push( body );
			}
		}

		return result;
	},

	execAndCheck: function( name, event ) {
		var arg, ret;

		arg = _lyteAccordion.findProperParent( event.target ).parentElement;
	 	ret = this.executeMethod( name, event, arg, this );
	 	ret = ret == undefined ? true : ret;
	 	return ret;
	},

	initiateClose: function( activeElement, cb, event ) {
		var header = _lyteAccordion.findProperParent( event.target ),
		accordionItem = activeElement.parentElement,
		isImmediate = accordionItem._immediate;

		if( !isImmediate ) {
			// Requires two rAFs to do this which is totally weird - https://jsfiddle.net/6dLnwyef/1/
			window.requestAnimationFrame( function() {
				activeElement.style.height = activeElement.getBoundingClientRect().height + 'px';
				window.requestAnimationFrame( function() {
					activeElement.style.height = '0px';
				} );
			} );
		}
		else {
			this.closeImmediately( activeElement );
		}
		
			
		activeElement.style.overflow = 'hidden';	
		activeElement._close = true;
		activeElement.parentElement.classList.remove( 'lyteAccordionActive' );
		header.setAttribute( 'aria-expanded', false );

		if( cb ) {
			cb.call( this, event );
		}
	},

	closeImmediately: function( accordionBody ) {

		accordionBody.style.transitionDuration = '0s';
		accordionBody.style.height = '0px';
		// TODO: Find a way to add onAfterClose callback
		// this.execNonRetCalls( [ 'onAfterClose', this ] );
	},

	execNonRetCalls: function( arr ) {
		if( this.getMethods( arr[ 0 ] ) ) {
			this.executeMethod.apply( this, arr );
	 	}
	},

	isVisible: function( item ) {
		return !!( item.offsetWidth || item.offsetHeight || item.getClientRects().length );
	},

	scrollIntoView: function( body ) {
		var isVisible = body && this.isVisible( body );

		if( !isVisible || !body ) {
			return ;
		}

		var height = this.$node.getBoundingClientRect().height, 
 		scrollTop = this.$node.scrollTop,
 		visibleBound = scrollTop + height,
 		offTop = body.offsetTop,
 		map = body.getAttribute( 'map' ),
 		elemBound = offTop + body.getBoundingClientRect().height, id;

 		if( visibleBound < elemBound ) {
 			this.$node.scrollTop = this.$node.scrollTop + ( elemBound - visibleBound );
 		}

 		id = window.requestAnimationFrame( this.scrollIntoView.bind( this, body ) );
 		Lyte.objectUtils( this.getData( 'rAFMap' ), 'add', map, id );
	},

	dynamic: function( body ) {
		/**
		 * body is definitely defined over here
		 *
		 */

		var final;

		body.style.height = 'auto';
		final = body.getBoundingClientRect().height;

		// This requires two rAFs just like initiateClose. Dk why -> https://jsfiddle.net/6dLnwyef/2/
		window.requestAnimationFrame( function() {

			/**
		 	 * Gotta put it inside a rAF else it just joins the previous 0px and the 
		 	 * current final height So the transition looks like auto -> final instead of 0 -> final
		 	 *
		 	 */

		 	body.style.height = '0px';
			window.requestAnimationFrame( function() {
				body.style.height = final + 'px';
			} );

		} )
		

		
	},

	static: function( sibling, configuration ) {

		/**
		 * The sibling is definitely always present
		 *
		 */

		var heightToSet = configuration.height;

		if( this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].conf 
	 		&& heightToSet 
	 	) {
	 		sibling.style.height = heightToSet;
	 	}
	 	else {
	 		sibling.style.height = this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].height;
	 	}
	},

	calculate: function( sibling, configuration ) {
		var dynamic = this.getData( 'ltPropDynamic' );
	 	
	 	sibling.parentElement.classList.add( 'lyteAccordionActive' );

		if( dynamic ) {
			this.dynamic( sibling );
		}
		else {
			this.static( sibling, configuration );
		}
	},

	initiateOpen: function( sibling, configuration, event ) {
		var ret;

		this.calculate( sibling, configuration );
	 	sibling._close = false;
	 	sibling.style.overflow = 'hidden';
	 	sibling.parentElement.classList.add( 'lyteAccordionActive' );
	 	ret = _lyteAccordion.findProperParent( event.target );
	 	ret.setAttribute( 'aria-expanded', 'true' );
	 	
 		this.scrollIntoView( sibling );
		this.execNonRetCalls( [  'onOpen', event, ret.parentElement, this ] );
		this.execNonRetCalls( [ 'onChanged', event, ret.parentElement, this ] );
	 		
	},

	didDestroy: function() {
		var allNodes = this.$node.querySelectorAll( 'lyte-accordion-item' ), i = 0, curValue;

		for( ; i < allNodes.length; i++ ) {
			curValue = allNodes[ i ].getAttribute( 'lyte-shortcut' );
			if( curValue ) {
				allNodes[ i ].setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );
			}
		}
	},

	cancelFrame: function( body, event ) {

		if( event.target !== body ) {
			return ;
		}
		
		var map = body.getAttribute( 'map' ),
		close = body._close,
		dynamic = this.getData( 'ltPropDynamic' );

		window.cancelAnimationFrame( this.getData( 'rAFMap' )[ map ] );
		body.style.overflow = close ? 'hidden' : 'auto';

		if( dynamic && !close ) {
			body.style.height = 'auto';
		}

		window.clearTimeout( body._callbackId );

		body._callbackId = setTimeout( function() {
			if( close ) {
				this.execNonRetCalls( [ 'onAfterClose', this ] );
			}
			else {
				this.execNonRetCalls( [ 'onAfterOpen', this ] );
			}
		}.bind( this ), 100 );
		
	},

	setEvent: function( body ) {
		if( body ) {
			body.addEventListener( 'transitionend', this.cancelFrame.bind( this, body ) );
		}
	},

	calculateHeight: function( body, index ) {
		var isStyle = body.style.height;

		this.getData( 'heights' )[ index ] = {};

		if( !isStyle ) {
			this.getData( 'heights' )[ index ].height = body.getBoundingClientRect().height - parseFloat( window.getComputedStyle( body ).paddingTop ) - parseFloat( window.getComputedStyle( body ).paddingBottom ) + 'px';
			this.getData( 'heights' )[ index ].conf = true;
		}
		else {
			this.getData( 'heights' )[ index ].height = isStyle;
			this.getData( 'heights' )[ index ].conf = false;
		}
	},

	readHeights: function() {
		var node = this.$node.querySelector( 'lyte-yield' ), 
		nodes = node.children, i = 0, body,
		dynamic = this.getData( 'ltPropDynamic' );

		for( ; i < nodes.length; i++ ) {
			if( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {
				continue;
			}

			body = nodes[ i ].querySelector( 'lyte-accordion-body' );
			if( !body ) {
				continue;
			}

			this.setEvent( body );
			// For now it looks like all the accordion-items must be specified at the start
			if( !dynamic ) {
				this.calculateHeight( body, i );
			}

			if( 
				nodes[ i ].classList.contains( 'lyteAccordionActive' ) 
				&& this.getData( 'ltPropExclusive' ) 
			) {
				this.flag = i;
			}
		}
	},

	maintainHeightOrder: function( body, index ) {
		var dynamic = this.getData( 'ltPropDynamic' );

		/* When setting height transitionend was fired in safari but not in other browsers */
		body._close = false;
		body.style.height = dynamic ? 
								'auto' : 
								!this.getData( 'heights' )[ index ].conf ? 
									this.getData( 'heights' )[ index ].height :
									this.getData( 'ltPropHeight' ) ? 
										this.getData( 'ltPropHeight' ) : 
										this.getData( 'heights' )[ index ].height
	},

	writeHeights: function() {
		var node = this.$node.querySelector( 'lyte-yield' ), nodes = node.children,
		exclusive = this.getData( 'ltPropExclusive' ), i = 0, body, header, ariaValue;

		for( ; i < nodes.length; i++ ) {
			if( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {
				continue;
			}

			body = nodes[ i ].querySelector( 'lyte-accordion-body' );
			if( !body ) {
				continue;
			}
			
			// No point setting this for dynamic but we are letting it go for now
			// because we may want to introduce an attribute to open the accordion from
			// the html
			body.setAttribute( 'map', i );

			if( !nodes[ i ].classList.contains( 'lyteAccordionActive' ) ) {
				/* When setting height transitionend was fired in safari but not in other browsers */
				body._close = true;
				body.style.height = '0px';
			}
			else if( exclusive ) {
				if( this.flag != i ) {
					/* When setting height transitionend was fired in safari but not in other browsers */
					body._close = true;
					nodes[ i ].classList.remove( 'lyteAccordionActive' );
					body.style.height = '0px';
				}
				else {
					// Doing this to achieve this precedence: inline style > ltPropHeight > boundingClientRect
					this.maintainHeightOrder( body, i );
				}
			}
			else {
				this.maintainHeightOrder( body, i );
			}

			header = _lyteAccordion.findHeader( body );

			if( header ) {
				header.setAttribute( 'aria-expanded', !body._close );
			}
		}

		this.didConnectCalled = true;
	},

	executeAfterRender: function() {
		this.execNonRetCalls( [ 'afterRender', this ] );
	},

	attachScrolls: function( item ) {
		var node = this.$node.querySelector( 'lyte-yield' ), nodes = item ? [ item ] : node.children,
		i = 0, body;

		for( ; i < nodes.length; i++ ) {
			if( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {
				continue;
			}

			body = nodes[ i ].querySelector( 'lyte-accordion-body' );
			if( !body ) {
				continue;
			}

			body.style.overflow = 'auto';
		}
	},

	getAllHeights: function() {
		this.setData( 'heights', {} );

		// A hack to make sure our attachScrolls happens before readHeights	
		$L.fastdom.measure( this.attachScrolls, this );
		$L.fastdom.measure( this.readHeights, this );
		$L.fastdom.mutate( this.writeHeights, this );
		$L.fastdom.measure( this.executeAfterRender, this );
		
	},

	didConnect: function() {
		this.setData( 'rAFMap', {} );		
		this.getAllHeights()
	},

	nestedClassObserver: function() {
		var accordion = this.$node,
		nested = this.getData( 'ltPropNested' );

		if( nested ) {
			accordion.classList.add( 'lyteAccordionNested' );
		}
		else {
			accordion.classList.remove( 'lyteAccordionNested' );
		}
	}.observes( 'ltPropNested' ).on( 'didConnect' ),

	initializeItem: function( item ) {
		this.flag = undefined;

		if( !this.getData( 'rAFMap' ) ) {
			this.setData( 'rAFMap', {} );
		}

		this.attachScrolls( item );
		this.readItemHeight( item );
		this.writeItemHeight( item );

	},

	readItemHeight: function( item ) {
		var index = this.getItemIndex( item ),
		dynamic = this.getData( 'ltPropDynamic' ),
		body = item.querySelector( 'lyte-accordion-body' );

		if( !body ) {
			return ;
		}

		this.setEvent( body );
		// For now it looks like all the accordion-items must be specified at the start
		if( !dynamic ) {
			this.calculateHeight( body, index );
		}

		// if( 
		// 	item.classList.contains( 'lyteAccordionActive' ) 
		// 	&& this.getData( 'ltPropExclusive' ) && this.isAlreadyOpen()
		// ) {
		// 	this.flag = index;
		// }
	},

	writeItemHeight: function( item ) {
		var body = item.querySelector( 'lyte-accordion-body' ),
		index = this.getItemIndex( item ),
		exclusive = this.getData( 'ltPropExclusive' ),
		openAccordion;

		if( !body ) {
			return ;
		}

		body.setAttribute( 'map', index );

		if( !item.classList.contains( 'lyteAccordionActive' ) ) {
			/* When setting height transitionend was fired in safari but not in other browsers */
			body._close = true;
			body.style.height = '0px';
		}
		// else if( exclusive ) {
		// 	// if( this.flag != index ) {
		// 		/* When setting height transitionend was fired in safari but not in other browsers */
		// 		body._close = true;
		// 		item.classList.remove( 'lyteAccordionActive' );
		// 		body.style.height = '0px';
		// 	// }
		// 	// else {
		// 	// 	// Doing this to achieve this precedence: inline style > ltPropHeight > boundingClientRect
		// 	// 	this.maintainHeightOrder( body, index );
		// 	// }
		// }
		else /* if( !exclusive ) */ {
			if( exclusive ) {
				openAccordion = this.getOpenAccordion();

				if( openAccordion ) {
					openAccordion.close();
				}

				this.maintainHeightOrder( body, index );
			}
			else {
				this.maintainHeightOrder( body, index );
			}
			
		}
	},

	getOpenAccordion: function() {
		var items = this.$node.querySelector( 'lyte-yield' ).children,
		body;

		for( var i = 0; i < items.length; i++ ) {
			body = items[ i ].querySelector( 'lyte-accordion-body' )
			if( body._close === false  ) {
				return items[ i ];
			}
		}
	},

	isAlreadyOpen: function() {
		var items = this.$node.querySelector( 'lyte-yield' ).children,
		body;

		for( var i = 0; i < items.length; i++ ) {
			body = items[ i ].querySelector( 'lyte-accordion-body' )
			if( body._close === false  ) {
				return true;
			}
		}

		return false;
	},

	getItemIndex: function( item ) {
		var index = 0;

		while( item.previousElementSibling ) {
			item = item.previousElementSibling;

			if( item.tagName === 'LYTE-ACCORDION-ITEM' ) {
				index++;
			}
		}

		return index;
	},

	getConfiguration: function() {
		var config = {};
		
		config.transition = this.getData( 'ltPropDuration' )
		config.height = this.getData( 'ltPropHeight' )
		config.exclusive = this.getData( 'ltPropExclusive' )
		return config;
	}
} );

var _lyteAccordion = {

	_lyteAccordionHeaderID: 0,

	_lyteAccordionBodyID: 0,

	generateHeaderID: function() {
		return 'lyte_accordion_header_' + _lyteAccordion._lyteAccordionHeaderID++;
	},

	generateBodyID: function() {
		return 'lyte_accordion_body_' + _lyteAccordion._lyteAccordionBodyID++;
	},

	findHeader: function( body ) {
		while( body 
			&& body.tagName !== 'LYTE-ACCORDION-HEADER' 
		) {
			body = body.previousElementSibling;
		}

		return body;
	},

	findProperParentS: function( elm ) {
		var properparent, stack = [], found = false, i;

		while( elm.tagName != "LYTE-YIELD" && elm.tagName != 'HTML' ) {
			properparent = elm;
			stack.push( elm );
			elm = elm.parentElement;

			// Clicking on a node and it gets detached by one of the bottom event listeners before it comes here
			if( !elm ) {
				return null;
			}
		}

		for( i = stack.length - 1; i > -1; i-- ) {
			if( stack[ i ].tagName === 'LYTE-ACCORDION-HEADER' 
				|| ( stack.length === 1 && stack[ i ].tagName === 'LYTE-ACCORDION-ITEM' ) 
			) {
				found = true;
				break;
			}
		}

		if( !found ) {
			return null;
		}

		// May need to add a check here
		return properparent.children[ 0 ];

	},

	findProperParent: function( element ) {
		var properparent;

		if( !element ) {
			return ;
		}

		while( element.tagName != "LYTE-YIELD" && element.tagName != 'HTML' ) {
			properparent = element;
			element = element.parentElement;

			// Clicking on a node and it gets detached by one of the bottom event listeners before it comes here
			if( !element ) {
				return {};
			}
		}

		// May need to add a check here
		if( ( properparent.children[ 0 ] || {} ).tagName === 'LYTE-ACCORDION-HEADER' ) {
			return properparent.children[ 0 ];
		}

	}
}

document.addEventListener( 'click', function( event ) {
	var elementClicked = _lyteAccordion.findProperParentS( event.target ), 
	parent, temp, childs, flag, i = 0, sibling, component, configuration, transition,
	openElement, bodyElement, returnval, itsStyle, activeElement;

	if( !elementClicked ) {
		return ;
	}

	parent  = elementClicked;

	while(
		parent.tagName != 'HTML' 
		&& parent.tagName != 'LYTE-ACCORDION'
	) {
		parent = parent.parentElement;

		if( !parent ) {
			return ;
		}
	}

	// This is a safety check because it is generally guaranteed to be a LYTE-ACCORDION Element
	if( parent.tagName == 'HTML' ) {
		return ;
	}

	temp  = parent.querySelector( 'lyte-yield' );
	childs = temp.children;
	flag = true;

	// why is this here??
	for( ; i < childs.length; i++ ) {
		if( childs[ i ].querySelector( 'lyte-accordion-header' ) == elementClicked ) {
			flag = false
			break;
		}
	}

	if( flag ) {
		return ;
	}

	/* sibling - The lyte-accordion-body tag of current clicked accordion item */

	sibling = temp.children[ i ].querySelector( 'lyte-accordion-body' );
	component = temp.parentElement.component;
	configuration = component.getConfiguration();
	transition = configuration.transition;

	/* When they haven't provided a lyte-accordion-body tag */
	if(
		!sibling 
		|| sibling.tagName != 'LYTE-ACCORDION-BODY'
	) {
		// Close accordion
 		if( 
 			configuration 
 			&& configuration.exclusive 
 			&& ( openElement = component.$node.querySelector( '.lyteAccordionActive' ) )
 			&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) )
 		 ) {
 			
 			bodyElement.style.transitionDuration = transition;
 			if( component.getMethods( 'onBeforeClose' ) ) {
 				returnval = component.execAndCheck( 'onBeforeClose', event );
	 			if( returnval ){
	 				component.initiateClose( bodyElement, function( e ) {
	 					this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 				}, event );
	 			}
	 			else {
	 				return ;
	 			} 			
	 		}
	 		else {
	 			component.initiateClose( bodyElement, function( e ) {
	 				this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 			}, event );		
	 		}
 		}


 		if( temp.children[ i ].classList.contains( 'lyteAccordionActive' ) ) {
 			temp.children[ i ].classList.remove( 'lyteAccordionActive' )
 		}
 		else {
 			temp.children[ i ].classList.add( 'lyteAccordionActive' )
 		}

 		$L.fastdom.measure( function() {
 			component.execNonRetCalls( [ 'onChanged', event, _lyteAccordion.findProperParent( event.target ).parentElement, component ] );
 		} )
 		
		return ;
	}

	itsStyle = window.getComputedStyle( sibling ).height;
 	if( transition ) {
 		sibling.style.transitionDuration = transition;

 		// Added so that it slides the first time as well
 		if( ( openElement = component.$node.querySelector( '.lyteAccordionActive' ) )
 			&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) ) ) {
 			 	bodyElement.style.transitionDuration = transition;
 		}
 	}

 	activeElement = component.$node.querySelector( '.lyteAccordionActive' );

 	// Close the already opened accordion-item in exclusive accordion. 
	if( 
		configuration 
		&& configuration.exclusive 
		&& activeElement 
		&& activeElement != sibling.parentElement
	) {	
		if( 
			( bodyElement = activeElement.querySelector( 'lyte-accordion-body' ) )
			&& component.getMethods( 'onBeforeClose' ) 
		) {
			returnval = component.execAndCheck( 'onBeforeClose', event );
	 		if( returnval ) {
	 			component.initiateClose( bodyElement, function( e ) {
	 				this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 			}, event );
	 		}
	 		else {
	 			return ;
	 		} 			
		}
	 	else if( ( bodyElement = activeElement.querySelector( 'lyte-accordion-body' ) ) ) {
	 		component.initiateClose( bodyElement, function( e ) {
	 			this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 		}, event );
	 	}

	 	// If the element has no bodyelement you still need to remove it.
 		if( activeElement.classList.contains( 'lyteAccordionActive' ) ) {
 			activeElement.classList.remove( 'lyteAccordionActive' )
 		}
		
	}
	
	// itsStyle.height = '0px' -> Meaning it is closed
	if( itsStyle == '0px' ) {
	 	
	 	if( component.getMethods( 'onBeforeOpen' ) ) {
	 		returnval = component.execAndCheck( 'onBeforeOpen', event );

	 		// Get configuration again incase user sets height in onBeforeOpen
	 		configuration = component.getConfiguration();
	 		if( returnval ) {
	 			component.initiateOpen( sibling, configuration, event );
	 		}
	 		else {
	 			return ;
	 		}	 		
	 	}
	 	else {
	 		component.initiateOpen( sibling, configuration, event );
	 	}
	 }

	 // It is opened so close it
	 else {
	 	if( component.getMethods( 'onBeforeClose' ) ) {
	 		returnval = component.execAndCheck( 'onBeforeClose', event );
	 		if( returnval ) {
	 			component.initiateClose( sibling, function( e ) {
	 				var ret =  _lyteAccordion.findProperParent( e.target );
	 				this.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );
	 				this.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );
	 			}, event );
	 		}
	 		else{
	 			return;
	 		}
	 	}
	 	else {
	 		component.initiateClose( sibling, function( e ) {
	 			var ret =  _lyteAccordion.findProperParent( e.target );
	 			this.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );
	 			this.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );
	 		}, event );
	 	}
	 }
}, true );

document.addEventListener( 'keydown', function( event ) {
	var keyCode = event.keyCode, header = document.activeElement,
	accordion = header, comp;

	if( header.tagName !== 'LYTE-ACCORDION-HEADER' ) {
		return ;
	}

	if( 
		keyCode === 38
		|| keyCode === 40
		|| keyCode === 13
		|| keyCode === 32
	) {

		while( accordion
			&& accordion.tagName !== 'LYTE-ACCORDION'
			&& accordion.tagName !== 'HTML' 
		) {
			accordion = accordion.parentElement;
		}

		if( accordion.tagName !== 'LYTE-ACCORDION' ) {
			return ;
		}

		comp = accordion.component;
		event.preventDefault();

		switch( keyCode ) {
			case 13:
			case 32:
				comp.toggleCurrentPanel( header );
				break;
			case 38:
				comp.moveToPreviousPanel();
				break;
			case 40:
				comp.moveToNextPanel();
				break;
		}
	}
	
} );

/**
 * @customElement lyte-accordion-item
 */
/**
 * @customElement lyte-accordion-header
 */
/**
 * @customElement lyte-accordion-body
 */

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-item' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-item' ] = true; 
	
	Lyte.createCustomElement( "lyte-accordion-item", {
		static: {
			"observedAttributes": {
				get: function() {
					return [ 'lyte-shortcut' ]; 
				}
			}
		},

		"connectedCallback": function() {
			var that = this , comp = this;

			if( this._hasConnectedCallbackFired ) {
				return ;
			}

			this._hasConnectedCallbackFired = true;

			while(
				comp.tagName != 'HTML' 
				&& comp.tagName != 'LYTE-ACCORDION'
			) {
				comp = comp.parentElement;

				if( !comp ) {
					return ;
				}
			}

			// This is a safety check because it is generally guaranteed to be a LYTE-ACCORDION Element
			if( comp.tagName == 'HTML' ) {
				return ;
			}

			comp = comp.component;

			this.open = function() {
				if( !that.classList.contains( 'lyteAccordionActive' ) ) {
					that.click();
				}
			}

			this.close = function( immediate ) {

				that._immediate = immediate;

				if( that.classList.contains( 'lyteAccordionActive' ) ) {
					that.click();
				}

				that._immediate = false;
			}

			if( comp.didConnectCalled ) {
				comp.initializeItem( this );
			}
		},

		"attributeChangedCallback": function( attributeName, oldValue, newValue, namespace ) {
			if( typeof shortcut == "function" ){
	         	if( !newValue ) {
	            	return ;
	          	}

	          	newValue = JSON.parse( newValue )
	          	if( !newValue.key ){
	            	return ;
	          	}

	          	var newKey = newValue.key, type = newValue.type, wait = newValue.wait;
	          	if( !oldValue ){
	            	oldValue = {};
	          	}

	          	shortcut.push( {
	            	newKey: newKey,
	            	type: type,
	            	wait: wait,
	            	oldKey: oldValue.key,
	            	value: this
	         	} )
	      	}
		}
	} );
}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-header' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-header' ] = true; 
	
	Lyte.createCustomElement( "lyte-accordion-header", {
		static: {
			"observedAttributes" : {
				get : function() {
					return [ ];
				}
			}
		},

		"connectedCallback": function() {
			var id = this.getAttribute( 'id' );

			this.setAttribute( 'role', 'button' );

			if( !this.hasAttribute( 'tabindex' ) ) {
				this.setAttribute( 'tabindex', '0' );
			}

			if( !id ) {
				this.setAttribute( 'id', _lyteAccordion.generateHeaderID() );
			}
		}
	} );
}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-body' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-accordion-body' ] = true; 
	
	Lyte.createCustomElement( "lyte-accordion-body", {
		static: {
			"observedAttributes" : {
				get : function() {
					return [ ];
				}
			}
		},

		"connectedCallback": function() {
			var id = this.getAttribute( 'id' ), 
			head = _lyteAccordion.findHeader( this );

			this.setAttribute( 'role', 'region' );
 
			if( !id ) {
				id = _lyteAccordion.generateBodyID();
				this.setAttribute( 'id', id );
			}

			if( head ) {
				head.setAttribute( 'aria-controls', id );
				this.setAttribute( 'aria-labelledby', head.getAttribute( 'id' ) );
			}
		}
	} );
}

/**
 * @syntax yielded
 * <lyte-accordion>
 *     <template is="registerYield" yield-name="yield">
 *         <lyte-accordion-item>
 *             <lyte-accordion-header>
 *                 HEADER 1
 *             </lyte-accordion-header>
 *             <lyte-accordion-body>
 *                 CONTENT 1
 *             </lyte-accordion-body>
 *         </lyte-accordion-item>
 *         <lyte-accordion-item>
 *             <lyte-accordion-header>
 *                 HEADER 2
 *             </lyte-accordion-header>
 *             <lyte-accordion-body>
 *                 CONTENT 2
 *             </lyte-accordion-body>
 *         </lyte-accordion-item>
 *     </template>
 * </lyte-accordion>
 */

/**
 * Renders an alert
 * @component lyte-alert
 * @version 1.0.0
 * @dependencies lyte-button,lyte-wormhole
 */ 

Lyte.Component.register("lyte-alert",{
_template:"<template tag-name=\"lyte-alert\"> <template is=\"if\" value=\"{{ltPropShowCopy}}\"> <template case=\"true\"><lyte-wormhole on-before-append=\"{{method(&quot;beforeWormholeAppend&quot;)}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"alertWrapper {{ltPropWrapperClass}}\"> <div class=\"{{lyteUiConcatAlertClass(ltPropContentAlign,'alertPopup')}}\"> <template is=\"if\" value=\"{{ltPropShowCloseButton}}\"> <template case=\"true\"><span class=\"lyte-svg alertClose\" onclick=\"{{action('closeAlert')}}\" tabindex=\"0\"></span></template> </template> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"alert\"></lyte-yield> </template><template case=\"false\"> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropHeading,'')}}\"> <template case=\"false\"><div class=\"alertHeader\"> <span class=\"dBlock\">{{ltPropHeading}}</span> </div></template> </template> <div class=\"alertContent\"> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'')}}\"> <template case=\"false\"><div class=\"alertContentMiddle\"> <span class=\"{{lyteUiConcatTypeClass(ltPropType,'AlertIcon','lyteStatusIcon')}}\"></span> </div></template> </template> <div class=\"alertContentMiddle\"> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropPrimaryMessage,'')}}\"> <template case=\"false\"><div> <span class=\"alertPrimaryMsg\">{{ltPropPrimaryMessage}}</span> </div></template> </template> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropSecondaryMessage,'')}}\"> <template case=\"false\"><div> <span class=\"alertSecondaryMsg\">{{ltPropSecondaryMessage}}</span> </div></template> </template> </div> <div class=\"clearFloat\"></div> </div> </template></template> <template is=\"if\" value=\"{{nonYieldFooter}}\"><template case=\"true\"> <template is=\"if\" value=\"{{lyteUiIsEmptyArray(ltPropButtons)}}\"> <template case=\"false\"><div class=\"{{lyteUiConcat('alertFooter ',ltPropButtonPosition)}}\"> <template is=\"for\" items=\"{{ltPropButtons}}\"> <template is=\"if\" value=\"{{lyteUiIfEquals(item.type,'accept')}}\"> <template case=\"true\"><lyte-button class=\"lyteAlertBtn\" onclick=\"{{action('accept',item.text)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{item.text}}</template> </lyte-button></template> </template> <template is=\"if\" value=\"{{lyteUiIfEquals(item.type,'reject')}}\"> <template case=\"true\"><lyte-button class=\"lyteAlertBtn\" onclick=\"{{action('reject',item.text)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{item.text}}</template> </lyte-button></template> </template> </template> </div></template> </template> </template></template> </div> <div class=\"{{lyteUiAddShowClass(ltPropShowCopy,'','alertFreezeLayer')}}\"></div> </div> </template> </lyte-wormhole></template> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[0,1]}]}},"default":{}},{"type":"attr","position":[3,3,1]},{"type":"if","position":[3,3,1],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}},{"type":"attr","position":[3,3,3]},{"type":"if","position":[3,3,3],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"attr","position":[0,1]},{"type":"for","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropShow","ltPropWrapperClass","ltPropAllowMultiple","ltPropHeading","ltPropPrimaryMessage","ltPropSecondaryMessage","ltPropTop","ltPropButtons","ltPropButtonPosition","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropDimmer","ltPropYield","ltPropAnimation","ltPropContentAlign","ltPropAria","ltPropAriaAttributes","ltPropPreventFocus","nonYieldFooter","triggerShow"],
    data: function(){
        return {
            /**
             * @componentProperty {success|error|warning|info|confirm} ltPropType
             * @version 1.0.0
             */
            "ltPropType":Lyte.attr("string",{"default": ""}),

            /**
             * @componentProperty {boolean} ltPropShow
             * @version 1.0.0
             * @default false
             * 
             */
            "ltPropShow":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {string} ltPropWrapperClass
             * @version 1.0.0
             */
            "ltPropWrapperClass":Lyte.attr("string",{"default": ""}),

            /**
             * @componentProperty {boolean} ltPropAllowMultiple
             * @version 1.0.0
             * @default false
             * 
             */
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {string} ltPropHeading
             * @version 1.0.0
             */
            "ltPropHeading":Lyte.attr("string",{"default": ""}),

            /**
             * @componentProperty {string} ltPropPrimaryMessage
             * @version 1.0.0
             */
            "ltPropPrimaryMessage":Lyte.attr("string",{"default": ""}),

            /**
             * @componentProperty {string} ltPropSecondaryMessage
             * @version 1.0.0
             */
            "ltPropSecondaryMessage":Lyte.attr("string",{"default": ""}),

            /**
             * @componentProperty {string} ltPropTop
             * @version 1.0.0
             * @suffix px,%,em
             * @default 40px
             */
            "ltPropTop":Lyte.attr("string",{"default":"40px"}),

            /**
             * @componentProperty {array} ltPropButtons
             * @version 1.0.0
             * @default []
             */
            "ltPropButtons":Lyte.attr("array",{"default": []}),

            /**
             * @componentProperty {left|center|right} ltPropButtonPosition
             * @version 1.0.0
             * @default right
             */
            "ltPropButtonPosition":Lyte.attr("string",{"default": "right"}),

            /**
             * @componentProperty {boolean} ltPropShowCloseButton
             * @version 1.0.0
             * @default true
             * 
             */
            "ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {boolean} ltPropCloseOnEscape
             * @version 1.0.0
             * @default true
             * 
             */
            "ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),
            /**
             * @typedef {object} dimmer
             * @property {colorstring} color=black
             * @property {number} opacity=0.4
             * @minValue 0
             * @maxValue 1
             * @step 0.1
             */
            /**
             * @componentProperty {dimmer} ltPropDimmer
             * @version 1.0.0
             */
            "ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),

            /**
             * @componentProperty {boolean} ltPropYield
             * @version 1.0.0
             * @default false
             * 
             */
            "ltPropYield":Lyte.attr("boolean",{"default":false}),

            /**
             * @componentProperty {slideDown|zoomIn} ltPropAnimation=slideDown
             * @version 2.0.0
             */
            "ltPropAnimation" : Lyte.attr("string",{"default":"slideDown"}), //Other value zoomIn

            /**
             * @componentProperty {left|center} ltPropContentAlign=left
             * @version 2.0.0
             */
            "ltPropContentAlign" : Lyte.attr("string",{"default" : "left"}), //other value center

            /**
             * @componentProperty {boolean} ltPropAria
             * @version 3.1.0
             * @default false
             * 
             */
            "ltPropAria" : Lyte.attr( 'boolean', { default : false } ),

            /**
             * @componentProperty {object} ltPropAriaAttributes
             * @version 3.1.0
             */
            "ltPropAriaAttributes" : Lyte.attr( 'object', { default : {} } ),

            /**
             * @componentProperty {boolean} ltPropPreventFocus
             * @version 3.3.0
             * @default false
             * 
             */
            "ltPropPreventFocus" : Lyte.attr('boolean', { default : false } ),
            "nonYieldFooter" : Lyte.attr("boolean",{"default":true}),
            "triggerShow" : Lyte.attr("number",{"default":0})
        }
    },
    didConnect : function() {
        if(this.$node.ltProp("show")){
            this.setData('triggerShow',this.getData('triggerShow')+1);
        }
    },

    /**
     * The method is going to add the aria properties to the alert component
     *
     */
    addAriaValues : function() {
        if(this.getData('ltPropAria')){
            var ariaProp = this.getData('ltPropAriaAttributes') || {};
            if('aria-labelledby' in ariaProp){
                var header = this.getAlertWidget('header');
                if(header){
                    // header.setAttribute('id',Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'aria-labelledby'));
                    header.classList.add(Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'aria-labelledby'));
                }
            }
            if('aria-describedby' in ariaProp){
                var content = this.getAlertWidget('content');
                if(content){
                    // content.setAttribute('id',Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'aria-describedby'));
                    content.classList.add(Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'aria-describedby'));
                }
            }
            _lyteUiUtils.setAttribute( this.getAlertWidget(), ariaProp, {} );
            var closeIcon = this.getAlertWidget('close');
            if(closeIcon){
                closeIcon.setAttribute('aria-label', Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'close-label') || 'Close icon at top right position');
            }
        }
    },

    /**
     * The method is going to return the element from the alert based on the prop value
     * @param {property} prop - The type of element to be returned
     *
     */
    getAlertWidget : function(prop){
        if(prop === "header"){
            return this.getData('ltPropYield') ? this.childComp.querySelector('lyte-alert-header') : this.childComp.querySelector('.alertHeader');
        }
        else if(prop === "content"){
            return this.getData('ltPropYield') ? this.childComp.querySelector('lyte-alert-content') : this.childComp.querySelector('.alertContentMiddle');
        }
        else if(prop === "close"){
            return this.childComp.querySelector('.alertClose');
        }
        else{
            return this.childComp.querySelector('.alertPopup');
        }
    },
    showToggled : function() {
        if(this.$node.ltProp("show")){
            // this.printId();
            if(this.closeTId){
                clearTimeout(this.closeTId);
                delete this.closeTId;
            }
            if(this.sId){
                clearTimeout(this.sId);
                delete this.sId;
                this.setData('ltPropShowCopy',false);
                delete this.sId;
                delete this.actualModalDiv;
                delete this.childComp;
                // LytePopup.bodywrapperCount -= 1;
                // if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
                //     document.body.classList.remove('bodyWrapper');
                // }
            }
            // if(this.getData('nonYieldFooter')){
            //     if(this.getData('ltPropButtons').length == 0){
            //         if(this.getData('ltPropType') == "confirm"){
            //             this.setData('ltPropButtons',[{"type":"accept","text":"Ok"},{"type":"reject","text":"Cancel"}]);
            //         }
            //         else{
            //             this.setData('ltPropButtons',[{"type":"accept","text":"Ok"}]);
            //         }
            //     }
            // }
            var self = this;
            this.openTId = setTimeout(function(){
                delete self.openTId;
                document.body.classList.add('bodyWrapper');
                // LytePopup.bodywrapperCount += 1;
                self.showAlert();
            },0);
        }
        else{
            if(this.openTId){
                clearTimeout(this.openTId);
                delete this.openTId;
            }
            if(this.showTId){
                clearTimeout(this.showTId);
                delete this.showTId;
            }
            var self = this;
            this.closeTId = setTimeout(function(){
                delete self.closeTId;
                self.closeAlert();
            },0);
            
        }
    }.observes('ltPropShow','triggerShow'),
    printId : function(){
        console.log("this.openTId ---> "+this.openTId);
        console.log("this.showTId ---> "+this.showTId);
        console.log("this.closeTId ---> "+this.closeTId);
        console.log("this.sId ---> "+this.sId);
    },
    closeAlertFn : function(){

        /**
        * @method onClose
        * @version 1.0.0
        */
        if(this.getMethods("onClose")){
            this.executeMethod("onClose",this);  
        }
    },

    /**
     * The method is going to add the left and top values to the alert
     * Add the configurations for the button which are provided using ltPropButtons
     * Makes the alert visible
     *
     */
    showAlert : function(){
        var self = this;
        this.showTId = setTimeout(function(){
            delete self.showTId;
            if(self.actualModalDiv){
                LytePopup.bindTransitionEnd(self.actualModalDiv);
                if(self.getData('ltPropTop') == "center"){
                    var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                    self.actualModalDiv.style.top = (h - self.actualModalDiv.getBoundingClientRect().height)/2 + "px";
                }
                else{
                    self.actualModalDiv.style.top = self.getData('ltPropTop');
                }
                if(self.getData("ltPropAnimation") == "zoomIn"){
                    self.actualModalDiv.classList.add('alertOpened');
                }
                self.$node.classList.add('lyteAlertOpened');
                /**
                * @method onShow
                * @version 2.2.0
                */
                if(self.getMethods('onShow')){
                    self.executeMethod('onShow',self);
                }
            }
            else{
                if(self.getData('ltPropShow')){
                    self.setData('ltPropShow',false);
                }
            }
        },100);
        this.setData('ltPropShowCopy',true);
        this.addAriaValues();
        if(this.getData("ltPropAnimation") == "slideDown"){
            this.actualModalDiv.classList.add('lyteAlertSlideDown');
        }
        else if(this.getData("ltPropAnimation") == "zoomIn"){
            this.actualModalDiv.classList.add('lyteAlertZoomIn');
        }
        if(this.getData('ltPropButtons') && this.getData('nonYieldFooter')){
            var buttons = this.getData('ltPropButtons');
            var buttonComp;
            for(var i=0; i<buttons.length; i++){
                buttonComp = this.actualModalDiv.querySelectorAll(".lyteAlertBtn")[i];
                var keys = Object.keys(buttons[i]);
                for(var j = 0; j<keys.length; j++){
                    buttonComp.ltProp(keys[j], buttons[i][keys[j]]);
                };
            }
            buttonComp = null;
        }
        LytePopup.addPopup(this);
        var freezeStyle = this.childComp.querySelector(".alertFreezeLayer").style;
        freezeStyle.background = this.getData('ltPropDimmer').color;
        if(!this.addedFreezeDetails){
            freezeStyle.opacity = this.getData('ltPropDimmer').opacity;
        }
    },

    /**
     * The method is going to do the calculations and close the alert
     *
     */
    closeAlert : function(){
        if(this.childComp && this.actualModalDiv){
            if(this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this);
                delete this.addedFreezeDetails;
            }
            if(this.getData('ltPropAnimation') == "slideDown"){
                this.actualModalDiv.style.top = "-"+(this.actualModalDiv.getBoundingClientRect().height+this.actualModalDiv.getBoundingClientRect().top+40)+"px";
            }
            var animDur = parseFloat(document.defaultView.getComputedStyle(this.actualModalDiv).getPropertyValue("transition-duration")) * 1000;
            if(this.getData('ltPropAnimation') == "zoomIn"){
                this.actualModalDiv.classList.remove('alertOpened');
            }
            var self = this;
            this.sId = setTimeout(function(){
                self.setData('ltPropShowCopy',false);
                delete self.sId;
                delete self.actualModalDiv;
                delete self.childComp;
                // LytePopup.bodywrapperCount -= 1;
                // if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
                //     document.body.classList.remove('bodyWrapper');
                // }
                LytePopup.checkAndRemoveWrapper();
            },animDur-100);
            this.closeAlertFn();
            LytePopup.closePopup(this);
            if(this.addedFreezeDetails){
                this.childComp.querySelector(".alertFreezeLayer").style.opacity = 0;
                this.childComp.querySelector(".alertFreezeLayer").style.visibility = "";
            }
            // LytePopup.bindTransitionEnd(this.actualModalDiv);
        }
        else{
            LytePopup.closePopup(this);
        }
        this.$node.classList.remove('lyteAlertOpened');
    },
    didDestroy : function(){
        this.$node.classList.remove('lyteAlertOpened');
        if(this.openTId){
            clearTimeout(this.openTId);
            delete this.openTId;
        }
        if(this.showTId){
            clearTimeout(this.showTId);
            delete this.showTId;
        }
        if(this.closeTId){
            clearTimeout(this.closeTId);
            delete this.closeTId;
        }
        if(this.sId){
            clearTimeout(this.sId);
            delete this.sId;
        }
        if(this.childComp){
            if(this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close", this);
                delete this.addedFreezeDetails;
            }
            LytePopup.closePopup(this);
            this.childComp.remove();
            delete this.actualModalDiv;
            delete this.childComp;
            // LytePopup.bodywrapperCount -= 1;
            // if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
            //     document.body.classList.remove('bodyWrapper');
            // }
            LytePopup.checkAndRemoveWrapper();
        }
    },
    actions: {
        closeAlert : function(){
            this.$node.ltProp("show",false);            
        },
        accept : function(buttonText){
            var retVal = true;
            /**
            * @method onAccept
            * @version 1.0.0
            */
            if(this.getMethods("onAccept")){
                retVal = this.executeMethod("onAccept",buttonText,this); 
                retVal = retVal == undefined ? true : retVal; 
            }
            retVal && this.$node.ltProp("show",false);            
        },
        reject : function(buttonText){
            var retVal = true;
            /**
            * @method onReject
            * @version 1.0.0
            */
            if(this.getMethods("onReject")){
                retVal = this.executeMethod("onReject",buttonText,this);  
                retVal = retVal == undefined ? true : retVal; 
            }
            retVal && this.$node.ltProp("show",false);
        }
    },
    methods: {
        beforeWormholeAppend : function(arg){
            this.childComp = arg;
            this.actualModalDiv = this.childComp.querySelector(".alertPopup");
            if(this.getData('ltPropYield') && arg.querySelector('lyte-alert-footer')){
                this.setData("nonYieldFooter",false);
            }
            else{
                this.setData("nonYieldFooter",true);
            }
            if(this.getData('nonYieldFooter')){
                if(this.getData('ltPropButtons').length == 0){
                    if(this.getData('ltPropType') == "confirm"){
                        this.setData('ltPropButtons',[{"type":"accept","text":"Ok"},{"type":"reject","text":"Cancel"}]);
                    }
                    else{
                        this.setData('ltPropButtons',[{"type":"accept","text":"Ok"}]);
                    }
                }
            }
        }
    }
});

/**
 * @syntax nonYielded
 * <lyte-alert lt-prop-heading="Delete Profile" lt-prop-primary-message="Confirm Delete" lt-prop-secondary-message="Are you sure want to delete this profile?" >
 * </lyte-alert>
 */

/**
 * @syntax yielded
 * <lyte-alert lt-prop-wrapper-class = "sampleAlert" lt-prop-yield = "true"> 
 *     <template is = "registerYield" yield-name = "alert"> 
 *         <lyte-alert-header> Delete Profile </lyte-alert-header> 
 *         <lyte-alert-content> Are you sure want to delete this profile? </lyte-alert-content> 
 *     </template> 
 * </lyte-alert> 
 */

/**
 * This component is used to show and search list of suggestions for the given input value
 * @component lyte-autocomplete
 * @version 1.0.0
 * @utility toggle,focus,blur,click,select,setValue
 * @dependency lyte-input
 *  /components/lyte-input.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-input.css
 * @dependency lyte-dropdown
 *  /components/lyte-dropdown.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-dropdown.css
 * @import lyte-input
 * @ignoreProperties ltPropRows,ltPropCols,ltPropTextAreaResize,ltPropMax,ltPropMin,ltPropStep,ltPropTimeFormat,ltPropHourInterval,ltPropDefaultTime,ltPropMinuteInterval,ltPropDropdown,ltPropShowInterval,ltPropStartTime,ltPropEndTime,ltPropFillRows,ltPropNumberOfRows,ltPropMinDate,ltPropMaxDate,ltPropStartWeekDay,ltPropMonthHeaderFormat,ltPropYear,ltPropFormat,ltPropStartDate,ltPropEndDate,ltPropCurrentDate,ltPropBindToBody,ltPropCalendarClass,ltPropHeaderType,ltPropDropdownDisabled,ltPropDropdownShow,ltPropDropdownCallout,ltPropDropdownFreeze,ltPropDropdownId,ltPropDropdownClass,ltPropPosition,ltPropBoundary,ltPropWheel,ltPropYield,ltPropAnimate,ltPropPreventSelection,ltPropPreventKeys,ltPropCalendarProperties,ltPropDropdownProperties
 * @ignoreMethods onTimeChange,onDateChange,onValueChange,onPositionChanged,onHide,onBeforeHide,onShow,onBeforeShow,onScroll,onNavigate,onViewdateChange,onViewChange,onBeforeCalendarClose,onCalendarClose,onCalendarOpen,onFocus,onBlur,onClear,beforeRender,afterRender
 * @ignoreUtils focus,blur,click,select,revertToToday,revertToSelected
 * @import lyte-dropdown
 * @ignoreProperties ltPropShow,ltPropRemoveMultiple,ltPropYield,ltPropOptions,ltPropUserValue,ltPropSystemValue,ltPropIconClass,ltPropPlaceholder,ltPropNoResult,ltPropMaxCount,ltPropInputClass,ltPropAjaxRequest,ltPropDisplayValue,ltPropDisabledList,ltPropTooltip,ltPropBoxClass,ltPropIsOpen,ltPropFixPositionOnOpen
 * @ignoreMethods onShow,onBeforeShow,onHide,onBeforeHide,beforeSelect,onBeforeRemove,onBeforeAdd,onOptionSelected,onAdd,onRemove,onPositionChanged,onScroll,onChange
 * @ignoreUtils toggle
 */

Lyte.Component.register("lyte-autocomplete",{
_template:"<template tag-name=\"lyte-autocomplete\"> <lyte-dropdown lt-prop=\"{{stringify(ltPropDropdown)}}\" lt-prop-set-pos=\"{{ltPropSetPos}}\" lt-prop-type=\"{{ltPropDropType}}\" lt-prop-yield=\"true\" lt-prop-freeze=\"{{ltPropFreeze}}\" lt-prop-callout=\"{{ltPropCallout}}\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-hover=\"{{ltPropHover}}\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-tabindex=\"{{ltPropTabindex}}\" lt-prop-animate=\"{{ltPropAnimate}}\" on-option-selected=\"{{method('valSet')}}\" on-show=\"{{method('show')}}\" on-hide=\"{{method('hide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-add=\"{{method('add')}}\" on-remove=\"{{method('remove')}}\" on-position-changed=\"{{'positionChanged'}}\" on-scroll=\"{{method('scroll')}}\" lt-prop-selected=\"{{lbind(ltPropSelected)}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button onkeyup=\"{{action('keyup',event)}}\"> <lyte-input lt-prop=\"{{stringify(ltPropInput)}}\" lt-prop-maxlength=\"{{ltPropMaxlength}}\" lt-prop-auto-update=\"{{ltPropAutoUpdate}}\" on-value-change=\"{{method('valuechange')}}\" lt-prop-tab-index=\"{{ltPropTabIndex}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-wrapper-style=\"{{ltPropWrapperStyle}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-autocomplete=\"{{ltPropAutocomplete}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-placeholder=\"{{ltPropPlaceholder}}\" lt-prop-value=\"{{lbind(ltPropValue)}}\" lt-prop-width=\"100%\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-direction=\"vertical\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-readonly=\"{{ltPropReadonly}}\" lt-prop-pattern=\"{{ltPropPattern}}\" rows=\"{{ltPropRows}}\" cols=\"{{ltPropCols}}\" title=\"{{ltPropInputTitle}}\" lt-prop-text-area-resize=\"{{ltPropTextAreaResize}}\" lt-prop-input-title=\"{{ltPropInputTitle}}\" on-focus=\"{{method('focus')}}\" on-blur=\"{{method('blurEvent')}}\" oninput=\"{{action('input',event)}}\" lt-prop-update-delay=\"{{ltPropUpdateDelay}}\" lt-prop-aria=\"{{ltPropAria}}\" lt-prop-aria-attributes=\"{{ltPropAriaAttributes}}\" lt-prop-focus=\"{{ltPropFocus}}\"></lyte-input> <template is=\"if\" value=\"{{expHandlers(ltPropType,'==','search')}}\"><template case=\"true\"> <div class=\"closeIconWrapper lyteAutoCompCloseIconWrapper\" onclick=\"{{action('resetValue',event)}}\" style=\"{{if(ltPropValue,'display: block;','display: none;')}}\"> <span class=\"closeIcon lyteAutoCompCloseIcon\"></span> </div> <span class=\"iconSeparator\" style=\"{{if(ltPropValue,'display: block;','display: none;')}}\"></span> </template></template> </lyte-drop-button> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-drop-box class=\"{{ltPropDropdownClass}} lyteautocompleteDropdown\" id=\"{{ltPropDropdownId}}\"> <lyte-drop-body> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(list)}}\"><template case=\"true\"> <lyte-drop-group elemorder=\"{{indexVal}}\"> <lyte-drop-label>{{lyteUiReturnOnlyKey(list)}}</lyte-drop-label> <template is=\"for\" items=\"{{lyteUiReturnOnlyValue(list)}}\" item=\"list1\" index=\"indexVal1\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(list1),'==',false)}}\"><template case=\"true\"> <lyte-drop-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{list1}}\"> <lyte-autocomplete-label keywords=\"{{list1}}\">{{list1}}</lyte-autocomplete-label> </lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{list1[ltPropLabel]}}\" class=\"{{list1.class}}\"> <lyte-autocomplete-label keywords=\"{{list1[ltPropKeyWords]}}\">{{list1[ltPropLabel]}}</lyte-autocomplete-label> <template is=\"if\" value=\"{{list1[ltPropDescription]}}\"><template case=\"true\"> <lyte-autocomplete-description><span class=\"lyteAutoSeparator\">,</span> {{list1[ltPropDescription]}}</lyte-autocomplete-description> </template></template> </lyte-drop-item> </template></template></template> </lyte-drop-group> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(list),'==',false)}}\"><template case=\"true\"> <lyte-drop-item elemorder=\"{{indexVal}}\" data-value=\"{{list}}\"> <lyte-autocomplete-label keywords=\"{{list}}\">{{list}}</lyte-autocomplete-label> </lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item elemorder=\"{{indexVal}}\" data-value=\"{{list[ltPropLabel]}}\" class=\"{{list1.class}}\"> <lyte-autocomplete-label keywords=\"{{list[ltPropKeyWords]}}\">{{list[ltPropLabel]}}</lyte-autocomplete-label> <template is=\"if\" value=\"{{list[ltPropDescription]}}\"><template case=\"true\"> <lyte-autocomplete-description><span class=\"lyteAutoSeparator\">,</span> {{list[ltPropDescription]}}</lyte-autocomplete-description> </template></template> </lyte-drop-item> </template></template></template></template></template> </lyte-drop-body> </lyte-drop-box> </template><template case=\"false\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template> </template> </lyte-dropdown> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}}]}},"default":{}},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,2]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,2]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropAutocomplete","ltPropPlaceholder","ltPropAutofocus","ltPropMaxlength","ltPropReadonly","ltPropId","ltPropClass","ltPropType","ltPropName","ltPropWidth","ltPropValue","ltPropContent","ltPropLabel","ltPropDescription","ltPropAppearance","ltPropDirection","ltPropExternalSearch","ltPropYield","ltPropHeight","ltPropHighlight","ltPropHighlightClass","ltPropKeyWords","ltPropMinLength","ltPropErrorClass","ltPropDropdownWidth","ltPropDropdownHeight","ltPropDropdownClass","ltPropDropdownId","ltPropMethod","ltPropWrapperStyle","ltPropTabIndex","ltPropTabindex","ltPropFreeze","ltPropCallout","ltPropDisabled","ltPropHover","ltPropBoundary","ltPropPosition","ltPropDropType","ltPropSetPos","ltPropPattern","ltPropAutoUpdate","ltPropValueSet","ltPropPreventInsideClick","ltPropExtSearchOpen","ltPropInputTitle","ltPropErrorMessage","ltPropErrorClass","ltPropAnimate","ltPropSelected","ltPropTrim","ltPropFocus","ltPropAria","ltPropAriaAttributes","ltPropUpdateDelay","ltPropRows","ltPropCols","ltPropTextAreaResize","ltPropDiacritic","ltPropDropdown","ltPropInput","timeout","optGroup","autocompleteFlag"],
    init : function(){ 

        this.$node.toggle = function( arg1, arg2 ){

            var drop = this.dropdown;
            return drop.toggle( arg1, arg2 );

        }.bind( this );

       /**
        * @method beforeRender
        * @version 1.0.1
        */

        var cb = "beforeRender";

        if( this.getMethods( cb ) ){
            this.executeMethod( cb, this.$node );
        }
    },

    didDestroy : function(){
        var _this = this,
        $node = _this.$node;

        clearTimeout( _this.data.timeout );

        [ 'autocompleteComp', 'input', 'dropdown', 'dropbody' ].forEach( function( item ){
            delete _this[ item ];
        });

        [ 'toggle', 'setValue', 'focus', 'blur', 'click', 'select' ].forEach( function( item ){
          delete $node[ item ];
        });
    },


    didConnect : function(){
       var data = this.data,
       errorDiv = $L( document.createElement( 'div' ) ).addClass( 'lyteautocompleteError ' + ( data.ltPropErrorClass || '' ) ).css( 'display', 'none' ).get( 0 ),
       dropdown,
       dropbody,
       cb = "afterRender";

       errorDiv.textContent = data.ltPropErrorMessage || '';

       this.autocompleteComp = errorDiv;

       dropdown = this.dropdown = $L( this.$node ).children( 'lyte-dropdown' ).get( 0 );
       dropbody = this.dropbody =  dropdown.component.childComp || $L( 'lyte-drop-box', dropdown ).get( 0 );

       dropbody.appendChild( errorDiv );

       this.$node.setValue  = function( value ){
          value = value || "";

          $L( 'lyte-input', this.$node ).get( 0 ).ltProp( 'value', value );
          this.pressFunc( value, {} );

       }.bind( this );

       [ 'focus', 'blur', 'click', 'select' ].forEach( function( item ){
          this.$node[ item ] = function( arg ){
              $L( 'lyte-input', this ).get( 0 )[ item ]( arg );
          }
       }.bind( this ));

       /**
        * @method afterRender
        * @version 1.0.1
        */

        if( this.getMethods( cb ) ){
            this.executeMethod( cb, this.$node );
        }
    },

    errObs : function( arg ){
        var elem = this.autocompleteComp;

        if( arg.item == 'ltPropErrorMessage' ){
            elem.textContent = arg.newValue;
        } else{
            $L( elem ).removeClass( arg.oldValue ).addClass( arg.newValue );
        }

    }.observes( 'ltPropErrorMessage', 'ltPropErrorClass' ),

    typeObs : function(){
        var $node = $L( this.$node )[ this.data.ltPropType == "search" ? 'addClass' : 'removeClass' ]( 'searchPresent' );

        this.input = $node.find( 'input,textarea' ).get( 0 );
    }.observes( 'ltPropType' ).on( 'didConnect' ),

    arrayFrom : function( nodeList ){
        if( Array.from ){
            return Array.from( nodeList );
        }
        return Array.apply( Array, nodeList );
    },

     optGroupObs : function(){
        setTimeout( this.optGroup.bind( this, true ), 0 );
     }.observes( 'ltPropContent', 'ltPropContent.[]' ),      
     
     optGroup : function( prevent ){
          var $drop = $L( this.dropbody ),
          input = this.input,
          value = input.value,
          data = this.data;

          if( ( !$drop.hasClass( 'lyteDropdownHidden' ) && value.length ) || data.ltPropExternalSearch ) {

              if( data.ltPropTrim ){
                  value = value.trim();
              }

              this.contentFiltering( value );
          }

          if( data.ltPropAnimate && data.ltPropExternalSearch ) {
              $drop.find( "lyte-drop-body" ).css( "height", "" );
              delete this.dropdown.component._prevent;
          }
     },

     classObs : function( arg ){
        if( this.data.ltPropYield ) {
              var dropbody = $L( this.dropbody )
              if( arg ) {
                 dropbody.removeClass( arg.oldValue )
              }
              var cls = this.data.ltPropDropdownClass;
              if( cls ){
                dropbody.addClass( cls )
              }
          }
      }.observes('ltPropDropdownClass').on('didConnect'),

     heigthSetObs : function(){
        this.heigthSet();
     }.observes('ltPropDropdownHeight').on('didConnect'),

     heigthSet : function(){
        $L( this.dropbody ).find( 'lyte-drop-body' ).css( 'maxHeight', this.data.ltPropDropdownHeight || "" );
     },
     // setting width 

     widthSetObs : function(){
        this.widthSet();
     }.observes('ltPropDropdownWidth').on('didConnect'),

     widthSet : function(){
        $L( this.dropbody ).find( 'lyte-drop-body' ).css( 'width', this.data.ltPropDropdownWidth || "" );
     },

     data : function (){
      //user data
            return {
               ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
               ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
               ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
               ltPropMaxlength : Lyte.attr("number",{"default" : 25}),
               ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
               ltPropId : Lyte.attr("string",{"default" : 'inputId'}),
               ltPropClass : Lyte.attr("string",{"default" : ''}),
               ltPropType : Lyte.attr("string",{"default" : 'text'}),
               ltPropName : Lyte.attr("string",{"default" : ''}),
               ltPropWidth : Lyte.attr("string",{"default" : '100%'}),
               ltPropValue : Lyte.attr("string",{"default" : ''}),
              /**
               * @componentProperty {string[] | object[]} ltPropContent
               * @version 1.0.0
               * @default []
               */
               ltPropContent : Lyte.attr("array",{"default" : []}),
               ltPropLabel : Lyte.attr("string",{"default" : ''}),
              /**
               * @componentProperty {string} ltPropDescription=''
               * @version 1.0.0
               */
               ltPropDescription : Lyte.attr("string",{"default" : ''}),
               ltPropAppearance : Lyte.attr("string",{"default" : 'flat'}),
               ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
               ltPropExternalSearch : Lyte.attr("boolean",{"default" : false}),
              /**
               * @componentProperty {boolean} ltPropYield=false
               * @version 1.0.0
               */
               ltPropYield : Lyte.attr("boolean",{"default" : false}),
               ltPropHeight : Lyte.attr("string",{"default" : ''}),
              /**
               * @componentProperty {boolean} ltPropHighlight=false
               * @version 1.0.0
               */
               ltPropHighlight : Lyte.attr("boolean",{"default" : false}),
              /**
               * @componentProperty {string} ltPropHighlightClass=lyteautocompleteHighlight
               * @version 1.0.0
               */
               ltPropHighlightClass : Lyte.attr("string",{"default" : 'lyteautocompleteHighlight'}),
              /**
               * @componentProperty {string} ltPropKeyWords=''
               * @version 1.0.0
               */
               ltPropKeyWords : Lyte.attr("string",{"default" : ''}),
              /**
               * @componentProperty {number} ltPropMinLength=1
               * @version 1.0.0
               */
               ltPropMinLength : Lyte.attr('number',{'default' : 1}),
              /**
               * @componentProperty {string} ltPropErrorClass=lyteautocompleteError
               * @version 1.0.5
               */
               ltPropErrorClass : Lyte.attr('string',{'default' : 'lyteautocompleteError'}),
              /**
               * @componentProperty {string} ltPropDropdownWidth=auto
               * @version 1.0.0
               */
               ltPropDropdownWidth : Lyte.attr('string',{'default' : 'auto'}),
              /**
               * @componentProperty {string} ltPropDropdownHeight=300px
               * @version 1.0.0
               * @suffix px,pt,cm,mm,vh,vm,em
               */
               ltPropDropdownHeight : Lyte.attr('string',{'default' : '300px'}),
              /**
               * @componentProperty {string} ltPropDropdownClass=''
               * @version 1.0.0
               */
               ltPropDropdownClass : Lyte.attr('string', {'default' : ''}),
              /**
               * @componentProperty {string} ltPropDropdownId=lyteAutocomplete
               * @version 1.0.0
               */
               ltPropDropdownId : Lyte.attr('string', {'default' : 'lyteAutocomplete'}),
              /**
               * @componentProperty {startsWith | endsWith | contains} ltPropMethod=contains
               * @version 1.0.0
               */
               ltPropMethod : Lyte.attr('string',{'default' : 'contains'}),
               ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
               ltPropTabIndex : Lyte.attr('string',{default : '0'}),
               ltPropTabindex : Lyte.attr('string',{default : '-1'}),
               ltPropFreeze : Lyte.attr('boolean', { default: false}),
               ltPropCallout : Lyte.attr('boolean',{default : false}),
               ltPropDisabled : Lyte.attr('boolean', { default : false}),
               ltPropHover : Lyte.attr('boolean', { default : false}),
               ltPropBoundary : Lyte.attr('object', { default : {}}),
               ltPropPosition : Lyte.attr('string', { default : 'down'}),
              /**
               * @componentProperty {default | multiple | multisearch} ltPropDropType=default
               * @version 1.0.0
               */
               ltPropDropType : Lyte.attr('string', { default : 'default'}),
               ltPropSetPos : Lyte.attr('boolean', { default : false}),
               ltPropPattern : Lyte.attr('string', { default : ".+"}),
               ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),
              /**
               * @componentProperty {boolean} ltPropValueSet=true
               * @version 1.0.2
               */
               ltPropValueSet : Lyte.attr('boolean', { default : true}),
              /**
               * @componentProperty {boolean} ltPropPreventInsideClick=false
               * @version 1.0.2
               */
               ltPropPreventInsideClick : Lyte.attr('boolean', { default : false}),
              /**
               * @componentProperty {boolean} ltPropExtSearchOpen=false
               * @version 1.0.2
               */
               ltPropExtSearchOpen :Lyte.attr('boolean', { default : false }),
               ltPropInputTitle : Lyte.attr('string', { default : '' }),
              /**
               * @componentProperty {string} ltPropErrorMessage=''
               * @version 1.0.5
               */
               ltPropErrorMessage : Lyte.attr( 'string',{ default : '' } ),
              /**
               * @componentProperty {string} ltPropErrorClass=''
               * @version 1.0.5
               */
               ltPropErrorClass  :Lyte.attr( 'string', { default : '' } ),
               ltPropAnimate : Lyte.attr( 'boolean', { default : false } ),
               ltPropSelected : Lyte.attr( 'string', { default : '' } ),
              /**
               * @componentProperty {boolean} ltPropTrim=false
               * @version 2.2.6
               */
               ltPropTrim : Lyte.attr( 'boolean', { default : false } ),
               ltPropFocus : Lyte.attr( 'boolean', { default : false } ),

               // aria
               ltPropAria : Lyte.attr( 'boolean', { default : false } ),
               ltPropAriaAttributes : Lyte.attr( 'object', { default : {} } ),
               
               ltPropUpdateDelay : Lyte.attr( 'number', { default : 250 } ),

              /**
               * @experimental ltPropRows
               */
               ltPropRows : Lyte.attr("number",{"default" : undefined}),
              /**
               * @experimental ltPropCols
               */
               ltPropCols : Lyte.attr("number",{"default" : undefined}),
              /**
               * @experimental ltPropTextAreaResize
               */
               ltPropTextAreaResize : Lyte.attr("object",{"default" : {vertical : true, horizontal : true}}),

               /**
                * @componentProperty {boolean} ltPropDiacritic=false
                * @version 3.12.0
                */

               ltPropDiacritic : Lyte.attr( 'boolean', { default : false } ),

               /**
                * @componentProperty {object} ltPropDropdown
                * @version 3.12.0
                * @default {}
                */

               ltPropDropdown : Lyte.attr( 'object', { default : {} } ),

               /**
                * @componentProperty {object} ltPropInput
                * @version 3.12.0
                * @default {}
                */

               ltPropInput : Lyte.attr( 'object', { default : {} } ),

               // system data
              /**
               * @experimental timeout
               */
               timeout : Lyte.attr("number",{"default" : undefined}),
              /**
               * @experimental optGroup
               */
               optGroup : Lyte.attr("boolean",{"default" : false}),
              /**
               * @experimental autocompleteFlag
               */
               autocompleteFlag : Lyte.attr('boolean', {'default' : true})

             }
         },

// to Highlight selected text

    convertString : function( nodes, value ){
        var str = '';
        nodes.forEach( function( item ){
            var tag = item.tagName || '';
            if( /^template$/i.test( tag ) ){
                item.remove();
            } else if( tag ){
                this.convertString( Array.from( item.childNodes ), value );
            } else if( value ) {
                var str = item.nodeValue,
                lower = str.toLowerCase(),
                index = lower.indexOf( value ),
                is_modified,
                ref = item;

                while( index != -1 ){
                  var first = str.slice( 0, index ),
                  limit = index + value.length,
                  second = str.slice( index, limit ),
                  third = str.slice( limit ),
                  is_modified = true;

                  if( first ){
                    var node = document.createTextNode( first );
                    Lyte.Component.insertAfter( ref, ref = node );
                  }

                  var node = $L( document.createElement( 'span' ) ).addClass( this.data.ltPropHighlightClass ).get( 0 );
                  node.textContent = /* value */ second;
                  Lyte.Component.insertAfter( ref, ref = node );

                  str = third;
                  lower = str.toLowerCase();
                  index = lower.indexOf( value );
                }

                if( is_modified ){
                    if( str ){
                        var node = document.createTextNode( str );
                        Lyte.Component.insertAfter( ref, node );
                    }
                    item.remove();
                }
            }
        }.bind( this ));
    },

    highlightText : function( targetArray, inputValue ){
      var len = targetArray.length,
      LC = Lyte.Component;

      for( var i = 0; i < len; i++ ){
          var cur = targetArray[ i ],
          label = cur.getElementsByTagName( 'lyte-autocomplete-label' )[ 0 ],
          span = cur.getElementsByClassName( 'lyteAutoComplete' )[ 0 ],
          cloned_element = label.cloneNode( true );

          cloned_element.normalize();

          if( !span ){
             span = $L( '<div class = "lyteAutoComplete"></div>' ).get( 0 );
             LC.insertBefore( label, span );
          }

          $L( label ).css( 'display', 'none' );

          span.style.display = '';

          this.convertString( Array.from( cloned_element.childNodes ), inputValue );

          var __child = Array.from( cloned_element.childNodes ),
          fn = LC.appendChild.bind( LC, span );

          span.innerHTML = '';

          __child.forEach( fn );
      }

    },

    errorMessage : function( bool ){
        var elem = this.autocompleteComp,
        obj = {
          display : bool ? 'block' : 'none'
        };

        if( bool && !elem.style.width ){
            obj.width = window.getComputedStyle( this.$node ).getPropertyValue( 'width' );
        }

        $L( elem ).css( obj );
    },

    actions : {
        resetValue : function( evt ) {
          this.$node.setValue( '' );
          this.$node.focus();
        },
          //filtering process  checks
        "keyup":function(event){

            var keycode = event.keyCode || event.which;

            if( [ 37, 13, 38, 39, 40, 27 ].indexOf( keycode ) != -1 ){
                return;
            }

            var value = this.input.value;

            if( this.data.ltPropTrim ){
                value = value.trim();
            }

            clearTimeout( this.data.timeout );

            if( ( value.length >= this.data.ltPropMinLength || ( [ 8, 91, 17, 46 ].indexOf( keycode ) != -1 ) ) && keycode != 13 ){
                this.data.timeout = setTimeout( this.pressFunc.bind( this, value, event ), 100 );
            }  
        },

        input : function( evt ) {

          // keyup not happening in firefox android mobiles because of input event
          if( _lyteUiUtils.isAndroid && /firefox/ig.test( navigator.userAgent ) ) {
              clearTimeout( this.data.timeout );
              var value = evt.target.value;

              if( this.getData( 'ltPropTrim' ) ){
                 value = value.trim();
              }

              if( value.length >= this.data.ltPropMinLength ) {
                this.data.timeout = setTimeout( this.pressFunc.bind( this ), 100, value, evt );
              }
           }
        }    
    },

     methods : {
             // when dropdown value selected 

        valSet : function( event, selectedVal ){
            var targetElem = $L( ( event || window.event ).target ).closest( 'lyte-drop-item' ),
            cb = "onSelect";

            if( targetElem.length ){
                var label = targetElem.find( 'lyte-autocomplete-label' );
                selectedVal = label.text();
            }

            if( selectedVal ){
                if( this.getData( 'ltPropValueSet' )  ){
                    this.setData( 'ltPropValue', selectedVal.trim() );
                }

                if( this.getMethods( cb ) ){
                    var value;
                    if( this.data.ltPropYield ){
                        value = targetElem.attr( 'data-value' );
                    } else {
                        var ltPropContent = this.data.ltPropContent,
                        group = targetElem.closest( 'lyte-drop-group' ).get( 0 ),
                        children = this.arrayFrom( $L( this.dropbody ).children( 'lyte-drop-body' ).children() ),
                        target_dom = targetElem.get( 0 );

                        if( group ){
                            var grp_data = ltPropContent[ children.indexOf( group ) ];
                            value = grp_data[ Object.keys( grp_data )[ 0 ] ][ this.arrayFrom( targetElem.parent().children( 'lyte-drop-item' ) ).indexOf( target_dom ) ];
                        } else {
                            value = ltPropContent[ children.indexOf( target_dom ) ];
                        }
                    }

                    /**
                      * @method onSelect
                      */ 
                    this.executeMethod( cb, value, event, this.$node );
                }
            }
        },
           show :  function(){
              this.optGroupHide.call( this, true )
             /**
              * @method onShow
              */
              this.getMethods('onShow') && this.executeMethod('onShow', arguments[0], arguments[1])
           },
           hide :  function(){
             /**
              * @method onHide
              */
              this.getMethods('onHide') && this.executeMethod('onHide', arguments[0], arguments[1])
           },
           beforeShow : function( arg1, arg2 ){
             var ret,
             value = this.input.value,
             cb = "onBeforeShow";

             if( this.getData( 'ltPropTrim' ) ){
                 value = value.trim();
             }

              if( value.length < this.data.ltPropMinLength ) {
                 return false
              }
              if( this.getMethods( cb ) ) {
                 /**
                  * @method onBeforeShow
                  */
                  ret = this.executeMethod( cb, arg1, arg2 );
                  if( ret == false ){
                     return false
                  }
              }  
              if( ret && ret.then ) {
                  ret.then( function(){
                     if( this.dropdown && this.dropdown != _lyteDropdown.lastDropdownWithAPromise ){
                        return;
                     }
                     setTimeout( this.pressFunc.bind( this ), 0, value, {} );
                  }.bind( this ) );
                  return ret;
              } else if( !this._bymanual ) {
                  setTimeout( this.pressFunc.bind( this ), 0, value, {} );
              } 
           },
           beforeHide : function( evt, arg2 ){

              if( this.getData( 'ltPropPreventInsideClick' ) && evt && evt.type == "click" ) {
                if( this.$node.contains( evt.target) ) {
                    return false
                 }
              }
              if(this.getMethods('onBeforeHide')){
               /**
                * @method onBeforeHide
                */
                return this.executeMethod('onBeforeHide', evt, arg2 )
              } 
           },
           add : function(){
              var arg = arguments,
              cb = "onAdd";

              this.getMethods( cb ) && this.executeMethod( cb, arg[ 0 ], arg[ 1 ], arg[ 2 ], arg[ 3 ] );
           },
           remove : function(){
              var arg = arguments,
              cb = "onRemove";

              this.getMethods( cb ) && this.executeMethod( cb, arg[ 0 ], arg[ 1 ], arg[ 2 ], arg[ 3 ] );
           },
           positionChanged : function( arg1, arg2 ){
              var cb = 'onPositionChanged';
             /**
              * @method onPositionChanged
              */
              this.getMethods( cb ) && this.executeMethod( cb, arg1, arg2 );
           },
           scroll : function(){
             /**
              * @method onScroll
              */
              this.getMethods('onScroll') && this.executeMethod('onScroll', arguments[0], arguments[1]);
           },
          valuechange : function(arg1){
             /**
              * @method onValueChange
              */
              this.getMethods('onValueChange') && this.executeMethod('onValueChange', arg1, this.$node);
          },
          blurEvent : function(arg1){
             /**
              * @method onBlur
              */
              this.getMethods('onBlur') && this.executeMethod('onBlur',arg1,this.$node);
          },
          
          focus :function( arg1, arg2 ){
             /**
              * @method onFocus
              */
              this.getMethods('onFocus') && this.executeMethod('onFocus',arg1, this.$node);
          }

        },

        filteringArray : function( searchList, targetList, val, event ){
            var data = this.data,
            method = data.ltPropMethod,
            visibleList = [],
            hiddenList = [],
            cb = 'onSearch',
            className = 'lyteSearchHidden';

            if( val.length ){
                var len = searchList.length;

                for( var i = 0; i < len; i++ ){
                    var check = false,
                    str = searchList[ i ].trim().toLowerCase(),
                    __index = str.indexOf( val );

                    switch( method ){
                      case 'contains' : {
                          check = __index >= 0;
                          break;    
                       }
                       case 'startsWith' : {
                          check = __index == 0;
                          break;  
                       }
                       case 'endsWith' : {
                            var __index = str.lastIndexOf( val );
                            if( __index != -1 ) {
                                check = ( __index + val.length ) == str.length;
                            } 
                            break;
                       }
                    } 
                    if( check ){
                       visibleList.push( targetList[ i ] );
                    } else {
                       hiddenList.push( targetList[ i ] );
                    }
                }

            } else {
                visibleList = this.arrayFrom( targetList );
            }
             /**
              * @method onSearch
              */
            if( this.getMethods( cb ) && this.executeMethod( cb, visibleList, this.autocompleteComp, this.$node, val, event ) == false ){
              return;
            }

            visibleList.forEach( function( item ){
                item.classList.remove( className );
            });

            hiddenList.forEach( function( item ){
                item.classList.add( className );
            });

            this.optGroupHide();
            this.errorMessage( !visibleList.length ); 
            if( visibleList.length && this.data.ltPropHighlight ) {
               this.highlightText( targetList, val );
            }
        },

        // hide category

        optGroupHide : function( bool ){
            var item_str = "lyte-drop-item",
            hiddenClass = 'lyteSearchHidden',
            selectionClass = 'lyteDropdownSelection',
            dropbody = $L( this.dropbody ),
            items = dropbody.find( item_str + ':not(.' + hiddenClass + '):not(.lyteDropdownActive)' ),
            selected = dropbody.find( item_str + '.' + selectionClass ).get( 0 );

            if( !bool ){
                var categories = dropbody.find( 'lyte-drop-group' ),
                __length = categories.length;

                for( var i = 0; i < __length; i++ ){
                    var current = categories.eq( i );
                    if( current.find( item_str + '.' + hiddenClass ).length == current.find( item_str ).length ){
                       current.css( 'display', 'none' );
                    } else {
                       current.css( 'display', 'block' );
                    }
                }
            }

            $L.fastdom.measure( function(){
                  var curr,
                  __length = items.length;

                  for( var i = 0; i < __length; i++ ) {
                      var $curr = items.eq( i ),
                      curr_dom = $curr.get( 0 );

                      if( curr_dom.offsetParent && !$curr.hasClass( 'lyteDropdown-disabled' )  ){
                        curr = curr_dom;
                        break;
                      }
                  }
                  $L.fastdom.mutate( function(){
                    if( curr && selected != curr ) {
                      $L( selected ).removeClass( selectionClass );
                      $L( curr ).addClass( selectionClass );
                    }
                  }.bind( this ) );
              }.bind( this ) );

        },

        contentFiltering : function( val, event ){
            var dropdown = this.dropdown,
            content = [],
            $dropbody = $L( this.dropbody ),
            hiddenClass = 'lyteDropdownHidden',
            data = this.data,
            is_hidden = $dropbody.hasClass( hiddenClass ),
            __length = val.length,
            minLength = data.ltPropMinLength;

            event = event || {};

            if( ( is_hidden && __length >= minLength ) || ( !is_hidden && __length < minLength ) ){
                this._bymanual = true;
                dropdown.toggle();
                delete this._bymanual;

                if( $dropbody.hasClass( hiddenClass ) ){
                  return;
                }
            }

            var target = $dropbody.find( 'lyte-drop-item:not(.lyteDropdownActive)' ),
            dia = data.ltPropDiacritic,
            __len = target.length;

            for( var k = 0; k < __len; k++ ){
                var label = target.eq( k ).find( 'lyte-autocomplete-label' ),
                keyword = label.attr( 'keywords' );

                if( keyword ){
                    try{
                        keyword = JSON.parse( keyword ).join( ' ' );
                    } catch( err ){
                        keyword = '';
                    }
                }

                var valueToPush = keyword || label.text().trim();

                if( dia ){
                    valueToPush = _lyteUiUtils.convert_diacritics( valueToPush );
                }

                content.push( valueToPush );
            }

            if( dia ){
                val = _lyteUiUtils.convert_diacritics( val );
             }
             this.filteringArray( content, target, val.toLowerCase(), event )
        },

        // filtering process  
        pressFunc : function( val, event ){
            var data = this.data;

            if( data.ltPropTrim ){
                val = val.trim();
            }

            if( !data.ltPropExternalSearch ){
                 this.contentFiltering( val, event );
            } else {
                var $dropbody = $L( this.dropbody ),
                hiddenClass = 'lyteDropdownHidden',
                dropdown = this.dropdown,
                cb = 'onExtSearch';

                if( val.length >= data.ltPropMinLength || !event.target ){
                    if( event.type && $dropbody.hasClass( hiddenClass ) && data.ltPropExtSearchOpen ){
                        dropdown.toggle();
                        if( $dropbody.hasClass( hiddenClass ) ){
                            return;
                        }
                    }
                    if( this.getMethods( cb ) ){
                        /**
                          * @method onExtSearch
                          */
                        this.executeMethod( cb, val, this.$node, event );
                    }
                } else if( !$dropbody.hasClass( hiddenClass ) ) {
                    dropdown.toggle();
                }
            }
        }
  });

/**
 * @syntax nonYielded
 * <lyte-autocomplete lt-prop-appearance='flat' lt-prop-content='[{"label":"New File","key":"Ctrl + N","words":["new"]}]' lt-prop-highlight='true'>
 * </lyte-autocomplete>
 */

/**
 * @syntax yielded
 *  <lyte-autocomplete lt-prop-yield="true" lt-prop-appearance='flat' lt-prop-highlight=true >
 *     <template is="registerYield" yield-name="yield">
 *        <lyte-drop-box>
 *            <lyte-drop-body>
 *                <lyte-drop-item>
 *                   <lyte-autocomplete-label keywords='["new","file","document"]'> New File </lyte-autocomplete-label> 
 *                   <lyte-autocomplete-description> Ctrl + N </lyte-autocomplete-description> 
 *                </lyte-drop-item> 
 *            </lyte-drop-body>
 *        </lyte-drop-box>
 *    </template> 
 * </lyte-autocomplete>
 */
/**
 * This is used to indicate the current position in a page
 * @component lyte-breadcrumb
 * @version 1.0.0
 * @methods onClick
 * @utility modifyCrumbItems
 */


Lyte.Component.register('lyte-breadcrumb',{
_template:"<template tag-name=\"lyte-breadcrumb\"> <div onclick=\"{{action('divClick',event,this)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-breadcrumb-structure class=\"{{ltPropClass}}\"> <template is=\"for\" items=\"{{ltPropData}}\" item=\"array\" index=\"indexVal\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(array),'==',false)}}\"><template case=\"true\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteBreadcrumbBullet')}}\"><template case=\"true\"> <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-breadcrumb-body> {{array}} </lyte-breadcrumb-body> <lyte-breadcrumb-head>{{indexVal}}</lyte-breadcrumb-head> </lyte-breadcrumb-item> </template><template case=\"false\"> <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-breadcrumb-body> {{array}} </lyte-breadcrumb-body> </lyte-breadcrumb-item> </template></template></template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteBreadcrumbBullet')}}\"><template case=\"true\"> <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-breadcrumb-body> {{array[ltPropLabel]}} </lyte-breadcrumb-body> <lyte-breadcrumb-head>{{array[ltPropOption]}}</lyte-breadcrumb-head> </lyte-breadcrumb-item> </template><template case=\"false\"> <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-breadcrumb-body> {{array[ltPropLabel]}} </lyte-breadcrumb-body> </lyte-breadcrumb-item> </template></template></template></template></template> </lyte-breadcrumb-structure> </template><template case=\"false\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropClass","ltPropData","ltPropActiveClass","ltPropCompletedClass","ltPropYield","ltPropLabel","ltPropOption","ltPropAria","ltPropAriaValue"],
	init : function(){
	   /**
        * @method beforeRender
        * @version 1.0.1
        */
		this.getMethods('beforeRender') && this.executeMethod('beforeRender', this.$node);
	},	

	didDestroy : function(){
		clearTimeout( this._timeout );
		delete this.$node.modifyCrumbItems;
	},

	didConnect : function(){
		this.ArrayContentChange();
		this.$node.modifyCrumbItems = function( property, arg1, arg2 ){
			if( !this.data.ltPropYield ){
				Lyte.arrayUtils( this.data.ltPropData, property, arg1, arg2 );
			} else {
				this.ArrayContentChange();
			}
		}.bind( this );

		this.breadcrumbClass();

		$L.fastdom.measure( function(){
			var is_rtl = _lyteUiUtils.getRTL();
			$L.fastdom.mutate( function(){
				if( is_rtl ){
					$L( this.$node ).addClass( 'lyteRTL' );
				}
			}.bind( this ));
		}.bind( this ));

		var cb = "afterRender";
		/**
        * @method afterRender
        * @version 1.0.1
        */
       if( this.getMethods( cb ) ){
       		this.executeMethod( cb, this.$node );
       }
	},

	ArrayContentChangeObs : function(){
		clearTimeout( this._timeout );
		this._timeout = setTimeout( this.ArrayContentChange.bind( this ), 0 );
	}.observes( 'ltPropData.[]', 'ltPropData' ),

	ArrayContentChange : function(){
		var data = this.data,
		active = data.ltPropActiveClass,
		completed = data.ltPropCompletedClass,
		aria = data.ltPropAria,
		innerElements = $L( 'lyte-breadcrumb-item', this.$node ),
		__length = innerElements.length - 1,
		last = innerElements.eq( -1 );

		for( var i = 0; i < __length; i++ ){
			var cur = innerElements.eq( i );
			cur.addClass( completed ).removeClass( active );
			if( aria ){
				cur.find( 'a' ).removeAttr( 'aria-current' );
			}
		}

		last.removeClass( completed ).addClass( active );
		if( aria ){
			last.find( 'a' ).attr( 'aria-current', data.ltPropAriaValue );
		}
	},

	breadcrumbClassObs : function(){
		this.breadcrumbClass();
	}.observes('ltPropClass'),

	breadcrumbClass : function(){
		if( this.data.ltPropYield ) {
			$L( 'lyte-breadcrumb-structure', this.$node ).addClass( this.data.ltPropClass );
		}
	},
	data : function(){
        return {
			//  user data
		   /**
			* @componentProperty {string} ltPropClass=lyteBreadcrumbSlash
			* @version 1.0.0
			*/
			ltPropClass : Lyte.attr("string",{"default":'lyteBreadcrumbSlash'}),
		   /**
			* @componentProperty {string[] | object[]} ltPropData
			* @version 1.0.0
			* @default []
			*/
			ltPropData : Lyte.attr("array",{"default":[]}),
		   /**
			* @componentProperty {string} ltPropActiveClass=lyteActive
			* @version 1.0.0
			*/
			ltPropActiveClass : Lyte.attr("string",{"default":'lyteActive'}),
		   /**
			* @componentProperty {string} ltPropCompletedClass=lyteCompleted
			* @version 1.0.0
			*/
			ltPropCompletedClass : Lyte.attr("string",{"default":'lyteCompleted'}),
		   /**
			* @componentProperty {boolean} ltPropYield=false
			* @version 1.0.0
			*/
			ltPropYield : Lyte.attr("boolean",{"default":false}),
		   /**
			* @componentProperty {string} ltPropLabel=''
			* @version 1.0.0
			*/
			ltPropLabel : Lyte.attr('string', {'default': ''}),
		   /**
			* @componentProperty {string} ltPropOption=''
			* @version 1.0.0
			*/			
            ltPropOption : Lyte.attr('string', {'default': ''}),

            // aria
		   /**
			* @componentProperty {boolean} ltPropAria=false
			* @version 3.1.0
			*/
            ltPropAria : Lyte.attr( 'boolean', { default : false } ),
           /**
			* @componentProperty {string} ltPropAriaValue=page
			* @version 3.1.0
			*/
            ltPropAriaValue : Lyte.attr( 'string', { default : "page" } )
		}
	},
	actions : {
	   'onclick' : function ( event, Component, data ){
		   	var target = event.target,
		   	cb = 'onClick';

			if( ( event.ctrlKey == true || event.metaKey == true || event.which == 2 ) && event.target.href != undefined && target.href.indexOf( 'javascript:' ) != -1 && target.target == '_blank' ){
				return false;
			}

			if( this.getMethods( cb ) ){
				this.executeMethod( cb, Component, this.$node, event, data );
				event.stopPropagation();	
			}
		},
        divClick : function( event, div ){
        	var target = event.target,
        	cb = "onClick";

			if( ( event.ctrlKey == true || event.metaKey == true || event.which == 2 ) && target.href != undefined && target.href.indexOf( 'javascript:' ) != -1 && target.target == '_blank' ){
				return false;
			}
            if( this.getMethods( cb ) && this.data.ltPropYield ) {

            	var node = $L( target.correspondingElement || target ).closest( 'lyte-breadcrumb-item', div );

            	if( node.length ){
            		this.executeMethod( cb, node.get( 0 ), this.$node, event, node.attr( 'data-value' ) );
            	}
            }
        }
	}
});

/**
 * @syntax yielded
 *  <lyte-breadcrumb lt-prop-yield="true">
 *		<template is="registerYield" yield-name="yield">
 *			<lyte-breadcrumb-structure>
 *				<lyte-breadcrumb-item>
 *					<lyte-breadcrumb-body>
 *						Home 
 *					</lyte-breadcrumb-body>
 *				</lyte-breadcrumb-item>
 *				<lyte-breadcrumb-item>
 *					<lyte-breadcrumb-body>
 *						Menu 
 *					</lyte-breadcrumb-body>
 *				</lyte-breadcrumb-item>
 *				<lyte-breadcrumb-item>
 *					<lyte-breadcrumb-body>
 *						Edit 
 *					</lyte-breadcrumb-body>
 *				</lyte-breadcrumb-item>
 *				<lyte-breadcrumb-item>
 *					<lyte-breadcrumb-body>
 *						Save 
 *					</lyte-breadcrumb-body>
 *				</lyte-breadcrumb-item>
 *			</lyte-breadcrumb-structure>
 *		</template>
 *	</lyte-breadcrumb>
 */

/**
 * @syntax nonYielded
 * <lyte-breadcrumb lt-prop-data='["home","works",{"name": "Leads"},{"name": "Contacts"},{"name": "Services"}]' lt-prop-label="name">
 * </lyte-breadcrumb>
 */
/**
 * Renders a button
 * @component lyte-button
 * @version 1.0.0
 * @utility click, focus, blur
 * @dependencies lyte-shortcut
 * 		/plugins/lyte-shortcut.js
 */ 

Lyte.Component.register( 'lyte-button', {
_template:"<template tag-name=\"lyte-button\" onclick=\"{{action('check',event)}}\" onmousedown=\"{{action('check',event)}}\"> <button type=\"{{ltPropType}}\" class=\"{{finalClass}}\" value=\"{{ltPropValue}}\" tabindex=\"{{ltPropTabindex}}\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" style=\"{{finalStyle}}\"> <lyte-yield yield-name=\"text\"></lyte-yield> </button> </template>",
_dynamicNodes : [{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"finalStyle"},"type":{"name":"type","dynamicValue":"ltPropType"}}},{"type":"insertYield","position":[1,1]}],
_templateAttributes :{"type":"attr","position":[]},
_observedAttributes :["ltPropName","ltPropDisabled","ltPropAutofocus","ltPropAppearance","ltPropId","ltPropType","ltPropValue","ltPropTabindex","ltPropStyle","ltPropSize","ltPropBackgroundColor","ltPropColor","lyteShortcut","ltPropClass","lyteUnbound","ltPropAriaButton"],
	data: function() {
		return {

			/**
			 * @componentProperty {string} ltPropName
			 */

			'ltPropName': Lyte.attr( 'string', {
				'default': undefined
			} ),


			/**
			 * @componentProperty {boolean} ltPropDisabled=false
			 */

			'ltPropDisabled': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {boolean} ltPropAutoFocus=false
			 */

			'ltPropAutofocus': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {default | primary | secondary | success | failure} ltPropAppearance=default
			 */

			'ltPropAppearance': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'appearance', 'default' )
			} ),

			/**
			 * @componentProperty {string} ltPropId
			 */

			'ltPropId': Lyte.attr( 'string', {
				'default': undefined
			} ),

			/**
			 * @componentProperty {button | submit | reset} ltPropType=button
			 */

			'ltPropType': Lyte.attr( 'string', {
				'default': 'button'
			} ),

			/**
			 * @componentProperty {string} ltPropValue
			 */

			'ltPropValue': Lyte.attr( 'string', {
				'default': undefined
			} ),

			/**
			 * @componentProperty {string} ltPropTabindex
			 */

			'ltPropTabindex': Lyte.attr( 'string', {
				'default': undefined
			} ),

			/**
			 * @componentProperty {string} ltPropStyle
			 */

			'ltPropStyle': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'style', undefined )
			} ),

			/**
			 * @componentProperty {extra-small | small | medium | large} ltPropSize=default
			 */

			'ltPropSize': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'size', 'default' )
			} ),
			/**
			 * @componentProperty {colorString} ltPropBackgroundColor
			 */

			'ltPropBackgroundColor': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'backgroundColor', undefined )
			} ),
			/**
			 * @componentProperty {colorString} ltPropColor
			 */

			'ltPropColor': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'color', undefined )
			} ),

			/**
			 * @componentProperty {string} lyteShortcut
			 */

			'lyteShortcut': Lyte.attr( 'string', {
				'default': ''
			} ),

			/**
			 * @componentProperty {string} ltPropClass
			 */

			'ltPropClass':Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'class', '' )
			} ),

			'lyteUnbound': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {object} ltPropAriaButton={}
			 * @version 3.1.0
			 */

			'ltPropAriaButton': Lyte.attr( 'object', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-button', 'ariaButton', {} )
			} )
		}
	},

	ariaObserver: function( change ) {
		var oldAria = change.oldValue,
		newAria = change.newValue;

		this.addAriaValues( oldAria, newAria );
	}.observes( 'ltPropAriaButton' ),

	init: function() {
		this.pushValue();
	},

	registerFunction: function( fn ) {
		var that = this;
		this.$node[ fn ] = function() {
			var node = that.$node,
			button = node.querySelector( 'button' ),
			disabled = node.ltProp( 'disabled' );

			if( disabled ) {
				return ;
			}

			button[ fn ]();
		}
	},

	didConnect: function() {
		var fns = [ 'click', 'focus', 'blur' ], i = 0,
		oldAria = {}, newAria = this.getData( 'ltPropAriaButton' );

		for( ; i < fns.length; i++ ) {
			this.registerFunction( fns[ i ] );
		}

		this.addAriaValues( oldAria, newAria );
	},

	addAriaValues: function( oldAria, newAria ) {
		var button = this.getButtonWidget();

		_lyteUiUtils.setAttribute( button, newAria, oldAria );
	},

	getButtonWidget: function() {
		return this.$node.querySelector( 'button' );
	},

	didDestroy: function() {
		var val = this.getData('lyteShortcut');
		if( val ) {
			if( typeof shortcut === 'function' ) {
				shortcut.push( {
					newKey: undefined,
					type: undefined,
					wait: undefined,
					oldKey: val.key
				} );
			}
		}

		delete this.$node.focus;
		delete this.$node.blur;
		delete this.$node.click;
	},

	shortcutChanged: function() {
		this.pushValue();
	}.observes( 'lyteShortcut' ),

	pushValue: function() {
		var key = this.getData( 'lyteShortcut' ),
		node = this.$node;

		if(!key){
			return
		}
		newObj = JSON.parse( key );
		if(Array.isArray(newObj)){
			newObj.forEach(function(item){
				if(item.key){
					shortcut.push( {
						newKey : item.key,
						type : item.type,
						wait : item.wait,
						oldKey:undefined,
						value:node
					} );
				}
			})
		}
		else{
			if(newObj.key){
				shortcut.push( {
					newKey : newObj.key,
					type : newObj.type,
					wait : newObj.wait,
					oldKey:undefined,
					value:node
				} );
			}
		}
	},

	changeClass: function() {
		var cls = this.getData( 'ltPropClass' ), tempStyle = '', 
		tempClass = 'lyte-button' + ( cls ? ' ' + cls : '' ),
		app = this.getData( 'ltPropAppearance' ), size = this.getData( 'ltPropSize' ),
		color = this.getData( 'ltPropColor' ), bg = this.getData( 'ltPropBackgroundColor' );
		size = size ? size.toLowerCase() : '';
		app = app ? app : 'default';

		if( bg ) {
			tempClass = tempClass + ' lyteBackgroundColorBtn';
		}
		else if( color ) {
			tempClass = tempClass + ' lyteColorBtn';
		}
		else if( app.indexOf( 'default' ) !== -1 ) {
			tempClass = tempClass + ' lyteDefaultBtn';
		}
		else if( app.indexOf( 'primary' ) !== -1 ) {
			tempClass = tempClass + ' lytePrimaryBtn';
		}
		else if( app.indexOf( 'secondary' ) !== -1 ) {
			tempClass = tempClass + ' lyteSecondary';
		}

		if( app.indexOf( 'success' ) !== -1 ) {
			tempClass = tempClass + ' lyteSuccess';
		}
		else if( app.indexOf( 'failure' ) !== -1 ) {
			tempClass = tempClass + ' lyteFailure';
		}

		if( size === 'extra-small' ) {
			tempClass = tempClass + ' lyteExsm';
		}
		else if( size === 'small' ) {
			tempClass = tempClass + ' lyteSm';
		}
		else if( size === 'large' ) {
			tempClass = tempClass + ' lyteLg';
		}

		if( color ) {
			if( !bg ) {
				// Adding bg-color #fff because androids render a grayish button.
				tempStyle = tempStyle + 'background-color: #fff; color:' + color + ';border-color:' + color + ';';
			}
			else {
				tempStyle = tempStyle + 'background-color:' + bg + ';border-color:' + bg + ';color:' + color + ';';
			}
		}
		else if( bg ) {
			tempStyle = tempStyle + 'background-color:' + bg + ";border-color:" + bg + ";color:white;";
		}

		if( this.getData( 'ltPropStyle' ) ) {
			tempStyle = tempStyle + this.getData( 'ltPropStyle' );
		}

		this.setData( 'finalStyle', tempStyle );
		this.setData( 'finalClass', tempClass );
	}.observes(
		'ltPropClass',
		'ltPropBackgroundColor',
		'ltPropColor',
		'ltPropStyle',
		'ltPropSize',
		'ltPropAppearance'
	).on( 'init' ),
	actions: {
		check: function( event ) {
			var button = this.$node.querySelector( 'button' )
			if( button.disabled ) {
				event.stopPropagation()
			}
		}
	}
} );

/**
 * @syntax yielded
 * <lyte-button>
 *     <template is="registerYield" yield-name="text">
 *         click me
 *     </template>
 * </lyte-button>
 */

/**
 * Renders a notification badge
 * @component lyte-badge
 * @version 2.2.0
 */

Lyte.Component.register("lyte-badge", {
_template:"<template tag-name=\"lyte-badge\"> <div class=\"lyteBadge\"> <span class=\"lyteBadgeContent\">{{ltPropData}} <lyte-yield yield-name=\"lyteBadgeYield\"></lyte-yield> </span> </div> </template>",
_dynamicNodes : [{"type":"text","position":[1,1,0]},{"type":"insertYield","position":[1,1,2]}],
_observedAttributes :["ltPropBadgeStyle","ltPropPosition","ltPropData","ltPropMaxLength"],
	data : function(){
		return {
			/**
			 * @componentProperty {object} ltPropBadgeStyle
			 */

			'ltPropBadgeStyle' : Lyte.attr('object' , { default : {}
			}),

			/**
			 * @componentProperty {topRight|topLeft|bottomRight|bottomLeft} ltPropPosition
			 * @default topRight
			 */

			'ltPropPosition' : Lyte.attr('string' , {
				default : 'topRight'
			}),

			/**
			 * @componentProperty {string} ltPropData
			 */

			'ltPropData' : Lyte.attr('string' , {
				default : ''
			}),

			/**
			 * @componentProperty {number} ltPropMaxLength
			 * @default 0
			 */

			'ltPropMaxLength' : Lyte.attr('number' , {
				default : 0
			})
		}
	},
	didConnect : function(){

		var maxCount = this.getData('ltPropMaxLength');

		if(maxCount !== 0){

			var countStr = ''

			for(var i=0 ; i<maxCount ;i++){

				countStr += '9';

			}

			countStr = parseInt(countStr);

			var userData = parseInt(this.getData('ltPropData'))

			if(countStr < userData){

				this.setData('ltPropData' , countStr + '+')

			}

		}


		if(window.getComputedStyle(this.$node.parentElement).position === "static"){
			this.$node.parentElement.style.position = 'relative';
		}
		var styleObject = this.getData('ltPropBadgeStyle');
		var lyteBadgeDiv = this.$node.querySelector('.lyteBadge');
		var newStyle = '';
		for(css in styleObject){
			newStyle += css + ":" + styleObject[css] + ';';
		}
		lyteBadgeDiv.setAttribute('style' , newStyle);
		if(this.getData('ltPropData') === ''){
			lyteBadgeDiv.classList.add('lyteBadgeWidHeiWD');
		} else {
			lyteBadgeDiv.classList.add('lyteBadgeWidHeiD');
		}

		var positionData = this.getData('ltPropPosition');
		positionData = 'lyteBadge' + positionData.charAt(0).toUpperCase() + positionData.slice(1);
		lyteBadgeDiv.classList.add(positionData);
	}
});


/**
 * @syntax yielded
 * <lyte-badge>
 *    <template is="registerYield" yield-name='lyteBadgeYield'>
 *        *
 *    </template>
 * </lyte-badge>
 */

/**
 * Renders a button-group
 * @dependency lyte-grouper,lyte-button
 * @component lyte-button-group
 * @version 3.1.0
 * @methods onBeforeSelected,onSelected,onBeforeUnselected,onUnselected,onChanged
 * @import lyte-grouper
 * @ignoreProperties ltPropAlignment,ltPropAppearance,ltPropWidth,ltPropSelectedClass
 */
Lyte.Component.register("lyte-button-group", {
_template:"<template tag-name=\"lyte-button-group\" style=\"width:{{ltPropWidth}}\" onclick=\"{{action('click')}}\"> <lyte-grouper lt-prop-alignment=\"{{ltPropAlignment}}\" lt-prop-appearance=\"{{ltPropAppearance}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-yield yield-name=\"yield\" class=\"lyteBtnGroupWrap\"> </lyte-yield> </template> </lyte-grouper> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"insertYield","position":[1]}]},{"type":"componentDynamic","position":[1]}],
_templateAttributes :{"type":"attr","position":[],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width:'","ltPropWidth"]}}}},
_observedAttributes :["ltPropType","ltPropAlignment","ltPropAppearance","ltPropSelectedValues","ltPropSelected","ltPropSelectedClass","ltPropWidth","ltPropFireOnInit","preventSelect"],
	data : function(){
		return {
			/** 
			 * @componentProperty {checkbox | radiobutton} ltPropType=checkbox
			 */
			ltPropType : Lyte.attr("string",{"default" : "checkbox"}),
			/** 
			 * @componentProperty {Horizontal | Vertical} ltPropAlignment=Horizontal
			 */
			ltPropAlignment : Lyte.attr("string", {
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-button-group', 'alignment', "Horizontal" )
			}),
			/** 
			 * @componentProperty {fill | line} ltPropAppearance=line
			 */
			ltPropAppearance : Lyte.attr("string",{
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-button-group', 'appearance', "line" )
			}),
			/** 
			 * @componentProperty {array} ltPropSelectedValues
			 * @default []
			 */
			ltPropSelectedValues : Lyte.attr("array",{"default" : []}),
			/** 
			 * @componentProperty {string} ltPropSelected=""
			 */
			ltPropSelected : Lyte.attr("string",{"default" : ""}),
			/** 
			 * @componentProperty {string} ltPropSelectedClass=lyteBtnGroupSelectedBtn
			 */
			ltPropSelectedClass : Lyte.attr("string",{
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-button-group', 'selectedClass', "lyteBtnGroupSelectedBtn" )
			}),
			/** 
			 * @componentProperty {string} ltPropWidth=auto
			 * @default auto
			 */
			ltPropWidth : Lyte.attr("string",{"default" : "auto"}),
			/** 
			 * @componentProperty {boolean} ltPropFireOnInit=false
			 */
			ltPropFireOnInit : Lyte.attr("boolean",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-button-group', 'fireOnInit', false )
			}),
			preventSelect : Lyte.attr("boolean",{"default" : false})
		}		
	},
	isRadioButton : function(){
		if(this.data.ltPropType === "radiobutton"){
			return true;
		}
	},
	isCheckbox : function(){
		if(this.data.ltPropType === "checkbox"){
			return true;
		}
	},
	didConnect : function(){
		if(this.data.ltPropFireOnInit){
			this.setupButtons(); //ForCallbacks
		}
		else{
			if(this.isRadioButton()){
				this.updateButtons([],[this.data.ltPropSelected]);
			}
			else if(this.isCheckbox()){
				this.updateButtons([],this.data.ltPropSelectedValues);
			}
		}
	},
	updateButtons: function(oldValue,newValue){
		var oldButton = this.getSelectedButtons(oldValue),
		newButton =  this.getSelectedButtons(newValue);
		if(oldButton.length > 0){
			this.removeClass(oldButton);
		}
		if(newButton.length > 0){
			this.addClass(newButton);
		}
	},
	setupButtons : function(){
		var type =  this.data.ltPropType;
		if(type === "radiobutton" && this.data.ltPropSelected){
			this.changeRadiobutton("",this.data.ltPropSelected);
		}
		else if(type === "checkbox" && this.data.ltPropSelectedValues.length > 0){
			this.selectCheckbox(this.data.ltPropSelectedValues);
		}
	},
	setSelectedValue : function(dataName,value){
		this.setData("preventSelect",true);
		this.setData(dataName,value);
		this.setData("preventSelect",false);
	},
	changeCheckbox : function(oldArray,newArray,oldValue,index,event){
		var	unselectedButtons = this.getSelectedButtons(oldArray),
		selectedButtons =  this.getSelectedButtons(newArray),
		oldButtons =  this.getSelectedButtons(oldValue),
		newButtons = oldButtons.slice();
		if(oldArray.length > 0){
			if(this.onBeforeUnselected(oldArray,unselectedButtons,event)){
				return;
			}
			this.removeClass(unselectedButtons);
			Lyte.arrayUtils(this.getData("ltPropSelectedValues"),"removeAt", index ,1);
			newButtons.splice(index,1);
			this.onUnselected(oldArray,unselectedButtons,event);
		}
		if(newArray.length > 0){
			if(this.onBeforeSelected(newArray,selectedButtons,event)){
				this.setSelectedValue("ltPropSelectedValues",oldValue);
				return;
			}
			this.addClass(selectedButtons);
			Lyte.arrayUtils(this.getData("ltPropSelectedValues"),"push",newArray[0]);
			newButtons.push(selectedButtons[0]);
			this.onSelected(newArray,selectedButtons,event);
		}
		this.onChanged(oldValue,this.data.ltPropSelectedValues, oldButtons,newButtons);
	},
	selectCheckbox : function(newValue){
		var newButtons = this.getSelectedButtons(newValue);
		if(newValue.length > 0){
			if(this.onBeforeSelected(newValue,newButtons,event)){
				this.setSelectedValue("ltPropSelectedValues",[]);
				return;
			}
			this.addClass(newButtons);
			this.onSelected(newValue,newButtons,event);
		}
		this.onChanged([], newValue,[],newButtons);
	},
	changeRadiobutton : function(oldValue,newValue,event){
		var oldButton = this.getSelectedButton( oldValue ),
		newButton = this.getSelectedButton( newValue );
		if(oldButton && this.onBeforeUnselected(oldValue,oldButton,event)){
			this.setSelectedValue("ltPropSelected",oldValue);
			return;
		}
		if(newButton && this.onBeforeSelected(newValue,newButton,event)){
			this.setSelectedValue("ltPropSelected",oldValue);
			return;
		}
		if(oldButton){
			this.removeClass([oldButton]);
			this.onUnselected(oldValue,oldButton,event);
		}
		if(newButton){
			this.addClass([newButton]);
			if(event){
				this.setSelectedValue("ltPropSelected",newValue);
			}
			this.onSelected(newValue,newButton,event);
		}
		this.onChanged( oldValue, newValue, oldButton, newButton);
	},
	onBeforeSelected: function( values, buttons, event ) {
		if( this.getMethods( 'onBeforeSelect' ) ) {
			if(this.executeMethod( 'onBeforeSelect', values, buttons,event ) === false){
				return true;
			}
		}
	},
	onSelected : function(values, buttons, event){
		if( this.getMethods( 'onSelect' ) ) {
			this.executeMethod( 'onSelect',values, buttons, event );
		}
	},
	onBeforeUnselected: function( values, buttons, event ) {
		if( this.getMethods( 'onBeforeUnselect' ) ) {
			if(this.executeMethod( 'onBeforeUnselect', values, buttons,event ) === false){
				return true;
			}
		}
	},
	onUnselected : function(values, buttons, event){
		if( this.getMethods( 'onUnselect' ) ) {
			this.executeMethod( 'onUnselect',values, buttons, event );
		}
	},
	onChanged: function(oldValue, newValue, prevLyteButtons,currentLyteButtons) {
		if( this.getMethods( 'onChanged' ) ) {
			this.executeMethod( 'onChanged',oldValue, newValue, prevLyteButtons, currentLyteButtons);
		}
	},
	getSelectedButtons : function(arr){ // this for array
		var array = [];
		for(var index=0;index<arr.length;index++){
			if(arr[index]){
				var button = this.$node.querySelector("[lt-prop-value ='"+window._lyteUiUtils.escape(arr[index])+"']");
				if(button){
					array.push(button);
				}
			}
		}
		return array;
	},
	getSelectedButton : function(value){
		if(value){
			var button = this.$node.querySelector("[lt-prop-value ='"+window._lyteUiUtils.escape(value)+"']");
			return button;
		}
	},
	removeClass: function(nodes){
		var className =  this.data.ltPropSelectedClass;
		if(className){
			nodes.forEach(function(node){
				var button = node.querySelector("button");
				button.classList.remove(className);
			});
		}
	},
	addClass: function(nodes){
		var className =  this.data.ltPropSelectedClass;
		if(className){
			nodes.forEach(function(node){
				var button = node.querySelector("button");
				button.classList.add(className);
			});
		}
	},
	handleBtnOldandNewValue : function(oldArr,newArr){
		var oldArray=[],newArray=[];
		if(newArr.length){
			for(var index=0;index<oldArr.length;index++){
				var temp = oldArr[index];
				if(newArr.indexOf(temp)<0){
					oldArray.push(temp);
				}
			}
		}
		else{
			oldArray = oldArr;
		}
		if(oldArr.length){
			for(var index=0;index<newArr.length;index++){
				var temp = newArr[index];
				if(oldArr.indexOf(temp)<0){
					newArray.push(temp);
				}
			}
		}
		else{
			newArray =  newArr;
		}
		return {newValue:newArray,oldValue:oldArray}
	},
	selectedObserver : function(change){
		if(this.data.preventSelect){
			return;
		}
		if(this.isRadioButton()){
			this.updateButtons([change.oldValue],[change.newValue]);
		}
	}.observes('ltPropSelected'),
	selectedValuesObserver  : function(change){
		if(this.data.preventSelect){
			return;
		}
		if(this.isCheckbox()){
			var obj = this.handleBtnOldandNewValue(change.oldValue,change.newValue);
			this.updateButtons(obj.oldValue,obj.newValue);
		}
	}.observes('ltPropSelectedValues'),
	classChange : function(change){
		if(change.oldValue){
			var nodes = this.$node.querySelectorAll("."+change.oldValue);
			nodes.forEach(function(node){
				node.classList.remove(change.oldValue);
			});
			if(change.newValue){
				nodes.forEach(function(node){
					node.classList.add(change.newValue);
				});
			}
		}
	}.observes("ltPropSelectedClass"),
	actions : {
		click : function(){
			var target = event.target,lyteButton = $L(target).closest('lyte-button',this.$node)[0];
			if(lyteButton && lyteButton.contains(target)){
				var type = this.data.ltPropType,selected,
				value =  lyteButton.getAttribute("lt-prop-value");
				if(type == "checkbox"){
					selected = this.data.ltPropSelectedValues.slice();
					var index = selected.indexOf(value);
					if(index > -1){
						this.changeCheckbox([value],[],selected,index,event);
					}
					else{
						this.changeCheckbox([],[value],selected,undefined,event);
					}
				}
				else if(type == "radiobutton"){
					selected = this.data.ltPropSelected;
					if(selected != value){
						this.changeRadiobutton(selected,value,event);
					}
				}
			}
		}
	}
}); 
/**
 * @syntax yielded 
 *	<lyte-button-group>
 * 		<template is='registerYield' yield-name='yield'> 
 *	  		<lyte-button lt-prop-value='button1'> 
 *	  	  		<template is='registerYield' yield-name='text'> 
 *	  	  	  		Button1 
 *	  	  	  	</template> 
 *	  	  	</lyte-button> 
 *	  	  	<lyte-button lt-prop-value='button2'> 
 *	  	  		<template is='registerYield' yield-name='text'> 
 *	  	  	  		Button2 
 *	  	  	  	</template> 
 *	  	  	</lyte-button> 
 *	  	</template> 
 *	</lyte-button-group>
 */
/**
 * Renders a calculator
 * @component lyte-calculator
 * @version  1.0.0
 * @dependencies lyte-scrollbar
 */
Lyte.Component.register("lyte-calculator", {
_template:"<template tag-name=\"lyte-calculator\"> <div class=\"lyteCalculator basic\" tabindex=\"0\" onkeydown=\"{{action('keydown',event)}}\" onkeyup=\"{{action('keyup',event)}}\"> <div class=\"calculatorDisplay\"> <template is=\"if\" value=\"{{ltPropEditable}}\"><template case=\"true\"> <input type=\"text\" class=\"lyteCalculatorTextField\" autocomplete=\"off\" onmousedown=\"{{action('mdwnTextField',event)}}\" onmouseup=\"{{action('mupTextField',event)}}\" spellcheck=\"false\"> </template><template case=\"false\"> <div> <div class=\"lyteCalculatorTextField\" tabindex=\"0\"></div> </div> </template></template> <div class=\"calculatorDispspan\">0</div> <div class=\"calculatorrad\"></div> </div> <div class=\"calculatorbuttons\" onmousedown=\"{{action('mousedown',event)}}\" onmouseup=\"{{action('mouseup',event)}}\"> <div class=\"calculatorToggle\"> <span class=\"calculatorsmaller\"></span> </div> <div class=\"advancedCalculator\"> <span class=\"CalculatorBtn15\">2<sup>nd</sup></span> <span class=\"CalculatorBtn15\">m+</span> <span class=\"CalculatorBtn15\">m-</span> <span class=\"CalculatorBtn15 memorymr\">mr</span> <span class=\"CalculatorBtn15\">mc</span> <span class=\"CalculatorBtn14 Deg\">Deg</span> <span class=\"CalculatorBtn15\">(</span> <span class=\"CalculatorBtn15\">)</span> <span class=\"CalculatorBtn14\">Rand</span> <span class=\"CalculatorBtn15\">1/x</span> <span class=\"CalculatorBtn15\">log<sub>y</sub></span> <span class=\"CalculatorBtn16 pieButton\">p</span> <span class=\"CalculatorBtn14\">E</span> <span class=\"CalculatorBtn16\">e</span> <span class=\"CalculatorBtn15\">!</span> <span class=\"CalculatorBtn17 toggleBtns squareroot\">x<sup>2</sup></span> <span class=\"CalculatorBtn15 toggleBtns logbtn\">log</span> <span class=\"CalculatorBtn14 toggleBtns trignometry\">sin</span> <span class=\"CalculatorBtn14 toggleBtns trignometry\">cos</span> <span class=\"CalculatorBtn14 toggleBtns trignometry\">tan</span> <span class=\"CalculatorBtn17 toggleBtns calcLeft lastrow cuberoot\">x<sup>y</sup></span> <span class=\"CalculatorBtn16 toggleBtns lastrow naturallog\">ln</span> <span class=\"CalculatorBtn14 toggleBtns lastrow hyperbolic\">sinh</span> <span class=\"CalculatorBtn14 toggleBtns lastrow hyperbolic\">cosh</span> <span class=\"CalculatorBtn14 toggleBtns lastrow hyperbolic\">tanh</span> </div> <div class=\"basicCalculator\"> <span class=\"calcBackspace\">C</span> <span class=\"calcClearAc\">AC</span> <span class=\"calcPercent\">%</span> <span class=\"basicOp calcDivide\">/</span> <span>7</span> <span>8</span> <span>9</span> <span class=\"basicOp calcMultiply\">*</span> <span>4</span> <span>5</span> <span>6</span> <span class=\"basicOp calcAdd\">+</span> <span>1</span> <span>2</span> <span>3</span> <span class=\"basicOp calcSub\">-</span> <span class=\"lastrow doubleWidth calcLeft\">0</span> <span class=\"calzero lastrow\">.</span> <span class=\"basicOp lastrow calcRight calcEqual\">=</span> </div> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3]}],
_observedAttributes :["bigger","equation","previous","numstack","opstack","rank","secondLayer","operator","check_error","deg","memory","secondLayer","secondKeySet","secondActive","secondValue","cursor","cursorIndex","ltPropEditable","ltPropAutoFocus"],
	data : function(){
		return {
			'bigger' : Lyte.attr("boolean",{"default":false}),
			'equation' : Lyte.attr("string"),
			'previous' : Lyte.attr("string"),
			'numstack' : Lyte.attr("array",{"default" : []}),
			'opstack' : Lyte.attr("array",{"default":[]}),
			'rank' : Lyte.attr("object",{"default":undefined}),
			'secondLayer' : Lyte.attr("array",{"default" : []}),
			'operator' : Lyte.attr("string",{"default" : ''}),
			'check_error' : Lyte.attr("boolean",{"default" : false}),
			'deg' : Lyte.attr("boolean",{"default":false}),
			'memory' : Lyte.attr("number",{"default":0}),
			'secondLayer' : Lyte.attr('array',{"default":[]}),
			'secondKeySet' : Lyte.attr("array",{"default" : []}),
			'secondActive' : Lyte.attr("boolean",{"default" : false}),
			'secondValue' : Lyte.attr("array",{"default" : []}),
			'cursor' : Lyte.attr("boolean",{"default" : false}),
			'cursorIndex' : Lyte.attr("number",{"default":0}),
			/**
			 * @componentProperty {boolean} ltPropEditable=false
			 */

			'ltPropEditable' : Lyte.attr("boolean",{"default" :  _lyteUiUtils.resolveDefaultValue( 'lyte-calculator', 'editable', false )}),
			/**
			 * @componentProperty {boolean} ltPropAutoFocus=false
			 */

			'ltPropAutoFocus' : Lyte.attr("boolean",{"default" :  _lyteUiUtils.resolveDefaultValue( 'lyte-calculator', 'autoFocus', false )})
		}
	},
	init : function(){
		var secondLayer = [
			['x<sup>2</sup>','log','sin', 'cos', 'tan','x<sup>y</sup>', 'ln', 'sinh', 'cosh', 'tanh'],
			[
				'sqrt','10<sup>x</sup>','sin<sup>-1</sup>','cos<sup>-1</sup>','tan<sup>-1</sup>','xry','e<sup>x</sup>',
				'sinh<sup>-1</sup>', 'cosh<sup>-1</sup>', 'tanh<sup>-1</sup>'
			]
		];
		var rank={'=': 0,'+': 1, '-': 1,'/': 2, '*': 2,'~':6 , 'N': 5, '^': 5,'E':4,'s':7,'c':7,'t':7,'l':7,'S':7,'C':7,'T':7,'L':7,'i':7,'o':7
		,'a':7,'I':7,'O':7,'A':7,'G':7,'Q':7,'%':3,'!':3};
		this.setData('secondLayer', secondLayer);
		this.setData('rank',rank);
	},
	didConnect: function() {
		var calc=this.$node.querySelector('.calculatorbuttons'),keyBoard=[],secondLayer=this.getData('secondLayer'),brackets=this.getData('brackets'),calcObj={};
		var secondKeySet=[].slice.call(calc.querySelector('.advancedCalculator').children, 15, 25);
		this.setData('secondKeySet',secondKeySet);
		// colloect all keys...

		for (var k = 2; k>=0;k-- ) {

			for (var l = calc.children[k], m = l.children, n = m.length; n--; ) {
				keyBoard[l.children[n].textContent.replace(/\s*/g, '')] = l.children[n];
			}
		}
		
		for (var m = secondLayer[0], n = m.length; n--; ) {
			var val=m[n];
			if(val==='x<sup>2</sup>'){
				val='x2';
			}
			else if(val==='x<sup>y</sup>'){
				val='xy';
			}

			keyBoard[secondLayer[1][n].replace(/<\/*\w+>/g, '')] = keyBoard[val];
		}
		keyBoard.Rad= keyBoard.Deg;
		this.setData('keyBoard',keyBoard);
		if(!this.getData('ltPropEditable')){
			$L('.lyteCalculatorTextField',this.$node).scroll({preventVertical : true, preventHorizontal : true});
		}
		if(this.getData('ltPropAutoFocus')){
			this.$node.querySelector('.lyteCalculatorTextField').focus();
		}
	},
	render:function(val,inp){
		var regx = /(\d+)(\d{3})/,
			hasComma = val.match(/\./),
			tmp,display=this.$node.querySelector('.calculatorDispspan'),inputField=this.$node.querySelector('.lyteCalculatorTextField');
			valAbs = Math.abs(+val),
			displayStyle = display.style,
			displayParentStyle = display.parentNode.style;
		if (val.match(/NaN|Inf/)) {
			tmp = 'NaN';
		} 
		else if(val!=="Error"){
			if (valAbs >= 1e+16) {
				val = (+val).toExponential(13) + '';
			}
			if (((!inp || inp === '+/-') && valAbs !== 0)) {
				val = (+val).toPrecision(12);
			}
			tmp = (val + '').split('.');
			if (tmp[1]) {
				tmp[2] = tmp[1].split('e');
				if (tmp[2][1]) {
					tmp[1] = tmp[2][0];
				}
				if (!inp || inp === '+/-') {
					tmp[1] = (((+('1.' + tmp[1])).toPrecision(12)) + '');
					if (tmp[1] >= 2) {
						tmp[0] = (+tmp[0] + 1) + '';
					}
					tmp[1] = tmp[1].substr(2).replace(/0+$/, '');
				}
			}
			tmp = tmp[0] + ((tmp[1] || hasComma) ? '.' + tmp[1] : '').
				replace('.undefined', '').
				replace(inp ? '' : /\.$/, '') + (tmp[2] && tmp[2][1] ? 'e' + tmp[2][1] : '');
		}
		else{
			tmp=val;
			display.innerHTML = ' ';
			return;
		}
		tmp = tmp.replace(/\./g, '#').replace(/\s/g,  ',').replace(/#/g, '.');
		display.innerHTML = tmp;
	},
	getTargetKey: function (elm) {
		var calc=this.$node.querySelector('.lyteCalculator');
		while (elm !== calc && elm.className.indexOf("calculatorToggle")===-1&&elm.className.indexOf("lyteCalculatorTextField")===-1&&elm.className.indexOf("calculatorsmaller")===-1 && elm.parentNode  &&elm.parentNode.className.indexOf("basicCalculator")===-1&&elm.parentNode.className.indexOf("advancedCalculator")===-1){
			elm = elm.parentNode;
		}
		return elm;
	},
	 keyUp:function() {
	 	var pressedKey=this.getData('pressedKey'),secondActive=this.getData('secondActive');
		if (pressedKey && pressedKey !== secondActive) {
			pressedKey.className = pressedKey.className.replace(' calc-press', '');
			pressedKey = null;
			this.setData('pressedKey',pressedKey);
		}
	},
	keyDown: function (e, obj) { // works for mouse and key
		var event = e || window.event,
			target = obj || this.getTargetKey(event.target),
			keyText = target.textContent.replace(/\s*/g, ''),keyBoard=this.getData('keyBoard'),
			key = keyBoard[keyText],pressedKey=this.getData('pressedKey');
		if (key) {
			this.keyUp();
			pressedKey = key;this.setData('pressedKey',pressedKey);
			key.className =key.className+ ' calc-press';
		}
		return false;
	},
	preformMouseUp: function(e){

			var inputField=this.$node.querySelector('.lyteCalculatorTextField'),elementMath=[],value,edit=this.getData('ltPropEditable');
			if(edit){
				value=inputField.value;
			}
			else{
				value=inputField.innerHTML;
			}
			equation=value;
			var a=this.convertequation(equation);
			var value1=a.split(/([0-9.]+|\(|\)|\+|\-|\/|\*|\^|~|N|s|c|t|l|S|C|T|!|%|L|i|o|a|I|O|A|G|E|p|R|e|Q)/g).filter(function(x) {return x!=""} );
			if(value1.length>=2 && !value1[value1.length-1].match(/[!|%|^]/)&&this.isOperator(value1[value1.length-1])&&value1[value1.length-2].match(/[0-9!pe%)]/))
			{	value1=value.split(/(p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
				value1=value1.splice(0,value1.length-1);
				equation=value1.join("");
			}
			else if(value1.length>=2 && !value1[value1.length-1].match(/[!|%]/)&& this.isOperator(value1[value1.length-1])){
				this.render('Error');this.keyUp();
				return ;
			}
			equation=this.standardizeString(equation);
			if(!this.getData('check_error')){
				elementMath=this.processString(equation);
			}
			if(!this.getData('check_error')){
				elementMath=this.postfix(elementMath);
			}
			if(!this.getData('check_error')){
				equation=this.valueMath(elementMath);
			}
			if(this.getData('check_error')){
				this.render('Error');
				return ;
			}
			this.render(equation);
			this.keyUp();
	},
	processString : function(e){
		var s=e.split(/([0-9.]+|\(|\)|\+|\-|\/|\*|\^|~|N|s|c|t|l|S|C|T|!|%|L|i|o|a|I|O|A|G|E|p|R|e|Q)/g).filter(function(x) {return x!=""} );
		for(var i=0;i<s.length;i++){
			if(i<s.length-1&&(s[i]==='p'||s[i]==='R'||s[i]==='e')&& !this.isOperator(s[i+1])){
				this.setData('check_error',true);
				return null;
			}
			if(i==0 && !s[0].match(/[0-9a-zA-Zpe(.~]/)){
				this.setData('check_error',true);
				return null;
			}
			if(i===0 && s[0]==='G'){
				this.setData('check_error',true);
				return null;
			}
			if(i<s.length-1&& !s[i].match(/[(|)|%|!]/) && !s[i+1].match(/[(]/) && (this.isOperator(s[i]) && !this.isOneMath(s[i])) && (this.isOperator(s[i+1]) && !this.isOneMath(s[i+1]))){
				this.setData('check_error',true);
				return null;
			}
			if(i<s.length-1&& !s[i]==='!' && s[i+1].match(/[E]/) ){
				this.setData('check_error',true);
				return null;
			}
			if(i<s.length-1&& s[i].match(/[(]/) && (this.isOperator(s[i+1]) && !this.isOneMath(s[i+1]))){
				this.setData('check_error',true);
				return null;
			}
			if(i<s.length-1&& this.isOneMath(s[i])&& (this.isOperator(s[i+1]) && !this.isOneMath(s[i+1])) ){
				this.setData('check_error',true);
				return null;
			}
		}
		return s;
	},
	postfix : function(elementMath){
			var s1='',s=[],stack=[],rank=this.getData('rank'),j=0;
			if(elementMath.length===1){
				return elementMath;
			}
  			for(var i=0;i<elementMath.length;i++){
				var c=elementMath[i];
				if(!this.isOperator(c)){
					s[j]=c;j++;
				}
				else{
					if(c==='('){
						stack.push(c);
					}
					else{
						if(c===')'){
							var c1;
							do{
								c1=stack[stack.length-1][0];
								if(c1!=='('){
									s[j]=stack[stack.length-1];j++;
								}
								stack.pop();
							}while(c1!=='(');
						}
						else{
							while(stack.length!==0&&rank[stack[stack.length-1]+""]>=rank[c+""]){
								s[j]=stack.pop();j++;
							}
							stack.push(c);
						}
					}
				}
			}
			while(stack.length!=0){
				
					s[j]=stack.pop();j++;
				
				
			}
			return s;
	},
	factorial : function(n){
		return n < 0 || n > 170 ? NaN : n <= 1 ? 1 : n * this.factorial(n - 1);
	},
	valueMath : function(elementMath){
		var stack=[],num,deg=this.getData('deg'),_PI=Math.PI;
		for(var i=0;i<elementMath.length;i++){
			var c=elementMath[i];
			if(c==='p'){
				stack.push(Math.PI);
			}
			else if(c==='e'){
				stack.push(Math.exp(1));
			}
			else if(this.isOperator(c)||c.match(/^(\d*\.)?\d+$/)){
				if(!this.isOperator(c)){
					
					stack.push(parseFloat(c));
				}
				else if(stack.length!==0){
					 var num1=stack.pop();
					switch(c){
						case '~':{
									num=-num1;
									break;
								}
						case 's':{
									num=(!deg && Math.abs(num1) === _PI ? '0' :Math.sin(num1 * (deg ? _PI / 180 : 1)) + '');
									break;
								}
						case 'c':{
									num=(Math.cos(num1 * (deg ? _PI / 180 : 1)) + '');
									break;
								}
						case 't':{
									num=(!deg && Math.abs(num1) === _PI ? '0' :Math.tan(num1 * (deg ? _PI / 180 : 1)) + '');
									break;
								}
						case '%':{
									num=num1/100;break;
								}
						case '!':{
									if(num1>=0&&parseInt(num1)===num1){
									num=this.factorial(Math.round(+num1));
									}
									else{
										return 'NaN';
									}
									break;
								}
						case 'l':{
									num=Math.log(num1) / Math.log(10);
									break;
								}
						case 'L':{
									num=Math.log(num1);
									break;
								}
						case 'S':{
									num=((Math.pow(Math.E, num1) - Math.pow(Math.E, -1 * num1)) / 2) ;
									break;
								}
						case 'C':{
									num=((Math.pow(Math.E, num1) + Math.pow(Math.E, -1 * num1)) / 2);
									break;
								}
						case 'T':{
									var e1=Math.pow(Math.E, num1),e2=Math.pow(Math.E, -1 *num1);
									num=(e1 == Infinity ? 1 : e2 == Infinity ? -1 :(e1 - e2) / (e1 + e2));
									break;
								}
						case 'i':{
									num=Math.asin(num1) * (deg ? 180 / _PI : 1);
									break;
								}
						case 'o':{
									num=Math.acos(num1) * (deg ? 180 / _PI : 1)
									break;
								}
						case 'a':{
									num=Math.atan(num1) * (deg ? 180 / _PI : 1);
									break;
								}
						case 'I':{
									num=Math.log(+num1 + Math.sqrt(1 + Math.pow(num1, 2)));
									break;
								}
						case 'O':{
									num=2 * Math.log(Math.sqrt((+num1 + 1) / 2) + Math.sqrt((+num1 - 1) / 2));
									break;
								}
						case 'A':{
									num=(Math.log(+num1 + 1) - Math.log(1 - num1)) / 2;
									break;
								}
						case 'Q':{
									num=Math.pow(num1, 1 / 2);
									break;
								}
						
					}
					if(stack.length!==0){
						var num2=stack[stack.length-1];
						switch(c){
							case '+':{ 	num=parseFloat(num2)+parseFloat(num1);
									 	stack.pop();
									  	break;
									}
							case '-':{ 
										num=num2-num1;
									 	stack.pop();
										break;
									}
							case '*':{ 
										num=num2*num1;
									  	stack.pop();
									  	break;
									}
							case '/':{ if(num1!=0){
											num=num2/num1;
									  	}
									  	else{
									  		return 'NaN';
									  	}
									 	stack.pop();
									 	 break;
									}
							case '^':{
										num=Math.pow(num2,num1);
									 	stack.pop();
									  	break;
									}
							case 'N':{ 
										num=Math.pow(num1, 1 / num2);
										 stack.pop();
										 break;
									}
							case 'E':{
										num=num2 * Math.pow(10, num1);
									 	stack.pop();
										 break;
									}
							case 'G':{
										num=Math.log(num1) / Math.log(num2); stack.pop();
										break;
									}
						}
						
					}
					stack.push(num);
				}
				else{
					return "Error";
				}
			}
			else{
				return "Error";
			}
		}
		return stack.pop()+"";
	},
	checkrank : function(key){
		var opstack=this.getData(opstack),rank=this.getData('rank');
		if(opstack.length>0){
			return true;
		}
		else if(opstack.length>0&&rank[opstack.length-1]<rank[key]){
			return true;
		}
		return false;
	},
	isOperator : function(op){
		if(op.match(/^[+|\-|/|*|^|~|N|s|c|t|l|S|C|T|!|%|(|L|)|i|o|a|I|O|A|E|G|Q]+$/)){
			return true;
		}
		return false;
	},
	isOneMath :function(op){
		if(op.match(/^[s|c|t|l|S|C|T|(|L|i|o|a|I|O|A|Q|~]+$/)){
			return true;
		}
		return false;
	},
	convertequation : function(s){
		s=this.convertToPiandRoot(s);
		s=s.trim();
		s=s.replace("\\s+"," ");
		s=s.replace(/sqrt/g,"Q");
		s=s.replace(/logy/g,"G");
		s=s.replace(/arcsinh/g,"I");
		s=s.replace(/arccosh/g,"O");
		s=s.replace(/arctanh/g,"A");
		s=s.replace(/arcsin/g,"i");
		s=s.replace(/arccos/g,"o");
		s=s.replace(/arctan/g,"a");
		s=s.replace(/log/g,"l");
		s=s.replace(/sinh/g,"S");
		s=s.replace(/cosh/g,"C");
		s=s.replace(/tanh/g,"T");
		s=s.replace(/sin/g,"s");
		s=s.replace(/cos/g,"c");
		s=s.replace(/tan/g,"t");
		s=s.replace(/Rand/g,"R");
		s=s.replace(/ln/g,"L");
		return s;
	},
	convertToPiandRoot : function(s){
		var r=String.fromCharCode(parseInt('221A',16));
		var pi=String.fromCharCode(parseInt('03C0',16));
		var re = new RegExp(pi, 'g');
		s=s.replace(re,"p");
		re = new RegExp(r, 'g');
		s=s.replace(re,"N");
		return s;
	},
	standardizeString : function(s){
		var newString='',open=0,close=0;
		s=this.convertequation(s);
		open=s.split("(").length;
		close=s.split(")").length;
		if(close>open){
			this.setData('check_error',true);
			return null;
		}
		for(var i=0;i<(open-close);i++){
			s+=')';
		}
		for(var i=0;i<s.length;i++){
			if(i>0 && this.isOneMath(s[i])&&(s[i-1]==')'||s[i-1].match(/^[\d|\.|!|%|p|R|e]$/))){
				newString=newString+ "*";
			}
			if((i===0||(i>0&& !s[i-1].match(/^[\d|\.|%|!]$/)))&& s[i]==='-' && s[i+1]&&(s[i+1].match(/^[\d|\.]$/)||s[i+1]==='R'||s[i+1]==='e'||s[i+1]==='p'||s[i+1]==='('||this.isOneMath(s[i+1]))){
				newString = newString+"~";
			}
			else if((i===0||(i>0&& s[i-1]==='('))&& s[i]==='+' && s[i+1]&&(s[i+1].match(/^[\d|\.]$/)||s[i+1]==='R'||s[i+1]==='e'||s[i+1]==='p'||s[i+1]==='(')){
				newString = newString+'';
			}
			else if(i>0&& (s[i-1].match(/^[\d|\.]$/)||s[i-1]===')'||s[i-1]==='R'||s[i-1]==='e'||s[i-1]==='p')&&s[i]==='p'){
				newString =newString+"*"+s[i];
			}
			else if(i>0&& (s[i-1].match(/^[\d|\.]$/)||s[i-1]===')'||s[i-1]==='p'||s[i-1]==='e'||s[i-1]==='R')&&s[i]==='R'){
				newString =newString+"*"+s[i];
			}
			else if(i>0&& (s[i-1].match(/^[\d|\.]$/)||s[i-1]===')'||s[i-1]==='p'||s[i-1]==='R'||s[i-1]==='e')&&s[i]==='e'){
				newString =newString+"*"+s[i];
			}
			else if(i>0&& (s[i-1]==='%')&&(s[i].match(/^[\d|\.]$/)||s[i]==='p'||s[i]==='R'||s[i]==='e')){
				newString =newString+"*"+s[i];
			}
			else if(i>0&& (s[i-1]==='!')&&(s[i].match(/^[\d|\.]$/)||s[i]==='p'||s[i]==='R'||s[i]==='e')){
				newString =newString+"*"+s[i];
			}
			else if(i>0&& (s[i-1]===')'||s[i-1]==='p'||s[i-1]==='R'||s[i-1]==='e')&&s[i].match(/^[\d|\.]$/)){
				newString =newString+"*"+s[i];
			}
			else{
				newString=newString+s[i];
			}
		}
		return newString;
	},
	clearValue : function(){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField');
		this.setData('check_error',false);this.setData('cursorIndex',0);
		if(this.getData('ltPropEditable')){
			inputField.value="";
		}
		else{
			inputField.innerHTML="";
		}
		this.$node.querySelector('.calculatorDispspan').innerHTML='0';
	},
	memoryoperations : function(key){
		var memory=this.getData('memory'),dispVal=this.$node.querySelector('.calculatorDispspan').innerHTML,inputField=this.$node.querySelector('.lyteCalculatorTextField');
		if(key==='mc'){
			memory = 0;
			this.$node.querySelector('.memorymr').classList.remove('active');
		}
		else if(key==='m+'){
			memory += parseFloat(dispVal);
			this.$node.querySelector('.memorymr').classList.add('active');
		}
		else if(key==='m-'){
			memory -= parseFloat(dispVal);
			this.$node.querySelector('.memorymr').classList.add('active');
		}
		else if(key==='mr')
		{	var index=this.getData('cursorIndex'), value,val;
			if(this.getData("ltPropEditable")){
				value=inputField.value;
			}
			else{
				value=inputField.innerHTML;
			}
			val=this.convertToPiandRoot(value);
			if(!this.getData('check_error')){
				if((value.length==0||index==0)||(val[index-1]&& !val[index-1].match(/[0-9.]/))){
					if(value.length>index&&val[index].match(/[0-9.]/)){
						return;
					}
					var val=value.substring(0, index)+memory+value.substring(index, value.length);
					if(this.getData('ltPropEditable')){
						inputField.value=val;
					}
					else{
						inputField.innerHTML=val;
					}
					this.setData('cursorIndex',index+(memory+'').length);
				}
				this.setData('check_error',false);
				this.preformMouseUp();
			}
			
		}
		this.setData('memory',memory);
	},
	getSelectionIndex : function(){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField');
		if (document.selection) {
			inputField.focus();
			var range = document.selection.createRange();
			var rangelen = range.text.length;
			range.moveStart('character', -inputField.value.length);
			var start = range.text.length - rangelen;
			return start + rangelen;
		}
		else if (inputField.selectionStart || inputField.selectionStart == '0') {
			return inputField.selectionEnd ;
		} else {
			return 0;
		}
	},
	operationForBackspace : function(){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField'),value,index,edit=this.getData('ltPropEditable');
		if(edit){
			value=inputField.value;
			inputField.focus();
			index=this.getSelectionIndex();
		}
		else{
			value=inputField.innerHTML;
			index=value.length;
		}
		var val=this.convertToPiandRoot(value);
		index=value.length-index;
		var value1=val.split(/(p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
		var sum=0,i;
		for( i=value1.length-1;i>=0;i--){
			if(sum===index){
				break;
			}
			else{
				sum+=value1[i].length;
			}
		}
		if(i>=0){
			if(edit){
				this.setData('cursorIndex',this.getData('cursorIndex')-value1[i].length);
			}
			value1.splice(i,1);
			value1=value1.join("");
			var r=String.fromCharCode(parseInt('221A',16));
			var pi=String.fromCharCode(parseInt('03C0',16));
			value1=value1.replace(/p/g,pi);
			value1=value1.replace(/N/g,r);
			if(edit){
				inputField.value=value1;
			}
			else{
				inputField.innerHTML=value1;
			}
		}
	},
	operationForDot : function(e){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField'),value,index,edit=this.getData('ltPropEditable');
		if(edit){
			value=inputField.value;inputField.focus();
			index=this.getSelectionIndex();
		}
		else{
			value=inputField.innerHTML;
			index=value.length;
		}
		var val=this.convertToPiandRoot(value);
		index=value.length-index;
		var value1=val.split(/([0-9.]+|p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
		var sum=0,i;
		for( i=value1.length-1;i>=0;i--){
			if(sum>=index){
				break;
			}
			else{
				sum+=value1[i].length;
			}
		}
		if(i+1===value1.length && sum===index){
			if(value1[i].match(/[.]/g)){
			  	return true;
			}
		}
		else if(i>=1 && sum===index && value1[i+1].match(/([0-9])/)){
			if(value1[i+1].match(/[.]/g)){
			  	return true;
			}
		}
		else if(i>=0 && sum===index && !value1[i+1].match(/([0-9])/)){
			if(value1[i].match(/[.]/g)){
			  	return true;
			}
		}
		else if(sum>index){
			if(value1[i+1].match(/[.]/g)){
			 	return true;
			}
		}
		else if(i===0 && sum===index){
			if(value1[i].match(/[.]/g)){
				return true;
			}
		}
		return false;
	},
	operationForZero : function(e){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField'),value,index,edit=this.getData('ltPropEditable');
		if(edit){
			value=inputField.value;
			inputField.focus();
			index=this.getSelectionIndex();
		}
		else{
			value=inputField.innerHTML;
			index=value.length;
		}
 		var val=this.convertToPiandRoot(value);
		index=value.length-index;
		var value1=val.split(/([0-9.]+|p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
		var sum=0,i;
		for( i=value1.length-1;i>=0;i--){
			if(sum>=index){
				break;
			}
			else{
				sum+=value1[i].length;
			}
		}
		if(i>=0 && sum===index){
			if(parseInt(value1[i])+''==='0' && !value1[i].match(/[.]/g)){
				return true;
			}
		}
		else if(index>0&&sum>index){
			if(parseInt(value1[i+1])+''==='0' && !value1[i+1].match(/[.]/g)){
				return true;
			}
		}
		return false;
	},
	operationForArrowLeft : function(e){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField'),index,value=inputField.value;
		inputField.focus();
		index=this.getSelectionIndex();
		var val=this.convertToPiandRoot(value);
		var value1=val.split(/([0-9.]|p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
		var sum=0,i;
		for(i=0;i<value1.length-1;i++){
			if(value1[i+1]&&sum+value1[i].length<index){
				sum+=value1[i].length;
			}
			else{
				break;
			}
		}
		if(i==0){
			sum=0;
		}
		this.setData('cursorIndex',sum+1);
		inputField.setSelectionRange(this.getData('cursorIndex'),this.getData('cursorIndex'));
		return;
	},
	operationForArrowRight : function(e){
		var inputField=this.$node.querySelector('.lyteCalculatorTextField'),index,value=inputField.value;
		inputField.focus();
		index=this.getSelectionIndex();
		var val=this.convertToPiandRoot(value);
		var value1=val.split(/([0-9.]|p|Rand|e|arcsinh\(|arccosh\(|arctanh\(|arcsin\(|ln\(|arccos\(|arctan\(|sinh\(|cosh\(|tanh\(|sin\(|cos\(|tan\(|logy\(|log\(|sqrt\(|N\(|\(|\)|\+|\-|\|*|\^|!|%)/g).filter(function(x) {return x!=""} );
		var sum=0,i;
		for(i=0;i<value1.length;i++){
			if(sum+value1[i].length<=index){
				sum+=value1[i].length;
			}
			else{
				break;
			}
		}
		if(i==value1.length){
			sum=val.length;
		}
		else{
			sum+=value1[i].length;
		}
		this.setData('cursorIndex',sum-1);
		inputField.setSelectionRange(this.getData('cursorIndex'),this.getData('cursorIndex'));
		return;
	},
	preformMouseDown : function(e){
			this.keyDown( e );
			var pressedKey=this.getData('pressedKey');
			if (!pressedKey){
			 	return false;
			}
			var r=String.fromCharCode(parseInt('221A',16));
			var pi=String.fromCharCode(parseInt('03C0',16));
			var inputField=this.$node.querySelector('.lyteCalculatorTextField'),index;
			var event = e || window.event,
			target = this.getTargetKey(event.target),
			keyText = target.textContent.replace(/\s*/g, ''),keyBoard=this.getData('keyBoard'),
			key = keyBoard[keyText],secondKeySet=this.getData('secondKeySet'),secondLayer=this.getData('secondLayer'),
			secondValue=this.getData('secondValue'),value,flag=0,cursorIndex,val,edit=this.getData('ltPropEditable');
			if(edit){
				inputField.focus();
				index=this.getSelectionIndex();
				value=inputField.value;
			}
			else{
				value=inputField.innerHTML;
				index=value.length;
				$L.fastdom.measure(function(){
					//scroll for non-editable calculator
					if( inputField)
						{
							var offWidth = inputField.offsetWidth;
							var sWidth = inputField.scrollWidth;
							$L.fastdom.mutate(function(){
								inputField.scrollLeft = sWidth-offWidth;
							}.bind(this))
						}
					}.bind(this));	
				
			}
			cursorIndex=this.getData('cursorIndex');
			val=this.convertToPiandRoot(value);
			if(key!==null||key!=="undefined"){
				text=key.innerText;this.setData('previous',text);
			}
			if(this.$node.querySelector('.calculatorDisplay').className.indexOf('equalBtn')!==-1){
				this.$node.querySelector('.calculatorDisplay').classList.remove('equalBtn');
			}
			if(key.className.indexOf('calculatorsmaller')!==-1||key.className.indexOf('calculatorToggle')!==-1){
				this.setData('bigger',!this.getData('bigger'));
				if(this.getData('bigger')){
					this.$node.querySelector('.basicCalculator').classList.add('anim');
					this.$node.querySelector('.lyteCalculator').classList.remove('basic');
					this.$node.querySelector('.lyteCalculator').classList.add('advanced');

				}
				else{
					this.$node.querySelector('.basicCalculator').classList.remove('anim');
					this.$node.querySelector('.lyteCalculator').classList.remove('advanced');
					this.$node.querySelector('.lyteCalculator').classList.add('basic');
				}
				
				this.$node.querySelector('.calculatorrad').innerHTML = this.getData('bigger') ? "Rad" : "";
				if( !this.getData('bigger')){
					this.setData('deg',false);
				}
				this.keyUp();return;
			}
			if(value.length>0 && (!text.match(/[0-9|.]/)||(text=='1/x' || text=='10x')) &&text!='C' && text!='AC'  && value[value.length-1]=='.'){
				value=value+'0';
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				val=this.convertToPiandRoot(value);
				this.setData('cursorIndex',this.getData('cursorIndex')+1);
				cursorIndex+=1;
				index+=1;
				this.preformMouseUp();
			}
			else if(text=='10x'&& value!==''&& value[index-1]&&value[index-1].match(/([0-9])/g)){
				value+='*';
				if(edit){
					inputField.value=value;
					}
					else{
						inputField.innerHTML=value;
					}
				val=this.convertToPiandRoot(value);
				this.setData('cursorIndex',this.getData('cursorIndex')+1);
				cursorIndex+=1;
				index+=1;
				this.preformMouseUp();
			}
			 if(text==='Rand'&& index!==0 && value.length>index && val[index-1].match(/([0-9|e|p|.])/) && (val[index].match(/([0-9|e|p])/)||value[index]===pi)){
				var v=Math.random().toPrecision(11)+'';this.setData('cursorIndex',cursorIndex+v.length+1);
				value=value.substring(0, index) +'*'+ v+ '*'+value.substring(index, value.length+2);
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				this.preformMouseUp();
				this.keyUp();
				return;
			}
			else if(text==='Rand' && index!==0 && value.length>=1 &&  val[index-1] && val[index-1].match(/([0-9|e|p|.])/)){
				var v=Math.random().toPrecision(11)+'';this.setData('cursorIndex',cursorIndex+v.length+1);
				value=value.substring(0, index) +'*'+ v+ value.substring(index, value.length+1);
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				this.preformMouseUp();
				this.keyUp();
				return;
			}
			else if(text==='Rand'&& value.length>index &&  value[index] && val[index].match(/([0-9|e|p|.])/)){
				var v=Math.random().toPrecision(11)+'';this.setData('cursorIndex',cursorIndex+v.length+1);
				value=value.substring(0, index) + v+ '*'+value.substring(index, value.length+1);
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				this.preformMouseUp();
					this.keyUp();
				return;
			}
			else if(text==='Rand'){
				var v=Math.random().toPrecision(11)+'';
				value=value.substring(0, index) + v+ value.substring(index, value.length);
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				this.preformMouseUp();
				this.setData('cursorIndex',cursorIndex+v.length);
				this.keyUp();
				return;
			}
			else if(text==='1/x' && value.length>=1 &&  value[index-1] && val[index-1].match(/([0-9|e|p])/)){
				text='*1/'
				value=value.substring(0, index) + text+ value.substring(index, value.length);
				if(edit){
					inputField.value=value;
				}
				else{
					inputField.innerHTML=value;
				}
				this.preformMouseUp();
				this.setData('cursorIndex',cursorIndex+text.length);
				this.keyUp();
				return;
			}
			var value1=this.convertequation(value);
			value1=value1.replace(/^[a-z][(]/,'');
			value1=value1.split(/([0-9.]+|\(|\)|\+|\-|\/|\*|\^|~|N|s|c|t|l|S|C|T|!|%|L|i|o|a|I|O|A|G|E|p|R|e|Q)/g).filter(function(x) {return x!=""} );
			if(value.length!=0 && text==='.'){
				
				if(this.operationForDot()){
					this.keyUp();return;
				}
			}
			else if(value.length!=0 && text==='0'){
				
				if(this.operationForZero()){
					this.keyUp();return;
				}
			}
			else if(text==='='){
				this.$node.querySelector('.calculatorDisplay').classList.add('equalBtn');
				if(this.$node.querySelector('.calculatorDispspan').innerHTML==' '){
					this.$node.querySelector('.calculatorDispspan').innerHTML='Error';
				}
				if(inputField.className.indexOf('hideCursor')==-1){
					inputField.classList.add('hideCursor');
				}
				this.keyUp();
				return;
			}
			if(text==='C'){
				this.operationForBackspace();
				var inputField=this.$node.querySelector('.lyteCalculatorTextField'),value;
				if(edit){
					value=inputField.value;
				}
				else{
					value=inputField.innerHTML;
				}
				if(value.length>=1){
					this.preformMouseUp();
				}
				else if(value.length<1){
					this.clearValue();
				}
				this.keyUp();
			}
			else if(text==='AC'){
				this.clearValue();this.keyUp();return;
			}
			else if(text==="-"&&value1.length>=2&& value[index-2] && value[index-1]==="-" && !val[index-2].match(/[0-9|p|e]/)){
				this.keyUp(); return;
			}
			else if(text==="E"&&value1.length>=1 && value[index-1]&& val[index-1].match(/[!||p|e]/)){
				this.keyUp(); return;
			}
			if(index===0 && (text.match(/^[+|/|*|!|E|%|.]+$/)||text==='logy'||text==='xry'||text==='x2'||text=='xy')){
				this.keyUp();return;
			}
			else if(value!=='' && index-1!==-1 && value[index-1]==='.' && text==='.'){
				this.preformMouseUp();this.keyUp();return;
			}
			else if(value!=='' && index-1!==-1 && (value[index-1]==='E')&&text.match(/([^0-9])/g)){
				this.keyUp();return;
			}
			else if(index==1&&value[index-1]=='-' && (text.match(/^[+|-|/|*|!|%|E]+$/)||text==='logy'||text=='xy')){
				this.keyUp();return;
			}
			else if(value!=='' && index-1!==-1 && value[index-1] && (val[index-1].match(/^[+|\-|/|*|E|^]+$/)||value.substring(index-5,index)==='logy(')&&(text.match(/^[+|-|/|*|!|%|E]+$/)||text==='logy'||text=='xy')){
				if(text=='logy'){
					text+='(';
				}
				if(text=='xy'){
					text='^';
				}
				if(value.substring(index-5,index)==='logy(' && text!=='logy('){
					value=value.substring(0, index-5) + text+ value.substring(index, value.length);
					if(edit){
					inputField.value=value;
					}
					else{
						inputField.innerHTML=value;
					}
					this.preformMouseUp();this.keyUp();this.setData('cursorIndex',cursorIndex-5);
				}
				else if(value.substring(index-5,index)!=='logy(')
				{
					value=value.substring(0, index-1) + text+ value.substring(index, value.length);
					if(edit){
					inputField.value=value;
					}
					else{
						inputField.innerHTML=value;
					}
					this.preformMouseUp();this.keyUp();this.setData('cursorIndex',cursorIndex-1);
				}
				this.setData('cursorIndex',this.getData('cursorIndex')+text.length);
			}
			else if(value!=='' && index-1!==-1 &&  value[index-1] && (val[index-1].match(/([^0-9-%ep!)])/g)||value.substring(index-4,index)==='Rand') &&(text.match(/^[+|-|/|*|!|%|E]+$/)||text==='logy'||text==='xry'||text==='x2'||text==='xy')){
					this.keyUp();return;
			}
			else if(text==="="){

				this.keyUp();return;
			}
			else if(!text.match(/^m[c|+|-|r]/)&&text!='AC'&&text!='C'&&text!='2nd'&&text!='Deg'&&text!='Rad'&&text!='='&&text!='m-'&&text!='>'){
				if(text==="xry"){
					text=r;
				}
				else if(text==='p'){
					text=pi;
				}
				else if(text==='1/x'){
					text="1/"
				}
				else if(text==="10x"){
					text="10^";
				}
				else if(text==="ex"){
					text="e^";
				}
				else if(text==="xy"){
					text="^";
				}
				else if(text==="x2"){
					text="^2";
				}
				else if(text==="sin-1"){
					text="arcsin";
				}
				else if(text==="cos-1"){
					text="arccos";
				}
				else if(text==="tan-1"){
					text="arctan";
				}
				else if(text==="sinh-1"){
					text="arcsinh";
				}
				else if(text==="cosh-1"){
					text="arccosh";
				}
				else if(text==="tanh-1"){
					text="arctanh";
				}
				if(text.match(/^[sin|cos|tan|sinh|cosh|tanh|logy|log|ln|arcsin|arccos|arctan|arcsinh|arccosh|arctanh|sqrt|N]+$/)||text==r){
					text+='(';
				}
				if(value.length===index){
					if(edit){
						inputField.value+=text;
					}
					else{
						inputField.innerHTML+=text;
					}
				}
				else{
					value=value.substring(0, index) + text + value.substring(index, value.length);
					if(edit){
						inputField.value=value;
					}
					else{
						inputField.innerHTML=value;
					}
				}
				this.setData('cursorIndex',cursorIndex+text.length);
				if(flag===0){
					this.setData('check_error',false);
				}
				this.preformMouseUp();
				this.keyUp();return;
			}
			else if(text.match(/^m[c|+|-|r]/)||text==='m-'){
				this.memoryoperations(text);
				this.keyUp();return;
			}
			else if(text==='Deg'||text==='Rad'){
				this.$node.querySelector('.calculatorrad').innerHTML=this.getData('deg') ? 'Rad' : 'Deg';
				this.$node.querySelector('.Deg').innerHTML=this.getData('deg') ? 'Deg' : 'Rad';
				this.setData('deg',!this.getData('deg'));
				if(edit){
					value=this.$node.querySelector('.lyteCalculatorTextField').value;
				}
				else{
					value=this.$node.querySelector('.lyteCalculatorTextField').innerHTML;
				}
				if(value!==''){
					this.preformMouseUp();
				}
				this.keyUp();return;
			}
			else if(text==='2nd'){
				var secondActive=this.getData('secondActive');
				secondActive = secondActive ? false : true;this.setData('secondActive',secondActive);
				key.className = secondActive ? 'calc-second' : ''; // !!!
				for (var n = secondKeySet.length; n--; ) {
					secondKeySet[n].innerHTML = secondLayer[secondActive ? 1 : 0][n];
					if(secondActive){
						secondKeySet[n].classList.add('inverse');
					}
					else{
						secondKeySet[n].classList.remove('inverse');
					}
				}
				this.setData('secondKeySet',secondKeySet);this.keyUp();return;
			}
			
			this.keyUp();
		},
	actions : {
		"mousedown": function(e){ 
			var inputField=this.$node.querySelector('.lyteCalculatorTextField'),index,edit=this.getData('ltPropEditable');
			if(inputField.className.indexOf('hideCursor')!=-1){
				inputField.classList.remove('hideCursor');
			}
			if(!this.getData('ltPropEditable')){
				inputField.classList.add('hideCursorNonEditable');
			}
			this.setData('check_error',false);
			if(edit){
				inputField.focus();
				index=this.getSelectionIndex();
			}
			else{
				index=inputField.innerHTML.length;
			}
			this.setData('cursorIndex',index);
			this.preformMouseDown(e);
		},
		"mouseup": function(e){
			var inputField=this.$node.querySelector('.lyteCalculatorTextField'),index,value,edit=this.getData('ltPropEditable');
			if(edit){
				value=inputField.value;inputField.focus();
			}
			else{
				value=inputField.innerHTML;
			}
			if(edit&&e.key!='Rand'){
				inputField.setSelectionRange(this.getData('cursorIndex'), this.getData('cursorIndex'));
				inputField.focus();
			}
			
		},
		"keydown":function(e){
			var key = e.key,inputField=this.$node.querySelector('.lyteCalculatorTextField'),index,value,edit=this.getData('ltPropEditable');
			if(edit){
				value=inputField.value;inputField.focus();
				index=this.getSelectionIndex();
				inputField.classList.add('hideCursor');
			}
			else{
				value=inputField.innerHTML;
				index=value.length;
				$L.fastdom.measure(function(){
					//scroll for non-editable calculator
					if( inputField)
						{
							var offWidth = inputField.offsetWidth;
							var sWidth = inputField.scrollWidth;
							$L.fastdom.mutate(function(){
								inputField.scrollLeft = sWidth-offWidth;
							}.bind(this))
						}
					}.bind(this));	
			}
			this.setData('check_error',false);
			this.setData('cursorIndex',index);
			if(key==="Backspace"){
				this.operationForBackspace();
				e.preventDefault();return;
			}
			if(this.getData('ltPropEditable')&&(e.which===37)){
				this.operationForArrowLeft();
				return;
			}
			else if(this.getData('ltPropEditable')&&(e.which===39)){
				this.operationForArrowRight();
				return;
			}
			else if(!this.getData('bigger')&& (key==="^"|| key.match(/([^0-9/%*+-.])/g)||key===',') && key!="Backspace" && key!=='Enter' && (e.which!==38||e.which!==40)){
				e.preventDefault();return;
			}
			else if(this.getData('bigger')&& (key.match(/([^0-9/()%^!*+-.])/g)||key===',')&&key!=="Backspace" && key!=='Enter' &&(e.which!==38||e.which!==40)){
				e.preventDefault();return;
			}
			else if(key!="Backspace" && key!="Enter"){
				var value1=this.convertequation(value),val=this.convertToPiandRoot(value);
				value1=value1.replace(/^[a-zA-Z][(]/,'');
				value1=value1.split(/([0-9.]+|\(|\)|\+|\-|\/|\*|\^|~|N|s|c|t|l|S|C|T|!|%|L|i|o|a|I|O|A|G|E|p|R|e|Q)/g).filter(function(x) {return x!=""} );
				if(value.length>0 && (!key.match(/[0-9|.]/)||(key=='1/x' || key=='10x')) && key!='C' && key!='AC'  && value[value.length-1]=='.'){
					value=value+'0';
					if(edit){
						inputField.value=value;
					}
					else{
						inputField.innerHTML=value;
					}
					val=this.convertToPiandRoot(value);
					this.setData('cursorIndex',this.getData('cursorIndex')+1);
					cursorIndex+=1;
					index+=1;
					this.preformMouseUp();
				}
				if(value.length!==0 && key==='.'){
					if(this.operationForDot()){
						e.preventDefault();return;
					}
				}
				else if(value.length!==0 && key==='0'){
					if(this.operationForZero()){
						e.preventDefault();return;
					}
				}
				else if(index==1&&value[index-1]=='-' && (key.match(/^[+|-|/|*|!|%|E]+$/)||key==='logy'||key=='xy')){
					e.preventDefault();return;
				}
				else if(key==="-"&&value1.length>=2 && value[index-1]==="-" && !val[index-2].match(/[0-9|p|e]/)){
					e.preventDefault();return;
				}
				if((value.length===0||index===0)&& key.match(/^[+|/|*|!|%|.|^]+$/)){
					e.preventDefault();return;
				}
				else if(value!=='' && index-1!==-1 && value[index-1]==='.'&& key==='.'){
					e.preventDefault();return;
				}
				else if(value!=='' && index-1!==-1 && (value[index-1].match(/^[+|\-|/|*|E|\^]+$/)||value.substring(index-5,index)==='logy(')&&(key.match(/^[+|-|/|*|!|%|E|\^]+$/)||key==='logy')){
					if(key==='logy'){
						key+='(';
					}
					if(value.substring(index-5,index)==='logy(' && key!=='logy('){
						value=value.substring(0, index-5) + key+ value.substring(index, value.length);
						if(edit){
							inputField.value=value;
						}
						else{
							inputField.innerHTML=value;
						}
						this.setData('cursorIndex',this.getData('cursorIndex')-5);
						e.preventDefault();
					}
					else if(value.substring(index-5,index)!=='logy(')
					{
						value=value.substring(0, index-1) + key+ value.substring(index, value.length);
						if(edit){
							inputField.value=value;
						}
						else{
							inputField.innerHTML=value;
						}
						this.setData('cursorIndex',this.getData('cursorIndex')-1);
						e.preventDefault();
					}
				}
				else if(!edit){
						inputField.innerHTML+=key;
					
				}
					
					this.setData('cursorIndex',this.getData('cursorIndex')+key.length);
				
			}

			// inputField.blur();
		},
		"keyup":function(e){
			var key = e.key,inputField=this.$node.querySelector('.lyteCalculatorTextField'),value,edit=this.getData('ltPropEditable');
			this.setData('check_error',false);	
			if(this.getData('ltPropEditable')){
				value=inputField.value;
			}
			else{
				value=inputField.innerHTML;
			}
			if(this.getData('ltPropEditable')&&(e.which==37)){
				e.preventDefault();
				inputField.classList.remove('hideCursor');
				return;
			}
			else if(this.getData('ltPropEditable')&&(e.which==37)){
				e.preventDefault();
				inputField.classList.remove('hideCursor');
				return;
			}
			if(!this.getData('bigger')&&(key==="^"|| key.match(/([^0-9/%*+-=.])/g))&&key!=="Backspace"&& key!=='Enter' &&( e.which!=37||e.which!=39||e.which!==38||e.which!==40)){
				if(edit){
					inputField.classList.remove('hideCursor');
				}
				this.setData('cursorIndex',this.getData('cursorIndex'));
				e.preventDefault();
				return;
			}
			else if(this.getData('bigger')&& (key.match(/([^0-9/()%^!*+-=.])/g)&&((e.keyCode === 187||e.keyCode!==61)&&!(e.shiftKey)))&&key!=="Backspace" && key!=='Enter' &&( e.which!=37||e.which!=39||e.which!==38||e.which!==40)){
				inputField.classList.remove('hideCursor');this.setData('cursorIndex',this.getData('cursorIndex'));e.preventDefault();return;
			}
			else if(value.length>=1){
				// var key = e.key,inputField=this.$node.querySelector('.lyteCalculatorTextField');
				if(this.$node.querySelector('.calculatorDisplay').className.indexOf('equalBtn')!=-1){
					this.$node.querySelector('.calculatorDisplay').classList.remove('equalBtn');
				}
				if(key==='Backspace'){
					if(edit){
						inputField.setSelectionRange(this.getData('cursorIndex'), this.getData('cursorIndex'));
						inputField.classList.remove('hideCursor');
					}
					this.preformMouseUp();
				}
				else if(key==='='||key==='Enter'){
					var value1=this.convertequation(value);
					value1=value1.replace(/^[a-zA-Z][(]/,'');
					value1=value1.split(/([0-9.]+|\(|\)|\+|\-|\/|\*|\^|~|N|s|c|t|l|S|C|T|!|%|L|i|o|a|I|O|A|G|E|p|R|e|Q)/g).filter(function(x) {return x!=""} );
					this.$node.querySelector('.calculatorDisplay').classList.add('equalBtn');
					this.$node.querySelector('.calculatorDisplay').classList.add('equalBtn');
					if(this.$node.querySelector('.calculatorDispspan').innerHTML==' '){
						this.$node.querySelector('.calculatorDispspan').innerHTML='Error';
					}
					return;
				}
				else if(edit){

					inputField.setSelectionRange(this.getData('cursorIndex'), this.getData('cursorIndex'));
					inputField.classList.remove('hideCursor');
				}
				this.setData('previous',key);
				this.preformMouseUp();
			}
			else{
				if(edit){
					inputField.classList.remove('hideCursor');
				}
				this.clearValue();
			}
		},
		"mupTextField" : function(e){
			var inputField=this.$node.querySelector('.lyteCalculatorTextField'),value=inputField.value,val=this.convertToPiandRoot(value);
			if(this.$node.querySelector('.calculatorDisplay').className.indexOf('equalBtn')!=-1){
				this.$node.querySelector('.calculatorDisplay').classList.remove('equalBtn');
			}
			if(! this.getData('ltPropEditable')){
				inputField.setSelectionRange(value.length, value.length);  
				e.preventDefault();return;
			}
			if(inputField.value.length>=1){
				inputField.focus();
				index=this.getSelectionIndex();
				if((index!==0&&!val[index-1].match(/^[+|\-|/|*|!|^|(|e|p|)|E|%]+$/)&&!val[index-1].match(/[0-9.]/g))&&value.length!==index){
					inputField.setSelectionRange(value.length, value.length);  
						inputField.classList.remove('hideCursor');  
					e.preventDefault();return;
				}
				inputField.classList.remove('hideCursor');  
			}
			inputField.classList.remove('hideCursor');
			 
			
		},
		"mdwnTextField" : function(e){
			var inputField=this.$node.querySelector('.lyteCalculatorTextField');
			inputField.classList.add('hideCursor');
			if(!this.getData('ltPropEditable')&& inputField.className.indexOf('hideCursorNonEditable')===-1){
				inputField.classList.add('hideCursorNonEditable');
			}
			
		}
	}
});
/**
 * @syntax nonYielded 
 * <lyte-calculator> </lyte-calculator> 
 */
/**
 * Renders a card
 * @component lyte-card
 * @version  3.12.0
 */
Lyte.Component.register( 'lyte-card', {
_template:"<template tag-name=\"lyte-card\"> <lyte-card-box style=\"{{finalStyle}}\" class=\"{{finalClass}}\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </lyte-card-box> </template>",
_dynamicNodes : [{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"finalStyle"}}},{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropSize","ltPropBackgroundColor","ltPropAlignment","ltPropBoxShadow","lyteViewPort","ltPropViewPort","finalClass","finalStyle"],
	data: function() {
		return {
			
			/**
			 * @componentProperty {small | medium | large} ltPropSize=medium
			 */

			'ltPropSize': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-card', 'size', 'medium' ) } ),

			/**
			 * @componentProperty {colorString} ltPropBackgroundColor
			 */

			'ltPropBackgroundColor': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-card', 'backgroundColor', '' ) } ),

			/**
			 * @componentProperty {horizontal | vertical} ltPropAlignment=vertical
			 */

			'ltPropAlignment': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-card', 'alignment', 'vertical' ) } ),

			/**
			 * @componentProperty {string} ltPropBoxShadow
			 */

			'ltPropBoxShadow': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-card', 'boxShadow', '' ) } ),
			'lyteViewPort' : Lyte.attr( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {boolean} ltPropViewPort=false
			 */

			'ltPropViewPort': Lyte.attr( 'boolean', { 'default': false } ),


			'finalClass': Lyte.attr( 'string', { 'default': '' } ),
			'finalStyle': Lyte.attr( 'string', { 'default': '' } )
		};
	},

	init: function() {
		var useViewPortFeature = this.getData( 'ltPropViewPort' );

		if( useViewPortFeature ) {
			this.setData( 'lyteViewPort', true );
		}
	},

	didConnect: function() {
		var isInViewPort = !this.getData( 'lyteViewPort' );

		if( isInViewPort ) {
			this.setup();
		}
	},

	setup: function() {
		this.setYieldClass();
		this.setStyle();
		this.align();
		this.size();
	},
	
	setYieldClass: function() {
		this.$node.querySelector( 'lyte-yield' ).classList.add( 'lyteCardYield' );
	},

	setStyle: function() {
		var boxShadow = this.getData( 'ltPropBoxShadow' ),
		bg = this.getData( 'ltPropBackgroundColor' ), res = '';

		if( boxShadow ) {
			res += 'box-shadow:' + boxShadow + ';';
		}

		if( bg ) {
			res += 'background-color:' + bg + ';';
		}

		this.setData( 'finalStyle', res );
	},

	align: function( old ) {
		var align = this.getData( 'ltPropAlignment' );

		align = align ? align : 'vertical';
		this.setClass( old, align );
	},

	size: function( old ) {
		var size = this.getData( 'ltPropSize' );

		size = size ? size : 'medium';
		this.setClass( old, size );
	},

	setClass: function( oldValue, newValue ) {
		var newCls, oldCls, cur = this.getData( 'finalClass' ), ind;

		newCls = 'lyteCard' + newValue[ 0 ].toUpperCase() + newValue.substring( 1 );
		cur = cur ? cur.split( ' ' ) : [];

		if( oldValue ) {
			oldCls = 'lyteCard' + oldValue[ 0 ].toUpperCase() + oldValue.substring( 1 );
			ind = cur.indexOf( oldCls );

			if( ind !== -1 ) {
				cur.splice( ind, 1 );
			}
			
		}

		cur.push( newCls );
		this.setData( 'finalClass', cur.join( ' ' ) );
	},

	box: function() {
		return this.$node.querySelector( 'lyte-card-box' );
	},

	styleObserver: function() {
		this.setStyle();
	}.observes( 'ltPropBackgroundColor', 'ltPropBoxShadow' ),

	alignmentObserver: function( change ) {
		this.align( change.oldValue );
	}.observes( 'ltPropAlignment' ),

	sizeObserver: function( change ) {
		this.size( change.oldValue );
	}.observes( 'ltPropSize' ),

	viewPortObserver: function() {
		this.setup();
	}.observes( 'lyteViewPort' )
} );

/** 
 *
 * @syntax yielded
 * <lyte-card>
 * 		<template is="registerYield" yield-name="yield">
 *			<lyte-card-header>
 *				Header
 *			</lyte-card-header>
 *			<lyte-card-body>
 *				Body
 *			</lyte-card-body>
 *			<lyte-card-footer>
 *				Footer
 *			</lyte-card-footer>
 *		</template>
 * </lyte-card>
 *
 *
 */

/**
 * Renders a calendar
 * @component lyte-calendar
 * @version 1.0.0
 * @utility revertToToday,revertToSelected
 * @methods onDateSelected,onNavigate,onViewChange
 * @dependencies lyte-dropdown
 */

Lyte.Component.register( 'lyte-calendar', {
_template:"<template tag-name=\"lyte-calendar\"> <div class=\"{{containerClass}}\" ontouchstart=\"{{action('record',event)}}\" ontouchend=\"{{action('decide',event)}}\"> <div class=\"lyteCalendarView\"> <div> <template is=\"if\" value=\"{{navYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"navigator\"></lyte-yield> </template><template case=\"false\"> <div class=\"lyteCalendarNavigator\"> <template is=\"if\" value=\"{{ifNotEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropYear}}\"> <template case=\"true\"><span class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('previous','Y',event)}}\"></span></template> </template> </template></template> <span class=\"lyteCalNav lyteCaldLft {{lyteUiDisableCalendarNav(viewDate,'previous')}}\" onclick=\"{{action('previous','M',event)}}\"></span> <span class=\"lyteCalsCalMon\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropHeaderType,'===','dropdown'),'||',expHandlers(ltPropHeaderType,'===','picklist'))}}\"><template case=\"true\"> <lyte-dropdown lt-prop-freeze=\"false\" lt-prop=\"{{stringify(ltPropDropdown)}}\" on-show=\"{{method('setClass')}}\" class=\"lyteCalMonthDD\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','M')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{monthNames}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <template is=\"if\" value=\"{{expHandlers(ltPropHeaderType,'===','dropdown')}}\"><template case=\"true\"> <lyte-dropdown lt-prop-freeze=\"false\" lt-prop=\"{{stringify(ltPropDropdown)}}\" on-show=\"{{method('setClass')}}\" class=\"lyteCalYearDD\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','Y')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{years}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template><template case=\"false\"> <lyte-picklist lt-prop-options=\"{{years}}\" lt-prop-dropdown=\"{&quot;freeze&quot;: false, &quot;callout&quot;: true, &quot;tabindex&quot;: 2}\" class=\"lyteCalYearDD\" on-option-select=\"{{method('optionSelected','Y')}}\" on-show=\"{{method('setClass')}}\"> </lyte-picklist> </template></template> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropHeaderType,'===','drilldown')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(viewType,'===','dateView')}}\"><template case=\"true\"> <span class=\"lyteDrillCalHeaderButton\" onclick=\"{{action('changeToMonthView',event)}}\"> <span class=\"lyteCalsCalMonth\">{{lyteUiGetMonthOrYear(monthHeader,\"M\")}}</span> <span class=\"lyteCalsCalYear\">{{lyteUiGetMonthOrYear(monthHeader,\"Y\")}}</span> </span> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(viewType,'===','monthView')}}\"><template case=\"true\"> <span class=\"lyteDrillCalHeaderButton\" onclick=\"{{action('changeToDecadeView',event)}}\"> <span class=\"lyteCalsCalYear\">{{currentYear}}</span> </span> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(viewType,'===','decadeView')}}\"><template case=\"true\"> <span class=\"lyteDrillCalHeaderButton lyteDrillCalYearListHeader\"> {{decadeStart}} - {{decadeEnd}} </span> </template></template></template></template></template></template> </template><template case=\"false\"> <span class=\"lyteCalsCalMonth\">{{lyteUiGetMonthOrYear(monthHeader,\"M\")}}</span> <span class=\"lyteCalsCalYear\">{{lyteUiGetMonthOrYear(monthHeader,\"Y\")}}</span> </template></template></template></template> </span> <span class=\"lyteCalNav lyteCaldRgt {{lyteUiDisableCalendarNav(viewDate,'next')}}\" onclick=\"{{action('next','M',event)}}\"></span> <template is=\"if\" value=\"{{ifNotEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropYear}}\"> <template case=\"true\"><span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('next','Y',event)}}\"></span></template> </template> </template></template> </div> </template></template> </div> <div class=\"lyteCalTableContainer\"> <template is=\"if\" value=\"{{ltPropBodyYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"body\"></lyte-yield> </template><template case=\"false\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropHeaderType,'!==','drilldown'),'||',expHandlers(expHandlers(ltPropHeaderType,'===','drilldown'),'&amp;&amp;',expHandlers(viewType,'===','dateView')))}}\"><template case=\"true\"> <div class=\"lyteCalTableRowHeader\"> <template is=\"for\" items=\"{{daysOfWeek}}\" item=\"day\" indexval=\"idod\"> <div class=\"lyteCalTableCellHeader\">{{lyteUiI18n(day)}}</div> </template> </div> </template></template> <div class=\"lyteCalTableRowGroup\"> <template is=\"if\" value=\"{{expHandlers(ltPropHeaderType,'!==','drilldown')}}\"><template case=\"true\"> <template is=\"for\" items=\"{{matrix}}\" item=\"vector\" indexval=\"rowid\"> <template is=\"if\" value=\"{{lyteUiCheckEmpty(vector)}}\"> <template case=\"false\"> <div class=\"lyteCalTableRow\"> <template is=\"for\" items=\"{{vector}}\" item=\"date\" indexval=\"cellid\"> <template is=\"if\" value=\"{{lyteUiCheckInRange(ltPropMinDate,ltPropMaxDate,date.val,ltPropFormat)}}\"> <template case=\"true\"> <template is=\"if\" value=\"{{date.emptyBlock}}\"> <template case=\"true\"> <div class=\"lyteCalEmpty\"></div> </template> <template case=\"false\"> <div data-date=\"{{date.val}}\" onclick=\"{{action('dateSelected',event)}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div> </template> </template> </template> <template case=\"false\"> <template is=\"if\" value=\"{{date.emptyBlock}}\"> <template case=\"true\"> <div class=\"lyteCalEmpty\"></div> </template> <template case=\"false\"> <div data-date=\"{{date.val}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div> </template> </template> </template> </template> </template> </div> </template> </template> </template> </template><template case=\"false\"> <template is=\"if\" value=\"{{expHandlers(viewType,'===','dateView')}}\"><template case=\"true\"> <template is=\"for\" items=\"{{matrix}}\" item=\"vector\" indexval=\"rowid\"> <template is=\"if\" value=\"{{lyteUiCheckEmpty(vector)}}\"> <template case=\"false\"> <div class=\"lyteCalTableRow\"> <template is=\"for\" items=\"{{vector}}\" item=\"date\" indexval=\"cellid\"> <template is=\"if\" value=\"{{lyteUiCheckInRange(ltPropMinDate,ltPropMaxDate,date.val,ltPropFormat)}}\"> <template case=\"true\"> <template is=\"if\" value=\"{{date.emptyBlock}}\"> <template case=\"true\"> <div class=\"lyteCalEmpty\"></div> </template> <template case=\"false\"> <div data-date=\"{{date.val}}\" onclick=\"{{action('dateSelected',event)}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div> </template> </template> </template> <template case=\"false\"> <template is=\"if\" value=\"{{date.emptyBlock}}\"> <template case=\"true\"> <div class=\"lyteCalEmpty\"></div> </template> <template case=\"false\"> <div data-date=\"{{date.val}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div> </template> </template> </template> </template> </template> </div> </template> </template> </template> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(viewType,'===','monthView')}}\"><template case=\"true\"> <template is=\"for\" items=\"{{monthViewData}}\" item=\"row\" index=\"rowIndex\"> <div class=\"lyteCalTableRow\"> <template is=\"for\" items=\"{{row}}\" item=\"column\" index=\"columnIndex\"> <div onclick=\"{{action('monthSelected',event)}}\" class=\"{{column['class']}}\" data-date=\"{{column['systemValue']}}\"> {{column['displayValue']}} </div> </template> </div> </template> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(viewType,'===','decadeView')}}\"><template case=\"true\"> <template is=\"for\" items=\"{{decadeViewData}}\" item=\"row\" index=\"rowIndex\"> <div class=\"lyteCalTableRow\"> <template is=\"for\" items=\"{{row}}\" item=\"column\" index=\"columnIndex\"> <template is=\"if\" value=\"{{expHandlers(column.emptyBlock,'!')}}\"><template case=\"true\"> <div onclick=\"{{action('yearSelected',event)}}\" class=\"lyteCalTableCell {{column.class}}\" data-date=\"{{column.year}}\"> {{column.year}} </div> </template><template case=\"false\"> <div class=\"lyteCalEmpty\"> </div> </template></template> </template> </div> </template> </template></template></template></template></template></template> </template></template> </div> </template></template> </div> <div> <div class=\"lyteCalBtns\"> <template is=\"if\" value=\"{{expHandlers(showToday,'&amp;&amp;',ltPropShowToday)}}\"><template case=\"true\"> <p class=\"lyteCalCurrentDate\"><a onclick=\"{{action('today',event)}}\">{{lyteUiI18n('today')}}</a></p> </template></template> <template is=\"if\" value=\"{{ltPropYield}}\"> <template case=\"true\"> <lyte-yield yield-name=\"footer\"></lyte-yield> </template> </template> </div> </div> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"if","position":[1,1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5,1]},{"type":"if","position":[1,5,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"text","position":[1,3,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"text","position":[1,3]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"text","position":[3,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,7]},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,1,3,1]},{"type":"if","position":[1,1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"text","position":[1,0]}]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]}},"default":{}}]}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]}},"default":{}}]}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]}]}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,1,5,1,1]},{"type":"if","position":[1,1,5,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,0]},{"type":"text","position":[1,0,0]}]}},"default":{}},{"type":"attr","position":[1,1,5,1,3]},{"type":"if","position":[1,1,5,1,3],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropStartDate","ltPropEndDate","ltPropCurrentDate","ltPropFormat","ltPropYear","ltPropMonthHeaderFormat","daysOfWeek","monthSystemValues","monthNames","shortHands","todayName","viewDate","changeData","ltPropYield","ltPropMinDate","ltPropMaxDate","ltPropStartWeekDay","navYield","selectDate","currentDatechanged","ltPropFillRows","ltPropNumberOfRows","callFrmDidcnct","monthDD","yearDD","years","ltPropHeaderType","ltPropDropdown","cords","start","prev","tt","showToday","monthViewTableArray","ltPropBodyYield","ltPropShowToday","ltPropI18n"],
	data: function() {
		return {
			'ltPropStartDate': Lyte.attr( 'string', { 
				'default': ''
			} ),
			'ltPropEndDate': Lyte.attr( 'string', { 
				'default': ''
			} ),

			/** 
			 * @componentProperty {dateString} ltPropCurrentDate
			 */

			'ltPropCurrentDate': Lyte.attr( 'string', { 
				'default': '' 
			} ),
			/** 
			 * @typedef {
				* MM/DD/YYYY |
				* YYYY/MM/DD |
				* MMM/DD/YYYY |
				* MMM/YYYY/DD |
				* DD/MMM/YYYY |
				* YYYY/MMM/DD |
				* DD/YYYY/MMM |
				* YYYY/DD/MMM |
				* MMMM/DD/YYYY |
				* MMMM/YYYY/DD |
				* DD/YYYY/MMMM |
				* YYYY/DD/MMMM |
				* DD/MMMM/YYYY |
				* YYYY/MMMM/DD
				* } dateFormat
			*/
			/** 
			 * @componentProperty {dateFormat} ltPropFormat
			 * @default MM/DD/YYYY
			 */

			'ltPropFormat': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'format', 'MM/DD/YYYY' )  
			} ),

			/**
			 * @componentProperty {boolean} ltPropYear
			 * @default true
			 * 
			 */

			'ltPropYear': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'year', true ) 
			} ),

			/**
			 * @typedef {
			 * 'MMMM YYYY' |
			 * 'MMM YYYY' 
			 * } MonthHeaderFormat
			 */
			/**
			 * @componentProperty {MonthHeaderFormat} ltPropMonthHeaderFormat
			 * @default 'MMMM YYYY'
			 */

			'ltPropMonthHeaderFormat': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'monthHeaderFormat', 'MMMM YYYY' ) 
			} ),
			'daysOfWeek': Lyte.attr( 'array', { 
				'default': [] 
			} ),

			'monthSystemValues': Lyte.attr( 'array', {
				'default': [
					'January',
					'February',
					'March',
					'April',
					'May',
					'June',
					'July',
					'August',
					'September',
					'October',
					'November',
					'December' 
				]
			} ),

			'monthNames': Lyte.attr( 'array', { 
				'default': [
					'January',
					'February',
					'March',
					'April',
					'May',
					'June',
					'July',
					'August',
					'September',
					'October',
					'November',
					'December' 
				]
			} ),
			'shortHands': Lyte.attr( 'array', { 
				'default': [
				'Jan',
				'Feb',
				'Mar',
				'Apr',
				'short.may',
				'Jun',
				'Jul',
				'Aug',
				'Sep',
				'Oct',
				'Nov',
				'Dec'
				]
			} ),
			'todayName': Lyte.attr( 'string', {
				'default': 'Today' 
			} ),
			'viewDate': Lyte.attr( 'object', { 
				'default': {} 
			} ),
			'changeData': Lyte.attr( 'number', {
				'default': 0 
			} ),

			/**
			 * @componentProperty {boolean} ltPropYield
			 * @default false
			 * 
			 */

			'ltPropYield': Lyte.attr( 'boolean', { 
				'default': false
			} ),

			/**
			 * @componentProperty {dateString} ltPropMinDate
			 */

			'ltPropMinDate': Lyte.attr( 'string', { 
				'default': ''
			} ),

			/**
			 * @componentProperty {dateString} ltPropMaxDate
			 */

			'ltPropMaxDate': Lyte.attr( 'string', { 
				'default': '' 
			} ),

			/**
			 * @componentProperty {number} ltPropStartWeekDay
			 * @default 1
			 * @minValue 0
			 * @maxValue 6
			 * @step 1
			 */

			'ltPropStartWeekDay': Lyte.attr( 'number', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'startWeekDay', 1 )
			} ),
			'navYield': Lyte.attr( 'boolean', { 
				'default': false 
			} ),
			'selectDate': Lyte.attr( 'boolean', { 
				'default': true 
			} ),
			'currentDatechanged': Lyte.attr( 'number', { 
				'default': 0 
			} ),

			/**
			 * @componentProperty {boolean} ltPropFillRows
			 * @default true
			 * @version 1.0.2
			 * 
			 */

			'ltPropFillRows': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'fillRows', true ) 
			} ),

			/**
			 * @componentProperty {number} ltPropNumberOfRows
			 * @version 1.0.2
			 * @default 6
			 */

			'ltPropNumberOfRows': Lyte.attr( 'number', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'numberOfRows', 6 )
			} ),
			'callFrmDidcnct' : Lyte.attr('boolean',{"default" : false}),
			'monthDD' : Lyte.attr("object"),
			'yearDD' : Lyte.attr("object"),
			'years' :Lyte.attr("array",{"default":[1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100]}),

			/**
			 * @componentProperty {default|dropdown|drilldown} ltPropHeaderType
			 * @default default
			 * @version 1.0.2
			 */

			'ltPropHeaderType' : Lyte.attr( "string", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'headerType', 'default' ) } ),

			'ltPropDropdown': Lyte.attr( 'object', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'dropdown', 
				{
					'callout': true
				} 
			) } ),

			'cords': Lyte.attr( 'object', { default: {} } ),
			'start': Lyte.attr( 'number' ),
			'prev': Lyte.attr( 'boolean' ),
			'tt': Lyte.attr( 'boolean', { 'default': true } ),
			'showToday': Lyte.attr( 'boolean', { 'default': true } ),

			'monthViewTableArray': Lyte.attr( 'array', { 'default': [] } ),

			'ltPropBodyYield': Lyte.attr( 'boolean', { 'default': false } ),

			'ltPropShowToday': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'showToday', true ) } ),

			'ltPropI18n': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'I18n', false ) } )

		}
	},

	toDate : function(){
		if( this.isHavingTimezone ){
			return new Date( $L.moment().format( 'MM/DD/YYYY' ) );
		}
		return new Date();
	},

	moment : function( arg1, arg2, arg3 ){
		var timezone = this.isHavingTimezone;
		if( timezone ){// for test case failure
			if( arg3 ){
				arg3.ignore_timezone = timezone;
			} else{
				arg3 = { ignore_timezone : timezone };
			}
			return $L.moment( arg1, arg2, arg3 );
		} else{
			if( arg2 ){ // for test case failure
				return $L.moment( arg1, arg2 );
			}
			return $L.moment( arg1 );
		}
	},

	changeBodyContainerClass: function() {
		var container = this.$node.querySelector( '.lyteCalTableContainer' ),
		viewType = this.getData( 'viewType' );

		if( viewType === 'dateView' ) {
			container.classList.remove( 'lyteDrillCalMonthView' );
			container.classList.remove( 'lyteDrillCalYearView' );
		}
		else if( viewType === 'monthView' ) {
			container.classList.add( 'lyteDrillCalMonthView' );
			container.classList.remove( 'lyteDrillCalYearView' );
		}
		else if( viewType === 'decadeView' ) {
			container.classList.remove( 'lyteDrillCalMonthView' );
			container.classList.add( 'lyteDrillCalYearView' );
		}
	}.observes( 'viewType' ),

	changeDaysOfWeek: function() {
		var days = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], 
		startDay = this.getData( 'ltPropStartWeekDay' ), i, result = [] ;
		for( i = 0; i < 7; i++ ) { 
			result.push( days[ ( i + startDay ) % 7 ] );
		}

		this.setData( 'daysOfWeek', result );
		
	},

	isYYFormat: function() {
		var format = this.getData( 'ltPropFormat' ),
		rYY = /\byy\b/ig;

		return rYY.test( format );
	},

	outsideBoundary: function( calStartDate ) {
		var calculatedYear = calStartDate.getFullYear(),
		current = this.toDate(),
		currentYear = current.getFullYear(),
		diff = calculatedYear - currentYear,
		dateBounds = this.isMomentSupported ? $L.moment() : { uL: 19, lL: 80 };

		if( diff > dateBounds.uL ) {
			return true;
		}
		else if( diff < -dateBounds.lL ) {
			return true;
		}	
		
	},

	didDestroy: function() {
		delete this.$node.revertToToday;
	},

	setMonthAndYearDropdown : function(){
		if(!this.getData('navYield') && this.isDropdownHeader() && this.getData('monthDD') && this.getData('yearDD')){
			var monthHeaders = this.getData('monthHeader').split( ' ' ),
			format = this.getData( 'ltPropMonthHeaderFormat' ), 
			lmd = /MMMM YYYY/ig,
			ld = /MMM YYYY/ig,
			monthArray = [],
			monthNames;
			if(arguments[0].item == "callFrmDidcnct"){
				if(lmd.test( format )){
					monthNames = this.getData('monthNames');
				}
				else if(ld.test(format)){
					monthNames = this.getData('shortHands');
				}
				for(var i=0;i<monthNames.length; i++){
					monthArray[i] = _lyteUiUtils.i18n(monthNames[i]);
				}
				this.setData('monthNames',monthArray);
			}
			// this.getData('monthDD').component.setData('ltPropOptions',monthArray);
			this.getData('monthDD').component.setData('ltPropSelected',monthHeaders[0]);
			this.getData('yearDD').component.setData('ltPropSelected',monthHeaders[1]);
		}
	}.observes('monthHeader','callFrmDidcnct'),

	startWeekDayObserver: function() {
		this.changeDaysOfWeek();
	}.observes( 'ltPropStartWeekDay' ),

	monthHeaderObserver: function() {
		this.buildDateViewHeader();
	}.observes( 'monthNames.[]' ),

	getMonthHeader: function() {
		var format = this.getData( 'ltPropMonthHeaderFormat' ), 
		lmd = /MMMM YYYY/ig,
		ld = /MMM YYYY/ig,
		retval = "", monthArray;

		if( lmd.test( format ) ) {
			monthArray = this.getData( 'monthNames' )
			retval = _lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + " " + this.getData( 'viewDate' ).getFullYear();
		}
		else if( ld.test( format ) ) {
			monthArray = this.getData( 'shortHands' )
			retval = _lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + " " + this.getData( 'viewDate' ).getFullYear();
		}

		return retval;
	},

	revert: function( event ) {
		var from = new Date( this.getData( 'viewDate' ).getTime() ), 
		curDate = this.toDate();


		curDate.setDate(1);

		var to = new Date( curDate.getTime() );

		this.setData( 'viewDate', curDate );
		this.setAndBuildView( 'dateView', event );
		this.setData( 'showToday', false );
		if( this.getMethods( 'onNavigate' ) 
			&& ( from.getMonth() !== to.getMonth() 
			|| from.getFullYear() !== to.getFullYear() ) 
		) {
			this.executeMethod( 'onNavigate', event, this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) ), this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) ) ,this );
		}
	},

	getDateFromFormat: function( dateObj, format ) {
		if( this.isMomentSupported ) {
			return this.getDateStringFromMoment( dateObj, format );
		}
		else {
			return this.getDateStringManually( dateObj, format );
		}
	},

	getDateStringFromMoment: function( dateObj, format ) {
		format = this.getRelevantFormat( format );

		return this.moment( dateObj ).format( format );
	},

	resolveConflicts: function( format ) {
		var match = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/.exec( format ),
		index = ( match || {} ).index,
		matchLength = ( match || [] )[ 0 ].length || 0;

		if( !isNaN( index ) ) {
			return format.substring( 0, index + matchLength ) + ( format.substring( index + matchLength ) || '' ).toUpperCase();
		}

		return format.toUpperCase();
	},

	isConflictingFormat: function( format ) {
		var rdate = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/ig,
		match = format.match( rdate ) || [];

		return match.length > 1;
	},

	getRelevantFormat: function( format ) {

		if( this.isConflictingFormat( format ) ) {
			return this.resolveConflicts( format );
		}

		return format.toUpperCase();
	},

	getDateStringManually: function( dateObj, format ) {
		var date = dateObj.getDate(), year = dateObj.getFullYear(), month = dateObj.getMonth() + 1, monthArray,
		sd = /(MM).+(DD).+(YYYY)/ig,
		dmy = /(DD).+(MM).+(YYYY)/ig,
		ld = /(MMM|DD|YYYY).+(MMM|DD|YYYY).+(YYYY|MMM|DD)/ig,
		lmd = /(MMMM|DD|YYYY).+(MMMM|DD|YYYY).+(YYYY|MMMM|DD)/ig,
		iso =/(YYYY).+(MM).+(DD)/ig;

		format = format.toUpperCase();
		
		if( month < 10 ) {
			month = '0' + month
		}

		if( date < 10 ) {
			date = '0' + date
		}

		if( lmd.test( format ) ) {
			monthArray = [ 
			'January',
			'February',
			'March',
			'April',
			'May',
			'June',
			'July',
			'August',
			'September',
			'October',
			'November',
			'December'
			]
			format = format.replace( 'MMMM', monthArray[ month - 1 ] );
			format = format.replace( 'DD', date );
			format = format.replace( 'YYYY', year );
		}
		else if( ld.test( format ) ){
			monthArray=[ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ];
			format = format.replace( 'MMM', monthArray[ month - 1 ] );
			format = format.replace( 'DD', date );
			format = format.replace( 'YYYY', year );
		}
		else if( iso.test( format ) ){
			format = format.replace( 'MM', month );
			format = format.replace( 'DD', date );
			format = format.replace( 'YYYY', year );
		}
		else if( sd.test( format ) ) {
			format = format.replace( 'MM', month );
			format = format.replace( 'DD', date );
			format = format.replace( 'YYYY', year );
		}
		else if( dmy.test( format ) ) {
			format = format.replace( 'MM', month );
			format = format.replace( 'DD', date );
			format = format.replace( 'YYYY', year );
		}
		
		return format
	},

	isLeapYear: function( year ) {
		return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 );
	},

	getNumber: function(month,year) {
		var daysinmonths = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
		if( this.isLeapYear.call( this, year ) && month == 1 ) {
			return 29;
		}
		else{
			return daysinmonths[ month ];
		}
	},

	showtoday: function() {
		var curDate = this.toDate();

		if( curDate.getMonth() != this.getData('viewDate').getMonth() || curDate.getYear() != this.getData('viewDate').getYear() ) {
			this.setData( 'showToday', true );
		}
		else {
			this.setData( 'showToday', false );
		}
	},

	reset: function( cur ) {
		cur.setHours( 0 );
		cur.setMinutes( 0 );
		cur.setSeconds( 0 );
		cur.setMilliseconds( 0 );
	},

	checkDate: function( current ) {
		var start = this.getData( 'ltPropMinDate' ) || '', 
		end = this.getData( 'ltPropMaxDate' ) || '',
		startDate, endDate;

		this.reset( current );

		if( start === '' && end === '' ) {
			return true;
		}
		else if( start !== '' && end === '' ) {
			startDate = this.stringToDate( start, this.getData( 'ltPropFormat' ) );
			this.reset( startDate );
			
			if( current >= startDate ) {
				return true;
			}
		}
		else if( start !== '' && end !== '' ) {
			startDate = this.stringToDate( start, this.getData( 'ltPropFormat' ) );
			this.reset( startDate );

			endDate = this.stringToDate( end, this.getData( 'ltPropFormat' ) );
			this.reset( endDate );

			if( current >= startDate && current <= endDate ) {
				return true;
			}
		}
		else {
			endDate = this.stringToDate( end, this.getData( 'ltPropFormat' ) );
			this.reset( endDate );

			if( current <= endDate ) {
				return true;
			}
		}

		return false;
	},

	numberOfRowsChange: function() {
		// https://stackoverflow.com/questions/19727905/in-javascript-is-it-expensive-to-use-try-catch-blocks-even-if-an-exception-is-n
		// No penalty in chrome >= 60
		var numberOfRows = this.getData( 'ltPropNumberOfRows' );

		try {
			if( numberOfRows < 5 ) {
				throw "Calendar failed to render. The number of rows should be greater than 4.";
			}
		}
		catch( e ) {
			console.error( e );
			return ;
		}

		this.setDatesFunction();
	}.observes( 'ltPropNumberOfRows' ),

	setDates: function() {
		this.setDatesFunction();
	}.observes( 
		'ltPropStartDate', 
		'ltPropEndDate', 
		'changeData', 
		'ltPropMinDate', 
		'ltPropMaxDate',
		'ltPropFormat',
		'ltPropStartWeekDay'
	),

	getNumberOfFirstRowDates: function( firstday ) {
		var startDayOfMonth = this.getData( 'ltPropStartWeekDay' ), 
		firstRowDays;

		if( firstday == 0 ) {
			firstRowDays = startDayOfMonth === 0 ? 7 : startDayOfMonth;
		}
		else {
			if( firstday < startDayOfMonth ) {
				firstRowDays = startDayOfMonth - firstday;
			}
			else {
				firstRowDays = 7 - ( firstday - startDayOfMonth );
			}
		}

		return firstRowDays;

	},

	getNumberToSubtract: function( firstday ) {
		var numberToSubtract, startDayOfMonth = this.getData( 'ltPropStartWeekDay' );

		if( firstday == 0 ) {
			numberToSubtract = startDayOfMonth == 0 ? 0 : 7 - startDayOfMonth;
		}
		else {
			if( firstday < startDayOfMonth ) {
				numberToSubtract = 7 - ( startDayOfMonth - firstday );
			}
			else {
				numberToSubtract = firstday - startDayOfMonth;
			}
		}

		return numberToSubtract;
	},

	getFirstDay: function( date, day ) {
		var first;

		first = date - Math.floor( date / 7 ) * 7 - 1;
		first = day - first;

		if( first < 0 ){
			first = 7 - first;
		}

		return first;
	},

	getRemainingDays: function( numberOfDaysInMonth, firstRowDays ) {
		var rem = numberOfDaysInMonth - firstRowDays;
		rem = rem - 28;

		return rem;
	},

	inc: function( rem, num ) {
		if( rem > 0 && num == 6 ) {
			return 7; 
		}

		return num;
	},

	setDatesFunction: function() {
		// Number of rows in the table
		var numberOfRows = this.getData( 'ltPropNumberOfRows' ), 
		fillRows = this.getData( 'ltPropFillRows' ), 
		format = this.getData( 'ltPropFormat' ),
		reachedNextMonth = false, 
		result = [],
		cur = this.getData( 'viewDate' ), 
		day = cur.getDay(),
		date = cur.getDate(), 
		firstday =  this.getFirstDay( date, day ),
		month = cur.getMonth(),
		year = cur.getFullYear(),
		numberOfDaysInMonth = this.getNumber( month, year ),
		firstRowDays = this.getNumberOfFirstRowDates( firstday ),
		rem = this.getRemainingDays( numberOfDaysInMonth, firstRowDays );


		numberOfRows = this.inc( rem, numberOfRows );

		var calStartDate = new Date( month + 1 + '/1/' + year ), 
		numberToSubtract = this.getNumberToSubtract( firstday );

		calStartDate.setDate( calStartDate.getDate() -  numberToSubtract );
		
		var todayDate = this.toDate(), firstRow;

		// Construct array
		for( var i = 0; i < numberOfRows; i++ ) {

			// This is to ensure that we don't create an empty row when we reach the next month when fillRows is false.
			if(reachedNextMonth) {
				break;
			}

			result.push( [] );

			for( var j = 0; j < 7; j++ ) {
				if( !fillRows && month !== calStartDate.getMonth() ) {
					result[i].push( { emptyBlock: true } );
					calStartDate.setDate( calStartDate.getDate() + 1 );

					if( i != 0 ) {
						reachedNextMonth = true;
					}

					continue;
				}
				else if( fillRows && this.isYYFormat() && this.outsideBoundary( calStartDate ) ) {
					result[ i ].push( { emptyBlock: true } );
					calStartDate.setDate( calStartDate.getDate() + 1 );

					if( i != 0 ) {
						reachedNextMonth = true;
					}

					continue;
				}

				var clsname = 'lyteCalCdate', newMonth = calStartDate.getMonth(),
				curDate = new Date( this.getData( 'viewDate' ).getTime() ),
				curMonth = curDate.getMonth(),
				ndate = calStartDate.getDate(),
				tdate = this.getData( 'ltPropCurrentDate' ) ? this.stringToDate( this.getData( 'ltPropCurrentDate' ), this.getData( 'ltPropFormat' ) ) : 'nodate',
				nyear = calStartDate.getYear(),
				isInRange = this.checkDate( calStartDate ),
				isPresent = ( this.getData( 'ltPropMinDate' ) || "" ) !== "" || ( this.getData( 'ltPropMaxDate' ) || "" ) !== "";

				if( curMonth !== newMonth ) {
					clsname += ' lyteCalDiffMonth';

					if( !isPresent ) {
						clsname += ' lyteCalGray';
					}

					// Out of range in different month
					else if( !isInRange ) {
						clsname += ' lyteCalDisabled';
					}		
				}

				// Out of range in same month
				else if( isPresent 
					&& !isInRange ) {
					clsname += ' lyteCalDisabled';
				}

				if( tdate !== 'nodate' && tdate !== 'Invalid Date' && newMonth == tdate.getMonth() && tdate.getDate() == ndate && tdate.getYear() == nyear && this.getData( 'selectDate' ) ) {
					clsname += ' lyteCalSel'
				}

				if( todayDate.getMonth() === newMonth && todayDate.getDate() === ndate && todayDate.getYear() === nyear && this.getData( 'selectDate' ) ) {
					clsname += ' lyteCalToday'
				}

				// Add Classes for weekends
				if( calStartDate.getDay() == 0 || calStartDate.getDay() == 6 ) {
					clsname += ' lyteCalWeekend'
				}

				// Store in array and increment date by 1
				clsname += ' lyteCalTableCell';
				var obj = {};
				obj.date = calStartDate.getDate();
				obj.clsname = clsname;
				obj.val = this.getDateFromFormat.call( this, calStartDate, this.getData( 'ltPropFormat' ) );
				result[ i ].push( obj );
				// Lyte.arrayUtils( this.getData( 'matrix' )[ i ], 'push', obj )
				calStartDate.setDate( calStartDate.getDate() + 1 );
			}

		}

		this.setData( 'matrix', result );

	},

	executeViewDateChanges : function() {
		if( this.getMethods( 'onViewdateChange' ) ) {
			this.executeMethod( 'onViewdateChange', this, this.getData( 'viewDate' ) );
		}
	}.observes( 'viewDate' ),

	/** 
	 * get proper month from user defined value
	 * @param {String} mon - The current month
	 *
	 */

	getProperMonth: function( val ) {
		var sm = {
			'jan': 1,
			'feb': 2,
			'mar': 3,
			'apr': 4,
			'may': 5,
			'jun': 6,
			'jul': 7,
			'aug': 8,
			'sep': 9,
			'oct': 10,
			'nov': 11,
			'dec': 12
		}, lg = {
			'january': 1,
			'february': 2,
			'march': 3,
			'april': 4,
			'may': 5,
			'june': 6,
			'july': 7,
			'august': 8,
			'september': 9,
			'october': 10,
			'november': 11,
			'december': 12
		}, ret

		val = val.toLowerCase();
		ret = sm[ val ] || lg[ val ];

		if( !ret && ret !== 0 ) {
			return parseFloat( val ) - 1;
		}

		return ret-1;
	},

	/**
	 * Checks if the date is a proper date for the corresponding month and year
	 * @param {Number} year - The year of the date object
	 * @param {Number} month - The month of the date object
	 * @param {Number} date - The date value of the date object
	 *
	 */

	isProperDate: function( year, month, date ) {
		var daysInMonth = this.getNumber( month, year );

		if( date <= daysInMonth ) {
			return true;
		}

		return false;
	},


	/**
	 * Return the date object for the given string and format
	 * @param {String} dateString - The current date in the form of a string
	 * @param {String} format - The format of the dateString
	 *
	 */

	getDateObjFromString: function( dateString, format ) {
		try {
			var vals = dateString.match( /([\da-z]+)/ig ), year, month,
			format = format.toUpperCase(),
			sep = format.match( /([a-z]+)/ig ),
			date = this.toDate(), i = 0, order=['Y', 'M', 'D'];
			date.setDate(1);  //initialize the day to be 1 to avoid error for eg: 30 Feb if passed will generate 1 Mar as result.

			if( vals.length !== 3 ) {
				return 'Invalid Date';
			}

			while( i < sep.length ) {
				var ind = this.getOrderIndex(sep, order[ i ] );

				if( i == 0 ) {
					date.setFullYear( year = vals[ ind ] );
				}
				else if( i == 1 ) {
					month = this.getProperMonth( vals[ ind ] );

					if( month < 0 || month > 11 ) {
						return 'Invalid Date';
					}

					date.setMonth( month );
				}
				else if( i == 2 ) {
					if( !this.isProperDate( year, month, vals[ ind ] ) ) {
						return 'Invalid Date';
					}

					date.setDate( vals[ ind ] );
				}

				if( date.toString() === 'Invalid Date' ) {
					return date.toString();
				}

				i++;
			}

			return date;	
		}
		catch( e ) {
			return 'Invalid Date';
		}
	},

	getDateObjFromMoment: function( dateString, format ) {
		var momentObj, ret;

		format = this.getRelevantFormat( format );

		if( !dateString ) {
			return 'Invalid Date';
		} 

		try {
			momentObj = this.moment( dateString, format );
			ret = momentObj.getDObj();
		}
		catch( e ) {
			ret = 'Invalid Date';
		}

		if( Object.prototype.toString.call( ret ) === '[object Date]' ) {
			if( isNaN( ret.getTime() ) ) {
				ret = 'Invalid Date';
			}
		}

		return ret || 'Invalid Date';
	},

	/**
	 * Convert the string to date object based on the format
	 * @param {String} cur - The current date of the user passed
	 * @param {String} format - The format of the dates
	 *
	 */

	stringToDate: function( cur, format ) {
		var ret;

		cur = this.convertToEnglish( cur );

		if( this.isMomentSupported ) {
			ret = this.getDateObjFromMoment( cur, format );
		}
		else {
			ret = this.getDateObjFromString( cur, format );
		}

		return ret;
	},

	convertToEnglish: function( cur ) {
		var i18n = this.getData( 'ltPropI18n' ),
		format = this.getData( 'ltPropFormat' );

		if( i18n ) {
			return this.moment( cur, format, { i18n : true } ).format( format );
		}

		return cur;
	},

	getEnglishShorthand: function( cur ) {
		var months = this.getShortHands(), proper = -1, max = 0,
		shortHands = this.getData( 'shortHands' );

		for( var i = 0; i < months.length; i++ ) {
			if( !!~cur.indexOf( months[ i ] ) && months[ i ].length > max ) {
				proper = i;
				max = months[ i ].length;
			}
		}

		if( proper !== -1 ) {
			cur = cur.replace( months[ proper ], this.getProperShortHand( shortHands[ proper ] ) );
		}

		return cur;
	},

	getShortHands: function() {
		var shortHands = this.getData( 'shortHands' ), res = [];

		for( var i = 0; i < shortHands.length; i++ ) {
			res.push( _lyteUiUtils.i18n( shortHands[ i ] ) );
		}

		return res;
	},

	getProperShortHand: function( val ) {
		if( val === 'short.may' ) {
			return 'May';
		}

		return val;
	},

	getEnglishStandard: function( cur ) {
		var months = this.getStandardMonths(), englishMonths = this.getData( 'monthNames' ),
		proper = -1, max = 0;

		for( var i = 0; i < months.length; i++ ) {
			if( !!~cur.indexOf( months[ i ] ) && months[ i ].length > max ) {
				proper = i;
				max = months [ i ].length;
			}
		}

		if( proper !== -1 ) {
			cur = cur.replace( months[ proper ], englishMonths[ proper ] );
		}

		return cur;
	},

	getStandardMonths: function() {
		var monthNames = this.getData( 'monthNames' ), res = [];

		for( var i = 0; i < monthNames.length; i++ ) {
			res.push( _lyteUiUtils.i18n( monthNames[ i ] ) );
		}

		return res;
	},

	getOrderIndex : function(objArr, match){
		for(var i = 0; i < objArr.length; i++){
			if(objArr[i].charAt(0) === match){
				return i;
			}
		}
		return -1;
	},

	buildYears: function() {
		var yearBounds = this.buildMinAndMaxYear(),
		maxYear = yearBounds.maxYear,
		minYear = yearBounds.minYear, i, years = [];

		for( i = minYear; i <= maxYear; i++ ) {
			years.push( i.toString() );
		}

		this.setData( 'years', years );
	},

	buildMinAndMaxYear: function() {
		var currentDate = this.toDate(), 
		isYYFormat = this.isYYFormat(),
		currentYear = currentDate.getFullYear(),
		dateBounds = this.isMomentSupported ? $L.moment() : { uL: 19, lL: 80 },
		valueToAdd = dateBounds.uL,
		valueToRemove = dateBounds.lL;

		return {
			maxYear: isYYFormat ? currentYear + valueToAdd : 2100,
			minYear: isYYFormat ? currentYear - valueToRemove : 1900
		};

	},

	setAndBuildView: function( viewType, event, preventCallback ) {
		var oldView = this.getData( 'viewType' ),
		newView = viewType;

		this.setData( 'viewType', viewType );

		if( viewType === 'monthView' ) {
			this.buildMonthView();
		}
		else if( viewType === 'decadeView' ) {
			this.buildDecadeView();
		}
		else if( viewType === 'dateView' ) {
			this.buildDateView();
		}

		// pressing the today button should not fire the viewChange when it is in the dateview
		if( !preventCallback && ( oldView !== newView ) ) {
			if( this.getMethods( 'onViewChange' ) ) {
				this.executeMethod( 'onViewChange', event, viewType, this );
			}
		}
		
	},

	buildDateView: function() {
		this.buildDateViewHeader();
		this.buildDateViewContent();
		this.showtoday();
	},

	buildDateViewHeader: function() {
		this.setData( 'monthHeader', this.getMonthHeader() );
	},

	buildDateViewContent: function() {
		this.setDatesFunction();
	},

	buildMonthView: function() {
		this.buildMonthViewHeader();
		this.buildMonthViewContent();
	},

	buildMonthViewHeader: function() {
		var viewDate = this.getData( 'viewDate' ),
		year = viewDate.getFullYear();

		this.setData( 'currentYear', year );
	},

	buildMonthViewContent: function() {
		var systemValues = this.getData( 'monthSystemValues' ),
		displayValue = this.getData( 'shortHands' ),
		rowCount = 3, columnCount = 4,
		rowIterator = 0, columnIterator,
		result = [], indexOfMonth;

		for( ; rowIterator < rowCount; rowIterator++ ) {
			result.push( [] );

			for( columnIterator = 0; columnIterator < columnCount; columnIterator++ ) {
				indexOfMonth = ( rowIterator * columnCount ) + columnIterator;

				result[ rowIterator ].push( 
					{
						displayValue: _lyteUiUtils.i18n( displayValue[ indexOfMonth ] ),
						systemValue: systemValues[ indexOfMonth ],
						class: this.getProperClassForMonthView( indexOfMonth )
					} 
				);
			}
		}

		this.setData( 'monthViewData', result );
	},

	getProperClassForMonthView: function( month ) {
		var viewDate = this.getData( 'viewDate' ),
		viewYear = viewDate.getFullYear(),
		curMonth = this.getCurrentMonth(),
		currentYear = this.getCurrentYear(),
		ret = 'lyteCalTableCell';

		ret += currentYear === viewYear && month === curMonth ? ' lyteDrillCalCurrentMonth': '';

		return ret;
	},

	getCurrentYear: function() {
		var date = this.toDate();

		return date.getFullYear();
	},

	getCurrentMonth: function() {
		var date = this.toDate();

		return date.getMonth();
	},

	buildDecadeView: function() {
		this.buildDecadeViewHeader();
		this.buildDecadeViewContent();
	},

	buildDecadeViewHeader: function() {
		var viewDate = this.getData( 'viewDate' ),
		currentYear = viewDate.getFullYear(),
		numberOfYearsFromDecadeStart = currentYear % 10,
		decadeStart = currentYear - numberOfYearsFromDecadeStart,
		decadeEnd = decadeStart + 9;

		this.setData( 'decadeStart', decadeStart );
		this.setData( 'decadeEnd', decadeEnd );
	},


	buildDecadeViewContent: function() {
		var viewDate = this.getData( 'viewDate' ),
		currentYear = viewDate.getFullYear(),
		numberOfYearsFromDecadeStart = currentYear % 10,
		decadeStart = currentYear - numberOfYearsFromDecadeStart,
		yearBounds = this.buildMinAndMaxYear(),	
		isYYFormat = this.isYYFormat(),
		minYear = yearBounds.minYear, maxYear = yearBounds.maxYear,	
		rows = 3, columns = 4, i, j, result = [], year;

		for( i = 0; i < rows; i++ ) {
			result.push( [] );

			for( j = 0; j < columns; j++ ) {

				year = ( decadeStart + i * 4 + j ) - 1;

				if( isYYFormat ) {
					result[ i ].push( 
						( year > maxYear || year < minYear ) ? this.emptyCell() : this.currentYearCell( year, decadeStart )
					);
				}
				else {
					result[ i ].push( this.currentYearCell( year, decadeStart ) );
				}
				
			}
		}

		this.setData( 'decadeViewData', result );
	},

	emptyCell: function() {
		return {
			emptyBlock: true
		};
	},

	currentYearCell: function( year, decadeStart ) {
		var decadeEnd = decadeStart + 9,
		classVal = [], currentYear = this.getCurrentYear();

		if( year < decadeStart || year > decadeEnd ) {
			classVal.push( 'lyteCalOtherDecadeCell' );
		}

		if( currentYear === year ) {
			classVal.push( 'lyteDrillCalCurrentYear' );
		}


		return {
			year: year,
			emptyBlock: false,
			class: classVal.join( ' ' )
		}
	},

	buildNavigationalUI: function() {
		var type = this.getData( 'ltPropHeaderType' );

		if( this.isDropdownHeader() ) {
			this.buildYears();	
		}
	},

	initFn: function() {
		var self = this;

		this.addContainerClass();
		this.checkForMoment();		
		this.buildViewDate();
		this.changeDaysOfWeek();
		this.initializeCalendar();

		// set revert
		this.$node.revertToToday = function() {
			self.revert();
		};

		this.$node.revertToSelected = function() {
			self.revertToSelected();
		}

		// This is being internally used by CRM for their calendar
		this.$node.getDateArray = function( viewDate ) {
			self.setData( 'viewDate', viewDate );
			self.buildDateViewContent();

			return self.getData( 'matrix' );
		}

	}.observes( 'currentDatechanged' ).on( 'init' ),

	revertToSelected: function() {
		var from = new Date( this.getData( 'viewDate' ).getTime() ), 
		cur = this.getData( 'ltPropCurrentDate' ),
		format = this.getData( 'ltPropFormat' ),
		curDate = cur ? this.stringToDate( cur, format ) : this.toDate(),
		today = this.toDate(), event = {};

		if( curDate === 'Invalid Date' ) {
			return ;
		}
		
		curDate.setDate(1);

		var to = new Date( curDate.getTime() );

		this.setData( 'viewDate', curDate );
		this.setAndBuildView( 'dateView', event );

		if( to.getMonth() === today.getMonth() && to.getFullYear() === today.getFullYear() ) {
			this.setData( 'showToday', false );	
		}
		else {
			this.setData( 'showToday', true );
		}
		
		if( this.getMethods( 'onNavigate' ) 
			&& ( from.getMonth() !== to.getMonth() 
			|| from.getFullYear() !== to.getFullYear() ) 
		) {
			this.executeMethod( 'onNavigate', event, this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) ), this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) ) ,this );
		}
	},

	addContainerClass: function() {
		var type = this.getData( 'ltPropHeaderType' ),
		classVal = [ 'lyteCalendarPopup' ];

		if( type === 'drilldown' ) {
			classVal.push( 'lyteDrillDownCalendar' );
		}

		this.setData( 'containerClass', classVal.join( ' ' ) );
	},

	checkForMoment: function() {
		this.isMomentSupported = $L && $L.moment ? true : false; 
		this.isHavingTimezone = this.isMomentSupported && !!$L.moment()._timezone;
	},

	buildViewDate: function() {
		var viewDate = this.getData( 'ltPropCurrentDate' ) ? 
						this.stringToDate( this.getData( 'ltPropCurrentDate' ), this.getData( 'ltPropFormat' ) ) 
						: this.toDate();

		if( viewDate === 'Invalid Date' ) {
			viewDate = this.toDate();
		}

		viewDate.setDate( 1 );
		this.setData( 'viewDate', viewDate );
	},

	initializeCalendar: function() {
		this.buildNavigationalUI();
		this.setAndBuildView( 'dateView', undefined, true );
	},


	didConnect : function(){

		if( !this.getData('navYield') && this.isDropdownHeader() ) {
			this.setData( 'monthDD', this.getMonthDropdown() );
			this.setData( 'yearDD', this.getYearDropdown() );
			this.setData( 'callFrmDidcnct', true );
		}

	},


	isDropdownHeader: function() {
		var type = this.getData( 'ltPropHeaderType' );

		return type === 'picklist' || type === 'dropdown';
	},

	getYearDropdown: function() {
		var type = this.getData( 'ltPropHeaderType' ), 
		ret = this.$node.querySelector( '.lyteCalYearDD' );

		if( type === 'picklist' ) {
			ret = ret.querySelector( 'lyte-dropdown' ); 
		}

		return ret;
	},

	getMonthDropdown: function() {
		return this.$node.querySelector( '.lyteCalMonthDD' );
	},

	didDestroy: function() {
		delete this.$node.revertToToday;
	},

	removeClass: function() {
		var node = this.$node.querySelector( '.lyteCalSel' );

		if( node ) {
			node.classList.remove( 'lyteCalSel' );
		}
	},

	changeViewDate: function( val ) {
		var cur = this.getData( 'ltPropCurrentDate' ),
		type = this.getData( 'ltPropHeaderType' );

		if( this.getData( 'preventObs' ) ) {
			return ;
		}

		// Current Date is set to empty
		if( !cur ) {
			this.removeClass();
			return ;
		}

		// Bad current date
		if( this.stringToDate( cur, this.getData( 'ltPropFormat' ) ) === 'Invalid Date' ) {
			this.removeClass();
			return ;
		}

		var val = this.getData( 'ltPropCurrentDate' );
		var newDate = this.stringToDate( val, this.getData( 'ltPropFormat' ) );
		newDate.setDate( 1 );

		if( type === 'dropdown' && !this.isInRange( newDate ) ) {
			return ;
		}

		this.setData( 'viewDate', newDate );
		this.buildDateView();
	}.observes( 'ltPropCurrentDate' ),

	isInRange: function( date ) {
		var year = date.getFullYear();

		if( year >= 1900 && year <= 2100 ) {
			return true;
		}

		return false;
	},

	monthHeaderFormatObserver: function() {
		this.buildDateViewHeader();
	}.observes( 'ltPropMonthHeaderFormat' ),

	changeCurrentDate: function( set, val, event ) {
		var inter, to, from = new Date( this.getData( 'viewDate' ).getTime() ), 
		fromDate, toDate, formattedDate, format = this.getData( 'ltPropFormat' ),
		isYYFormat = this.isYYFormat();

		format = this.getRelevantFormat( format );

		if( set === 'Y' ) {
			inter = this.getData( 'viewDate' );
			formattedDate = this.getDateFromFormat( inter, format );

			if( this.isMomentSupported ) {
				if( val > 0 ) {
					to = this.moment( formattedDate, format ).add( val, 'fullYear', isYYFormat ).getDObj();
				}
				else {
					to = this.moment( formattedDate, format ).add( val, 'fullYear', isYYFormat ).getDObj();
				}
			}
			else {
				inter.setYear( inter.getFullYear() + val )
				to = new Date( inter.getTime() )
			}
			
			this.setData( 'viewDate', to );
			this.buildDateView();
		}
		else if( set === 'M' ) {
			inter = this.getData( 'viewDate' );
			formattedDate = this.getDateFromFormat( inter, format );

			if( this.isMomentSupported ) {
				if( val > 0 ) {
					to = this.moment( formattedDate, format ).add( val, 'month', isYYFormat ).getDObj();
				}
				else {
					to = this.moment( formattedDate, format ).add( val, 'month', isYYFormat ).getDObj();
				}
			}
			else {
				inter.setMonth( inter.getMonth() + val )
				to = new Date( inter.getTime() )
			}
			
			this.setData( 'viewDate', to )
			this.buildDateView();
		}

		fromDate = this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) );
		toDate = this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) );

		if( this.getMethods( 'onNavigate' ) ) {
			this.executeMethod( 'onNavigate', event, fromDate, toDate, this )
		}
	},

	changeCurrentYear: function( val, event ) {
		var viewDate = this.getData( 'viewDate' ),
		isMomentSupported = this.isMomentSupported,
		fullYear = viewDate.getFullYear(),
		format = this.getData( 'ltPropFormat' ),
		isYYFormat = this.isYYFormat(),
		formattedDate = this.getDateFromFormat( viewDate, format ),
		fromDate = formattedDate,
		toDate;

		if( isMomentSupported ) {
			format = this.getRelevantFormat( format );
			viewDate = this.moment( formattedDate, format ).add( val, 'fullYear', isYYFormat ).getDObj();
		}
		else {
			viewDate.setFullYear( fullYear + val );
		}

		toDate = this.getDateFromFormat( viewDate, format );
		this.setData( 'viewDate', viewDate );

		if( this.getMethods( 'onNavigate' ) ) {
			this.executeMethod( 'onNavigate', event, fromDate, toDate, this );
		}
	},

	changeCurrentDecade: function( val, event ) {
		var viewDate = this.getData( 'viewDate' ),
		format = this.getData( 'ltPropFormat' ),
		isMomentSupported = this.isMomentSupported,
		formattedDate = this.getDateFromFormat( viewDate, format ),
		isYYFormat = this.isYYFormat(),
		currentYear = viewDate.getFullYear(),
		fromDate = formattedDate,
		toDate;

		format = this.getRelevantFormat( format );

		if( isMomentSupported ) {
			viewDate = this.moment( formattedDate, format ).add( val * 10, 'fullYear', isYYFormat ).getDObj(); 
		}
		else {
			viewDate.setFullYear( currentYear + 10 * val );
		}

		toDate = this.getDateFromFormat( viewDate, format );
		this.setData( 'viewDate', viewDate );

		if( this.getMethods( 'onNavigate' ) ) {
			this.executeMethod( 'onNavigate', event, fromDate, toDate, this );
		}
	},

	/** 
	 * Get the proper calendar date item that was clicked
	 * @param {Element} elem - represents the element that was clickedd
	 *
	 */
	getProper: function( elem ) {
		while( elem 
			&& !elem.classList.contains( 'lyteCalTableCell' ) 
		) {
			elem = elem.parentElement;
		}

		return elem;
	},

	convertToLang: function( val ) {
		var i18n = this.getData( 'ltPropI18n' ),
		format = this.getData( 'ltPropFormat' );

		if( i18n ) {
			return this.moment( val, format ).i18N( format );
		}

		return val;
	},

	actions: {
		changeToMonthView: function( event ) {
			this.setAndBuildView( 'monthView', event );
			this.setData( 'showToday', false );
		},

		changeToDecadeView: function( event ) {
			this.setAndBuildView( 'decadeView', event );
			this.setData( 'showToday', false );
		},

		// Detecting a one finger swipe
		record: function( event ) {
			// This is stupid
			this.setData( 'prev', false );

			if( event.touches.length > 1 ) {
				this.setData( 'prev', true );

				return ;
			}

			var touch = event.targetTouches[ 0 ],
			cords = {
				x: touch.clientX,
				y: touch.clientY
			},
			start = new Date().getTime();

			this.setData( 'cords', cords );
			this.setData( 'start', start );
		},

		decide: function( event ) {
			var prev = this.getData( 'prev' );

			// prev will be false only when you do a single finger swipe
			// Multi finger swipes return out of execution
			if( prev ) {
				return ;
			}

			var start = this.getData( 'cords' ),
			x = start.x, y = start.y,
			touch = event.changedTouches[ 0 ],
			diffX = x - touch.clientX,
			diffY = y - touch.clientY,
			parent = this.$node.querySelector( '.lyteCalendarPopup' ),
			rect = parent.getBoundingClientRect(),
			width = rect.width,
			height = rect.height,
			xTolerance = width * 0.2,
			yTolerance = height * 0.15,
			begin = this.getData( 'start' ),
			delay = ( new Date().getTime() ) - begin;

			if( yTolerance > Math.abs( diffY ) 
				&& xTolerance < Math.abs( diffX ) 
				&& delay < 1000 
			) {
				if( diffX < 0 ) {
					this.changeCurrentDate( "M", -1, event );
				}
				else if( diffX > 0 ) {
					this.changeCurrentDate( "M", 1, event );
				}
			}
			
		},

		previous: function( val, event ) {
			var viewType = this.getData( 'viewType' );

			if( viewType === 'dateView' ) {
				this.changeCurrentDate( val, -1, event );
			}
			else if( viewType === 'monthView' ) {
				this.changeCurrentYear( -1, event );
				this.buildMonthView();
			}
			else if( viewType === 'decadeView' ) {
				this.changeCurrentDecade( -1, event );
				this.buildDecadeView();
			}
		},

		next: function( val, event ) {
			var viewType = this.getData( 'viewType' );

			if( viewType === 'dateView' ) {
				this.changeCurrentDate( val, 1, event );
			}
			else if( viewType === 'monthView' ) {
				this.changeCurrentYear( 1, event );
				this.buildMonthView();
			}
			else if( viewType === 'decadeView' ) {
				this.changeCurrentDecade( 1, event );
				this.buildDecadeView();
			}
			
		},

		yearSelected: function( event ) {
			var viewDate = this.getData( 'viewDate' ),
			target = this.getProper( event.target ),
			currentSelectedYear = target.getAttribute( 'data-date' );

			viewDate.setYear( currentSelectedYear );
			this.setData( 'viewDate', viewDate );
			this.setAndBuildView( 'monthView', event );
		},

		monthSelected: function( event ) {
			var viewDate = this.getData( 'viewDate' ),
			currentYear = viewDate.getFullYear(),
			target = this.getProper( event.target ),
			currentSelectedMonth = target.getAttribute( 'data-date' );

			currentSelectedMonth = this.getData( 'monthSystemValues' ).indexOf( currentSelectedMonth ) + 1;

			this.setData( 'viewDate', new Date( currentSelectedMonth + '/1/' + currentYear ) );
			this.setAndBuildView( 'dateView', event );
		},

		dateSelected: function( event ) {
			var target = this.getProper( event.target ), ele;
			if( event.button !== 0 ) {
				return ;
			}

			ele = this.$node.getElementsByClassName( 'lyteCalSel' );
			if( ele.length !== 0 ) {
				ele[0].classList.remove( 'lyteCalSel' );
			}

			this.setData( 'preventObs', true );
			this.setData( 'ltPropCurrentDate', this.convertToLang( target.getAttribute( 'data-date' ) ) );
			this.setData( 'preventObs', false );
			target.classList.add( 'lyteCalSel' );
			if( this.getMethods( 'onDateSelected' ) ) {
				this.executeMethod( 'onDateSelected', event, target.getAttribute( 'data-date' ), this );
			}
		},

		today: function( event ) {
			this.revert( event );
		}

	},

	methods : {
		optionSelected : function(prop,event,selected,comp){
			if(prop == 'M') {
				// var index = comp.getData('ltPropOptions').indexOf(selected);
				var index = this.getData('monthNames').indexOf(selected);

				this.changeCurrentDate(prop, index - this.getData('viewDate').getMonth(),event);
			}
			else if(prop == 'Y') {
				this.changeCurrentDate(prop, parseInt(selected) - this.getData('viewDate').getFullYear(),event);
			}
		},

		setClass: function( ev, comp ) {
			var drop = comp.childComp,
			rtl = _lyteUiUtils.getRTL(),
			dir = rtl ? 'right' : 'left',
			arrow = drop.querySelector( '.lyteArrow' );

			drop.classList.add( 'lyteCalendarDropdown' )
			arrow.style[ dir ] = '20%';

			if( rtl ) {
				arrow.style.left = 'auto';
			}
		}
	}
});

/**
 * @syntax nonYielded
 * <lyte-calendar></lyte-calendar>
 */

/**
 * @syntax yielded
 * <lyte-calendar>
 *     <template is="registerYield" yield-name="footer">
 *         <span>Footer Of The Calendar</span>
 *     </template>
 * </lyte-calendar>
 */

/**
 * Renders a carousel
 * @component lyte-carousel
 * @version  3.0.0
 * @methods onBeforeNext,onAfterNext
 */

Lyte.Component.register( 'lyte-carousel', {
_template:"<template tag-name=\"lyte-carousel\"> <div class=\"lyteCarouselWrapper\"> <lyte-yield yield-name=\"carouselBoxYield\"></lyte-yield> </div> </template>",
_dynamicNodes : [{"type":"insertYield","position":[1,1]}],
_observedAttributes :["ltPropAutoPlay","ltPropEffect","ltPropActiveIndex","ltPropMoreRecords","ltPropRecords","ltPropAutoPlayDuration","ltPropAutoPlayPause","ltPropData","currentActiveIndex"],
	data : function(){
		return {
			/** 
			 * @componentProperty {boolean} ltPropAutoPlay=false
			 * @version 3.0.0
			 */
			ltPropAutoPlay : Lyte.attr( 'boolean', {
			 'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlay', false )
			  }),
			/** 
			 * @componentProperty {slide | fade} ltPropEffect=slide
			 * @version 3.0.0
			 */
			ltPropEffect : Lyte.attr( 'string', { 
			 'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'effect', 'slide' ) 
			}),
			/** 
			 * @componentProperty {number} ltPropActiveIndex=0
			 * @version 3.0.0
			 */

			ltPropActiveIndex : Lyte.attr( 'number', {
			 'default' : 0
			}),
			/** 
			 * @componentProperty {boolean} ltPropMoreRecords=false
			 * @version 3.0.0
			 */
			ltPropMoreRecords : Lyte.attr( 'boolean', {
			 'default' : false
			}),
			/** 
			 * @componentProperty {number} ltPropRecords
			 * @version 3.0.0
			 */
			ltPropRecords : Lyte.attr( 'number', {
			 'default' : undefined
			}),
			/** 
			 * @componentProperty {number} ltPropAutoPlayDuration=3000
			 * @version 3.0.0
			 */
			ltPropAutoPlayDuration : Lyte.attr('number',{
			'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlayDuration', 3000 )
			}),
			/** 
			 * @componentProperty {boolean} ltPropAutoPlayPause=false
			 * @version 3.0.0
			 */
			ltPropAutoPlayPause : Lyte.attr( 'boolean', {
			 'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlayPause', false )
			}),
			/** 
			 * @componentProperty {array} ltPropData=[]
			 * @version 3.0.0
			 */
			ltPropData : Lyte.attr( 'array', {
			 'default' : []
			}),
			currentActiveIndex : Lyte.attr( 'number', {
			 'default' : 0
			})
		}		
	},
	didConnect : function() {
		var activeIndex = this.getData( 'ltPropActiveIndex' )
		if( activeIndex ) {
			this.setData( 'currentActiveIndex', activeIndex )
		}
		if( this.getData( 'ltPropRecords' ) >= 1 ) {
			this.setActiveItem()
		}
		if( this.getData( 'ltPropRecords' ) > 1 ) {
			this.setMethod();
		}
		this.$node.moveSlideByIndex = function(index){
			var activeIndex = this.getData( 'currentActiveIndex' ),
			itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ activeIndex +'"] ' );
			if( activeIndex >= 0 && activeIndex < itemList.length ){
				itemList[activeIndex].classList.remove('lyteActive')
				if(indicatorList) {
					indicatorList.classList.remove('lyteActive')
				}
			}
			clearTimeout( this._nextTimeout )
			clearTimeout( this._nextFadeTimeout )
			this.setData( 'currentActiveIndex', index )
			this.setActiveItem()
		}.bind( this ) 
		this.$node.reset = function(){
			setTimeout( function() {
				var activeIndex = this.getData( 'currentActiveIndex' ),
				itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),
			 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ activeIndex +'"] ' );
				if( activeIndex >= 0 && activeIndex < itemList.length ){
					itemList[activeIndex].classList.remove('lyteActive')
					if(indicatorList) {
						indicatorList.classList.remove('lyteActive')
					}
				}
				clearTimeout( this._nextTimeout )
				clearTimeout( this._nextFadeTimeout )
				this.setData( 'currentActiveIndex',this.getData( 'ltPropActiveIndex' ) )
				this.setActiveItem()
				this.setMethod();
			}.bind( this ) )
		}.bind( this ) 
		this.$node.getActiveSlideIndex =function(){
			return this.getData('currentActiveIndex')
		}
	},
	didDestroy : function() {
		clearInterval( this._autoId )
		delete this._autoId
	},
	setMethod : function() {
		var prev =this.$node.getElementsByTagName( 'lyte-carousel-prev' )[ 0 ],
			next = this.$node.getElementsByTagName( 'lyte-carousel-next' )[ 0 ],
			indicator = this.$node.getElementsByTagName( 'lyte-carousel-indicator' )[ 0 ];
			if( this.getData( 'ltPropEffect' ).toLowerCase() ==  "fade" ) {
				this.$node.classList.add( 'lyteFade' )
				if( prev ) {
					this._prevFadeClick = this.prevFadeClick.bind( this )
					prev.addEventListener( 'click', this._prevFadeClick )
				}
				if( next ) {
					this._nextFadeClick = this.nextFadeClick.bind( this )
					next.addEventListener( 'click', this._nextFadeClick )
				}
				if( indicator ) {
					this._indicatorFadeClick = this.indicatorFadeClick.bind( this )
					indicator.addEventListener( 'click', this._indicatorFadeClick )
				}
				this._zeroOpacityTransition = this.zeroOpacityTransition.bind( this )
			}
			else{
				this.$node.classList.add( 'lyteScroll' )
				if( prev ) {
					this._prevClick = this.prevClick.bind( this )
					prev.addEventListener( 'click', this._prevClick )
				}
				if( next ) {
					this._nextClick = this.nextClick.bind( this )
					next.addEventListener( 'click', this._nextClick )
				}
				if( indicator ) {
					this._indicatorClick = this.indicatorClick.bind( this );
					indicator.addEventListener( 'click', this._indicatorClick )
				}
				this._removePrevClass = this.removePrevClass.bind( this )
				this._removeNextClass = this.removeNextClass.bind( this )
			}
	},
	dataObs : function() {
		setTimeout( function() {
				clearTimeout( this._nextTimeout )
				clearTimeout( this._nextFadeTimeout )
				this.setData( 'currentActiveIndex',this.getData( 'ltPropActiveIndex' ) )
				this.setActiveItem()
				this.setMethod();
		}.bind( this ) )
	}.observes( 'ltPropData' ),
	currentActiveObs : function() {
		// this.checkButton();
		this.setActiveItem();
		
	    
	}.observes( 'currentActiveIndex' ),
	activeIndexObs : function() {
		// this.checkButton();
		var activeIndex = this.getData( 'currentActiveIndex' ),
			itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ activeIndex +'"] ' );
		if( activeIndex >= 0 && activeIndex < itemList.length ){
			itemList[activeIndex].classList.remove('lyteActive')
			if(indicatorList) {
				indicatorList.classList.remove('lyteActive')
			}
			this.setData( 'currentActiveIndex', this.getData( 'ltPropActiveIndex' ) )
		}
	    
	}.observes( 'ltPropActiveIndex' ),
	autoPlayPauseObs : function() {
		var carouselContent = this.$node.querySelector( '.lyteCarouselWrapper' );
		this._carouselContentFocus= this.carouselContentFocus.bind(this)
		if( this.getData( 'ltPropAutoPlayPause' ) && this.getData( 'ltPropAutoPlayDuration' ) ) {
			if( carouselContent ) {
				carouselContent.addEventListener( 'mouseenter', this._carouselContentFocus )
			}
		}
		else{
			if( carouselContent ) {
				carouselContent.removeEventListener( 'mouseenter', this._carouselContentFocus )
			}
		}
	}.observes( 'ltPropAutoPlayPause' ).on( 'didConnect' ),
	carouselContentFocus : function(  ){
		var carouselContent = this.$node.querySelector( '.lyteCarouselWrapper' );

		clearInterval( this._autoId );
		this._autoId = false
		this._carouselContentFocusOut = this.carouselContentFocusOut.bind( this, carouselContent )
		carouselContent.addEventListener( 'mouseleave',  this._carouselContentFocusOut)
	},
	carouselContentFocusOut : function(carouselContent  ) {

		carouselContent.removeEventListener( 'mouseleave', this._carouselContentFocusOut )
		if(this.getData('ltPropAutoPlay'))	{
			this.autoPlayFunc();
		}
			
	},
	autoPlayObs : function() {
		if( !this.getData( 'ltPropAutoPlay' ) && this._autoId ) {
			clearInterval( this._autoId );
			this._autoId = false
		}
		if(this.getData( 'ltPropAutoPlay' ) && this.getData( 'ltPropRecords' ) > 1 ) {
			this.autoPlayFunc();
		}
	}.observes( 'ltPropAutoPlay' ).on( 'didConnect' ),
	setActiveItem : function(){
		var activeIndex = this.getData( 'currentActiveIndex' ),
			itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ activeIndex +'"] ' );
			if( activeIndex >= 0 && activeIndex < itemList.length ){
				itemList[ activeIndex ].classList.add( 'lyteActive' );
				if( indicatorList ) {
					indicatorList.classList.add( 'lyteActive' ) ;
				}
	
			}
	},
	prevClick : function(event) {
		if( this._prevTrans ) {
			event.preventDefault();
			event.stopPropagation();
			return;
		}
		else{
			var records = this.getData( 'ltPropRecords' ),
		 	currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
			 indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="' +currentActive+ '"] ' );
			 res=true;
			if( this.getMethods( 'onBeforePrev' ) ){
				res = this.executeMethod( 'onBeforePrev' , event , this , currentActive ,records);
			}
			if(res){
				if( currentActive >= 1 ){
					this.previous( currentActive, currentActive-1, itemList, indicatorList, event )
				}
				else if(currentActive==0){
					this.previous( currentActive, records-1, itemList, indicatorList, event )
	
				}
			}
			
		}
	},
	nextClick : function( event ) {
		
		var records = this.getData( 'ltPropRecords' ),
		 	currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ currentActive +'"] ' ),
		 	res=true,that = this,index;
		if( this._nextTrans ) {
			event.preventDefault();
			event.stopPropagation();
				return;			
		}
		else{
			if( this._autoId ) {
				clearInterval( this._autoId )
				this._autoId = false;
			}
			if( this.getMethods( 'onBeforeNext' ) ){
						res = this.executeMethod( 'onBeforeNext' , event , this , currentActive ,records);
			}

			if(res && res.then ) {
				res.then( function( arg ) {
					if( currentActive >= 0 &&  currentActive < that.getData( 'ltPropRecords' ) ) {
						if( currentActive < that.getData( 'ltPropRecords' ) - 1 ) {
							that.next( currentActive, currentActive+1, itemList, indicatorList, event )

						}
						else if( currentActive == that.getData( 'ltPropRecords' ) - 1 ) {
							that.next( currentActive, 0, itemList, indicatorList, event )
						}
					}
					if( that.getData('ltPropAutoPlay')  ) {
							that.autoPlayFunc();
					}
					
				}).catch( function( err ) {
					console.error( err );
				} );
			}
			else if( res !== false ) {
				if( currentActive >= 0 && currentActive < records-1 ) {
					this.next( currentActive, currentActive+1, itemList, indicatorList, event )
							
				}
				else if( currentActive == records-1 ) {
					this.next( currentActive, 0, itemList, indicatorList, event )
				}
				if( this.getData( 'ltPropAutoPlay' )  ) {
					setTimeout( function() {
						this.autoPlayFunc();
					}.bind( this ), 100 )
				}
			}
		}
			
	},	
	next : function( currentActive, nextIndex, itemList, indicatorList, event ) {
		var res = true, records = this.getData('ltPropRecords')

		if(event && event.currentTarget && event.currentTarget.tagName == "LYTE-CAROUSEL-INDICATOR"){
			if( this.getMethods( 'onBeforeNext' ) ){
				res = this.executeMethod( 'onBeforeNext' , event , this , currentActive ,records);
			}
		}
		if(res){
			this._nextTrans = true
			var duration = parseFloat( getComputedStyle( itemList[ currentActive ] ).transitionDuration )
				duration = ( duration * 1000 ) +200
			setTimeout( function() {
					
					if( this._nextTrans ) {
						var itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),
						indicatorList = this.$node.getElementsByTagName( 'lyte-carousel-indicator-item' ),
						activeItemList = this.$node.querySelectorAll( 'lyte-carousel-item.lyteActive' )
						for( var i=0 ; i<itemList.length; ++i ) {
							if( $L(itemList[ i ] ).hasClass( 'lyteActivePrev' ) ) {
								itemList[ i ].classList.remove( 'lyteActivePrev' )
							}
						}
						if( activeItemList.length > 1 ) {
							for( var i=0 ; i < itemList.length; ++i ) {
								if( i != this.getData( 'ltPropActiveIndex' ) && $L( itemList[ i ] ).hasClass( 'lyteActive' ) ) {
									itemList[ i ].classList.remove( 'lyteActive' )
									indicatorList[ i ].classList.remove( 'lyteActive' )
	
								}
							}
						}
						delete this._nextTrans
					}
			}.bind( this ), duration )
	
			itemList[ nextIndex].classList.add( 'lyteActiveNext' ) 
			this._nextTimeout = setTimeout( function() {
				if( this._nextTrans ) {
					itemList[ currentActive ].addEventListener( 'transitionend', this._removePrevClass )
					itemList[ currentActive ].classList.add( 'lyteActivePrev' ) 
	
					itemList[ currentActive ].classList.remove( 'lyteActive' ) 
					if( indicatorList ) {
						indicatorList.classList.remove( 'lyteActive' ) 
					}
					itemList[ nextIndex].classList.remove( 'lyteActiveNext' ) 
					// this.setData( 'ltPropActiveIndex',	nextIndex ) ;
					this.setData( 'currentActiveIndex', nextIndex ) ;
					if( this.getMethods( 'onAfterNext' ) ){
						this.executeMethod( 'onAfterNext' , event , this , nextIndex ) ;
					}
				}
			}.bind( this ), 100 )
		}
		
	},
	previous : function( currentActive, prevIndex, itemList, indicatorList, event ) {
		var res = true, records = this.getData('ltPropRecords')
		if(event && event.currentTarget && event.currentTarget.tagName == "LYTE-CAROUSEL-INDICATOR"){
			if( this.getMethods( 'onBeforePrev' ) ){
				res = this.executeMethod( 'onBeforePrev' , event , this , currentActive ,records);
			}
		}
		if(res){

			this._prevTrans=true

			itemList[ prevIndex ].classList.add( 'lyteActivePrev' ) 
			setTimeout( function() {
				itemList[ currentActive ].addEventListener( 'transitionend', this._removeNextClass )
				itemList[ currentActive ].classList.add( 'lyteActiveNext' ) 
				itemList[ currentActive ].classList.remove( 'lyteActive' ) 
				itemList[ prevIndex ].classList.remove('lyteActivePrev') 

				if( indicatorList ) {
					indicatorList.classList.remove( 'lyteActive' ) 
				}
				// this.setData( 'ltPropActiveIndex', prevIndex )
				this.setData( 'currentActiveIndex', prevIndex )
				if( this.getMethods( 'onAfterPrev' ) ){
					this.executeMethod( 'onAfterPrev' , event , this , prevIndex ) 
				}
			}.bind( this ) )
		}
	},
	removePrevClass: function( event ) {
		
			// if(currentActive-1>=0){
				event.currentTarget.classList.remove( 'lyteActivePrev' ) 
				event.currentTarget.removeEventListener( 'transitionend', this._removePrevClass )

			// }

			delete this._nextTrans 
	},
	removeNextClass: function(event){
		

		event.currentTarget.classList.remove('lyteActiveNext') ;
		event.currentTarget.removeEventListener('transitionend',this.removeNextClass);
		
		delete this._prevTrans 
	},
	autoPlayFunc : function(){
		if(this._autoId){
			clearInterval(this._autoId)
			this._autoId = false
		}
		var duration = this.getData('ltPropAutoPlayDuration')
		if(duration && this.getData('ltPropRecords') > 1 ){
			this._autoId=setInterval(function(){
				var effect = this.getData('ltPropEffect') ?  this.getData('ltPropEffect') :'';
				if( effect.toLowerCase() == "fade" && !this._nextFadeTrans ){
					this.nextFadeClick();
				}
				else if( effect.toLowerCase() !== "fade" &&!this._nextTrans ){
					this.nextClick();
				}
			}.bind(this),duration);
		}
	},
	indicatorClick : function(event){

		var index, e = event.target,
		target= $L(e).closest('lyte-carousel-indicator-item')[ 0 ];

	
		if( target && target.tagName.toLowerCase() == 'lyte-carousel-indicator-item' ){
			index = target.getAttribute('data-value');
			var currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ currentActive +'"] ' ),
			res=true,that = this;

			if( index < currentActive ){
				this.previous( currentActive, index, itemList, indicatorList ,event );
			}
			else if(index > currentActive ){
				this.next( currentActive, index, itemList, indicatorList ,event );

			}
		}
	},
	prevFadeClick : function( event ) {
		if( this._prevFadeTrans ) {
			event.preventDefault()
			event.stopPropagation()
			return;
		}
		else{
			var records = this.getData( 'ltPropRecords' ),
		 	currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
			indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="' +currentActive+ '"] ' ),
			res=true;
			if( this.getMethods( 'onBeforePrev' ) ){
				res = this.executeMethod( 'onBeforePrev' , event , this , currentActive ,records );
			}
			if(res){
				if( currentActive >= 1 ){
					this.previousFade( currentActive, currentActive-1, itemList, indicatorList, event )
				}
				else if( currentActive==0 ) {
					this.previousFade( currentActive, records-1, itemList, indicatorList, event )
	
				}
			}
			
		}
	},
	previousFade : function( currentActive, prevIndex, itemList, indicatorList, event ) {
			this._prevFadeTrans=true

			setTimeout( function() {
				itemList[ prevIndex ].addEventListener( 'transitionend', this._zeroOpacityTransition )
				itemList[ currentActive ].classList.remove( 'lyteActive' ) ;
				itemList[ prevIndex ].classList.add('lyteActive') ;

				if( indicatorList ) {
					indicatorList.classList.remove( 'lyteActive' ) ;
				}
				this.setData( 'currentActiveIndex', prevIndex );
				if( this.getMethods( 'onAfterPrev' ) ){
					this.executeMethod( 'onAfterPrev' , event , this , prevIndex ) 
				}
			}.bind( this ) )
	},
	zeroOpacityTransition : function( event ){
		event.currentTarget.removeEventListener( 'transitionend', this._zeroOpacityTransition )
		
		delete this._prevFadeTrans ;
		delete this._nextFadeTrans ;
	},
	nextFadeClick : function( event ) {
		
		var records = this.getData( 'ltPropRecords' ),
		 	currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ currentActive +'"] ' ),
		 	res=true,that = this,index;
		if( this._nextTrans ) {
				event.preventDefault();
				event.stopPropagation();
				return;			
		}
		else{
			if( this._autoId ) {
				clearInterval( this._autoId )
				this._autoId = false;
			}
			if( this.getMethods( 'onBeforeNext' ) ){
						res = this.executeMethod( 'onBeforeNext' , event , this , currentActive ,records );
			}

			if( res && res.then ) {
				res.then(function( arg ) {
					if( currentActive >= 0 &&  currentActive < that.getData( 'ltPropRecords' ) ) {
						if( currentActive < that.getData( 'ltPropRecords' )-1 ) {
							that.nextFade( currentActive, currentActive+1, itemList, indicatorList, event )

						}
						else if( currentActive == that.getData( 'ltPropRecords' ) - 1 ) {
							that.nextFade( currentActive, 0, itemList, indicatorList, event )
						}
					}
					if( that.getData( 'ltPropAutoPlay' ) ) {
						// setTimeout(function(){
							that.autoPlayFunc();
						// }.bind(that),100)
					}
				} ).catch( function( err ) {
					console.error( err );
				} );
			}
			else if( res !== false ) {
				if( currentActive >= 0 && currentActive < records-1 ){
					this.nextFade( currentActive, currentActive+1, itemList, indicatorList, event )
							
				}
				else if( currentActive == records-1 ) {
					this.nextFade( currentActive, 0, itemList, indicatorList, event )
				}
				if( this.getData( 'ltPropAutoPlay' ) ) {
					setTimeout( function() {
						this.autoPlayFunc();
					}.bind( this ),100 )
				}
			}
		}
		
	},
	nextFade : function( currentActive, nextIndex, itemList, indicatorList, event ) {
		this._nextFadeTrans = true
		var duration = parseFloat( getComputedStyle( itemList[ currentActive ] ).transitionDuration )
			duration = ( duration * 1000 ) +20
			
		setTimeout( function() {
				if( this._nextFadeTrans ) {
					delete this._nextFadeTrans
				}
		}.bind( this ), duration )

		this._nextFadeTimeout = setTimeout( function() {
			itemList[ currentActive ].addEventListener( 'transitionend', this._zeroOpacityTransition)
			itemList[ currentActive ].classList.remove( 'lyteActive' ) ;
			if( indicatorList ) {
				indicatorList.classList.remove( 'lyteActive' ) ;
			}
			this.setData( 'currentActiveIndex', nextIndex ) ;
			if( this.getMethods( 'onAfterNext' ) ){
				this.executeMethod( 'onAfterNext' , event , this , nextIndex ) 
			}
		}.bind( this ), 100 )
	},
	indicatorFadeClick : function() {
		var index, e = event.target,
		target= $L( e ).closest( 'lyte-carousel-indicator-item' )[ 0 ];

	
		if( target && target.tagName.toLowerCase() == 'lyte-carousel-indicator-item' ) {
			index = target.getAttribute( 'data-value' );
			var currentActive = this.getData( 'currentActiveIndex' ),
		 	itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,
		 	indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value="'+ currentActive +'"] ' ),
			res=true,that = this;

			if( index < currentActive ){
				this.previousFade( currentActive, index, itemList, indicatorList ,event );
			}
			else if(index > currentActive ){
				this.nextFade( currentActive, index, itemList, indicatorList ,event );

			}
		}
	}
});

/**
 * Renders a checkbox
 * @component lyte-checkbox
 * @version 1.0.0
 * @utility focus,blur,click
 * @methods onBeforeChecked,onChecked,onChanged,onBeforeUnchecked,onUnchecked
 */

Lyte.Component.register( 'lyte-checkbox', {
_template:"<template tag-name=\"lyte-checkbox\" onkeydown=\"{{action('preventInputClick',event)}}\" onkeyup=\"{{action('preventInputClick',event)}}\"> <template is=\"switch\" value=\"{{ltPropType}}\"> <template case=\"default\"> <label class=\"lyteCheckbox lyteDefault\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\"> <input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" tabindex=\"{{ltPropTabindex}}\" disabled=\"{{ltPropDisabled}}\" class=\"\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\"> <span class=\"{{ltPropFinalClass}}\"> <span class=\"{{ltPropFinalLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </span> </label> </template> <template case=\"primary\"> <label class=\"lyteCheckbox lytePrimary\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\"> <input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" tabindex=\"{{ltPropTabindex}}\" disabled=\"{{ltPropDisabled}}\" class=\"\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\"> <span class=\"{{ltPropFinalClass}}\"> <span class=\"{{ltPropFinalLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </span> </label> </template> <template case=\"switch\"> <label class=\"\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\"> <input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" tabindex=\"{{ltPropTabindex}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide on-off-sw\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\"> <span class=\"{{ltPropFinalClass}}\"> <span class=\"on-btn\"></span> </span> <span class=\"{{ltPropFinalLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </label> </template> <template case=\"slider\"> <label class=\"lyteCheckSliderLabel\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\"> <input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" tabindex=\"{{ltPropTabindex}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\"> <span class=\"{{ltPropFinalClass}}\"> <span class=\"{{ltPropFinalLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </span> </label> </template> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"default":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"attr","position":[1,3,1,1]},{"type":"if","position":[1,3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]},"primary":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"attr","position":[1,3,1,1]},{"type":"if","position":[1,3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]},"switch":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"attr","position":[1,5,1]},{"type":"if","position":[1,5,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]},"slider":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"attr","position":[1,3,1,1]},{"type":"if","position":[1,3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]}},"default":{}}],
_templateAttributes :{"type":"attr","position":[]},
_observedAttributes :["ltPropType","ltPropId","ltPropDisabled","ltPropChecked","ltPropLabel","ltPropName","ltPropValue","ltPropReadonly","ltPropFireOnInit","ltPropClass","ltPropLabelClass","ltPropTabindex","lyteUnbound","ltPropYield","ltPropAriaCheckbox","ltPropFocus"],
	data: function() {
    	return {
    		/**
			 * @componentProperty {default | primary | secondary | switch | slider} ltPropType=default
			 */

			'ltPropType': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'type', 'default' )  
			} ),

			/**
			 * @componentProperty {string} ltPropId
			 */

			'ltPropId': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {boolean} ltPropDisabled=false
			 */

			'ltPropDisabled': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {boolean} ltPropChecked=false
			 */

			'ltPropChecked': Lyte.attr( 'boolean', { 
				'default': false 
			} ),

			/**
			 * @componentProperty {string} ltPropLabel
			 */

			'ltPropLabel': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {string} ltPropName
			 */

			'ltPropName': Lyte.attr( 'string', {
				'default': undefined
			} ),

			/**
			 * @componentProperty {string} ltPropValue
			 */

			'ltPropValue': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {boolean} ltPropReadOnly=false
			 */

			'ltPropReadonly': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {boolean} ltPropFireOnInit=false
			 */

			'ltPropFireOnInit': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'fireOnInit', false )
			} ),

			/**
			 * @componentProperty {string} ltPropClass
			 */

			'ltPropClass': Lyte.attr( 'string', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'class', '' )
			} ),

			/**
			 * @componentProperty {string} ltPropLabelClass
			 */

			'ltPropLabelClass': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'labelClass', '' )
			} ),

			/**
			 * @componentProperty {number} ltPropTabindex=0
			 */

			'ltPropTabindex': Lyte.attr( 'number', {
				'default': 0
			} ),
			'lyteUnbound': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {boolean} ltPropYield=false
			 * @version 2.2.8
			 */

			'ltPropYield': Lyte.attr( 'boolean', {
				'default': false
			} ),

			/**
			 * @componentProperty {object} ltPropAriaCheckbox={}
			 * @version 3.1.0
			 */


			'ltPropAriaCheckbox': Lyte.attr( 'object', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'ariaCheckbox', {} )
			} ),

			/**
			 * @componentProperty {boolean} ltPropFocus=false
			 * @version 3.2.0
			 */

			'ltPropFocus': Lyte.attr( 'boolean', {
				'default': false
			} )
		}
	},

	ariaObserver: function( change ) {
		var oldAria = change.oldValue,
		newAria = change.newValue;

		this.addAriaValues( oldAria, newAria );
	}.observes( 'ltPropAriaCheckbox' ),

	didDestroy: function() {
		delete this.$node.focus;
		delete this.$node.blur;
		delete this.$node.click;
	},

	reduceOpacity: function() {
		if( this.getData( 'ltPropDisabled' ) ) {
			this.$node.classList.add( 'lyteCheckDisabled' );
		}
		else {
			this.$node.classList.remove( 'lyteCheckDisabled' );
		}
	},

	disabledChange: function() {
		this.reduceOpacity();
	}.observes( 'ltPropDisabled' ),

	setDefaults: function() {
		var type = this.getData( 'ltPropType' ), 
		cls = this.getData( 'ltPropClass' ),
		label = this.getData( 'ltPropLabelClass' );

		if( type === 'switch' ) {
			this.setData( 'ltPropFinalClass', cls ? cls : 'lyteCheckSwitch' );
		}
		else if( type === 'default' ) {
			this.setData( 'ltPropFinalClass', cls ? cls : 'lyteCheckBoxDefault' );
		}
		else if( type === 'primary' ) {
			this.setData( 'ltPropFinalClass', cls ? cls : 'lyteCheckBoxPrimary' );
		}
		else if( type === 'slider' ) {
			this.setData( 'ltPropFinalClass', cls ? cls : 'lyteCheckSlider' );
		}

		if( type === 'slider' ) {
			this.setData( 'ltPropFinalLabelClass', label ? label : 'lyteCheckSliderText' );
		}
		else {
			this.setData( 'ltPropFinalLabelClass', label ? label : '' );
		}
	},

	typeObs: function() {
		this.setDefaults();
	}.observes( 'ltPropType', 'ltPropClass', 'ltPropLabelClass' ).on( 'init' ),

	didDestroy: function() {
		delete this.$node.focus;
		delete this.$node.blur;
		delete this.$node.click;
	},

	focusInput: function() {
		var input = this.$node.querySelector( 'input' ),
		doesNeedFocus = document.activeElement !== input;

		// Clicking on label doesn't focus checkbox in ff and safari
		if( doesNeedFocus ) {
			input.focus();
		}
	},

	didConnect: function() {
		var that = this, newAria = this.getData( 'ltPropAriaCheckbox' );

		this.reduceOpacity();
		
		this.$node.click = function() {
			var ev = new Event( 'click', {
				bubbles: true,
				cancelable: true
			} ),
			node = that.$node,
			checked = node.ltProp( 'checked' ),
			disabled = node.ltProp( 'disabled' ),
			readonly = node.ltProp( 'readonly' ),
			unbound = that.getData( 'lyteUnbound' ),
			item = that.$node.querySelector( 'input' );

			if( disabled || readonly ) {
				return ;
			}

			that.setData( 'eventCache', ev );
			// that.setData( 'preventRefire', true );

			that.clickFn = true;

			if( checked ) {
				node.ltProp( 'checked', false );
			}
			else {
				node.ltProp( 'checked', true );
			}

			// Unbound checkboxes don't check/uncheck visually on their own because we rely on lt-prop-checked to do it
			// TODO: The input will be checked in onBefore callbacks
			// TODO: This needs to be changed when LN provides the relevant APIs to check if it is unbound
			if( that.$node._fR ) {
				item.checked = node.ltProp( 'checked' );

				if( item.checked ) {
					item.setAttribute( 'checked', '' );
				}
				else {
					item.removeAttribute( 'checked' )
				}
				that.fireCallBacksFunction( {}, false );
			}

			that.clickFn = false;
			// that.setData( 'preventRefire', false );
			// that.fireCallBacksFunction( {}, false );
			node.dispatchEvent( ev );
		}

		this.$node.focus = function() {
			var node = that.$node,
			input = node.querySelector( 'input' ),
			disabled = node.ltProp( 'disabled' ),
			readonly = node.ltProp( 'readonly' );

			if( disabled || readonly ) {
				return ;
			}

			input.focus();
		}

		this.$node.blur = function() {
			var node = that.$node,
			input = node.querySelector( 'input' ),
			disabled = node.ltProp( 'disabled' ),
			readonly = node.ltProp( 'readonly' );

			if( disabled || readonly ) {
				return ;
			}

			input.blur();
		}

		this.fireCallBacksFunction.call( this, undefined, true );
		this.addAriaValues( {}, newAria );
	},

	addAriaValues: function( oldAria, newAria ) {
		var checkbox = this.getCheckboxWidget();

		_lyteUiUtils.setAttribute( checkbox, newAria, oldAria );
	},

	getCheckboxWidget: function() {
		return this.$node.querySelector( 'input' );
	},

	fireCallbacks:function( change, onrender ) {
		if( this.getData( 'preventRefire' ) ) {
			return ;
		}

		if( this.getData( 'preventObs' ) ) {
			return ;
		}

		if( this.getData( 'handleLbind' ) ) {

			this.setData( 'preventObs', true );
			this.setData( 'ltPropChecked', !this.getData( 'ltPropChecked' ) );
			this.setData( 'preventObs', false );

			this.setData( 'handleLbind', false );
			return ;
		}
		
		this.fireCallBacksFunction.call( this, change, onrender );
	}.observes( 'ltPropChecked' ),

	focusCheckbox: function() {
		var shouldFocus = this.getData( 'ltPropFocus' );

		if( shouldFocus ) {
			this.$node.focus();
		}

		this.data.ltPropFocus = false;
	}.observes( 'ltPropFocus' ).on( 'didConnect' ),

	fireCallBacksFunction: function( arg1, onrender ) {
		var checked = this.getData( 'ltPropChecked' ), 
		foi = this.getData( 'ltPropFireOnInit' ), returnval,
		eventCache = this.getData( 'eventCache' ), shouldBreak;

		// This property is very misleading don't use it for anything
		this.$node.checked = checked ? checked : false;

		if( checked && onrender ) {
			if( !foi ) {
				return ;
			}

			var input = this.$node.querySelector( 'input' );
			if( this.getMethods( 'onBeforeChecked' ) ) {
				this.executeMethod( 'onBeforeChecked', input, this, eventCache, 'script' );
			}

			if( this.getMethods( 'onChecked' ) ) {
				this.executeMethod( 'onChecked', input, this, eventCache, 'script' )
			}

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod('onChanged', input, this, eventCache, 'script' )
			}
		}
		else if( this.$node.checked && !onrender ) {
			var input = this.$node.querySelector( 'input' );

			if( !this.clicked ) {
				this.setData( 'preventRefire', true );

				if( this.getMethods( 'onBeforeChecked' ) ) {

					this.data.ltPropChecked = false;
					input.checked = false;

					// can return undefined or false
					shouldBreak = this.executeMethod( 'onBeforeChecked', input, this, eventCache, this.eventType() ) === false;

					if( shouldBreak ) {
						if( this.isCheckedLbound() ) {
							this.setData( 'handleLbind', true );
						}
						else {

							// I am doing this so that the framework will set the checked attribute
							this.data.ltPropChecked = true;
							this.setData( 'ltPropChecked', false );
						}

						this.setData( 'preventRefire', false );

						return ;
					}
					else {
						this.data.ltPropChecked = true;
						input.checked = true;
					}
				}
				
				this.setData( 'preventRefire', false );
			}

			if( this.getMethods( 'onChecked' ) ) {
				this.executeMethod( 'onChecked', input, this, eventCache, this.eventType() );
			}

			this.toggleClass( 'lyteCboxChecked' );

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod( 'onChanged', input, this, eventCache, this.eventType() );
			}
		}
		else if( !this.$node.checked && !onrender ) {
			var input = this.$node.querySelector( 'input' );

			if( !this.clicked ) {
				this.setData( 'preventRefire', true );
				// this.setData( 'ltPropChecked', true );

				if( this.getMethods( 'onBeforeUnchecked' ) ) {

					this.data.ltPropChecked = true;
					input.checked = true;

					shouldBreak = this.executeMethod( 'onBeforeUnchecked', input, this, eventCache, this.eventType() ) === false;

					if( shouldBreak ) {
						if( this.isCheckedLbound() ) {
							this.setData( 'handleLbind', true );
						}
						else {
							this.data.ltPropChecked = false;
							this.setData( 'ltPropChecked', true );
						}

						this.setData( 'preventRefire', false );

						return ;
					}
					else {
						this.data.ltPropChecked = false;
						input.checked = false;
					}
				}

				this.setData( 'preventRefire', false);
			}

			if( this.getMethods( 'onUnchecked' ) ) {
				this.executeMethod( 'onUnchecked', input, this, eventCache, this.eventType() );
			}

			this.toggleClass( 'lyteCboxUnchecked' );

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod( 'onChanged', input, this, eventCache, this.eventType() );
			}
		}

	},

	// class added only when it is checked/unchecked by user. Not added during initial render. Used to handle animations
	toggleClass: function( cls ) {
		var clsToRemove = cls === 'lyteCboxChecked' ? 'lyteCboxUnchecked' : 'lyteCboxChecked';

		this.$node.classList.remove( clsToRemove );
		this.$node.classList.add( cls );
	},

	eventType: function() {
		var isClicked = this.clicked || this.clickFn,
		key = this.eveType;

		if( !isClicked ) {
			return 'script';
		}

		return key ? key : 'click';
	},

	isCheckedLbound: function() {
		if( !this.$node._attributeDetails ) {
			return false;
		}

		return this.$node._attributeDetails[ 'lt-prop-checked' ] ? !!this.$node._attributeDetails[ 'lt-prop-checked' ].isLbind : false;
	},

	isNodeDestroyed: function() {
		return !this.$node;
	},

	fireClick: function( event ) {
		var input, hasClickHandlerFired = this.getData( 'sendEvent' ),
		disabled = this.getData( 'ltPropDisabled' ), clickEvent;

		this.isTimeoutInitiated = false;

		// sendEvent is going to tell us if the click handler was called or not
		if( !this.isNodeDestroyed() && !hasClickHandlerFired && !disabled ) {
			input = this.$node.querySelector( 'input' );
			input.checked = !input.checked;

			// This calls the click function
			clickEvent = new Event( 'click' );
			clickEvent.shiftKey = true;
			input.dispatchEvent( clickEvent );
		}
	},

	actions: {
		preventInputClick: function( event ) {
			if( event.keyCode === 32 ) {
				event.preventDefault();	
			}
		},

		mup: function( event ) {
			this.setData( 'prevented', false );
			this.setData( 'sendEvent', false );

			var disabled = this.getData( 'ltPropDisabled' ), checked, returnval;

			if( disabled ) {
				return ;
			}

			var ele =  this.$node.querySelector( 'input' )
			checked = ele.checked
			if( this.getMethods( 'onBeforeChecked' ) && !checked ) {
				returnval = this.executeMethod( 'onBeforeChecked', ele, this, event, 'click' ) == false ? false : true;
				if( !returnval ) {
					this.setData( 'prevented', true );
					event.preventDefault();
				}
			}

			else if( this.getMethods( 'onBeforeUnchecked' ) && checked ) {
				returnval = this.executeMethod( 'onBeforeUnchecked', ele, this, event, 'click' ) == false ? false : true;
				if( !returnval ) {
					this.setData( 'prevented', true )
					event.preventDefault();
				}
			}
		},

		prevent: function( event ) {
			var se = this.getData( 'sendEvent' ),
			isFireFox = !!~window.navigator.userAgent.indexOf( 'Firefox' ),
			isTimeoutInitiated = this.isTimeoutInitiated;

			// Two events originate - one from the user click and another from the browser click
			// We only allow the user click event to bubble up not the browser click

			// In the newer versions of the framework 3 events are originating.?
			if( !se ) {
				event.stopPropagation();
			}

			// Insanely hacky solution to fix firefox bug
			// https://bugzilla.mozilla.org/show_bug.cgi?id=559506
			if( isFireFox && !isTimeoutInitiated ) {
				this.isTimeoutInitiated = true;
				setTimeout( this.fireClick.bind( this, event ), 0 );	
			}
			
		}, 

		checkBoxClicked: function( event ) {

			this.setData( 'sendEvent', true );
			this.setData( 'eventCache', event );
			this.clicked = true
			var input;

			this.focusInput();

			if( this.getData( 'prevented' ) ) {
				input = this.$node.querySelector( 'input' );
				this.setData( 'prevented', false )
				this.setData( 'preventRefire', true )
				if( input.checked ) {
					input.checked = false
				}
				else {
					input.checked = true
				}

				this.setData( 'preventRefire', false )
				this.clicked = false
				this.setData( 'eventCache', {} );
				return;
			}

			if( this.getData( 'ltPropDisabled' ) ) {
				this.clicked = false
				event.preventDefault()
				this.setData( 'eventCache', {} );
				return ;
			}

			var checked
			var ele = event.target
			checked = ele.checked;

			// this.setData( 'preventRefire', true );

			if( !checked ) {
				this.setData( 'ltPropChecked', false );
			}
			else{
				this.setData( 'ltPropChecked', true );
			}

			// this.setData( 'preventRefire', false );
			// TODO: change this when LN gives his API
			if( this.$node._fR ) {
				if( this.getData( 'ltPropChecked' ) ) {
					this.$node.querySelector( 'input' ).setAttribute( 'checked', '' );
				}
				else {
					this.$node.querySelector( 'input' ).removeAttribute( 'checked' );
				}
				this.fireCallBacksFunction( {}, false );
			}
			// this.fireCallBacksFunction( {}, false );
			this.setData( 'eventCache', {} );
			this.clicked = false
		}
	}
} );

document.addEventListener( 'keyup', function( event ) {
	var keyCode = event.keyCode, node, checked, comp;

	if( keyCode === 32 ) {

		node = document.activeElement;

		if( node.tagName !== 'INPUT' ) {
			return ;
		}

		while( node.tagName !== 'LYTE-CHECKBOX' 
			&& node.tagName !== 'HTML' 
		) {
			node = node.parentElement;
		}

		if( node.tagName === 'LYTE-CHECKBOX' ) {
			// We are calling the checkbox's click because we want all the callbacks to be properly fired.
			// We'll be preventing the default behaviour of the browser in the keyup and keypress events
			node.component.eveType = 'key';
			node.click();
			node.component.eveType = '';
		}
	}
}, true );

/**
 * @syntax nonYielded
 * <lyte-checkbox lt-prop-value="1" lt-prop-label="check me"></lyte-checkbox>
 */

 /**
  * @syntax yielded
  * <lyte-checkbox lt-prop-value="1" lt-prop-yield="true">
  *     <template is="registerYield" yield-name="yield">
  *         check me
  *     </template>
  * </lyte-checkbox>
  */


Lyte.Component.register( 'lyte-checkbox-group', {
_template:"<template tag-name=\"lyte-checkbox-group\"> <div class=\"{{alignmentClass}}\"> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"index\"> <lyte-checkbox lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-label=\"{{item[ltPropUserValue]}}\" lt-prop-value=\"{{item[ltPropSystemValue]}}\" lt-prop-fire-on-init=\"{{ltPropFireOnInit}}\" lt-prop-label-class=\"{{ltPropLabelClass}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-prevent-callback-observers=\"true\" lt-prop-checked=\"{{unbound(lyteUiIsInArray(item,ltPropSelected,ltPropSystemValue))}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-disabled=\"{{lyteUiIsInArray(item,ltPropDisabledList,ltPropSystemValue)}}\" on-checked=\"{{method('fireCallback','onChecked',item)}}\" ,=\"\" on-unchecked=\"{{method('fireCallback','onUnchecked',item)}}\" on-before-checked=\"{{method('fireCallback','onBeforeChecked',item)}}\" on-before-unchecked=\"{{method('fireCallback','onBeforeUnchecked',item)}}\" on-changed=\"{{method('fireCallback','onChanged',item)}}\" data-value=\"{{item[ltPropSystemValue]}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-yield yield-name=\"yield\" lt-item=\"{{item}}\"></lyte-yield> </template> </template></template> </lyte-checkbox> </template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}],
_observedAttributes :["ltPropType","ltPropName","ltPropUserValue","ltPropSystemValue","ltPropFireOnInit","ltPropClass","ltPropOptions","ltPropSelected","ltPropAlignment","ltPropFocus","ltPropDisabledList","ltPropYield"],
	data: function() {
		return {

			/**
			 * @prop {string} ltPropType
			 * @default default
			 * @options default,primary,switch,slider
			 */

			'ltPropType': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox-group', 'type', 'default' )
			} ),

			/**
			 * @prop {string} ltPropName
			 */

			'ltPropName': Lyte.attr( 'string', { 
				'default': undefined 
			} ),

			/**
			 * @prop {string} ltPropUserValue
			 * @default name
			 */

			'ltPropUserValue': Lyte.attr( 'string', { 
				'default': 'name' 
			} ),

			/**
			 * @prop {string} ltPropSystemValue
			 * @default value
			 */

			'ltPropSystemValue': Lyte.attr( 'string', { 
				'default': 'value' 
			} ),

			/**
			 * @prop {boolean} ltPropFireOnInit
			 * @default false
			 */

			'ltPropFireOnInit': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox-group', 'fireOnInit', false ) 
			} ),

			/**
			 * @prop {string} ltPropClass
			 */

			'ltPropClass': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox-group', 'class', '' ) 
			} ),

			/**
			 * @prop {array} ltPropOptions
			 * @default []
			 */

			'ltPropOptions': Lyte.attr( 'array', { 'default': [] } ),

			/**
			 * @prop {array} ltPropSelected
			 * @default []
			 */

			'ltPropSelected': Lyte.attr( 'array', { 
				'default': [] 
			} ),

			/**
			 * @prop {string} ltPropAlignment
			 * @default horizontal
			 * @options horizontal,vertical
			 */

			'ltPropAlignment': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-checkbox-group', 'alignment', 'horizontal' )  
			} ),

			/**
			 * @prop {boolean} ltPropFocus
			 * @default false
			 */

			'ltPropFocus': Lyte.attr( 'boolean', { 
				'default': false 
			} ),

			/**
			 * @prop {array} ltPropDisabledList
			 * @default []
			 */

			'ltPropDisabledList': Lyte.attr( 'array', { 
				'default': [] 
			} ),

			/**
			 * @prop {boolean} ltPropYield
			 * @default false
			 */

			'ltPropYield': Lyte.attr( 'boolean', { 
				'default': false 
			} )
		}
	},

	init: function() {
		var alignment = this.getData( 'ltPropAlignment' );

		this.setData( 'alignmentClass', 'lyteCBoxGroup' + alignment[ 0 ].toUpperCase() + alignment.substring( 1 ) );
	},

	methods: {
		fireCallback: function( callbackName, item ) {

			if( callbackName === 'onChecked' ) {
				this.add( item );
			}
			else if( callbackName === 'onUnchecked' ) {
				this.remove( item );
			}

			if( this.getMethods( callbackName ) ) {
				return this.executeMethod.apply( this, this.constructArgs(callbackName, item, arguments ) );
			}
		}
	},

	add: function( item ) {
		this.preventObserver = true;
		Lyte.arrayUtils( this.getData( 'ltPropSelected' ), 'push', item );
		this.preventObserver = false;
	},

	remove: function( item ) {
		this.preventObserver = true;

		var sel = this.getData( 'ltPropSelected' ) || [],
		ind = sel.indexOf( item );

		if( ind !== -1 ) {
			Lyte.arrayUtils( sel, 'removeAt', ind, 1 );
		}

		this.preventObserver = false;
	},

	selectedObserver: function( changeObj ) {

		if( this.preventObserver ) {
			return ;
		}

		var oldValue = changeObj.oldValue,
		newValue = changeObj.newValue,
		addedValues = this.getAddedValues( oldValue, newValue ),
		removedValues = this.getRemovedValues( oldValue, newValue ),
		that = this;

		addedValues.forEach( function( cbox ) {
			that.check( cbox );
		} );

		removedValues.forEach( function( cbox ) {
			that.uncheck( cbox );
		} );


	}.observes( 'ltPropSelected.[]' ),

	getAddedValues: function( oldValue, newValue ) {
		return this.setSubtract( newValue, oldValue );
	},

	getRemovedValues: function( oldValue, newValue ) {
		return this.setSubtract( oldValue, newValue );
	},

	setSubtract: function( arrA, arrB ) {
		var sysValue = this.getData( 'ltPropSystemValue' );

		arrA = arrA || [];
		arrB = arrB || [];

		return arrA.filter( function( obj ) {
			for( var i = 0; i < arrB.length; i++ ) {
				if( obj[ sysValue ] === arrB[ i ][ sysValue ] ) {
					return false;
				}
			}

			return true;
		} );
	},

	constructArgs: function( methodName, item, args ) {
		var arr = [].slice.call( args );

		arr.shift();
		arr.shift();
		arr.unshift( methodName );
		arr.pop();
		arr.push(item);

		return arr; 
	},

	check: function( item ) {
		this.changeToState( item, true );
	},

	uncheck: function( item ) {
		this.changeToState( item, false );
	},

	changeToState: function( item, newState ) {
		var sysValue = this.getData( 'ltPropSystemValue' ),
		dataValue = item[ sysValue ];

		this.$node.querySelector( '[data-value="' + dataValue + '"]' ).ltProp( 'checked', newState );
	},

	focusObserver: function() {
		var focus = this.getData( 'ltPropFocus' );

		if( focus ) {
			this.focusCBox();
		}
	}.observes( 'ltPropFocus' ).on( 'didConnect' ),

	focusCBox: function() {
		var cbox;

		this.setData( 'ltPropFocus', false );
		cbox = this.getFirstEnabledCheckbox();

		if( cbox ) {
			cbox.ltProp( 'focus', true );
		}
	},

	getFirstEnabledCheckbox: function() {
		var cboxes = this.$node.querySelectorAll( 'lyte-checkbox' );

		for( var i = 0; i < cboxes.length; i++ ) {
			if( !cboxes[ i ].ltProp( 'disabled' ) ) {
				return cboxes[ i ];
			}
		}
	}
} );
/**
 * Renders a clock
 * @component lyte-clock
 * @version 3.5.0
 * @utility startTimer
 * @methods onTimerStart, onTimerEnd, onTimeReached
 */

Lyte.Component.register("lyte-clock", {
_template:"<template tag-name=\"lyte-clock\"> <template is=\"if\" value=\"{{expHandlers(ltPropType,'===','digital')}}\"><template case=\"true\"> <div class=\"lyteClkDigitalWrapper\"> <template is=\"if\" value=\"{{expHandlers(ltPropAppearance,'==','default')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','watch')}}\"><template case=\"true\"> <div class=\"lyteClkDef lyteClkWatch lyteClkWatchDef\"> <span class=\"lyteClkWatchHrVal\">{{lyteUiClockPairNumber(ltPropHours)}}</span> <span class=\"lyteClkWatchColon\">:</span> <span class=\"lyteClkWatchMinVal\">{{lyteUiClockPairNumber(ltPropMinutes)}}</span> <span class=\"lyteClkWatchColon\">:</span> <span class=\"lyteClkWatchSecVal\">{{lyteUiClockPairNumber(ltPropSeconds)}}</span> <span class=\"lyteClkWatchAMPM lyteClkWatchDefAMPM\">{{ltPropTimeMeridiem}}</span> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','forwardtimer')}}\"><template case=\"true\"> <div class=\"lyteClkDef lyteClkWatch lyteClkWatchDef\"> <template is=\"if\" value=\"{{ltPropShowHours}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkWatchHrVal\">{{lyteUiClockPairNumber(ltPropHours)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.hour}}</span> </div></template></template> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><span class=\"lyteClkTimerColon\">:</span></template></template> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkWatchMinVal\">{{lyteUiClockPairNumber(ltPropMinutes)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.minute}}</span> </div></template></template> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><span class=\"lyteClkTimerColon\">:</span></template></template> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkWatchSecVal\">{{lyteUiClockPairNumber(ltPropSeconds)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.second}}</span> </div></template></template> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','timer')}}\"><template case=\"true\"> <div class=\"lyteClkDef lyteClkTimer lyteClkTimerDef\"> <template is=\"if\" value=\"{{ltPropShowYears}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerYears)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.year}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowMonths}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerMonths)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.month}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowDays}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerDays)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.day}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowHours}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerHours)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.hour}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerMinutes)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.minute}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerDefBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerSeconds)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerDefLabel\">{{ltPropUnitLabel.second}}</span> </div></template></template> </div> </template></template></template></template></template></template> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropAppearance,'==','frame')}}\"><template case=\"true\"> <div class=\"lyteClkFrameOuter\"> <div class=\"lyteClkFrameInner\"> <template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','watch')}}\"><template case=\"true\"> <div class=\"lyteClkFrame lyteClkWatch lyteClkWatchFrame\"> <span class=\"lyteClkWatchHrVal\">{{lyteUiClockPairNumber(ltPropHours)}}</span> <span class=\"lyteClkWatchColon\">:</span> <span class=\"lyteClkWatchMinVal\">{{lyteUiClockPairNumber(ltPropMinutes)}}</span> <span class=\"lyteClkWatchColon\">:</span> <span class=\"lyteClkWatchSecVal\">{{lyteUiClockPairNumber(ltPropSeconds)}}</span> <span class=\"lyteClkWatchAMPM lyteClkWatchFrameAMPM\">{{ltPropTimeMeridiem}}</span> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','forwardtimer')}}\"><template case=\"true\"> <div class=\"lyteClkFrame lyteClkWatch lyteClkWatchFrame\"> <template is=\"if\" value=\"{{ltPropShowHours}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkWatchHrVal\">{{lyteUiClockPairNumber(ltPropHours)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.hour}}</span> </div></template></template> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><span class=\"lyteClkTimerColon\">:</span></template></template> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkWatchMinVal\">{{lyteUiClockPairNumber(ltPropMinutes)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.minute}}</span> </div></template></template> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><span class=\"lyteClkTimerColon\">:</span></template></template> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkWatchSecVal\">{{lyteUiClockPairNumber(ltPropSeconds)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.second}}</span> </div></template></template> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','timer')}}\"><template case=\"true\"> <div class=\"lyteClkFrame lyteClkTimer lyteClkTimerFrame\"> <template is=\"if\" value=\"{{ltPropShowYears}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerYears)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.year}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowMonths}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerMonths)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.month}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowDays}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerDays)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.day}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowHours}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerHours)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.hour}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowMinutes}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerMinutes)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.minute}}</span> </div></template></template> <span class=\"lyteClkTimerColon\">:</span> <template is=\"if\" value=\"{{ltPropShowSeconds}}\"><template case=\"true\"><div class=\"lyteClkTimerBox lyteClkTimerFrameBox\"> <span class=\"lyteClkTimerValue\">{{lyteUiClockPairNumber(ltPropTimerSeconds)}}</span> <span class=\"lyteClkTimerLabel lyteClkTimerFrameLabel\">{{ltPropUnitLabel.second}}</span> </div></template></template> </div>   </template></template></template></template></template></template> </div></div></template></template></template></template> <template is=\"if\" value=\"{{expHandlers(ltPropMode,'===','stopWatch')}}\"><template case=\"true\"> <div class=\"lyteClockStopWatch\"> <div class=\"lyteClkFrameOuter\"> <div class=\"lyteClkFrameInner\"> <div class=\"lyteClockSwWrap\"> <template is=\"if\" value=\"{{ltPropShowSWHours}}\"><template case=\"true\"><span>{{lyteUiClockPairNumber(ltPropStopHours)}}</span></template></template> <template is=\"if\" value=\"{{ltPropShowSWHours}}\"><template case=\"true\"><span>:</span></template></template> <span>{{lyteUiClockPairNumber(ltPropStopMinutes)}}</span> <span>:</span> <span>{{lyteUiClockPairNumber(ltPropStopSeconds)}}</span> <template is=\"if\" value=\"{{ltPropShowSWMilliSeconds}}\"><template case=\"true\"><span>.</span></template></template> <template is=\"if\" value=\"{{ltPropShowSWMilliSeconds}}\"><template case=\"true\"><span>{{lyteUiClockPairNumber(ltPropStopMilliSeconds)}}</span></template></template> </div> </div> </div> <div class=\"lyteClockSwActionBtnWrap\"> <template is=\"if\" value=\"{{ltPropShowStopStart}}\"><template case=\"true\"><div class=\"lyteClockSwActionBtn lyteClockSWStart \">Start</div></template></template> <template is=\"if\" value=\"{{ltPropShowStopPause}}\"><template case=\"true\"><div class=\"lyteClockSwActionBtn lyteClockSWPause\">Pause</div></template></template> <template is=\"if\" value=\"{{ltPropShowStopLap}}\"><template case=\"true\"><div class=\"lyteClockSwActionBtn lyteClockSWLap\">Lap</div></template></template> <template is=\"if\" value=\"{{ltPropShowStopReset}}\"><template case=\"true\"><div class=\"lyteClockSwActionBtn lyteClockSWReset\">Reset</div></template></template> </div> <div class=\"lyteClockSwLapWrapper\"> <template is=\"for\" items=\"{{ltPropLapTime}}\" item=\"item\" index=\"index\"> <div class=\"lyteClockSwLap\"> <span class=\"lyteClockSwLapLabel\">Lap {{index}}</span> <div class=\"lyteClockSwLapTime\"> <span>{{lyteUiClockPairNumber(item.lapHours)}}</span> : <span>{{lyteUiClockPairNumber(item.lapMinutes)}}</span> : <span>{{lyteUiClockPairNumber(item.lapSeconds)}}</span> . <span>{{lyteUiClockPairNumber(item.lapMilliSecs)}}</span> </div> </div> </template> </div> </div> </template></template> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropType,'===','analog')}}\"><template case=\"true\"> <div class=\"lyteClkFrameOuter\"> <div class=\"lyteClkFrameInner\"> <div class=\"lyteClkAlogCont\"> <div class=\"lyteClkAlogTik lyteClkTik126\"></div> <div class=\"lyteClkAlogTik lyteClkTik17\"></div> <div class=\"lyteClkAlogTik lyteClkTik28\"></div> <div class=\"lyteClkAlogTik lyteClkTik39\"></div> <div class=\"lyteClkAlogTik lyteClkTik410\"></div> <div class=\"lyteClkAlogTik lyteClkTik511\"></div> <div class=\"lyteClockMidCircle\"></div> <div class=\"lyteClkAlogDial lyteClockHrDial\"> <div class=\"lyteClkHrDialElem\"></div> </div> <div class=\"lyteClkAlogDial lyteClockMinDial\"> <div class=\"lyteClkMinDialElem\"></div> </div> <div class=\"lyteClkAlogDial lyteClockSecDial\"> <div class=\"lyteClkSecDialElem\"></div> </div> <template is=\"if\" value=\"{{ltPropShowDate}}\"><template case=\"true\"> <div class=\"lyteClockDate\"> <div class=\"\">{{ltPropDate}}</div> </div> </template></template> </div> </div> </div> </template></template></template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"text","position":[1,5,0]},{"type":"text","position":[1,9,0]},{"type":"text","position":[1,11,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,13]},{"type":"if","position":[1,13],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,17]},{"type":"if","position":[1,17],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,21]},{"type":"if","position":[1,21],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"text","position":[1,5,0]},{"type":"text","position":[1,9,0]},{"type":"text","position":[1,11,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,13]},{"type":"if","position":[1,13],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,17]},{"type":"if","position":[1,17],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}},{"type":"attr","position":[1,21]},{"type":"if","position":[1,21],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,1,0]},{"type":"text","position":[0,3,0]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1,1,1]},{"type":"if","position":[1,1,1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,0]}]}},"default":{}},{"type":"attr","position":[1,1,1,1,3]},{"type":"if","position":[1,1,1,1,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"text","position":[1,1,1,1,5,0]},{"type":"text","position":[1,1,1,1,9,0]},{"type":"attr","position":[1,1,1,1,11]},{"type":"if","position":[1,1,1,1,11],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,1,1,1,13]},{"type":"if","position":[1,1,1,1,13],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,0]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3,3]},{"type":"if","position":[1,3,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3,5]},{"type":"if","position":[1,3,5],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3,7]},{"type":"if","position":[1,3,7],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,5,1]},{"type":"for","position":[1,5,1],"dynamicNodes":[{"type":"text","position":[1,1,1]},{"type":"text","position":[1,3,1,0]},{"type":"text","position":[1,3,3,0]},{"type":"text","position":[1,3,5,0]},{"type":"text","position":[1,3,7,0]}]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1,21]},{"type":"if","position":[1,1,1,21],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]}]}},"default":{}}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropAppearance","ltPropFormat","ltPropType","ltPropMode","ltPropDuration","ltPropEndDate","ltPropStartTime","ltPropEndTime","ltPropAlarm","ltPropUnitLabel","ltPropUnits","ltPropHours","ltPropMinutes","ltPropSeconds","ltPropTimeMeridiem","ltPropStopHours","ltPropStopMinutes","ltPropStopSeconds","ltPropStopMilliSeconds","ltPropShowStopStart","ltPropShowStopPause","ltPropShowStopReset","ltPropShowStopLap","ltPropShowSWHours","ltPropShowSWMilliSeconds","ltPropShowDate","ltPropPause","stopWatchRunning","ltPropDate","ltPropLapTime","ltPropTimerHours","ltPropTimerMinutes","ltPropTimerSeconds","ltPropTimerDays","ltPropTimerMonths","ltPropTimerYears","ltPropShowYears","ltPropShowMonths","ltPropShowDays","ltPropShowHours","ltPropShowMinutes","ltPropShowSeconds","ltPropCurrentDate","ltPropGivenDate","timerPaused","userDefinedUnits"],
	data : function(){
		return {

			/**
			 * @prop {string} ltPropAppearance
			 * @default default
			 * @options default,frame
			 */

			ltPropAppearance: Lyte.attr('string' , {default : 'default'}),

			/**
			 * @prop {string} ltPropFormat
			 * @default 12
			 * @options 12,24
			 */

			ltPropFormat : Lyte.attr('string' , {default : '12'}),

			/**
			 * @prop {string} ltPropType
			 * @default digital
			 * @options digital,analog
			 */

			ltPropType : Lyte.attr('string' , {default : 'digital'}),

			/**
			 * @prop {string} ltPropMode
			 * @default watch
			 * @options watch, timer, stopWatch, forwardtimer
			 */

			ltPropMode : Lyte.attr('string' , {default : 'watch'}),

			/**
			 * @prop {string} ltPropDuration
			 * @default 00:00:00
			 */

			ltPropDuration :Lyte.attr('string',{default : '00:00:00'}),

			/**
			 * @prop {string} ltPropEndDate
			 * @default 00/00/0000
			 */

			ltPropEndDate :Lyte.attr('string',{default : '00/00/0000'}),

			/**
			 * @prop {string} ltPropStartTime
			 * @default 00:00:00
			 */

			ltPropStartTime : Lyte.attr('string',{default : '00:00:00'}),

			/**
			 * @prop {string} ltPropEndTime
			 * @default 00:00:00
			 */

			ltPropEndTime : Lyte.attr('string',{default : '00:00:00'}),

			/**
			 * @prop {string} ltPropAlarm
			 * @default 00:00:00
			 */

			ltPropAlarm : Lyte.attr('string' , {default : '00:00:00'}),

			/**
			 * @prop {object} ltPropUnitLabel
			 */

			ltPropUnitLabel : Lyte.attr('object' , {
				default : {
					year  : 'Yrs',
					month : 'Mths',
					day   : 'Days',
					hour	: 'Hrs',
					minute : 'Mins',
					second : 'Secs'
				}
			}),

			/**
			 * @prop {object} ltPropUnits
			 */

			 ltPropUnits : Lyte.attr('array' , {
				 default : []
			 }),


			ltPropHours : Lyte.attr('string' , {default : '00'}),
			ltPropMinutes : Lyte.attr('string' , {default : '00'}),
			ltPropSeconds : Lyte.attr('string' , {default : '00'}),
			ltPropTimeMeridiem : Lyte.attr('string' , {default : ''}),
			ltPropStopHours : Lyte.attr('string' , {default : '00'}),
			ltPropStopMinutes : Lyte.attr('string' , {default : '00'}),
			ltPropStopSeconds : Lyte.attr('string' , {default : '00'}),
			ltPropStopMilliSeconds : Lyte.attr('string' , {default : '00'}),

			ltPropShowStopStart : Lyte.attr('boolean' , {default:true}),
			ltPropShowStopPause : Lyte.attr('boolean' , {default:false}),
			ltPropShowStopReset : Lyte.attr('boolean' , {default:false}),
			ltPropShowStopLap : Lyte.attr('boolean' , {default:false}),

			ltPropShowSWHours : Lyte.attr('boolean' , {default : false}),
			ltPropShowSWMilliSeconds : Lyte.attr('boolean' , {default : true}),



			ltPropShowDate : Lyte.attr('boolean' , {default : false}),

			ltPropPause : Lyte.attr('boolean' , {default : false}),
			stopWatchRunning : Lyte.attr('boolean' , {default : false}),
			ltPropDate : Lyte.attr('string' , {default : ''}),
			ltPropLapTime : Lyte.attr('array' , {
				default : []
			}),



			ltPropTimerHours : Lyte.attr('string' , {default : '00'}),
			ltPropTimerMinutes : Lyte.attr('string' , {default : '00'}),
			ltPropTimerSeconds : Lyte.attr('string' , {default : '00'}),

			ltPropTimerDays : Lyte.attr('string' , {default : '00'}),
			ltPropTimerMonths : Lyte.attr('string' , {default : '00'}),
			ltPropTimerYears : Lyte.attr('string' , {default : '00'}),

			ltPropShowYears : Lyte.attr('boolean' , {default : false}),
			ltPropShowMonths : Lyte.attr('boolean' , {default : false}),
			ltPropShowDays : Lyte.attr('boolean' , {default : false}),
			ltPropShowHours : Lyte.attr('boolean' , {default : true}),
			ltPropShowMinutes : Lyte.attr('boolean' , {default : true}),
			ltPropShowSeconds : Lyte.attr('boolean' , {default : true}),

			ltPropCurrentDate : Lyte.attr('string',{default : '00/00/0000'}),
			ltPropGivenDate : Lyte.attr('string',{default : '00/00/0000'}),
			timerPaused : Lyte.attr('boolean' , {
				default : false
			}),
			userDefinedUnits : Lyte.attr('boolean', {
				default : false
			})

		}
	},

	init : function(){

		var _this = this

		var units = this.getData('ltPropUnits')

		if(units.length > 0){
			this.setData('userDefinedUnits' , true)
			_this.setData('ltPropShowYears' , false)
			_this.setData('ltPropShowMonths' , false)
			_this.setData('ltPropShowDays' , false)
			_this.setData('ltPropShowHours' , false)
			_this.setData('ltPropShowMinutes' , false)
			_this.setData('ltPropShowSeconds' , false)
			for(var i=0;i<units.length;i++){
				switch (units[i]) {
					case 'year':
						_this.setData('ltPropShowYears' , true)
					break;
					case 'month':
						_this.setData('ltPropShowMonths' , true)
					break;
					case 'day':
						_this.setData('ltPropShowDays' , true)
					break;
					case 'hour':
						_this.setData('ltPropShowHours' , true)
					break;
					case 'minute':
						_this.setData('ltPropShowMinutes' , true)
					break;
					case 'second':
						_this.setData('ltPropShowSeconds' , true)
					break;
				}
			}
		}

		this.$node.pauseTimer = function(){

			_this.setData('timerPaused' , true)

		};

		this.$node.resumeTimer = function(){

			_this.setData('timerPaused' , false)

			if(_this.getData('ltPropMode') === 'timer'){

				_this.lyteTimer();

			} else if(_this.getData('ltPropMode') === 'forwardtimer'){

				_this.lyteForwardTimer()

			}

		};

	},

	methods : {
		onTimerStart : function(){

		},
		onTimerEnd : function(){

		},
		onTimeReached : function(){

		},
		onTimerPassed : function(){

		}
	},


	modeChange : function(){
		if(this.getData('ltPropType') === 'digital'){
			this.lyteDigitalWatch();
		} else if(this.getData('ltPropType') === 'analog'){
			this.lyteAnalogWatch();
		}
	}.observes(
		'ltPropMode'
	),

	timerChange : function(){
		clearInterval(this.timerCaseD)
		clearInterval(this.timerCaseT)
		clearInterval(this.timerCaseET)
		this.setData('ltPropTimerYears',0);
		this.setData('ltPropTimerMonths',0);
		this.setData('ltPropTimerDays',0);
		this.setData('ltPropTimerHours',0);
		this.setData('ltPropTimerMinutes',0);
		this.setData('ltPropTimerSeconds',0);

		if(!this.getData('userDefinedUnits')){
			this.setData('ltPropShowYears' , true)
			this.setData('ltPropShowMonths' , true)
			this.setData('ltPropShowDays' , true)
			this.setData('ltPropShowHours' , true)
			this.setData('ltPropShowMinutes' , true)
			this.setData('ltPropShowSeconds' , true)
		}


		this.lyteTimer();
	}.observes(
		'ltPropEndDate',
		'ltPropDuration',
		'ltPropEndTime'
	),

	didConnect : function(){
		if(this.getData('ltPropType') === 'digital'){
			this.lyteDigitalWatch();
		} else if(this.getData('ltPropType') === 'analog'){
			this.lyteAnalogWatch();
		}

		var unitLabels = {}

		unitLabels.year = this.getData('ltPropUnitLabel').year || 'Yrs'
		unitLabels.month = this.getData('ltPropUnitLabel').month || 'Mths'
		unitLabels.day = this.getData('ltPropUnitLabel').day || 'Days'
		unitLabels.hour = this.getData('ltPropUnitLabel').hour || 'Hrs'
		unitLabels.minute = this.getData('ltPropUnitLabel').minute || 'Mins'
		unitLabels.second = this.getData('ltPropUnitLabel').second || 'Secs'

		this.setData('ltPropUnitLabel' , unitLabels)

		var _this = this;

		this.$node.startTimer = function(){

			_this.lyteTimer();

		}

		var time = new Date();
		this.setData('ltPropDate' , time.getDate());
	},

	lyteTimer : function(){

		this.executeMethod('onTimerStart')

		// Static Variables that are global for lyteTimer function
		var currentTime = new Date();
		var cT = currentTime.getHours()-12+':'+currentTime.getMinutes()+':'+currentTime.getSeconds();
		var _this = this;
		var liveDate;

		// Variables common for switch
		var timerType = '';
		var secTime = this.getData('ltPropDuration');
		var dayTime = this.getData('ltPropEndDate');
		var endTime = this.getData('ltPropEndTime');
		var alarmTime = this.getData('ltPropAlarm').split(':').map(function(x){return parseInt(x)})

		// Variables used for case : 'D' where the user gives only timer duration in date
		var timerCaseD;
		var durationDate;

		// Variables used for case : 'T' where the user gives only timer duration in time
		var durationTime;
		var updateTimer;
		var clearTimer;

		// Variables used for case : 'ET' where the user gives the end time when the timer has to stop
		var endTimeAr;
		var timerCaseET;

		// Conditions for selecting the timer type
		if((secTime !== '00:00:00')&&(dayTime !== '00/00/0000')){
			timerType = 'D&T';
		} else {
			if(dayTime !== '00/00/0000'){
				timerType = 'D';
			} if(secTime !== '00:00:00'){
				timerType = 'T';
			}
		}

		if((endTime !== '00:00:00')&&(dayTime==='00/00/0000')){
			timerType = 'ET';
		} else if((endTime !== '00:00:00')&&(dayTime!=='00/00/0000')) {
			timerType = 'D';
		}

		switch (timerType) {
			case 'D':

			{
				// Case runs when the user has given only the ltPropEndDate property


				durationDate = this.getData('ltPropEndDate').split('/').map(function(x){return parseInt(x)});

				var cd = (currentTime.getMonth()+1)+'/'+currentTime.getDate()+'/'+currentTime.getFullYear();
				var gd = _this.getData('ltPropEndDate')+" "+_this.getData('ltPropEndTime');
				var currentDate = new Date(cd);
				var givenDate = new Date(gd)


				_this.setData('ltPropCurrentDate',cd);
				_this.setData('ltPropGivenDate',gd);

				isTimePassedFun(givenDate);
				var diffDays = getTotalDaysRemaining(cd,gd);
				var rValue = getDifferenceCaseD(currentDate,givenDate);

				if(givenDate < currentDate){
					_this.executeMethod('onTimerPassed')
				}

				if((diffDays<=366)&&(diffDays>0)){

					timerCaseD =function(){

						isTimePassedFun(givenDate);
						rValue = getDifferenceCaseD(currentDate,givenDate);
						_this.setData('ltPropTimerYears',0);
						if(!_this.getData('userDefinedUnits')){
							_this.setData('ltPropShowYears' , false)
						}
						_this.setData('ltPropTimerMonths',rValue.months);
						_this.setData('ltPropTimerDays',rValue.days);
						_this.setData('ltPropTimerHours',rValue.hours);
						_this.setData('ltPropTimerMinutes',rValue.minutes);
						_this.setData('ltPropTimerSeconds',rValue.seconds);


						liveDate = new Date();

						if(
							alarmTime[0]+":"+alarmTime[1]+":"+alarmTime[2] === (liveDate.getHours()+":"+liveDate.getMinutes()+":"+liveDate.getSeconds())
						){
							_this.executeMethod('onTimeReached');
						}


						if(rValue.months <= 0){
							_this.setData('ltPropShowMonths' , false)
							if(rValue.days <= 0){
								_this.setData('ltPropShowDays' , false)
								if(rValue.hours <= 0){
									if(rValue.minutes <= 0){
										if(rValue.seconds < 1){
											clearInterval(clearThisTimer());
										}
									}
								}
							} else {
									_this.setData('ltPropShowSeconds' , false)
							}
						} else {
							if(!_this.getData('userDefinedUnits')){
								_this.setData('ltPropShowMinutes' , false)
								_this.setData('ltPropShowSeconds' , false)
							}
						}
					}

				} else {

					var remYears = givenDate.getFullYear() - currentDate.getFullYear();
					var remMonths;
					if(givenDate.getMonth() > currentDate.getMonth()){
						remMonths = givenDate.getMonth() - currentDate.getMonth();
					} else {
						remMonths = 12 - currentDate.getMonth() + givenDate.getMonth();

						if(currentDate.getDate() > givenDate.getDate()){
							remMonths -= 1;
						}

						remYears -= 1;

						if(remMonths === 12){
							remMonths = 0;
							remYears +=1;
						}

					}

					if(remYears<=0){
						remYears = 0;
						remMonths = 0;
						_this.executeMethod('onTimerPassed')
					}


					_this.setData('ltPropTimerYears',remYears);
					_this.setData('ltPropTimerMonths',remMonths);
					if(!_this.getData('userDefinedUnits')){
						_this.setData('ltPropShowYears' , true)
						_this.setData('ltPropShowMonths' , true)
					}
					_this.setData('ltPropTimerDays', 0 );
					_this.setData('ltPropTimerHours', 0 );
					_this.setData('ltPropTimerMinutes', 0 );
					_this.setData('ltPropTimerSeconds', 0 );

					if(!_this.getData('userDefinedUnits')){
						_this.setData('ltPropShowDays' , false)
						_this.setData('ltPropShowHours' , false)
						_this.setData('ltPropShowMinutes' , false)
						_this.setData('ltPropShowSeconds' , false)
					}

					clearInterval(_this.timerCaseD)

				}

				if((!(rValue.minutes < 0))&&(diffDays<=366)){
					_this.setData('ltPropTimerYears',0);
					if(!_this.getData('userDefinedUnits')){
						_this.setData('ltPropShowYears' , false)
					}
					_this.setData('ltPropTimerMonths',rValue.months);
					_this.setData('ltPropTimerDays',rValue.days);
					_this.setData('ltPropTimerHours',rValue.hours);
					_this.setData('ltPropTimerMinutes',rValue.minutes);
					_this.setData('ltPropTimerSeconds',rValue.seconds);
					if(rValue.months <= 0){
						if(!_this.getData('userDefinedUnits')){
							_this.setData('ltPropShowMonths' , false)
						}
						if(rValue.days <= 0){
							if(!_this.getData('userDefinedUnits')){
								_this.setData('ltPropShowDays' , false)
							}
						} else {
							if(!_this.getData('userDefinedUnits')){
									_this.setData('ltPropShowSeconds' , false)
								}
						}
					} else {
						if(!_this.getData('userDefinedUnits')){
							_this.setData('ltPropShowMinutes' , false)
							_this.setData('ltPropShowSeconds' , false)
						}
					}
					this.timerCaseD = setInterval(timerCaseD , 1000);
				}
				function clearThisTimer(){
					clearInterval(_this.timerCaseD)
					_this.executeMethod('onTimerEnd')
				}


			}

			break;
			case 'T':
			{

				// Case runs when the user has given only the ltPropDuration property

				durationTime = this.getData('ltPropDuration').split(':').map(function(x){return parseInt(x)});
				_this.setData('ltPropTimerSeconds' , durationTime[2])
				_this.setData('ltPropTimerMinutes' , durationTime[1])
				_this.setData('ltPropTimerHours' , durationTime[0])

				if(!_this.getData('userDefinedUnits')){
					_this.setData('ltPropShowYears' , false)
					_this.setData('ltPropShowMonths' , false)
					_this.setData('ltPropShowDays' , false)
				}

				updateTimer = function(){
					// Function that has been passed to the setInterval for every one second

					if(_this.getData('timerPaused')){
						clearInterval(_this.timerCaseT);
						return
					}

					_this.setData('ltPropTimerSeconds' , updateSeconds(_this.getData('ltPropTimerSeconds')))
					if(_this.getData('ltPropTimerSeconds')>=59){
						if(_this.getData('ltPropTimerHours')>0){
							_this.setData('ltPropTimerMinutes' , updateMinutes(60))
						} else {
							_this.setData('ltPropTimerMinutes' , updateMinutes(_this.getData('ltPropTimerMinutes')))
						}
						_this.setData('ltPropTimerHours' , updateHours(_this.getData('ltPropTimerHours')))
					}
					_this.setData('ltPropDuration' , parseFloat(_this.getData('ltPropTimerHours'))+':'+parseFloat(_this.getData('ltPropTimerMinutes'))+':'+parseFloat(_this.getData('ltPropTimerSeconds')))

					if(
							(parseFloat(_this.getData('ltPropTimerSeconds'))===alarmTime[2]) &&
							(parseFloat(_this.getData('ltPropTimerMinutes'))===alarmTime[1]) &&
							(parseFloat(_this.getData('ltPropTimerHours'))===alarmTime[0])
						){
							_this.executeMethod('onTimeReached');
					}

					if(
							(parseFloat(_this.getData('ltPropTimerSeconds'))===0) &&
							(parseFloat(_this.getData('ltPropTimerMinutes'))===0) &&
							(parseFloat(_this.getData('ltPropTimerHours'))===0)
						){
						_this.setData('ltPropDuration' , parseFloat(_this.getData('ltPropTimerHours'))+':'+parseFloat(_this.getData('ltPropTimerMinutes'))+':'+parseFloat(_this.getData('ltPropTimerSeconds')))
						endTimerCaseT();
					}

				}

				this.timerCaseT = setInterval(updateTimer , 1000);
				function endTimerCaseT(){
					clearInterval(_this.timerCaseT);
					_this.executeMethod('onTimerEnd')
				}

			}
			break;
			case 'ET':

			{

				var endTimeAr = this.getData('ltPropEndTime').split(':').map(function(x){return parseInt(x)});
				var cd = (currentTime.getMonth()+1)+'/'+currentTime.getDate()+'/'+currentTime.getFullYear();
				var gd = (currentTime.getMonth()+1)+'/'+currentTime.getDate()+'/'+currentTime.getFullYear()+" "+_this.getData('ltPropEndTime');
				var currentDate = new Date(cd);
				var givenDate = new Date(gd);

				_this.setData('ltPropCurrentDate',cd);
				_this.setData('ltPropGivenDate',gd);

				var rValue = getDifferenceCaseD(currentDate,givenDate);

				timerCaseET = function(){

					rValue = getDifferenceCaseD(currentDate,givenDate);

					_this.setData('ltPropTimerHours',rValue.hours);
					_this.setData('ltPropTimerMinutes',rValue.minutes);
					_this.setData('ltPropTimerSeconds',rValue.seconds);

					liveDate = new Date();

					if(
						alarmTime[0]+":"+alarmTime[1]+":"+alarmTime[2] === (liveDate.getHours()+":"+liveDate.getMinutes()+":"+liveDate.getSeconds())
					){
						_this.executeMethod('onTimeReached');
					}


					if(rValue.hours <= 0){
						if(rValue.minutes <= 0){
							if(rValue.seconds < 1){
								clearInterval(clearThisTimerET());
							}
						}
					}
				}

				if(!(rValue.minutes < 0)){
					_this.setData('ltPropTimerHours',rValue.hours);
					_this.setData('ltPropTimerMinutes',rValue.minutes);
					_this.setData('ltPropTimerSeconds',rValue.seconds);
					this.timerCaseEt = setInterval(timerCaseET , 1000);
				}
				function clearThisTimerET(){
					clearInterval(_this.timerCaseEt)
					_this.executeMethod('onTimerEnd')
				}





			}

			break;

		}

		function updateSeconds(sec){
			// Function that decrements the seconds value by 1
			if(sec>0){
				return sec-1;
			}
			return 59;
		}
		function updateMinutes(min){
			// Function that decrements the minutes value by 1
			if(min > 0){
				return min-1;
			}
			return 0;
		}
		function updateHours(hrs){
			// Function that decrements the hours value by 1
			if(hrs > 0){
				return hrs-1;
			}
			return 0;
		}


		function getTotalDaysRemaining(c,g){
			// Function that returns the total number of days

			var currentDate = new Date(c);
			var givenDate = new Date(g);
			var diffTime = givenDate - currentDate;
			var diffDays = Math.abs(Math.ceil(diffTime / (1000 * 60 * 60 * 24)));
			return diffDays;
		}

		function getNumberOfDaysInAMonth(date){
			// Function that returns the number of days present in a given month

			var year = date.getFullYear();
			var month = date.getMonth();
			var totalMonths = new Date(year, month, 0).getDate()
			return totalMonths ;
		}

		function getMonthsDif(c, g) {
			// Function that returns the number of months present between the two given dates

			var monthGap;

			if(c.getMonth() >= g.getMonth()){
				if(isDayPassedFun(g)){
					monthGap = 11 - c.getMonth() + g.getMonth() + 1
				} else {
					monthGap = 11 - c.getMonth() + g.getMonth()
				}

			} else {
				monthGap = g.getMonth() - c.getMonth();
				if(!isDayPassedFun(g)){
					if(c.getDate() === g.getDate()){
						if(!isMinutesPassedFun(g)){
							monthGap -= 1;
						} else {
							monthGap;
						}
					} else {
						monthGap -= 1;
					}
				}
			}

			if(c.getMonth() === g.getMonth()){
				if(isDayPassedFun(g)){
					monthGap = g.getMonth() - c.getMonth();
				} else {
					monthGap = 11 - c.getMonth() + g.getMonth() + 1
					if(!isDayPassedFun(g)){
						monthGap -= 1;
					}
					if(g.getDate() === c.getDate()){
						monthGap = 0;
					}
				}
			}

			if(monthGap<1){
				if(!_this.getData('userDefinedUnits')){
					_this.setData('ltPropShowMonths' , false)
				}
			} else {
				if(!_this.getData('userDefinedUnits')){
					_this.setData('ltPropShowMonths' , true)
				}
			}

			return monthGap;
		}

		function getDaysDiff(c,g){
			// Function that returns the remaining number of days after remaining months been calculated

			var ct = new Date();
			var daysInCurrentMonth = getNumberOfDaysInAMonth(c);
			var daysInGivenMonth = getNumberOfDaysInAMonth(g);
			var dayStarted = 0;
			var daysDiff = 0;
			var remainingDaysInCurrentMonth = daysInCurrentMonth - c.getDate();
			var remainingDaysInGivenMonth = g.getDate() - dayStarted;

			if(c.getDate() > g.getDate()){
				daysDiff = (getNumberOfDaysInAMonth(g) - c.getDate()) + g.getDate() -1
				if(g.getHours() === ct.getHours()){
					if(!isMinutesPassedFun(g)){
						daysDiff -=1;
					}
				}
			} else {
				daysDiff = g.getDate() - c.getDate();
				if(g.getDate() === c.getDate()){
					if(g.getHours() === ct.getHours()){
						if(!isMinutesPassedFun(g)){
							daysDiff = (getNumberOfDaysInAMonth(g) - c.getDate()) + (g.getDate() - 1)
						}
					}
				} else {
					if(g.getHours() === ct.getHours()){
						if(!isMinutesPassedFun(g)){
							daysDiff -= 1;
						}
					} if(g.getHours() < ct.getHours()){
						daysDiff -=1;
					}
				}
			}

			if(daysDiff<1){
				if(!_this.getData('userDefinedUnits')){
					_this.setData('ltPropShowDays' , false)
				}
			} else {
				if(!_this.getData('userDefinedUnits')){
					_this.setData('ltPropShowDays' , true)
				}
			}
			return daysDiff
		}

		function getHoursDiff(c,g){
			// Function that returns the remaining number of hours after

			var ct = new Date();
			var hrDif = (24 - Math.abs(ct.getHours() - g.getHours()));
			var millisecondDiff = g - ct;
			var secDiff = Math.floor( (g - ct) / 1000 );
			var minutesDiff = Math.floor( secDiff / 60 );
			var hrDif = Math.floor( minutesDiff / 60 );

			if(ct.getHours() >= g.getHours()){
				hrDif = 23 - ct.getHours() + g.getHours();
				if(ct.getHours() === g.getHours()){
					if(isMinutesPassedFun(g)){
						hrDif = ct.getHours() - g.getHours();
					}
				}
			} else {
				hrDif = g.getHours() - ct.getHours();
				if(!isMinutesPassedFun(g)){
					hrDif -= 1;
				}
			}

			return hrDif
		}

		function getMinutesDiff(c,g){
			// Function that returns the remaining number of minutes after

			var ct = new Date();
			var millisecondDiff = g - ct;
			var secDiff = Math.floor( (g - ct) / 1000 );
			var minDif = Math.floor( secDiff / 60 );

			if(minDif >= 59){
				if(ct.getMinutes() > g.getMinutes()){
					minDif = 59 - (ct.getMinutes() - g.getMinutes());
				} else {
					if(ct.getMinutes() === g.getMinutes()){
						if(!isSecondsPassedFun(g)){
							minDif = 59 - (ct.getMinutes() - g.getMinutes());
						}
					} else {
						minDif = g.getMinutes() - ct.getMinutes();
						if(!isSecondsPassedFun(g)){
							minDif -= 1;
						}
					}
				}
			}
			return minDif;
		}

		function getSecondsDiff(c,g){
			// Function that returns the remaining number of seconds after

			var ct = new Date();
			return (60 - Math.abs(ct.getSeconds() - g.getSeconds()) - 1);
		}

		function isDayPassedFun(g){
			// Function returns a boolean checking whether the current time has crossed the user given time
			// eg givenDate = 10 , currentDate = 6 true

			var ct = new Date();
			return ((g.getDate()>ct.getDate()) ? true : false);
		}

		function isTimePassedFun(g){
			// Function returns a boolean checking whether the current time has crossed the user given time
			// eg givenHour = 10 , currentHour = 16 true

			var ct = new Date();
			return ((g.getHours()>ct.getHours()) ? true : false);
		}
		function isMinutesPassedFun(g){
			// Function returns a boolean checking whether the current time has crossed the user given time
			// eg givenMinute = 15 , currentMinute = 00 true

			var ct = new Date();
			return ((g.getMinutes()>ct.getMinutes()) ? true : false);
		}
		function isSecondsPassedFun(g){
			// Function returns a boolean checking whether the current time has crossed the user given time

			var ct = new Date();
			return ((g.getSeconds()>ct.getSeconds()) ? true : false);
		}


		function getDifferenceCaseD(c,g){

			// Function returns the object that has all the remaining values

			var daysInCurrentMonth = getNumberOfDaysInAMonth(c);
			var daysInGivenMonth = getNumberOfDaysInAMonth(g);

			getHoursDiff(c,g)

			var remaining = {}
			remaining.months = getMonthsDif(c,g);
			remaining.days = getDaysDiff(c,g);
			remaining.hours = getHoursDiff(c,g);
			remaining.minutes = getMinutesDiff(c,g);
			remaining.seconds = getSecondsDiff(c,g);

			return remaining;

		}

	},

	lyteForwardTimer : function(){

		var startTime = this.getData('ltPropStartTime').split(':').map(function(x){return parseInt(x)})

		var startSec = startTime[2];
		var startMin = startTime[1];
		var startHr  = startTime[0];

		this.setData('ltPropSeconds' , startTime[2])
		this.setData('ltPropMinutes' , startTime[1])
		this.setData('ltPropHours' , startTime[0])

		var _this = this
		_this.executeMethod('onTimerStart')

		var setForwardTimer = function(){

			if(_this.getData('timerPaused')){
				clearForwardTimer()
				return
			}

			startSec += 1

			if(startSec === 60){
				startSec = 0
				startMin += 1
			}
			if(startMin === 60){
				startMin = 0
				startHr +=1
			}
			if(startHr === 24){
				_this.executeMethod('onTimerEnd')
				startSec = 0;
				startMin = 0;
				startHr  = 0;
			}

			_this.setData('ltPropSeconds' , startSec)
			_this.setData('ltPropMinutes' , startMin)
			_this.setData('ltPropHours' , startHr)

			var setTime = startHr+':'+startMin +':'+ startSec

			_this.setData('ltPropStartTime' , setTime)

		}

		this.forwardTimer = setInterval(setForwardTimer , 1000);

		function clearForwardTimer(){
			clearInterval(_this.forwardTimer)
		}

	},

	lyteDigitalWatch : function(){

			var currentTime = new Date();
			var _this = this;
			var stopWatchMilliSec = 0;
			var stopWatchSec = 1;
			var stopWatchMin = 1;
			var stopWatchHrs = 1;
			var alarmTime = this.getData('ltPropAlarm').split(':').map(function(x){return parseInt(x)})

			var setTime = function(){
				var currentTime = new Date();
				if(
					alarmTime[0]+":"+alarmTime[1]+":"+alarmTime[2] === (currentTime.getHours()+":"+currentTime.getMinutes()+":"+currentTime.getSeconds())
				){
					_this.executeMethod('onTimeReached');
				}
				_this.setData('ltPropSeconds' , currentTime.getSeconds());
				if(currentTime.getSeconds() === 0){
					_this.setData('ltPropMinutes' , currentTime.getMinutes());
				}
				if(currentTime.getMinutes() === 0){
					if(_this.getData('ltPropFormat') === '12'){
						if(currentTime.getHours() > 12){
							_this.setData('ltPropHours' , (currentTime.getHours()-11));
						}else {
							_this.setData('ltPropHours' , currentTime.getHours());
						}
					} else {
						_this.setData('ltPropHours' , currentTime.getHours());
					}
				}
				if(_this.getData('ltPropFormat') === '12'){
					if(currentTime.getHours() > 11){
						_this.setData('ltPropTimeMeridiem' , 'PM');
					} else {
						_this.setData('ltPropTimeMeridiem' , 'AM');
					}
				}
			}
			if(this.getData('ltPropMode') === 'watch'){
				if(this.getData('ltPropFormat') === '12'){
					if(currentTime.getHours() > 12){
						this.setData('ltPropHours' , (currentTime.getHours()-12));
					}else {
						this.setData('ltPropHours' , currentTime.getHours());
					}
				}else {
					this.setData('ltPropHours' , currentTime.getHours());
				}
				this.setData('ltPropMinutes' , currentTime.getMinutes());
				this.setData('ltPropSeconds' , currentTime.getSeconds());
				_this.digiWatch = setInterval(setTime , 1000);
			}
			if(_this.getData('ltPropFormat') === '12'){
				if(currentTime.getHours() > 11){
					_this.setData('ltPropTimeMeridiem' , 'PM');
				} else {
					_this.setData('ltPropTimeMeridiem' , 'AM');
				}
			}
			if(this.getData('ltPropMode') === 'stopWatch'){

				_this.lyteStopWatch();

			}	else if(this.getData('ltPropMode') === 'timer'){

				_this.lyteTimer();

			} else if(this.getData('ltPropMode') === 'forwardtimer'){

				_this.lyteForwardTimer();

			}
	},
	lyteStopWatch : function(){

			var _this = this;

			var stopWatchMilliSec = 0;
			var stopWatchSec = 1;
			var stopWatchMin = 1;
			var stopWatchHrs = 1;

			var pauseMilliValue;
			var pauseSecValue ;
			var pauseMinValue ;
			var pauseHrsValue ;

			var currentClock = this.$node;

			startClock = function(){
				pauseMilliValue = _this.getData('ltPropStopMilliSeconds');
				pauseSecValue = _this.getData('ltPropStopSeconds');
				pauseMinValue = _this.getData('ltPropStopMinutes');
				pauseHrsValue = _this.getData('ltPropStopHours');
				if(!_this.getData('ltPropPause')){
					_this.setData('ltPropStopMilliSeconds' , stopWatchMilliSec++);
					if(stopWatchMilliSec === 100){
						stopWatchMilliSec = 0;
						_this.setData('ltPropStopSeconds' , stopWatchSec++);
					}
					if(stopWatchSec === 60){
						stopWatchSec = 0;
						_this.setData('ltPropStopMinutes' , stopWatchMin++);
					}
					if(stopWatchMin === 60){
						stopWatchMin = 0;
						_this.setData('ltPropStopHours' , stopWatchHrs++);
					}
				}
				if(stopWatchHrs > 1){
					_this.setData('ltPropShowSWHours' , true);
					_this.setData('ltPropShowSWMilliSeconds' , false);
				}
			}
			var stopInterval;

			function stopWatchStart(){
				if(!_this.getData('stopWatchRunning')){
					_this.setData('ltPropPause' , false);
					_this.stopInterval = setInterval(startClock , 10);
				}
				_this.setData('stopWatchRunning' , true);
				_this.setData('ltPropShowStopPause' , true);
				_this.setData('ltPropShowStopLap' , true);
				_this.setData('ltPropShowStopStart' , false);
				_this.setData('ltPropShowStopReset' , false);
				$L(currentClock).find('.lyteClockSWPause')[0].addEventListener('click' , stopWatchPause);
				$L(currentClock).find('.lyteClockSWLap')[0].addEventListener('click' , stopWatchLap);
			}
			function stopWatchPause(){
				clearInterval(_this.stopInterval);
				_this.setData('stopWatchRunning' , false);
				_this.setData('ltPropPause' , true);
				_this.setData('ltPropStopHours' , pauseHrsValue);
				_this.setData('ltPropStopMinutes' , pauseMinValue);
				_this.setData('ltPropStopSeconds' , pauseSecValue);
				_this.setData('ltPropStopMilliSeconds' , pauseMilliValue);
				_this.setData('ltPropShowStopPause' , false);
				_this.setData('ltPropShowStopLap' , false);
				_this.setData('ltPropShowStopStart' , true);
				_this.setData('ltPropShowStopReset' , true);
				$L(currentClock).find('.lyteClockSWStart')[0].addEventListener('click' , stopWatchStart);
				$L(currentClock).find('.lyteClockSWReset')[0].addEventListener('click' , stopWatchReset);
			}
			function stopWatchLap(){
				var lapTime = {};
				lapTime.lapMilliSecs  = _this.getData('ltPropStopMilliSeconds');
				lapTime.lapSeconds  = _this.getData('ltPropStopSeconds');
				lapTime.lapMinutes  = _this.getData('ltPropStopMinutes');
				lapTime.lapHours  = _this.getData('ltPropStopHours');
				var lapTimeArr = _this.getData('ltPropLapTime');
				Lyte.arrayUtils(lapTimeArr ,'push',lapTime);
				_this.setData('ltPropLapTime' , lapTimeArr);
			}

			function stopWatchReset(){
				clearInterval(_this.stopInterval);
				_this.setData('ltPropStopHours' , '00');
				_this.setData('ltPropStopMinutes' , '00');
				_this.setData('ltPropStopSeconds' , '00');
				_this.setData('ltPropStopMilliSeconds' ,'00');
				_this.setData('ltPropLapTime' , []);
				pauseHrsValue = pauseMinValue = pauseSecValue = pauseMilliValue = "00"
				stopWatchMilliSec = 0;
				stopWatchSec = 1;
				stopWatchMin = 1;
				stopWatchHrs = 1;
				_this.setData('ltPropShowStopPause' , false);
				_this.setData('ltPropShowStopLap' , false);
				_this.setData('ltPropShowStopStart' , true);
				_this.setData('ltPropShowStopReset' , false);
				_this.setData('ltPropShowSWHours' , false);
				_this.setData('ltPropShowSWMilliSeconds' , true);
			}

			$L(currentClock).find('.lyteClockSWStart')[0].addEventListener('click' , stopWatchStart);
	},
	lyteAnalogWatch : function(){

		var secondsDial = $L('.lyteClockSecDial')[0];
		var minutesDial = $L('.lyteClockMinDial')[0];
		var hoursDial = $L('.lyteClockHrDial')[0];
		var time = new Date();
		var hrs = time.getHours();
		var min = time.getMinutes();
		var sec = time.getSeconds();
		var secRot = sec*6;
		var minRot = min*6;
		var hrsRot = ((hrs-12) * 30) + (min*.5);

		secondsDial.style.transform = 'rotate(' + secRot + 'deg)';
		minutesDial.style.transform = 'rotate(' + minRot + 'deg)';
		hoursDial.style.transform = 'rotate(' + hrsRot + 'deg)';

		var setAnalogSec = function(){
			var currentSecAngle = secondsDial.style.transform;
			currentSecAngle = currentSecAngle.replace('rotate(','').replace('deg)','');

			time = new Date();
			sec = time.getSeconds();
			// sec = currentSecAngle + 6;
			if(parseFloat(currentSecAngle)>=360){
				currentSecAngle = 0;
			}
			secRot = parseFloat(currentSecAngle) + .6;

			// secRot = (sec*6) + (time.getMilliseconds() * (6/1000));

			secondsDial.style.transform = 'rotate(' + secRot + 'deg)';
		}
		var setAnalogTime = function(){
			time = new Date();
			hrs = time.getHours();
			min = time.getMinutes();

			minRot = min * 6;
			hrsRot = ((hrs-12) * 30) + (min*.5);


			minutesDial.style.transform = 'rotate(' + minRot + 'deg)';
			hoursDial.style.transform = 'rotate(' + hrsRot + 'deg)';
		}


		this.analogSecTimeInt = setInterval(setAnalogSec , 100)
		this.analogTimeInt = setInterval(setAnalogTime , 1000);


	},
	didDestroy : function(){
		function clearIntervalFun(fun){
			if(fun){
				clearInterval(fun);
			}
		}
		clearIntervalFun(this.timerCaseD);
		clearIntervalFun(this.timerCaseT);
		clearIntervalFun(this.timerCaseET);
		clearIntervalFun(this.digiWatch)
		clearIntervalFun(this.forwardTimer)
		clearIntervalFun(this.stopInterval);
		clearIntervalFun(this.analogSecTimeInt);
		clearIntervalFun(this.analogTimeInt);
	}
});


/**
 * @yieldedSyntax
 * <lyte-clock></lyte-clock>
 */

/**
 * Renders a colorbox
 * @component lyte-colorbox
 * @version 1.0.0
 * @dependencies lyte-exif
 * @utility launch,push,open,zoomBy,replace,close,delete
 * @methods onBeforeOpen,onOpen,onBeforeClose,onClose,onLoad,onComplete,onFailure,onNavigate,onZoomin,onZoomout,onReset,onDownload
 */ 

var LyteColorbox = {
	_prefix : 'lyteCBox',
	_boxElement : 'lyteCBoxElement',
	_box : null,
	_content : null,
	_overlay : null,
	_title : null,
	_description: null,
	_close : null,
	_download : null,
	_next : null,
	_prev : null,
	_open : null,
	_zoomIn : null,
	_zoomOut : null,
	_reset : null,
	_active : null,
	_closing : null,
	_previousOffset : {},
	_first : true,
	_domEle : null,
	_related : null,
	_el : null,
	_photoRegex : /\.(gif|png|jp(e|g|eg)|bmp|ico|webp|jxr|svg)((#|\?).*)?$/i,
	_index : 0,
	_zoom : false,
	_component : null,
	_winheight : null,
	_winWidth : null,
	_isArray : false,
	_hrefArray : [],
	_titleArray : [],
	_nextItem : false,
	_prevItem : false,
	_zIndex : 0,
	_timeoutId : false,
	_thumbDiv : null,
	_clickNumber : 0,
	_zoomedThroughUtil: false,
	_count : 0,
	_boundKeydown : false,
	_boundResize : false,
	_diff : 0,
	_loadingIcon : null,

	setSize : function(size, dimension, param) {
		if(/%/.test(size)){
			return parseInt(size);
		}
		else{
			return Math.round((dimension === 'x' ? (isNaN(size/param) ? 0 : size/param) : (isNaN(size/param) ? 0 : size/param)) * 100);
		}
		// return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
	},

	createElement : function(tagName,id,className){
		var element = document.createElement(tagName);
		if (id) {
			element.id = id;
		}
		if (className) {
			element.classList.add(className);
		}
		return element;
	},

	/**
	 * The method is going to return the selector of the element that matches with ltPropSelectors
	 * ( Might be buggy when lt-prop-position is changed as it only removes opposites)
	 * @param {classList} compSelectors - The list of selectors provided to lyte-colorbox
	 * @param {ClassList} elemClasses - The list of classes that the element has
	 *
	 */
	getSelector : function(compSelectors,elemClasses){
		for(var i = 0; i<elemClasses.length; i++){
			if(compSelectors.indexOf('.'+elemClasses[i]) != -1){
				return elemClasses[i];
			}
		}
		return false;
	},

	/**
	 * The method is going to return the index of the next or previous element based on the argument passed ie. 1 or -1
	 * @param {number} increment - The value by which next or previous element's index is determined
	 *
	 */
	getIndex : function(increment) {
		var max = LyteColorbox._related.length,
		newIndex = (LyteColorbox._index + increment) % max;

		return (newIndex < 0) ? max + newIndex : newIndex;
	},

	isImage : function(url) {
		return LyteColorbox._domEle || LyteColorbox._photoRegex.test(url);
	},

	createName : function(param){
		if(!param){
			return LyteColorbox._el.type == "photo" ? "image" : "file";
		}
		return param.replace(/[ ,-]/g,"_");
	},

	/**
	 * The method is going to add the list or single object to the current list maintained in LyteColorbox._related
	 * @param {array of objects or a object} values - The list of objects or single object that will be added to the current related element list
	 *
	 */
	add : function(values){
		if(Array.isArray(values)){
			values = values.map(function(obj){
				if(!obj.lytecboxType || obj.lytecboxType == "photo"){
					obj.type = "photo";
				}
				else{
					var typeArr = obj.lytecboxType.split("/");
					obj.type = typeArr[0];
					if(typeArr.length > 1){
						obj.format = typeArr[1].toUpperCase();
					}
					else{
						obj.format = "WEBPAGE";
					}
				}
				return obj;
			});
		}
		else{
			if(!values.lytecboxType || values.lytecboxType == "photo"){
				values.type = "photo";
			}
			else{
				var typeArr = values.lytecboxType.split("/");
				values.type = typeArr[0];
				if(typeArr.length > 1){
					values.format = typeArr[1].toUpperCase();
				}
				else{
					values.format = "WEBPAGE";
				}
			}
		}
		Lyte.arrayUtils(LyteColorbox._related,"push",values);
	},

	/**
	 * The method is going to get the elements having same selector as mentioned by the rel property and will add it to LyteColorbox._related 
	 * @param {classList} rel - The classlist to be matched
	 *
	 */
	getRelated : function(rel) {
		LyteColorbox._index = 0;
		LyteColorbox._related = [];
		if (rel && rel !== false && rel !== 'nofollow') {
			var elements = Array.from(document.querySelectorAll('.' + LyteColorbox._boxEle)).filter(function (node) {
				return (LyteColorbox.getSelector(LyteColorbox._component.getData('ltPropSelectors'),Array.from(node.classList)) === rel);
			});
			for(var i = 0;i<elements.length;i++){
				var obj = LyteColorbox.getProperties(elements[i]);
				if(!obj.classList){
					obj.classList = [rel];
				}
				LyteColorbox._related.push(obj);
			}
			LyteColorbox._index = LyteColorbox._related.findIndex( function(obj) { return obj.lytecboxHref == LyteColorbox._el.lytecboxHref && obj.lytecboxTitle == LyteColorbox._el.lytecboxTitle});

			// Check direct calls to Colorbox.
			if (LyteColorbox._index === -1) {
				LyteColorbox._related.push(LyteColorbox._el);
				LyteColorbox._index = LyteColorbox._related.length - 1;
			}
		} else {
			LyteColorbox._related = [];
			LyteColorbox._related.push(LyteColorbox._el);
			LyteColorbox._index = LyteColorbox._related.length - 1;
		}
	},

	/**
	 * The method is going to hide the visible element in colorbox
	 *
	 */
	hideElement : function(){
		var elements = LyteColorbox._content ? LyteColorbox._content.querySelectorAll('.lyteCBoxVisible') : [];
		for(var i = 0; i < elements.length; i++){
			elements[i].classList.remove('lyteCBoxVisible');
		}
	},

	/**
	 * The method is going to specify mark the currently shown element in the colorbox
	 * @param {DOM element} element - The current visible element in colorbox
	 *
	 */
	setCurrentClass : function( element ){
		var elements = LyteColorbox._content ? LyteColorbox._content.querySelectorAll('.lyteCBoxCurrentElem') : [];
		for(var i = 0; i < elements.length; i++){
			elements[i].classList.remove('lyteCBoxCurrentElem');
		}
		element.classList.add('lyteCBoxCurrentElem');
	},

	/**
	 * The method is going to hide the loading icon
	 * @param {DOM element} parent - The parent element containing the loading icon
	 *
	 */
	hideLoadingIcon: function( parent ) {
		var loadingIcon;

		loadingIcon = parent.querySelector( '.lyteColorboxLoadingImg' );
		loadingIcon.style.display = 'none';
	},

	/**
	 * The method is going to hide or show the loading icon
	 *
	 */
	toggleLoadingIcon : function() {
		var type = LyteColorbox._component.getData( 'ltPropType' );

		if( type === 'custom' && !LyteColorbox._component.getData( 'ltPropYield' ) ) {
			if(LyteColorbox._content.querySelector('.lyteColorboxLoadingImg').style.display != "none"){
				LyteColorbox._content.querySelector('.lyteColorboxLoadingImg').style.display = "none";
			}
			else{
				LyteColorbox._content.querySelector('.lyteColorboxLoadingImg').style.display = "";
			}
		}
	},

	/**
	 * The method is going to create an object containing the properties that are required by the colorbox to load the element
	 * @param {DOM element} element - The element from which the properties are extracted
	 *
	 */
	getProperties : function(element){
		var obj = Object.assign({},element.dataset);
		if(!obj.lytecboxHref){
			if(element.tagName === "IMG"){
				obj.lytecboxHref = element.src;
			}
			else if(element.tagName === "A"){
				obj.lytecboxHref = element.href;
			}
		}
		if(!obj.lytecboxType || obj.lytecboxType == "photo"){
			obj.type = "photo";
		}
		else{
			var values = obj.lytecboxType.split("/");
			obj.type = values[0];
			if(values.length > 1){
				obj.format = values[1].toUpperCase();
			}
			else{
				obj.format = "WEBPAGE";
			}
		}
		obj.classList = element.classList;
		return obj;
	},

	removeElements : function(){
		var nodes = Array.from(LyteColorbox._content.querySelectorAll("."+LyteColorbox._prefix+"Photo")),
		comp = LyteColorbox._component,
		type = comp.getData( 'ltPropType' ),
		animation = comp.getData( 'ltPropAnimation' );
		Lyte.arrayUtils(nodes,"push",(Array.from(LyteColorbox._content.querySelectorAll("."+LyteColorbox._prefix+"Iframe"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(LyteColorbox._content.querySelectorAll("."+LyteColorbox._prefix+"Custom"))));

		for(var i=0;i<nodes.length;i++){

			// if( type === 'all' ) {
				if( animation === "slide" ){
					nodes[i].parentElement.remove();
				}
				else{
					nodes[i].remove();
				}
			// }
			// else {
			// 	nodes[ i ].parentElement.remove();
			// }
			
		}
	},

	/**
	 * The method is going to set percentage property to the element
	 * @param {number} value - The zoom value to be added
	 * @param {number} scale - The scale value to be added
	 *
	 */
	setPercentage : function(value, scale){

		if(value){
			LyteColorbox._domEle.setAttribute('data-lytecb-size',value);
		}
		else{
			var orientation = LyteColorbox._domEle.getAttribute('lytecbox-rotate'),
				width = orientation && orientation.indexOf('90') != -1 ? LyteColorbox._domEle.naturalHeight : LyteColorbox._domEle.naturalWidth,
				value, currWidth;
			if(scale){
				currWidth = orientation && orientation.indexOf('90') != -1 ? LyteColorbox._domEle.offsetHeight : LyteColorbox._domEle.offsetWidth;
				value = ((currWidth * scale) / width) * 100;

			}
			else{
				currWidth = LyteColorbox._domEle.getBoundingClientRect().width;
				value = (currWidth / width) * 100;
			}
			LyteColorbox._domEle.setAttribute('data-lytecb-size', (value % 1 != 0) ? Number.parseFloat(value).toFixed(2) : value);
		}
	},

	checkHW : function(){
		// var eleOffset = LyteColorbox._domEle.getBoundingClientRect();
		// var parentOffset = LyteColorbox._domEle.parentElement.getBoundingClientRect();
		if(LyteColorbox._el.type == "photo" && LyteColorbox._domEle.offsetHeight >= LyteColorbox._domEle.parentElement.offsetHeight){
			LyteColorbox._domEle.parentElement.classList.add('lyteCBoxAlignStart');
		}
		else{
			LyteColorbox._domEle.parentElement.classList.remove('lyteCBoxAlignStart');
		}
	},

	isSameColorBoxAsPrevious: function( comp ) {
		return LyteColorbox._component && LyteColorbox._component.$node.isEqualNode( comp.$node );
	},

	/**
	 * The method is going to set the properties of LyteColorbox object based on the current lyte-colorbox component
	 * @param {object} component - Properties of current lyte-colorbox component
	 *
	 */
	setupForBindings: function( comp ) {
		if( this.isSameColorBoxAsPrevious( comp ) ) {
			return;
		}

		LyteColorbox._boxEle = comp._boxElement;
		LyteColorbox._content = comp._content;
		LyteColorbox._overlay = comp._overlay;
		LyteColorbox._title = comp._title;
		LyteColorbox._description = comp._description;
		LyteColorbox._close = comp._close;
		LyteColorbox._download = comp._download;
		LyteColorbox._next = comp._next;
		LyteColorbox._prev = comp._prev;
		LyteColorbox._box = comp._box;
		LyteColorbox._zoomIn = comp._zoomIn;
		LyteColorbox._zoomOut = comp._zoomOut;
		LyteColorbox._reset = comp._reset;
		LyteColorbox._thumbDiv = comp._thumbDiv;
		LyteColorbox._loadingIcon = comp._loadingIcon;
		LyteColorbox._component = comp;
	},

	/**
	 * The method is going to initialize the colorbox component and derive all the properties required to show an element
	 * @param {DOM element} element - The current element to be opened
	 * @param {object} event - The current event object
	 *
	 */
	launch : function(element,event) {
		if(this.$node){
			LyteColorbox.setupForBindings(this);
		}

		if (!LyteColorbox._closing) {
			if(element && typeof element === "object"){
				if(element.nodeType){
					var obj = LyteColorbox.getProperties(element);
					LyteColorbox._el = element = obj;
					LyteColorbox.getRelated(LyteColorbox.getSelector(LyteColorbox._component.getData('ltPropSelectors'),Array.from(element.classList)));
				}
				else if(element.lytecboxHref){
					LyteColorbox._el = element;
					if(element.classList){
						LyteColorbox.getRelated(LyteColorbox.getSelector(LyteColorbox._component.getData('ltPropSelectors'),Array.from(element.classList)));
					}
					else{
						LyteColorbox._related = [];
						LyteColorbox._related.push(LyteColorbox._el);
					}
				}
			}
			else{
				LyteColorbox._related = [];
			}
			// LyteColorbox._component.setData('ltPropGroup',LyteColorbox._related);

			var returnVal = LyteColorbox._component.callOnBeforeOpen(LyteColorbox._related, event) == false ? false : true;
			if(!returnVal){
				LyteColorbox._related = null;
				LyteColorbox._el = null;
				return;
			}
			if(!LyteColorbox._el){
				LyteColorbox._el = element = LyteColorbox._related[0];
			}
			// LyteColorbox._related = LyteColorbox._component.getData('ltPropGroup');
			LyteColorbox._index = LyteColorbox._related instanceof Array ? LyteColorbox._related.findIndex( function(obj) { return obj.lytecboxHref == LyteColorbox._el.lytecboxHref && obj.lytecboxTitle == LyteColorbox._el.lytecboxTitle}) : 0;
			if(!LyteColorbox._component.getData('ltPropYield')){
				if(LyteColorbox._related.length > 1){
					LyteColorbox._next.classList.remove('lyteColorboxHideVisibility');
					LyteColorbox._prev.classList.remove('lyteColorboxHideVisibility');
				}
				else{
					LyteColorbox._next.classList.add('lyteColorboxHideVisibility');
					LyteColorbox._prev.classList.add('lyteColorboxHideVisibility');
				}
			}

			if (!LyteColorbox._open) {

				LyteColorbox._open = LyteColorbox._active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.
				document.body.classList.add('lyteCBoxOH');
				// setClass(settings.get('className'));
				LyteColorbox._box.classList.add('lyteColorboxHideVisibility','lyteColorboxDisplay');

				LyteColorbox._component.trapFocus();
				
				if(LyteColorbox._overlay){
					LyteColorbox.computeOffsetImpl();
				}
				LyteColorbox.hideElement();
				LyteColorbox._box.classList.remove('lyteColorboxHideVisibility');
				LyteColorbox._component.setData('thumbnails',LyteColorbox._related);
				LyteColorbox._component.setData('triggerSetThumbnail', LyteColorbox._component.getData('triggerSetThumbnail')+1 );
				LyteColorbox._component.callOnOpen();
				// setTimeout(function(){
					LyteColorbox.load(element, true);
				// },100)
				
			}
			else{
				LyteColorbox.load(element);
			}

			
		}
	},

	/**
	 * The method is going to use the values and load the item which can be an image or webpage or any other document
	 * @param {Object} element - DOM element or an object which contains the values that will be used to load the item to be shown in the colorbox
	 * @param {boolean} init - boolean value indicating that the colorbox is opening for the first time
	 * 
	 */
	load : function(element, init){
		LyteColorbox._active = true;
		LyteColorbox._domEle = false;
		var complete, failure, ele, domEl;
		
		var href = element.lytecboxHref;
		var title = element.lytecboxTitle;
		if(LyteColorbox._title && title){
			LyteColorbox._title.textContent = title;
		}
		var className = LyteColorbox._boxEle+'__'+LyteColorbox._index;
		LyteColorbox._content.classList.remove('lyteCBoxOH');
		if(element.type == "custom"){
			LyteColorbox._component.setData('isIframe',true);
			if(!element.lytecboxDlink){
				LyteColorbox._component.setData('download',false);
			}
			domEl = LyteColorbox._content.querySelector('.'+className);
			LyteColorbox._domEle = domEl;
			if(!LyteColorbox._domEle){
				LyteColorbox._domEle = LyteColorbox.createElement("div",null,null);
				$L(LyteColorbox._domEle)
					.attr({
						'class': LyteColorbox._prefix + 'Custom' +" "+className
					});
				if(element.lytecboxPreview == "none"){
					var htmlEle = LyteColorbox.createElement("div",null,LyteColorbox._prefix + 'PreviewNone');
					if(element.lytecboxIcon){
						htmlEle.style.backgroundImage = 'url('+element.lytecboxIcon+')';
					}
					LyteColorbox._domEle.append(htmlEle);
					htmlEle =  LyteColorbox.createElement("div",null,LyteColorbox._prefix + 'CustomText');
					htmlEle.textContent = element.lytecboxAlt || "Sorry, no preview is available for this file format";
					LyteColorbox._domEle.append(htmlEle);
				}
				LyteColorbox._component.callOnLoad(LyteColorbox._domEle,LyteColorbox._index);
				LyteColorbox.toggleLoadingIcon();
				LyteColorbox.appendElement(LyteColorbox._domEle);
				if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
					setTimeout(function(){
						LyteColorbox.slide();
					},10);
				}
				LyteColorbox._active = false;
				LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
			}
			else{
				LyteColorbox.toggleLoadingIcon();
				if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
					LyteColorbox._zIndex++;
					if(LyteColorbox._nextItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxNextItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					else if(LyteColorbox._prevItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxPreviousItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					setTimeout(function(){
						LyteColorbox.slide();
					},10);
				}else{
					LyteColorbox._domEle.classList.add('lyteCBoxVisible');
				}
				LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
				LyteColorbox._active = false;
			}
		}
		else if(element.type == "iframe"){
			LyteColorbox._component.setData('isIframe',true);
			if(!element.lytecboxDlink){
				LyteColorbox._component.setData('download',false);
			}
			domEl = LyteColorbox._content.querySelector('.'+className);
			LyteColorbox._domEle = domEl;
			if(!LyteColorbox._domEle){
				LyteColorbox._domEle = document.createElement('iframe');
				var attrs = element.lytecboxAttrs || {};
				if(!attrs.width){
					attrs.width = "100%";
				}
				if(!attrs.height){
					attrs.height = "100%";
				}

				if (typeof attrs === 'object') {
					$L.each(attrs, function(key, val){
						LyteColorbox._domEle[key] = val;
					});
				}

				if ('frameBorder' in LyteColorbox._domEle) {
					LyteColorbox._domEle.frameBorder = 0;
				}
				if ('allowTransparency' in LyteColorbox._domEle) {
					LyteColorbox._domEle.allowTransparency = "true";
				}
				LyteColorbox._domEle.name = (new Date()).getTime(); // give the iframe a unique name to prevent caching
				LyteColorbox._domEle.allowFullscreen = true;

				// if (!settings.get('scrolling')) {
				// 	iframe.scrolling = "no";
				// }

				// $events.one(event_purge, function () {
				// 	iframe.src = "//about:blank";
				// });
				var appendIframe = function(){
					LyteColorbox._domEle.onload = function(){
						// alert("loaded colorbox");
						LyteColorbox.toggleLoadingIcon();
						LyteColorbox._component.callOnLoad(LyteColorbox._domEle,LyteColorbox._index);
						if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
							setTimeout(function(){
								LyteColorbox.slide();
							},10);
						}
						LyteColorbox._active = false;
						LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
					}
					LyteColorbox._domEle.onerror = function(){
						alert("error on colorbox");
					}
					LyteColorbox.appendElement(LyteColorbox._domEle);
					
				};

				$L(LyteColorbox._domEle)
					.attr({
						'src': href,
						'class': LyteColorbox._prefix + 'Iframe' +" "+className
					});
				
				appendIframe();
				
			}
			else{
				LyteColorbox.toggleLoadingIcon();
				if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
					LyteColorbox._zIndex++;
					if(LyteColorbox._nextItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxNextItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					else if(LyteColorbox._prevItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxPreviousItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					setTimeout(function(){
						LyteColorbox.slide();
					},10);
				}else{
					LyteColorbox._domEle.classList.add('lyteCBoxVisible');
				}
				LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
				LyteColorbox._active = false;
			}			
		}
		else{	//element.type == "photo"
			var type = LyteColorbox._component.getData( 'ltPropType' ),
				getExifData = LyteColorbox._component.getData( 'ltPropAddOrientation' );

			LyteColorbox._component.setData('isIframe',false);
			LyteColorbox._component.setData('download',true);
			domEl = LyteColorbox._content.querySelector('.'+className);
			LyteColorbox._domEle = domEl;
			if(type != "image"){
				LyteColorbox._content.classList.add('lyteCBoxOH');
			}
			if(!LyteColorbox._domEle){
				LyteColorbox._domEle = new Image();
				if(element.lytecboxClass){
					var classes = element.lytecboxClass.split(" ");
					$L.each(classes,function(index, val){
						LyteColorbox._domEle.classList.add(val);
					});
				}				

				var divElement;
				if( type === "image" ) {
					divElement = LyteColorbox.appendElementForImage();

					if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
						if(init){
							divElement.classList.add('lyteCBoxCurrentItem');
						}
						LyteColorbox.slide();
					}
					else{
						LyteColorbox.setCurrentClass(divElement);
					}
				}

				var image = $L(LyteColorbox._domEle),
					imageComplete = LyteColorbox.imageComplete.bind( divElement ),
					imageFailure = LyteColorbox.imageFailure.bind( divElement );

				if(getExifData){
					var xhr = new XMLHttpRequest(), prefix = LyteColorbox._prefix;
					xhr.onload = function() {
					    var reader = new FileReader();
					    reader.onloadend = function() {
					    	image.attr({
								'src': reader.result,
								'class': prefix + 'Photo' +" "+className,
								'alt': LyteColorbox._component.getData('ltPropImgError')
							})
							.one('load', imageComplete )
							.one('error', imageFailure);
					    	// callback(reader.result);
					    }
					    reader.readAsDataURL(xhr.response);
					};
					xhr.onError = function() {
					    image.attr({
							'src': href,
							'class': prefix + 'Photo' +" "+className,
							'alt': LyteColorbox._component.getData('ltPropImgError')
						})
						.one('load', imageComplete )
						.one('error', imageFailure);
					};
					xhr.open('GET', href);
					xhr.responseType = 'blob';
					xhr.send();
				}
				else{
					image.attr({
						'src': href,
						'class': LyteColorbox._prefix + 'Photo' +" "+className,
						'alt': LyteColorbox._component.getData('ltPropImgError')
					})
					.one('load', imageComplete )
					.one('error', imageFailure);
				}
				

				if( type === 'image' ) {
					divElement.appendChild( image.get( 0 ) );
				}

				LyteColorbox._active = false;
			}
			else{
				LyteColorbox.toggleLoadingIcon();

				// We make the transition property none inside the reset function because of lyteCBoxPhoto
				// now we are bringing it back. We are emptying it because the lyteCBoxPhoto was causing the image
				// to slide when it was reset
				LyteColorbox.enableTransition( LyteColorbox._domEle );
				if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
					LyteColorbox._zIndex++;
					if(LyteColorbox._nextItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxNextItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					else if(LyteColorbox._prevItem){
						ele = LyteColorbox._domEle.parentElement;
						ele.classList.remove('lyteCBoxDN');
						ele.classList.add('lytCBoxPreviousItem');
						// ele.style.zIndex = LyteColorbox._zIndex;
						LyteColorbox._component.setData('currentEle',ele);
					}
					// setTimeout(function(){
						LyteColorbox.slide();

						if( LyteColorbox._domEle.parentElement._loaded ) {
							if(!(LyteColorbox._domEle.classList.contains('lyteCBoxVisible'))){
								LyteColorbox._domEle.classList.add('lyteCBoxVisible');
							}
							LyteColorbox.checkAspectRatio();
						}
						
					// },10);
					
				}else{
					if( type === "image" ) {
						LyteColorbox.setCurrentClass(LyteColorbox._domEle.parentElement);
					}
					LyteColorbox._domEle.classList.add('lyteCBoxVisible');
					LyteColorbox.checkHW();
					LyteColorbox.checkAspectRatio();
				}
				LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
				LyteColorbox._active = false;
			}
			
		}

		// $L(LyteColorbox._domEle).one('load', complete);

		if(LyteColorbox._component.getData('ltPropThumbnail')){
			var currentThumbnail = LyteColorbox._thumbDiv.querySelector('.thumb-on');
			if(currentThumbnail){
				currentThumbnail.classList.remove('thumb-on');
			}
			LyteColorbox._thumbDiv.querySelectorAll('.lyteColorboxThumb')[LyteColorbox._index].classList.add('thumb-on');
			LyteColorbox.updateThumbnailPos();
		}

		this.changeNavArrows();

	},

	changeNavArrows: function() {
		var ind = LyteColorbox._index;

		if(!LyteColorbox._component.getData('ltPropLoop')){
			if(ind == 0){
				if(LyteColorbox._prev){
					LyteColorbox._prev.classList.add('lyteColorboxHideVisibility');
				}
			}
			else if(ind == LyteColorbox._related.length - 1){
				if(LyteColorbox._next){
					LyteColorbox._next.classList.add('lyteColorboxHideVisibility');
				}
			}
			else{
				if(LyteColorbox._prev && LyteColorbox._prev.classList.contains('lyteColorboxHideVisibility')){
					LyteColorbox._prev.classList.remove('lyteColorboxHideVisibility');
				}
				if(LyteColorbox._next && LyteColorbox._next.classList.contains('lyteColorboxHideVisibility')){
					LyteColorbox._next.classList.remove('lyteColorboxHideVisibility');
				}
			}
		}
	},

	/**
	 * The method is going to do the computations after the image is loaded in the DOM
	 *
	 */
	imageComplete : function(){
		var type = LyteColorbox._component.getData( 'ltPropType' ), img,
			getExifData = LyteColorbox._component.getData( 'ltPropAddOrientation' );
		this._loaded = true;

		if( type === 'custom' ) {
			LyteColorbox.checkAndChangeStatus( LyteColorbox._domEle );
			LyteColorbox._domEle._offset = {
											height : LyteColorbox._domEle.naturalHeight,
											width : LyteColorbox._domEle.naturalWidth
										};
			LyteColorbox._component.callOnLoad(LyteColorbox._domEle,LyteColorbox._index);
			img = LyteColorbox._domEle;
			img.classList.add('lyteCBoxDNImp');
			if(LyteColorbox._overlay){
				LyteColorbox.computeOffsetImpl(null,img,true);
				if(getExifData && $L.exif){
					img._index = LyteColorbox._index;
					$L.exif({
							target : img,
							getData : function(obj){
								// console.log('lyte-exif', obj.exifdata);
								img = obj.target;
								img.classList.add('lyteColorBoxDisableTransition');
								if(getComputedStyle(img).imageOrientation != "from-image"){
									var rValue = obj.exifdata.Orientation;
									switch(rValue) {
										case 2 :
											img.setAttribute('style','transform:rotateY(180deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg)');
											break;
										case 3 :
											img.setAttribute('style','transform:rotate(180deg)');
											img.setAttribute('lytecbox-rotate','rotate(180deg)');
											break;
										case 4 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(180deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(180deg)');
											break;
										case 5 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(90deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(90deg)');
											break;
										case 6 :
											img.setAttribute('style','transform:rotate(90deg)');
											img.setAttribute('lytecbox-rotate','rotate(90deg)');
											break;
										case 7 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(-90deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(-90deg)');
											break;
										case 8 :
											img.setAttribute('style','transform:rotate(-90deg)');
											img.setAttribute('lytecbox-rotate','rotate(-90deg)');
											break;
							        }
								}
								img.classList.remove('lyteCBoxDNImp');
								img.classList.remove('lyteColorBoxDisableTransition');
								LyteColorbox.checkAspectRatio();
								LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
							}
						})
				}
				else{
					if(getExifData){
						console.log("Couldn't fetch exifdata as the plugin is not included.");
					}
					img.classList.remove('lyteCBoxDNImp');
					LyteColorbox.checkAspectRatio();
					LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
				}
			}
			else{
				LyteColorbox.toggleLoadingIcon();
				LyteColorbox.appendElement(LyteColorbox._domEle);	
				if(getExifData && $L.exif){
					img._index = LyteColorbox._index;
					$L.exif({
							target : img,
							getData : function(obj){
								// console.log('lyte-exif', obj.exifdata);
								img = obj.target;
								img.classList.add('lyteColorBoxDisableTransition');
								if(getComputedStyle(img).imageOrientation != "from-image"){
									var rValue = obj.exifdata.Orientation;
									switch(rValue) {
										case 2 :
											img.setAttribute('style','transform:rotateY(180deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg)');
											img.setAttribute('data-orientation',2);
											break;
										case 3 :
											img.setAttribute('style','transform:rotate(180deg)');
											img.setAttribute('lytecbox-rotate','rotate(180deg)');
											img.setAttribute('data-orientation',3);
											break;
										case 4 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(180deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(180deg)');
											img.setAttribute('data-orientation',4);
											break;
										case 5 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(90deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(90deg)');
											img.setAttribute('data-orientation',5);
											break;
										case 6 :
											img.setAttribute('style','transform:rotate(90deg)');
											img.setAttribute('lytecbox-rotate','rotate(90deg)');
											img.setAttribute('data-orientation',6);
											break;
										case 7 :
											img.setAttribute('style','transform:rotateY(180deg) rotate(-90deg)');
											img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(-90deg)');
											img.setAttribute('data-orientation',7);
											break;
										case 8 :
											img.setAttribute('style','transform:rotate(-90deg)');
											img.setAttribute('lytecbox-rotate','rotate(-90deg)');
											img.setAttribute('data-orientation',8);
											break;
							        }
								}
								img.classList.remove('lyteCBoxDNImp');
								img.classList.remove('lyteColorBoxDisableTransition');
								LyteColorbox.checkAspectRatio();
								if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
									// setTimeout(function(){
										LyteColorbox.slide();
									// },10);
								}
								LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
							}
						})
				}
				else{
					if(getExifData){
						console.log("Couldn't fetch exifdata as the plugin is not included.");
					}
					img.classList.remove('lyteCBoxDNImp');
					LyteColorbox.checkAspectRatio();
					if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
						// setTimeout(function(){
							LyteColorbox.slide();
						// },10);
					}
					LyteColorbox._component.callOnComplete(LyteColorbox._domEle,LyteColorbox._index);
				}
			}
		}
		else {
			img = this.querySelector( 'img' );

			LyteColorbox.checkAndChangeStatus( img );
			img._offset = {
				height : img.naturalHeight,
				width : img.naturalWidth
			};

			LyteColorbox.hideLoadingIcon( this );
			// Ask if index will be proper
			if(getExifData && $L.exif){
				img._index = LyteColorbox._index;
				$L.exif({
						target : img,
						getData : function(obj){
							// console.log('lyte-exif', obj.exifdata);
							img = obj.target;
							img.classList.add('lyteColorBoxDisableTransition');
							if(getComputedStyle(img).imageOrientation != "from-image"){
								var rValue = obj.exifdata.Orientation;
								switch(rValue) {
									case 2 :
										img.setAttribute('style','transform:rotateY(180deg)');
										img.setAttribute('lytecbox-rotate','rotateY(180deg)');
										img.setAttribute('data-orientation',2);
										break;
									case 3 :
										img.setAttribute('style','transform:rotate(180deg)');
										img.setAttribute('lytecbox-rotate','rotate(180deg)');
										img.setAttribute('data-orientation',3);
										break;
									case 4 :
										img.setAttribute('style','transform:rotateY(180deg) rotate(180deg)');
										img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(180deg)');
										img.setAttribute('data-orientation',4);
										break;
									case 5 :
										img.setAttribute('style','transform:rotateY(180deg) rotate(90deg)');
										img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(90deg)');
										img.setAttribute('data-orientation',5);
										break;
									case 6 :
										img.setAttribute('style','transform:rotate(90deg)');
										img.setAttribute('lytecbox-rotate','rotate(90deg)');
										img.setAttribute('data-orientation',6);
										break;
									case 7 :
										img.setAttribute('style','transform:rotateY(180deg) rotate(-90deg)');
										img.setAttribute('lytecbox-rotate','rotateY(180deg) rotate(-90deg)');
										img.setAttribute('data-orientation',7);
										break;
									case 8 :
										img.setAttribute('style','transform:rotate(-90deg)');
										img.setAttribute('lytecbox-rotate','rotate(-90deg)');
										img.setAttribute('data-orientation',8);
										break;
						        }
							}
							LyteColorbox._component.callOnLoad( img,img._index, img.exifdata );
							// img.classList.add('lyteCBoxVisible');
							img.classList.remove('lyteColorBoxDisableTransition');

							// only calculate aspect ratio if it is current displayed image
							if( LyteColorbox._domEle === img ) {
								img.classList.add('lyteCBoxVisible');
								LyteColorbox.checkAspectRatio();
							}
							LyteColorbox._component.callOnComplete(img, img._index);
							// LyteColorbox.setPercentage();
						}
					})
			}
			else{
				if(getExifData){
					console.log("Couldn't fetch exifdata as the plugin is not included.");
				}
				LyteColorbox._component.callOnLoad( img, LyteColorbox._index );
				img.classList.add('lyteCBoxVisible');

				// only calculate aspect ratio if it is current displayed image
				if( LyteColorbox._domEle === img ) {
					LyteColorbox.checkAspectRatio();
				}
				LyteColorbox._component.callOnComplete(img,LyteColorbox._index);
				// LyteColorbox.setPercentage();
			}
		}
		
	},

	/**
	 * The method is triggered when the image fails to load
	 *
	 */
	imageFailure : function(){
		var type = LyteColorbox._component.getData( 'ltPropType' ), img;
		if(type === 'custom'){
			img = LyteColorbox._domEle;
			LyteColorbox.toggleLoadingIcon();
		}
		else{
			img = this.querySelector( 'img' );
			LyteColorbox.hideLoadingIcon( this );
		}
		LyteColorbox._component.callOnFailure(img,LyteColorbox._index,LyteColorbox._content);
	},

	/**
	 * The method is going to update the thumbnail based on the item shown in the colorbox
	 *
	 */
	updateThumbnailPos : function(){
		var ind = LyteColorbox._index,
			total = LyteColorbox._component.getData('ltPropThumbnailNumber'),
			mean = parseInt(total / 2),
			end = total % 2 == 0 ? LyteColorbox._related.length : LyteColorbox._related.length - 1,
			div = LyteColorbox._thumbDiv.querySelector('.lyteColorboxThumbInnerWrapper'),
			thumbnails = LyteColorbox._thumbDiv.querySelectorAll('.lyteColorboxThumb'),
			thumbnailsOffset = window.getComputedStyle(thumbnails[0]),
			thumbnailWidth = (parseInt(thumbnailsOffset.width) + (thumbnailsOffset.marginLeft ? parseInt(thumbnailsOffset.marginLeft) : 0) + (thumbnailsOffset.marginRight ? parseInt(thumbnailsOffset.marginRight) : 0)),
			direction = /*LyteColorbox._component.getData('ltPropDirection') == 'rtl'*/_lyteUiUtils.getRTL() ? -1 : 1;
		if(LyteColorbox._component.getData('ltPropType') === "custom"){
			if(ind >= mean && ind <= (end - mean)){
				div.style.transform = "translate("+((mean - ind)*thumbnailWidth * direction)+"px,0)";
			}
			else if(ind < mean){
				div.style.transform = "translate(0,0)";
			}
			else if(ind > (end - mean) && LyteColorbox._related.length > total){
				div.style.transform = "translate("+((mean - (end - mean))*thumbnailWidth * direction)+"px,0)";
			}
		}
		else{
			var width = LyteColorbox._thumbDiv.offsetWidth;
			total = Math.floor(width/thumbnailWidth);
			mean = parseInt(total / 2);
			if(ind >= mean && ind <= (end - mean)){
				var left = 0;
				if((ind == mean || ind == (end - mean)) && total % 2 == 0){
					LyteColorbox._diff = left = thumbnailWidth / 2 * (-direction);
				}
				if(ind > mean && ind < (end - mean)){
					left = ((mean - ind)*thumbnailWidth * direction) + ((width - total * thumbnailWidth) / 2) + LyteColorbox._diff;
				}
				if(ind == (end - mean)){
					left = (width - LyteColorbox._related.length * thumbnailWidth) * direction + (thumbnailsOffset.marginRight ? parseInt(thumbnailsOffset.marginRight) : 0);
				}
				div.style.transform = "translate("+/*((mean - ind)*thumbnailWidth * direction)*/left+"px,0)";
			}
			else if(ind < mean){
				div.style.transform = "translate(0,0)";
			}
			else if(ind > (end - mean) && LyteColorbox._related.length > total){
				var left = (width - LyteColorbox._related.length * thumbnailWidth) * direction + (thumbnailsOffset.marginRight ? parseInt(thumbnailsOffset.marginRight) : 0);
				div.style.transform = "translate("+left+"px,0)";
			}
		}
	},

	calculateOverlayHeight : function(winheight){
		if(!LyteColorbox._component.getData('ltPropYield')){
			LyteColorbox._overlay.style.height = winheight - 50 + "px";
		}
		else{
			LyteColorbox._overlay.style.height = LyteColorbox._overlay.getBoundingClientRect().height + "px";
		}
	},

	/**
	 * The method is going to do the calculation when images are loaded in a custom lyte-colorbox and will set the height and width
	 * @param {object} event - The event object
	 * @param {DOM element} photo - The image element
	 * @param {boolean} preventCheckAspectRatio - Boolean value based on which the aspect ratio of the image is checked
	 *
	 */
	computeOffsetImpl : function(event,photo,preventCheckAspectRatio){
		var comp = LyteColorbox._component, 
		type = comp.getData( 'ltPropType' ),
		header = type === 'custom' ? document.querySelector('.lyteColorboxHeader') : comp._header;

		if( LyteColorbox._open && LyteColorbox._overlay) {
			var winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    	var winheight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    	if(LyteColorbox._component.getData('ltPropThumbnail')){
	    		var cs = window.getComputedStyle(LyteColorbox._thumbDiv);
	    		winheight = winheight - (parseInt(cs.height) + parseInt(cs.marginTop));
	    	}
			var offset = {};
			if(!LyteColorbox._first){
				window.removeEventListener('resize',LyteColorbox.computeOffsetImpl);
			}
			LyteColorbox._first = false;
	    	var overlayOffset = LyteColorbox._overlay.getBoundingClientRect();
			if(photo){
				if(LyteColorbox._component.getData('ltPropHeight')){
					offset.conHeight = parseInt(LyteColorbox._component.getData('ltPropHeight'));
				}
				else{
					if(photo.height >= overlayOffset.height){
						offset.conHeight = overlayOffset.height;
					}
					else{
						offset.conHeight = photo.height;
					}
				}
				if(LyteColorbox._component.getData('ltPropWidth')){
					offset.conWidth = parseInt(LyteColorbox._component.getData('ltPropWidth'));
				}
				else{
					if(photo.width >= overlayOffset.width){
						offset.conWidth = overlayOffset.width;
					}
					else{
						offset.conWidth = photo.width;
					}
				}

				LyteColorbox.toggleLoadingIcon();
				LyteColorbox.appendElement(photo);
				if(!preventCheckAspectRatio){
					LyteColorbox.checkAspectRatio();
				}
				LyteColorbox._active = false;

			}
			if(!LyteColorbox._component.getData('ltPropYield')){
				offset.top = (winheight - LyteColorbox._content.getBoundingClientRect().height) / 2 ;
				offset.left = (winWidth - LyteColorbox._content.getBoundingClientRect().width) / 2;
				offset.iconTop = ((winheight - LyteColorbox._next.getBoundingClientRect().height) / 2 ) + (header.getBoundingClientRect().height / 2);
			}
			else{
				var contentOffset = LyteColorbox._content.getBoundingClientRect();
				var overlayOffset = LyteColorbox._overlay ? LyteColorbox._overlay.getBoundingClientRect() : {height : winheight, width : winWidth};
				LyteColorbox._content.style.top = (overlayOffset.height - contentOffset.height) / 2 + "px";
				LyteColorbox._content.style.left = (overlayOffset.width - contentOffset.width) / 2 + "px";
				if(window.getComputedStyle(LyteColorbox._content).transform){
					LyteColorbox._content.style.transform = "none";
				}
			}
			if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
				LyteColorbox.slide();
			}
			
			window.addEventListener('resize',LyteColorbox.computeOffsetImpl);
		}
	},

	/**
	 * The method is going to append the image containing div for image type lyte-colorbox
	 *
	 */
	appendElementForImage : function() {
		var ele,
		comp = LyteColorbox._component;

		if(LyteColorbox._nextItem){
			ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');

			// ele.append(element);
			LyteColorbox._component.setData('currentEle',ele);
			var item = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+(LyteColorbox._index + 1));
			if(!item){
				LyteColorbox._content.append(ele);
			}
			else{
				LyteColorbox._content.insertBefore(ele,item.parentElement);
			}
		}
		else if(LyteColorbox._prevItem){
			ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');


			// ele.append(element);
			LyteColorbox._component.setData('currentEle',ele);
			var item = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+(LyteColorbox._index + 1));
			if(!item){
				LyteColorbox._content.append(ele);
			}
			else{
				LyteColorbox._content.insertBefore(ele,item.parentElement);
			}
		}
		else{
			ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');
			// ele.append(element);


			LyteColorbox._content.append(ele);
			LyteColorbox._component.setData('currentEle',ele);
		}
		// element.classList.add('lyteCBoxVisible');

		LyteColorbox.createLoadingIcon( ele );

		return ele;
	},

	/**
	 * The method is going to create the loading icon and append it
	 * @param {DOM element} div - The div that contains the loading icon
	 *
	 */
	createLoadingIcon: function( div ) {
		var loadingIcon;
		if(LyteColorbox._loadingIcon){
			loadingIcon = LyteColorbox._loadingIcon.cloneNode();
		}
		else{
			loadingIcon = document.createElement( 'div' );
			loadingIcon.innerHTML = unescape("%3Csvg%20class%3D%22lyteColorboxLoadingCircle%22%20width%3D%2230%22%20height%3D%2230%22%20viewBox%3D%220%200%2030%2030%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20data-svg%3D%22spinner%22%3E%3Ccircle%20fill%3D%22none%22%20stroke%3D%22%23000%22%20cx%3D%2215%22%20cy%3D%2215%22%20r%3D%2214%22%3E%3C/circle%3E%3C/svg%3E");
		}
		loadingIcon.classList.add( 'lyteColorboxLoadingImg' );
		div.appendChild( loadingIcon );
	},

	/**
	 * The method is going to append the element that will be shown to the colorbox
	 * @param {classList} arr - The classlist under question
	 *
	 */
	appendElement : function(element){
		var comp = LyteColorbox._component,
		type = comp.getData( 'ltPropType' );

		if(LyteColorbox._component.getData('ltPropAnimation') == "slide"){
			var ele;
			LyteColorbox._zIndex++;
			if(LyteColorbox._nextItem){
				ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');

				//if( type === 'custom' ) {
					ele.classList.add('lytCBoxNextItem');
				// }
				ele.append(element);
				LyteColorbox._component.setData('currentEle',ele);
				var item = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+(LyteColorbox._index + 1));
				if(!item){
					LyteColorbox._content.append(ele);
				}
				else{
					LyteColorbox._content.insertBefore(ele,item.parentElement);
				}
			}
			else if(LyteColorbox._prevItem){
				ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');

				// if( type === 'custom' ) {
					ele.classList.add('lytCBoxPreviousItem');
				// }
				ele.append(element);
				LyteColorbox._component.setData('currentEle',ele);
				var item = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+(LyteColorbox._index + 1));
				if(!item){
					LyteColorbox._content.append(ele);
				}
				else{
					LyteColorbox._content.insertBefore(ele,item.parentElement);
				}
			}
			else{
				ele = LyteColorbox.createElement('div',null,'lyteCBoxItem');
				ele.append(element);

				// if( type === 'custom' ) {
					ele.style.zIndex = LyteColorbox._zIndex;
				// }

				LyteColorbox._content.append(ele);
				LyteColorbox._component.setData('currentEle',ele);
			}
			element.classList.add('lyteCBoxVisible');
		}
		else{
			if(LyteColorbox._related.length > 1){
				var item = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+(LyteColorbox._index + 1));
				if(item){
					LyteColorbox._content.insertBefore(element, item);
				}
				else{
					LyteColorbox._content.append(element);
				}
			}
			else{
				LyteColorbox._content.append(element);
			}
			element.classList.add('lyteCBoxVisible');
			LyteColorbox.checkHW();
			LyteColorbox._component.setData('currentEle',null);
		}
	},

	isZoomed: function( img ) {
		return img && !img._isDefault;
	},

	isCurrentDisplayedImage: function( img ) {
		return img === LyteColorbox._domEle;
	},

	isZoomedAndCurrentDisplayedImage: function( img ) {
		// console.log( LyteColorbox._clickNumber, LyteColorbox._domEle, img ); 
		return !img._isDefault && LyteColorbox._domEle === img;
		// return LyteColorbox._domEle === img && LyteColorbox.isImageZoomed( img );
	},

	transitionEnd: function( event ) {
		var img;

		if( event.target === this && event.propertyName === 'transform' ) {
			img = this.querySelector( 'img' );

			if( LyteColorbox.isZoomed( img ) && !LyteColorbox.isCurrentDisplayedImage( img ) ) {
				LyteColorbox.reset( img );
			}

			// if( LyteColorbox.isZoomedAndNotCurrentDisplayedImage( img ) ) {
				
			// }
			// else {
			// 	LyteColorbox.reset( img );
			// }
			
			this.removeEventListener( 'transitionend', LyteColorbox.transitionEnd );
			// LyteColorbox.showScrollbar();
		}
	},

	doesImageExceedContentBoxAfterMovingRight: function( imgOffsets, contentOffsets ) {
		return imgOffsets.left < contentOffsets.left;
	},

	/**
	 * The method is going to move the element out of view towards right in colorbox
	 * @param {DOM element} elementMovingOutOfView - The div containing the image
	 * @param {classList} className - className to be removed
	 *
	 */
	moveElementOutOfViewTowardsRight: function( elementMovingOutOfView, className ) {
		var content = elementMovingOutOfView,
		img = elementMovingOutOfView.querySelector( 'img' ),
		contentOffsets = content.getBoundingClientRect(),
		imgOffsets,
		exceededBy, contentWidth = contentOffsets.width,
		percentExceededWithRespectToParent,
		totalTranslateValue = 100,
		translateBy;

		if( img ) {
			imgOffsets = img.getBoundingClientRect();

			if( LyteColorbox.doesImageExceedContentBoxAfterMovingRight( imgOffsets, contentOffsets ) ) {
				exceededBy = contentOffsets.left - imgOffsets.left;
				percentExceededWithRespectToParent = ( exceededBy / contentWidth ) * 100;
				totalTranslateValue += percentExceededWithRespectToParent;
			}
		}

		elementMovingOutOfView.style.transition = 'transform 0.3s ease';
		elementMovingOutOfView.style.transform = 'translate3d(' + totalTranslateValue + '%,0,0)';
		elementMovingOutOfView.classList.remove( className );
	},

	doesImageExceedContentBoxAfterMovingLeft: function( imgOffsets, contentOffsets ) {
		return imgOffsets.right > contentOffsets.right;
	},

	/**
	 * The method is going to move the element out of view towards left in colorbox
	 * @param {DOM element} elementMovingOutOfView - The div containing the image
	 * @param {classList} className - className to be removed
	 *
	 */
	moveElementOutOfViewTowardsLeft: function( elementMovingOutOfView, className ) {
		var content = elementMovingOutOfView,
		img = elementMovingOutOfView.querySelector( 'img' ),
		contentOffsets = content.getBoundingClientRect(),
		imgOffsets, exceededBy, contentWidth = contentOffsets.width,
		percentExceededWithRespectToParent,
		totalTranslateValue = 100,
		translateBy;

		if( img ) {
			imgOffsets = img.getBoundingClientRect();

			if( LyteColorbox.doesImageExceedContentBoxAfterMovingLeft( imgOffsets, contentOffsets ) ) {
				exceededBy = imgOffsets.right - contentOffsets.right;
				percentExceededWithRespectToParent = ( exceededBy / contentWidth ) * 100;
				totalTranslateValue += percentExceededWithRespectToParent;
			}
		}

		elementMovingOutOfView.style.transition = 'transform 0.3s ease';
		elementMovingOutOfView.style.transform = 'translate3d(-' + totalTranslateValue + '%,0,0)';
		elementMovingOutOfView.classList.remove( className );
	},

	/**
	 * The method is going to show the slide animation when another item from the list is opened in the colorbox
	 *
	 */
	slide : function(){
		var comp = LyteColorbox._component,
		ele = comp.getData('currentEle'),
		elementMovingIntoView = ele,
		type = comp.getData( 'ltPropType' ),
		elementMovingOutOfView, className = 'lyteCBoxCurrentItem';

		if( type === 'custom' ) {
			if(ele){
				LyteColorbox.checkHW();
				if(LyteColorbox._nextItem){
					var elements = Array.from(ele.parentElement.querySelectorAll('.lyteCBoxCurrentItem')) /*$L('.lyteCBoxCurrentItem',ele.parentElement).e).filter(function(element){return !element.isEqualNode(ele)})*/;
					for(var i = 0; i < elements.length; i++){
						elements[i].classList.add('lytCBoxPreviousItem');
					}
				}
				if(LyteColorbox._prevItem){
					var elements = Array.from(ele.parentElement.querySelectorAll('.lyteCBoxCurrentItem')) /*$L('.lyteCBoxCurrentItem',ele.parentElement).e).filter(function(element){return !element.isEqualNode(ele)})*/;
					for(var i = 0; i < elements.length; i++){
						elements[i].classList.add('lytCBoxNextItem');
					}
				}
				ele.style.zIndex = LyteColorbox._zIndex;
				ele.classList.add('lyteCBoxCurrentItem');
				if(LyteColorbox._nextItem || LyteColorbox._prevItem){
					if(LyteColorbox._timeoutId){
						clearTimeout(LyteColorbox._timeoutId);
						LyteColorbox._timeoutId = false;
					}
					LyteColorbox._timeoutId = setTimeout(function(){
						ele.classList.remove('lytCBoxPreviousItem','lytCBoxNextItem');
						var elements = Array.from(ele.parentElement.querySelectorAll('.lyteCBoxCurrentItem') /*$L('.lyteCBoxCurrentItem',ele.parentElement).e*/).filter(function(element){return !element.isEqualNode(ele)});
						for(var i = 0; i < elements.length; i++){
							// elements[i].remove();
							elements[i].classList.remove('lytCBoxNextItem','lytCBoxPreviousItem','lyteCBoxCurrentItem');
							elements[i].classList.add('lyteCBoxDN');
						}
						// ele.style.zIndex = 0;
						// LyteColorbox._zIndex = 0;
						LyteColorbox._timeoutId = false;
					},300);
					LyteColorbox._nextItem = false;
					LyteColorbox._prevItem = false;
				}
			}
		}
		else {
			if( elementMovingIntoView ) {

				if( elementMovingIntoView ) {

					if( LyteColorbox._nextItem ) {
						elementMovingOutOfView = elementMovingIntoView.parentElement.querySelector( '.lyteCBoxCurrentItem' );
						if(!elementMovingOutOfView){
							elementMovingOutOfView = elementMovingIntoView.parentElement.querySelector( '.lyteCBoxMoveRight' );
							className = 'lyteCBoxMoveRight';
						}
						LyteColorbox.moveElementOutOfViewTowardsLeft( elementMovingOutOfView, className );
						// elementMovingOutOfView.classList.add( 'lyteCBoxMoveLeftWithTransition' );
						// elementMovingOutOfView.classList.remove( 'lyteCBoxCurrentItem' );

						elementMovingIntoView.style.removeProperty( 'transition' );
						elementMovingIntoView.classList.add( 'lyteCBoxMoveRight' );
						elementMovingIntoView.style.removeProperty( 'transform' );
						// elementMovingIntoView.classList.remove( 'lyteCBoxMoveLeftWithTransition' );
						// elementMovingIntoView.classList.remove( 'lyteCBoxMoveRightWithTransition' );
						
					}

					if( LyteColorbox._prevItem ) {
						elementMovingOutOfView = elementMovingIntoView.parentElement.querySelector( '.lyteCBoxCurrentItem' );
						if(!elementMovingOutOfView){
							elementMovingOutOfView = elementMovingIntoView.parentElement.querySelector( '.lyteCBoxMoveLeft' );
							className = 'lyteCBoxMoveLeft';
						}
						LyteColorbox.moveElementOutOfViewTowardsRight( elementMovingOutOfView, className );
						// elementMovingOutOfView.classList.add( 'lyteCBoxMoveRightWithTransition' );
						// elementMovingOutOfView.classList.remove( 'lyteCBoxCurrentItem' );

						elementMovingIntoView.style.removeProperty( 'transition' );
						elementMovingIntoView.classList.add( 'lyteCBoxMoveLeft' );
						elementMovingIntoView.style.removeProperty( 'transform' );
						// elementMovingIntoView.classList.remove( 'lyteCBoxMoveRightWithTransition' );
						// elementMovingIntoView.classList.remove( 'lyteCBoxMoveLeftWithTransition' );
						
					}

					if( elementMovingOutOfView ) {
						elementMovingOutOfView.addEventListener( 'transitionend', LyteColorbox.transitionEnd );
					}

					// Remove it to cause the animation
					var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
                    var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
                    if(LyteColorbox._reqAF1){
						cancelAnimationFrame(LyteColorbox._reqAF1);
					}
					if(LyteColorbox._reqAF2){
						cancelAnimationFrame(LyteColorbox._reqAF2);
					}
					LyteColorbox._reqAF1 = requestAnimationFrame( function() {
						LyteColorbox._reqAF1 = false;
						// Firefox requires two requestAnimationFrames for this to work
						LyteColorbox._reqAF2 = requestAnimationFrame( function() {
							LyteColorbox._reqAF2 = false;
							elementMovingIntoView.classList.remove( 'lyteCBoxMoveLeft', 'lyteCBoxMoveRight', 'lytCBoxPreviousItem', 'lytCBoxNextItem' );
							elementMovingIntoView.classList.add( 'lyteCBoxCurrentItem' );
						} );
					} );
												
					

					LyteColorbox._nextItem = false;
					LyteColorbox._prevItem = false;
				}

				
			}
		}
	},
	
	/**
	 * The method is going to navigate to the next item/image in the LyteColorbox._related list
	 * @param {object} event - Event object
	 * @param {boolean} stopMethod - boolean value that determines if the onNavigate method will be triggered or not
	 *
	 */
	next : function (event,stopMethod) {
		var promise, that = LyteColorbox._component,
		loop = that.getData( 'ltPropLoop' ),
		curIndex = LyteColorbox._index + 1,
		totalLength = ( LyteColorbox._related || [] ).length;

		if( !loop && curIndex >= totalLength ) {
			return ;
		}

		if( that.getMethods( 'onBeforeNavigate' ) ) {
			promise = that.executeMethod( 'onBeforeNavigate', event, that.$node, LyteColorbox._index, 1 );
		}

		if( promise ) {
			promise.then( function() {
				LyteColorbox.moveToNext( event, stopMethod );
			} );
		}
		else {
			LyteColorbox.moveToNext( event, stopMethod );
		}
	},

	moveToNext: function( event, stopMethod ) {
		var comp = LyteColorbox._component,
		type = comp.getData( 'ltPropType' );

		if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._related[(LyteColorbox._index + 1)])) {
			if(LyteColorbox._component.getData('ltPropAnimation') != "slide"){
				LyteColorbox.hideElement();
				// LyteColorbox.toggleLoadingIcon();
				// document.querySelector('.lyteCBoxPhoto').remove();
			}else{
				// LyteColorbox.hideScrollbar();
				LyteColorbox._nextItem = true;
			}
			// if(LyteColorbox._clickNumber != 0){
			// 	LyteColorbox._clickNumber = 0;
			// }
			LyteColorbox.toggleLoadingIcon();

			if( type === 'custom' ) {
				LyteColorbox.reset();
			}
			
			LyteColorbox._index = LyteColorbox.getIndex(1);
			LyteColorbox._domEle = null;
			LyteColorbox.load(LyteColorbox._el = LyteColorbox._related[LyteColorbox._index]);
			!stopMethod && LyteColorbox._component.getMethods("onNavigate") && LyteColorbox._component.executeMethod('onNavigate',event,LyteColorbox._component.$node,LyteColorbox._index+1, 1 );
		}
	},

	/**
	 * The method is going to navigate to the previous item/image in the LyteColorbox._related list
	 * @param {object} event - Event object
	 * @param {boolean} stopMethod - boolean value that determines if the onNavigate method will be triggered or not
	 *
	 */
	prev : function (event,stopMethod) {
		var promise, that = LyteColorbox._component,
		curIndex = LyteColorbox._index,
		loop = that.getData( 'ltPropLoop' );

		if( !loop && curIndex === 0 ) {
			return ;
		}

		if( that.getMethods( 'onBeforeNavigate' ) ) {
			promise = that.executeMethod( 'onBeforeNavigate', event, that.$node, LyteColorbox._index, -1 );
		}

		if( promise ) {
			promise.then( function() {
				LyteColorbox.moveToPrevious( event, stopMethod );
			} );
		}
		else {
			LyteColorbox.moveToPrevious( event, stopMethod );
		}
	},

	moveToPrevious: function( event, stopMethod ) {
		var comp = LyteColorbox._component,
		type = comp.getData( 'ltPropType' );

		if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._index)) {
			if(LyteColorbox._component.getData('ltPropAnimation') != "slide"){
				LyteColorbox.hideElement();
				// LyteColorbox.toggleLoadingIcon();
				// document.querySelector('.lyteCBoxPhoto').remove();
			}else{
				// LyteColorbox.hideScrollbar();
				LyteColorbox._prevItem = true;
			}
			// if(LyteColorbox._clickNumber != 0){
			// 	LyteColorbox._clickNumber = 0;
			// }
			LyteColorbox.toggleLoadingIcon();

			if( type === 'custom' ) {
				LyteColorbox.reset();
			}

			LyteColorbox._index = LyteColorbox.getIndex(-1);
			LyteColorbox._domEle = null;
			LyteColorbox.load(LyteColorbox._el = LyteColorbox._related[LyteColorbox._index]);
			!stopMethod && LyteColorbox._component.getMethods("onNavigate") && LyteColorbox._component.executeMethod('onNavigate',event,LyteColorbox._component.$node,LyteColorbox._index+1, -1 );
		}
	},

	/**
	 * The method is going to close the colorbox and remove all the related properties
	 *
	 */
	close : function () {
		if (LyteColorbox._open && !LyteColorbox._closing) {
			LyteColorbox._component.setData('currentEle',null);
			document.body.classList.remove('lyteCBoxOH');
			LyteColorbox._content.classList.remove('lyteCBoxOH');
			if(LyteColorbox._component.getData('ltPropThumbnail')){
				var thumbnails = LyteColorbox._thumbDiv.querySelector('.lyteColorboxThumbnails');
				var thumbs = LyteColorbox._thumbDiv.querySelector('.lyteColorboxThumbInnerWrapper');
				thumbnails.style.width = "";
				thumbnails.classList.add('lyteColorboxHideVisibility');
				thumbs.style.transform = "";
				thumbs.style.width = "";
			}

			// We don't need to call check and change status over here because we just destroy all the images
			if(LyteColorbox._zoomIn){
				LyteColorbox._zoomIn.classList.remove('lyteColorboxDisabled');
			}

			if(LyteColorbox._zoomOut && LyteColorbox._component.getData( 'ltPropType' ) != 'image'){
				LyteColorbox._zoomOut.classList.add('lyteColorboxDisabled');
			}

			if(LyteColorbox._reset){
				LyteColorbox._reset.classList.add('lyteColorboxDisabled');
			}
			LyteColorbox._clickNumber = 0;
			LyteColorbox._zoomedThroughUtil = false;
			LyteColorbox._closing = true;
			LyteColorbox._open = false;
			LyteColorbox._box.classList.remove('lyteColorboxDisplay');
			LyteColorbox._domEle = null;
			LyteColorbox._related = [];
			LyteColorbox._closing = false;
			LyteColorbox._el = null;
			LyteColorbox._diff = 0;
			LyteColorbox.removeElements();
			LyteColorbox.toggleLoadingIcon();
			LyteColorbox._loadingIcon = null;
			LyteColorbox._component.callOnClose();
		}
	},

	/**
	 * The method is going to perform the download action
	 *
	 */
	download : function(){
		var returnVal = true;
		if(LyteColorbox._component.getMethods('onDownload')){
			returnVal = LyteColorbox._component.executeMethod('onDownload',LyteColorbox._domEle,LyteColorbox._el, LyteColorbox._component.$node);
			returnVal = returnVal === undefined ? true : returnVal;
		}
		if(!returnVal){
			return;
		}
		var a = document.createElement('a');
		if(LyteColorbox._el.lytecboxDlink){
			a.setAttribute("href", LyteColorbox._el.lytecboxDlink);
		}else{
			if(LyteColorbox._el.type == "photo"){
				a.setAttribute("href", LyteColorbox._el.lytecboxHref);
			}
		}
		a.setAttribute("download", LyteColorbox.createName(LyteColorbox._el.lytecboxTitle));
		document.body.append(a);
		a.click();
		a.remove();
	},

	isIE : function(){
		var ua = window.navigator.userAgent;

	    var msie = ua.indexOf('MSIE ');
	    if (msie > 0) {
	        // IE 10 or older => return version number
	        // return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	        return true;
	    }

	    var trident = ua.indexOf('Trident/');
	    if (trident > 0) {
	        // IE 11 => return version number
	        var rv = ua.indexOf('rv:');
	        // return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	        return true;
	    }

	    // var edge = ua.indexOf('Edge/');
	    // if (edge > 0) {
	    //    // Edge => return version number
	    //    // return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	    //    return true;
	    // }

	    // other browser
	    return false;
	},

	/**
	 * The method is going to zoom the image by the mentioned scale
	 * @param {number} newScale - New scale value by which the image will be zoomed in or out
	 * @param {object} originPoint - left and top values that determine the position at which the image will be zoomed
	 * @param {DOM element} image - image element
	 *
	 */
	zoomTo : function( newscale, originPoint, image ){
		originPoint = originPoint || {};
		var comp = LyteColorbox._component,
		orientation = image.getAttribute('lytecbox-rotate'),
		width = image.offsetWidth,
        height = image.offsetHeight,
        bcr = image.getBoundingClientRect(),
        contentOffsets = LyteColorbox._content.getBoundingClientRect(),
        xPt = originPoint.left || ( comp.getData('ltPropZoomPosition') == "center" ? contentOffsets.left + contentOffsets.width * 0.5 : bcr.left + bcr.width * 0.5 ),
        yPt = originPoint.top || ( comp.getData('ltPropZoomPosition') == "center" ? contentOffsets.top + contentOffsets.height * 0.5 : bcr.top + bcr.height * 0.5 ),
        transform = image.style.transform,
        transformOrigin = image.style.transformOrigin,
        matches = transform.match( /scale\((.+)\)/ ) || [ null, 1, 0 ,0 ],
        originMatch = transformOrigin.match( /(.+)% (.+)%/ ) || [ null, 50, 50 ],
        oldscale = parseFloat( matches[ 1 ] ),
        translateX = parseFloat( image.style.left || 0 ),
        translateY = parseFloat( image.style.top || 0 ),
        originX = parseFloat( originMatch[ 1 ] ),
        originY = parseFloat( originMatch[ 2 ] ),
        newOriginX = ( xPt - bcr.left ) / bcr.width * 100,
        newOriginY = ( yPt - bcr.top ) / bcr.height * 100,

        translateX2set = ( newOriginX - originX ) * 0.01 * width * ( oldscale - 1 ),
        
        translateY2set = ( newOriginY - originY ) * 0.01 * height * ( oldscale - 1 );
        
        image.style.transformOrigin = newOriginX + '% ' + newOriginY + '%';

        image.style.transform = "scale(" + newscale + ")" + (orientation == null ? '' : ' ' + orientation);
        image.style.left = ( translateX2set + translateX ) + 'px';
        image.style.top = ( translateY2set + translateY ) + 'px';
	},

	/**
	 * The method is going to return the transform property value
	 * @param {DOM element} ele - Image element
	 *
	 */
	getMatrixValue : function(ele){
		if(window.WebKitCSSMatrix){
			return new WebKitCSSMatrix( window.getComputedStyle( ele ).transform )
		}
		if(window.MSCSSMatrix){
			return new MSCSSMatrix( window.getComputedStyle( ele ).transform )
		}
	},

	/**
	 * The method is going to zoom the image based on the mouse wheel behaviour
	 * @param {object} event - Event object
	 *
	 */
	wheel : function( evt ){

		evt.preventDefault();
		var delta = evt.deltaMode && evt.deltaMode == 1,
		y = evt.deltaY * ( delta ? 6 : 1 ),
		x = evt.deltaX * ( delta ? 6 : 1 );
		if( Math.abs( y ) < Math.abs( x ) ){
            return;
        }
        if( Math.abs( y ) > 50 ){
        	if( y > 0 ){
        		y = 50;
        	} else {
        		y = -50;
        	}
        }
        
        var image = LyteColorbox._domEle,
        min = LyteColorbox._component.data.ltPropMinScale,
        max = LyteColorbox._component.data.ltPropMaxScale,
		matrix = LyteColorbox.getMatrixValue( image ),
		curZoom = LyteColorbox.getCurrentZoom( image ),
		newscale = Math.min( Math.max( /* matrix.a */ curZoom + ( y / 1000 ), min ), max );
        if( !image.classList.contains( 'preventAnimation' ) ){
            image.classList.add( 'preventAnimation' );
        }
        clearTimeout( image._timeout );
        image._timeout = setTimeout( function(){
            image.classList.remove( 'preventAnimation' );
        }, 500)

        this.zoomTo( newscale, { left : evt.clientX, top : evt.clientY }, image );
        LyteColorbox._zoom = true;
        LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.remove('lyteColorboxDisabled');
		LyteColorbox._reset && LyteColorbox._reset.classList.remove('lyteColorboxDisabled');
	},

	getCurrentZoom: function( img ) {
		var rscale = /scale\(([\d.]*)\)/,
		parsed = rscale.exec( img.style.transform ),
		scale = ( parsed || [] )[ 1 ] || '1';

		return parseFloat( scale );
	},

	checkAndChangeStatus: function( img ) {
		var currentZoom = LyteColorbox.getCurrentZoom( img ),
		no_zoom_scale = 1;

		if( currentZoom === no_zoom_scale ) {
			img._isDefault = true;
		}
		else {
			img._isDefault = false;
		}
	},

	/**
	 * The method is going to zoom in the image
	 *
	 */
	zoomIn : function(){
		LyteColorbox._clickNumber += 1;
		if(LyteColorbox._clickNumber <= LyteColorbox._component.getData('ltPropZoomClickNumber')){
			LyteColorbox.resetLeftAndTopHelpers();

			if( LyteColorbox._component.data.ltPropZoomPosition == "imageCenter" ){
				LyteColorbox._domEle.style.left = "0px";
				LyteColorbox._domEle.style.top = "0px";
				LyteColorbox._domEle.style.transformOrigin = "";
			}
			$L.fastdom.measure( function(){
				var zoomBy = parseFloat(LyteColorbox._component.getData('ltPropZoomBy')) / 100;
				// var matrix = LyteColorbox.getMatrixValue( LyteColorbox._domEle );
				var curZoom = LyteColorbox.getCurrentZoom( LyteColorbox._domEle );
				var offset = LyteColorbox._domEle.getBoundingClientRect();

				this.zoomTo( curZoom + zoomBy, {}, LyteColorbox._domEle );
				// this.zoomTo( matrix.a + zoomBy, {}, LyteColorbox._domEle );
				LyteColorbox.checkAndChangeStatus( LyteColorbox._domEle );
				if(LyteColorbox._clickNumber == 1 || (LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.contains('lyteColorboxDisabled')) || (LyteColorbox._reset && LyteColorbox._reset.classList.contains('lyteColorboxDisabled'))){
					LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.remove('lyteColorboxDisabled');
					LyteColorbox._reset && LyteColorbox._reset.classList.remove('lyteColorboxDisabled');
				}
				if(LyteColorbox._clickNumber == LyteColorbox._component.getData('ltPropZoomClickNumber')){
					LyteColorbox._zoomIn && LyteColorbox._zoomIn.classList.add('lyteColorboxDisabled');
				}
				LyteColorbox.setPercentage(undefined, curZoom + zoomBy);
				LyteColorbox._component.getMethods("onZoomin") && LyteColorbox._component.executeMethod('onZoomin',(Math.round((curZoom+zoomBy) * 100) - 100),LyteColorbox._component.$node);
				// LyteColorbox._component.getMethods("onZoomin") && LyteColorbox._component.executeMethod('onZoomin',(Math.round((matrix.a+zoomBy) * 100) - 100),LyteColorbox._component.$node);
			}.bind( this ))
		}
		else{
			LyteColorbox._clickNumber -= 1;
		}
	},

	/**
	 * The method is going to zoom out the image
	 *
	 */
	zoomOut : function(){
		LyteColorbox.resetLeftAndTopHelpers();
		if(LyteColorbox._zoom){		//if the picture is zoomed using the util function then reset it.
			var orientation = LyteColorbox._domEle.getAttribute('lytecbox-rotate');
			LyteColorbox._zoom = false;
			LyteColorbox._domEle.style.transform = (orientation ? orientation : "");
			LyteColorbox._domEle.style.top = "0px";
			LyteColorbox._domEle.style.left = "0px";
			LyteColorbox._domEle.style.transformOrigin = "";
			LyteColorbox.checkAndChangeStatus( LyteColorbox._domEle );
			LyteColorbox._clickNumber = 0;
			LyteColorbox._zoomedThroughUtil = false;
			LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.add('lyteColorboxDisabled');
			LyteColorbox._reset && LyteColorbox._reset.classList.add('lyteColorboxDisabled');
			if(LyteColorbox._zoomIn && LyteColorbox._zoomIn.classList.contains('lyteColorboxDisabled')){
				LyteColorbox._zoomIn.classList.remove('lyteColorboxDisabled');
			}
			LyteColorbox.setPercentage(undefined, 1);
			LyteColorbox._component.getMethods("onZoomout") && LyteColorbox._component.executeMethod('onZoomout',0,LyteColorbox._component.$node);
		}
		else{
			LyteColorbox._clickNumber -= 1;
			if(LyteColorbox._clickNumber >= 0 && LyteColorbox._clickNumber < LyteColorbox._component.getData('ltPropZoomClickNumber')){
				//Reset left and top helpers
				LyteColorbox._domEle._left = undefined;
				LyteColorbox._domEle._top = undefined;
				if( LyteColorbox._component.data.ltPropZoomPosition == "imageCenter" ){
					LyteColorbox._domEle.style.left = "0px";
					LyteColorbox._domEle.style.top = "0px";
					LyteColorbox._domEle.style.transformOrigin = "";
				}
				$L.fastdom.measure( function(){
					var zoomBy = parseFloat(LyteColorbox._component.getData('ltPropZoomBy')) / 100;
					//var matrix = LyteColorbox.getMatrixValue( LyteColorbox._domEle );
					// this.zoomTo( matrix.a - zoomBy, {}, LyteColorbox._domEle );
					var curZoom = LyteColorbox.getCurrentZoom( LyteColorbox._domEle );
					this.zoomTo( curZoom - zoomBy, {}, LyteColorbox._domEle );

					LyteColorbox.checkAndChangeStatus( LyteColorbox._domEle );
					if(LyteColorbox._clickNumber == 0){
						LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.add('lyteColorboxDisabled');
						LyteColorbox._reset && LyteColorbox._reset.classList.add('lyteColorboxDisabled');
					}
					if(LyteColorbox._clickNumber == LyteColorbox._component.getData('ltPropZoomClickNumber') - 1){
						LyteColorbox._zoomIn && LyteColorbox._zoomIn.classList.remove('lyteColorboxDisabled');
					}
					LyteColorbox.setPercentage(undefined, curZoom - zoomBy);
					LyteColorbox._component.getMethods("onZoomout") && LyteColorbox._component.executeMethod('onZoomout',(Math.round((curZoom-zoomBy)*100)-100),LyteColorbox._component.$node);
					// LyteColorbox._component.getMethods("onZoomout") && LyteColorbox._component.executeMethod('onZoomout',(Math.round((matrix.a-zoomBy)*100)-100),LyteColorbox._component.$node);
				}.bind( this ))
			}
			else{
				LyteColorbox._clickNumber += 1;
			}
		}
		
	},

	disableTransition: function( img ) {
		img.classList.add( 'lyteColorBoxDisableTransition' );
	},

	enableTransition: function( img ) {
		img.classList.remove( 'lyteColorBoxDisableTransition' );
	},

	/**
	 * The method is going to reset the zoomed behaviour of the image
	 *
	 */
	reset : function( elementToBeReset , onclick ) {
		elementToBeReset = elementToBeReset || LyteColorbox._domEle;
		var orientation = elementToBeReset.getAttribute('lytecbox-rotate');
		if( elementToBeReset.classList.contains(LyteColorbox._prefix+"Photo" ) && ( LyteColorbox._clickNumber > 0 || LyteColorbox._zoomedThroughUtil ) ){
			LyteColorbox.resetLeftAndTopHelpers();
			LyteColorbox._zoom = false;
			LyteColorbox._clickNumber = 0;
			LyteColorbox._zoomedThroughUtil = false;
			var width = elementToBeReset.offsetWidth,
			actualWidth = elementToBeReset.naturalWidth,
			value = (width / actualWidth) * 100;


			// don't remove the animation class when it is reset through the reset button
			if( !onclick ) {
				elementToBeReset.classList.remove( 'lyteCBoxAnimateOnUp' );
				LyteColorbox.disableTransition( elementToBeReset );
			}
			// elementToBeReset.classList.remove( 'lyteCBoxPhoto' );

			elementToBeReset.style.transform = (orientation ? orientation : "");
			elementToBeReset.style.top = "0px";
			elementToBeReset.style.left = "0px";
			elementToBeReset.style.transformOrigin = "";

			LyteColorbox.setPercentage(value % 1 != 0 ? value.toFixed(2) : value);
			LyteColorbox.checkAndChangeStatus( elementToBeReset );
			// LyteColorbox.checkAndChangeStatus( elementToBeReset );		

			if(LyteColorbox._zoomIn){
				LyteColorbox._zoomIn.classList.remove('lyteColorboxDisabled');
			}

			if(LyteColorbox._zoomOut){
				LyteColorbox._zoomOut.classList.add('lyteColorboxDisabled');
			}

			if(LyteColorbox._reset){
				LyteColorbox._reset.classList.add('lyteColorboxDisabled');
			}

			onclick && LyteColorbox._component.getMethods("onReset") && LyteColorbox._component.executeMethod('onReset', LyteColorbox._component.$node);

		}
	},

	resetLeftAndTopHelpers : function(){
		//Reset left and top helpers
		LyteColorbox._domEle._left = undefined;
		LyteColorbox._domEle._top = undefined;
		LyteColorbox._domEle.classList.remove('lyteCBoxAnimateOnUp');
	},

	/**
	 * The method is going to zoom the image by the value provided
	 * @param {number} value - zoom value
	 *
	 */
	zoomByUtilFn : function(value){
		if(LyteColorbox._domEle && LyteColorbox._domEle.classList.contains('lyteCBoxPhoto') && (value >= 0 || value === "fitWidth" || value === 'actual' || value === 'reset' )){
			var zoomBy, fit, curZoom;
			LyteColorbox.resetLeftAndTopHelpers();
			if(value === "fitWidth"){
				fit = true;
				var parentWidth = parseFloat(getComputedStyle(LyteColorbox._content).width),
				orientation = LyteColorbox._domEle.getAttribute('lytecbox-rotate'); 
				zoomBy = ((parentWidth / (orientation && orientation.indexOf('90') != -1 ? LyteColorbox._domEle.offsetHeight : LyteColorbox._domEle.offsetWidth)));
				LyteColorbox._zoomedThroughUtil = true;
				var value = (parentWidth / (orientation && orientation.indexOf('90') != -1 ? LyteColorbox._domEle.naturalHeight : LyteColorbox._domEle.naturalWidth)) * 100;
				LyteColorbox.setPercentage(value % 1 != 0 ? value.toFixed(2) : value);
			}
			else if( value === 'reset' ){
				zoomBy = 1;
				var width = LyteColorbox._domEle.offsetWidth,
				actualWidth = LyteColorbox._domEle.naturalWidth,
				value = (width / actualWidth) * 100;
				LyteColorbox.setPercentage(value % 1 != 0 ? value.toFixed(2) : value);
			}
			// else if( value === 'actual' ) {
			// 	var img = LyteColorbox._domEle,
			// 	fullWidth = img.naturalWidth,
			// 	curWidth = parseFloat( window.getComputedStyle( img ).width );
			// 	zoomBy = fullWidth / curWidth;
			// 	LyteColorbox._zoomedThroughUtil = true;
			// }
			else{
				// zoomBy = 1 + (value / 100);
				var img = LyteColorbox._domEle,
				fullWidth = img.naturalWidth,
				curWidth = img.offsetWidth,
				newWidth = fullWidth * value / 100,
				diff = (newWidth - curWidth) / curWidth;
				zoomBy = (1 + diff).toFixed(2);
				LyteColorbox._zoomedThroughUtil = true;
				LyteColorbox.setPercentage(value);
			}
			if( LyteColorbox._component.data.ltPropZoomPosition == "imageCenter" ){
				LyteColorbox._domEle.style.left = "0px";
				LyteColorbox._domEle.style.top = "0px";
				LyteColorbox._domEle.style.transformOrigin = "";
			}
			$L.fastdom.measure( function(){
				// var matrix = LyteColorbox.getMatrixValue( LyteColorbox._domEle );
				// this.zoomTo( zoomBy, {}, LyteColorbox._domEle );
				curZoom = LyteColorbox.getCurrentZoom( LyteColorbox._domEle );
				this.zoomTo( zoomBy, {}, LyteColorbox._domEle );

				LyteColorbox.checkAndChangeStatus( LyteColorbox._domEle );
				if(zoomBy == 1){
					LyteColorbox._zoom = false;
					LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.add('lyteColorboxDisabled');
					LyteColorbox._reset && LyteColorbox._reset.classList.add('lyteColorboxDisabled');
				}
				else{
					LyteColorbox._zoom = true;	//incase the picture is zoomed using util function
					LyteColorbox._zoomOut && LyteColorbox._zoomOut.classList.remove('lyteColorboxDisabled');
					LyteColorbox._reset && LyteColorbox._reset.classList.remove('lyteColorboxDisabled');
					LyteColorbox._domEle.classList.add('onZoom');
				}
				if( /* zoomBy >= matrix.a */ zoomBy >= curZoom ) {
					LyteColorbox._component.getMethods("onZoomin") && LyteColorbox._component.executeMethod('onZoomin',value,LyteColorbox._component.$node);
				}
				else{
					LyteColorbox._component.triggerCheck();
					LyteColorbox._component.getMethods("onZoomout") && LyteColorbox._component.executeMethod('onZoomout',value,LyteColorbox._component.$node);
				}
			}.bind( this ) );
		}
	},

	checkForLeftAndTopAfterZoomOut : function(){
		var image = LyteColorbox._domEle,
		eleOffset = LyteColorbox._domEle.getBoundingClientRect(),
		parentOffset = LyteColorbox._content.getBoundingClientRect(),
		transformOrigin = image.style.transformOrigin,
		originMatch = transformOrigin.match( /(.+)% (.+)%/ ) || [ null, 50, 50 ],
		originX = parseFloat( originMatch[ 1 ] ),
	    originY = parseFloat( originMatch[ 2 ] ),
		diff = 0;
		image.classList.add('lyteCBoxAnimateOnUp');
		if(eleOffset.width < parentOffset.width){
			image.style.left = "0px";
			originX = 50;
		}
		else{
			// debugger
			var left = Math.round(eleOffset.left),
			right = Math.round(eleOffset.right);
			if(left > parentOffset.left){
				diff = left - parentOffset.left;
				image.style.left = (parseFloat(image.style.left || 0) - diff) + "px";
			}
			if(right < parentOffset.right){
				diff = parentOffset.right - right;
				image.style.left = (parseFloat(image.style.left || 0) + diff) + "px";
			}
		}
		if(eleOffset.height < parentOffset.height){
			image.style.top = "0px";
			originY = 50;
		}
		else{
			// debugger
			var top = Math.round(eleOffset.top),
			bottom = Math.round(eleOffset.bottom);
			if(top > parentOffset.top){
				diff = top - parentOffset.top;
				image.style.top = (parseFloat(image.style.top || 0) - diff) + "px";
			}
			if(bottom < parentOffset.bottom){
				diff = parentOffset.bottom - bottom;
				image.style.top = (parseFloat(image.style.top || 0) + diff) + "px";
			}
		}
		image.style.transformOrigin = originX + '% ' + originY + '%';
		image.removeEventListener('transitionend',LyteColorbox.checkForLeftAndTopAfterZoomOut);
	},

	convertToPx: function( val, parentDimensionValue ) {
		var rpercent = /(\d*)%/i,
		rpx = /(\d*)px/i,
		parsed, res = '', percentValue;

		if( ( parsed = rpercent.exec( val ) ) ) {
			percentValue = parseInt( parsed[ 1 ] ) / 100;
			res = ( percentValue * parseInt( parentDimensionValue ) ) + 'px';
		}
		else if( rpx.exec( val ) ) {
			res = val;
		}
		else if( val ) {
			res = val + 'px';
		}

		// returns empty string when no value is provided by the user
		return res;
	},

	getProperOffsetsToCalculateImageDimensions: function() {
		var styles = window.getComputedStyle(LyteColorbox._content),
		component = LyteColorbox._component,
		width = LyteColorbox.convertToPx( component.getData( 'ltPropWidth' ), styles.width ) || ( parseInt( styles.width )  * 0.8 + 'px' ),
		height = LyteColorbox.convertToPx( component.getData( 'ltPropHeight' ), styles.height ) || ( parseInt( styles.height ) * 0.8 + 'px' );

		return {
			width: parseInt( width ),
			height: parseInt( height )
		};
	},

	/**
	 * The method is going to check the aspect ratio to fit it properly inside the colorbox element when opened
	 *
	 */
	checkAspectRatio : function(){
		var elementOffset = LyteColorbox._domEle._offset;

		if( !elementOffset ) {
			return ;
		}
		
		var referenceOffsets = LyteColorbox.getProperOffsetsToCalculateImageDimensions();
		var orientation = LyteColorbox._domEle.getAttribute('lytecbox-rotate');
		if(orientation && orientation.indexOf('90') != -1){
			var offset = Object.assign({}, referenceOffsets);
			referenceOffsets = {
								height : offset.width,
								width : offset.height
							}
		}
		var width = elementOffset.width;
		var height = elementOffset.height;


		// landscape and width exceeds the reference container
		if(elementOffset.width > elementOffset.height && elementOffset.width > referenceOffsets.width){
			height = LyteColorbox.getHeight(height,width,referenceOffsets);
			width = referenceOffsets.width;
			LyteColorbox._domEle.style.width = width + "px";
			LyteColorbox._domEle.style.height = height + "px";

			// even after changing width height exceeds reference container
			if(height > referenceOffsets.height){
				width = LyteColorbox.getWidth(height,width,referenceOffsets);
				height = referenceOffsets.height;
				LyteColorbox._domEle.style.height = height + "px";
				LyteColorbox._domEle.style.width = width + "px";
			}
		}
		else{
			// landscape and height exceeds the container but not the width
			// portrait and height exceeds reference container
			if(height > referenceOffsets.height){
				width = LyteColorbox.getWidth(height,width,referenceOffsets);
				height = referenceOffsets.height;
				LyteColorbox._domEle.style.height = height + "px";
				LyteColorbox._domEle.style.width = width + "px";
			}

			// portrait and width exceeds reference container even after changing height
			// portrait and width exceeds reference container
			if(width > referenceOffsets.width){
				LyteColorbox._domEle.style.width = referenceOffsets.width + "px";
				LyteColorbox._domEle.style.height = LyteColorbox.getHeight(height,width,referenceOffsets) + "px";
			}
		}
		LyteColorbox.setPercentage();
	},

	getHeight : function(height,width,parentOffset){
		var derivedHeight = parentOffset.width * (height/width);
		return Math.round(derivedHeight);
	},

	getWidth : function(height,width,parentOffset){
		var derivedWidth = parentOffset.height * (width/height);
		return Math.round(derivedWidth);
	},

	/**
	 * The method is going to open a particular item from the list of items based on the index value. The index is 1 based ie. ist image's index value is 1
	 * @param {number} index - index value of the image/item to be opened in the colorbox
	 *
	 */
	open : function(index){
		index -= 1;
		if((index != LyteColorbox._index) && (index >= 0 && index < LyteColorbox._related.length)){
			if(LyteColorbox._component.getData('ltPropAnimation') != "slide"){
				LyteColorbox.hideElement();
				// LyteColorbox.toggleLoadingIcon();
				// document.querySelector('.lyteCBoxPhoto').remove();
			}else if(index < LyteColorbox._index){
				LyteColorbox._prevItem = true;
			}else{
				LyteColorbox._nextItem = true;
			}
			// if(LyteColorbox._clickNumber != 0){
			// 	LyteColorbox._clickNumber = 0;
			// }
			LyteColorbox.toggleLoadingIcon();
			LyteColorbox.reset();
			LyteColorbox._index = index;
			LyteColorbox._domEle = null;
			LyteColorbox.load(LyteColorbox._el = LyteColorbox._related[LyteColorbox._index]);
		}
	},

	/**
	 * The method is going to replace the item url with a new url to fetch the item
	 * @param {number} index - index value of the item whose url or other properties needs to be updated
	 * @param {object} obj - Object containing the updated set of properties along with their values
	 *
	 */
	replace : function(index,obj){
		var indexObj = LyteColorbox._related[index - 1];
		var changedHref = false;
		for(var key in obj){
			if(key in indexObj){
				if(key == 'lytecboxHref'){
					changedHref = true;
				}
				Lyte.Component.set(indexObj, key, obj[key]);
				// indexObj[key] = obj[key];
			}
		}
		var className = LyteColorbox._boxEle+"__"+(index - 1);
		var ele = LyteColorbox._content.querySelector('.'+className);
		if(ele && changedHref){
			$L(ele)
				   .attr({
				   		'src': indexObj.lytecboxHref
				   })
			if(indexObj.type == "photo"){
				ele.style.height = "";
				ele.style.width = "";
				ele.onload = function(){
					ele._offset = {
									height : ele.naturalHeight,
									width : ele.naturalWidth
								};
					if(ele.classList.contains('lyteCBoxVisible') && !(ele.parentElement.classList.contains('lyteCBoxDN'))){
						LyteColorbox.checkAspectRatio();
						LyteColorbox.checkHW();
					}
				}
			}
		}
		if(ele && ele.classList.contains('lyteCBoxVisible') && !(ele.parentElement.classList.contains('lyteCBoxDN'))){
			if(LyteColorbox._title){
				LyteColorbox._title.textContent = indexObj.lytecboxTitle;
			}
			LyteColorbox._el = indexObj;
		}

		if( !ele ){
			var cbox = LyteColorbox;
			if( cbox._open && index - 1 == cbox._index ){
				cbox.reset();
				cbox.load( indexObj );
			}
		}
	},

	removeElementObjectFromDom : function(index){
		var element = LyteColorbox._content.querySelector('.'+LyteColorbox._boxEle+'__'+index);
		if(element){
			LyteColorbox._component.getData('ltPropAnimation') == "slide" ? element.parentElement.remove() : element.remove();
		}
	},

	updateSelectors : function(index){
		var elements = Array.from(LyteColorbox._content.querySelectorAll('.lyteCBoxPhoto')),
			regex1 = /(lyteCBoxElement\d*__\d*)/g,
			regex2 = /[+-]?\d+(\.\d+)?/g;
		Lyte.arrayUtils(elements,'push',Array.from(LyteColorbox._content.querySelectorAll('.lyteCBoxIframe')));
		Lyte.arrayUtils(elements,'push',Array.from(LyteColorbox._content.querySelectorAll('.lyteCBoxCustom')));
		for(var i = 0 ; i < elements.length ; i++){
			var cname = elements[i].getAttribute('class'),
				reqdClass = cname.match(regex1)[0],
				indexVal = parseInt(reqdClass.match(regex2)[1]);
			if(indexVal > index){
				indexVal -= 1;
				cname = cname.replace(reqdClass, LyteColorbox._boxEle+'__'+indexVal);
				elements[i].className = cname;
			}
		}
	},

	/**
	 * The method is going to delete an item from the LyteColorbox._related list based on the passed index value
	 * @param {number} index - index of the item to be removed
	 *
	 */
	remove : function(index){
		var currImg = false;
		if(LyteColorbox._index === index - 1){
			currImg = true 
			if( LyteColorbox._component.getData('ltPropLoop') || index != LyteColorbox._related.length ){
				LyteColorbox.next(null, true);
			}
			else{
				LyteColorbox.prev(null, true);
				currImg = false;
			}
			$L(LyteColorbox._domEle)
				.off( 'load', LyteColorbox.imageComplete )
				.off( 'error', LyteColorbox.imageFailure );
		}
		this.removeElementObjectFromDom( index - 1 );
		Lyte.arrayUtils( LyteColorbox._related, 'removeAt', index - 1, 1 );
		if(currImg && LyteColorbox._index != 0){
			LyteColorbox._index -= 1;
		}
		this.updateSelectors( index -1 );
		if(LyteColorbox._component.getData('ltPropThumbnail')){
			LyteColorbox._component.setData('triggerSetThumbnail',LyteColorbox._component.getData('triggerSetThumbnail')+1);
			this.updateThumbnailPos();
		}

		this.changeNavArrows();
	}

};

Lyte.Component.register("lyte-colorbox", {
_template:"<template tag-name=\"lyte-colorbox\"> <template is=\"if\" value=\"{{expHandlers(ltPropType,'===','custom')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"colorBoxYield\"></lyte-yield> </template><template case=\"false\"> <div id=\"lyteColorbox\" class=\"lyteColorbox lyteCBox\"> <div class=\"lyteColorboxFreezeLayer lyteCBoxOverlay\"></div> <div class=\"lyteColorboxWrapper\"> <template is=\"if\" value=\"{{expHandlers(isIframe,'!')}}\"><template case=\"true\"> <div class=\"lyteColorboxUtilDiv\"> <span class=\"lyteCBoxZoomOut lyteColorboxZoomOut lyteColorboxDisabled\" lt-prop-title=\"Zoom Out\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></span> <span class=\"lyteCBoxReset lyteColorboxReset lyteColorboxDisabled\" lt-prop-title=\"Reset Zoom\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></span> <span class=\"lyteCBoxZoomIn lyteColorboxZoomIn\" lt-prop-title=\"Zoom In\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></span> </div> </template></template> <div class=\"lyteColorboxContent lyteCBoxContent\"> <span class=\"lyteColorboxLoadingImg\"></span> </div> <div class=\"lyteColorboxHeader\"> <div class=\"lyteColorboxTitle lyteCBoxTitle\"></div> <template is=\"if\" value=\"{{download}}\"><template case=\"true\"> <div class=\"lyteColorboxDownloadDiv lyteCBoxDownload\"> <span class=\"lyteColorboxDownloadImg\"></span> </div> </template></template> </div> </div> <div class=\"lyteColorboxCloseIcon lyteCBoxClose\"></div> <div class=\"lyteColorboxIconDiv lyteCBoxPrevious\"> <div class=\"lyteColorboxPreviousIcon\"></div> </div> <div class=\"lyteColorboxIconDiv lyteCBoxNext\"> <div class=\"lyteColorboxNextIcon\"></div> </div> <template is=\"if\" value=\"{{ltPropThumbnail}}\"><template case=\"true\"> <div class=\"lyteColorboxThumbOuterWrapper\"> <div class=\"lyteColorboxThumbnails\" onclick=\"{{action(&quot;clickOnThumbnails&quot;,event)}}\"> <div class=\"lyteColorboxThumbInnerWrapper\"> <template is=\"for\" items=\"{{thumbnails}}\" item=\"item\" index=\"index\"> <div class=\"{{lyteUiAddShowClass(ltPropAddOrientation,'lyteColorboxThumb','addedOrientation')}}\" data-thumb-val=\"{{lyteUiSetIndexString(index,thumbnails.length)}}\"> <template is=\"if\" value=\"{{ifEquals(item.type,&quot;photo&quot;)}}\"><template case=\"true\"> <img src=\"{{item.lytecboxHref}}\"> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIfEqualsAny(item.type,&quot;iframe&quot;,&quot;custom&quot;)}}\"><template case=\"true\"><template is=\"if\" value=\"{{item.lytecboxThumbnail}}\"><template case=\"true\"> <img class=\"lyteCBoxFavImg\" src=\"{{item.lytecboxThumbnail}}\"> </template><template case=\"false\"> <div class=\"lyteCBoxIframeWrap\"> <div class=\"lyteCBoxIframeIcon\"></div> <div class=\"lyteCBoxIframeLabel\">{{item.format}}</div> </div> </template></template> </template></template></template></template> </div> </template> </div> </div> </div> </template></template> </div> </template></template> </template><template case=\"false\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"colorBoxYield\"></lyte-yield> </template><template case=\"false\"> <lyte-colorbox-container> <lyte-colorbox-header> <lyte-colorbox-title></lyte-colorbox-title> <template is=\"if\" value=\"{{download}}\"><template case=\"true\"> <lyte-colorbox-download> <span class=\"lyteColorboxDownloadImg\"></span> </lyte-colorbox-download> </template></template> <lyte-colorbox-close></lyte-colorbox-close> </lyte-colorbox-header> <lyte-colorbox-content> </lyte-colorbox-content> <lyte-colorbox-previous> <div class=\"lyteColorboxPreviousIcon\"></div> </lyte-colorbox-previous> <lyte-colorbox-next> <div class=\"lyteColorboxNextIcon\"></div> </lyte-colorbox-next> <lyte-colorbox-description> </lyte-colorbox-description> <div class=\"lyteColorboxUtilDiv\"> <lyte-colorbox-zoomin lt-prop-title=\"Zoom In\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></lyte-colorbox-zoomin> <lyte-colorbox-reset class=\"lyteColorboxDisabled\" lt-prop-title=\"Reset Zoom\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></lyte-colorbox-reset> <lyte-colorbox-zoomout lt-prop-title=\"Zoom Out\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;appearance&quot; : &quot;box&quot;,&quot;margin&quot; : 5}\"></lyte-colorbox-zoomout> </div> <template is=\"if\" value=\"{{ltPropThumbnail}}\"><template case=\"true\"> <lyte-colorbox-thumbnail> <div class=\"lyteColorboxThumbnails\" onclick=\"{{action(&quot;clickOnThumbnails&quot;,event)}}\"> <div class=\"lyteColorboxThumbInnerWrapper\"> <template is=\"for\" items=\"{{thumbnails}}\" item=\"item\" index=\"index\"> <div class=\"{{lyteUiAddShowClass(ltPropAddOrientation,'lyteColorboxThumb','addedOrientation')}}\" data-thumb-val=\"{{lyteUiSetIndexString(index,thumbnails.length)}}\"> <template is=\"if\" value=\"{{ifEquals(item.type,&quot;photo&quot;)}}\"><template case=\"true\"> <img src=\"{{item.lytecboxHref}}\"> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIfEqualsAny(item.type,&quot;iframe&quot;,&quot;custom&quot;)}}\"><template case=\"true\"><template is=\"if\" value=\"{{item.lytecboxThumbnail}}\"><template case=\"true\"> <img class=\"lyteCBoxFavImg\" src=\"{{item.lytecboxThumbnail}}\"> </template><template case=\"false\"> <div class=\"lyteCBoxIframeWrap\"> <div class=\"lyteCBoxIframeIcon\"></div> <div class=\"lyteCBoxIframeLabel\">{{item.format}}</div> </div> </template></template> </template></template></template></template> </div> </template> </div> </div> </lyte-colorbox-thumbnail> </template></template> </lyte-colorbox-container> </template></template> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3,5,3]},{"type":"if","position":[1,3,5,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,11]},{"type":"if","position":[1,11],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1,1]},{"type":"for","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,3,0]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1,1,5]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1,5]},{"type":"componentDynamic","position":[1,7]},{"type":"componentDynamic","position":[1,9]},{"type":"componentDynamic","position":[1,11,1]},{"type":"componentDynamic","position":[1,11,3]},{"type":"componentDynamic","position":[1,11,5]},{"type":"attr","position":[1,13]},{"type":"if","position":[1,13],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1,1]},{"type":"for","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,3,0]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropHeight","ltPropWidth","ltPropOverlayClose","ltPropYield","ltPropSelectors","ltPropLoop","ltPropArrowKey","ltPropZoomBy","ltPropEscKey","ltPropImgError","ltPropAnimation","ltPropThumbnail","ltPropThumbnailNumber","ltPropZoomClickNumber","ltPropType","ltPropMinScale","ltPropMaxScale","ltPropWheelZoom","ltPropZoomPosition","ltPropAddOrientation","currentEle","thumbnails","triggerSetThumbnail","isIframe","download"],
	data : function(){
		return {
			
			/**
			 * @componentProperty {string} ltPropHeight
			 * @version 1.0.0
			 * @suffix px,pt,cm,mm,vh,vm,em
			 */
			'ltPropHeight' : Lyte.attr("string"),

			/**
			 * @componentProperty {string} ltPropWidth
			 * @version 1.0.0
			 * @suffix px,pt,cm,mm,vh,vm,em
			 */
			'ltPropWidth' : Lyte.attr("string"),

			/**
             * @componentProperty {boolean} ltPropOverlayClose
             * @version 1.0.0
             * @default true
             * 
             */
			'ltPropOverlayClose' : Lyte.attr("boolean",{"default":true}),

			/**
             * @componentProperty {boolean} ltPropYield
             * @version 1.0.0
             * @default false
             * 
             */
			'ltPropYield' : Lyte.attr("boolean",{"default":false}),

			/**
             * @componentProperty {array} ltPropSelectors
             * @version 1.0.0
             * @default []
             */
			'ltPropSelectors' : Lyte.attr("array",{"default" : []}),

			/**
             * @componentProperty {boolean} ltPropLoop
             * @version 1.0.0
             * @default true
             * 
             */
			'ltPropLoop' : Lyte.attr("boolean",{"default":true}),

			/**
             * @componentProperty {boolean} ltPropArrowKey
             * @version 1.0.0
             * @default true
             * 
             */
			'ltPropArrowKey' : Lyte.attr("boolean",{"default":true}),

			/**
             * @componentProperty {string} ltPropZoomBy
             * @version 1.0.0
             * @default 25%
             */
			'ltPropZoomBy' : Lyte.attr("string",{"default":"25%"}),

			/**
             * @componentProperty {boolean} ltPropEscKey
             * @version 1.0.0
             * @default true
             * 
             */
			'ltPropEscKey' : Lyte.attr("boolean",{"default":true}),

			/**
             * @componentProperty {string} ltPropImgError
             * @version 1.0.0
             * @default This image failed to load.
             */
			'ltPropImgError' : Lyte.attr("string",{"default":"This image failed to load."}),

			/**
             * @componentProperty {string} ltPropAnimation
             * @version 1.0.0
             * @default default
             * @options default,slide
             */
			'ltPropAnimation' : Lyte.attr("string",{"default":"default"}),   //default,slide

			/**
             * @componentProperty {boolean} ltPropThumbnail
             * @version 1.0.0
             * @default true
             * 
             */
			'ltPropThumbnail' : Lyte.attr("boolean",{"default":true}),

			/**
             * @componentProperty {number} ltPropThumbnailNumber
             * @version 1.0.0
             * @default 7
             */
			'ltPropThumbnailNumber' : Lyte.attr("number",{"default":7}),

			/**
             * @componentProperty {number} ltPropZoomClickNumber
             * @version 1.0.0
             * @default 5
             */
			'ltPropZoomClickNumber' : Lyte.attr('number',{'default':5}),

			/**
             * @componentProperty {custom|image} ltPropType
             * @version 2.2.5
             * @default custom
             */
			'ltPropType': Lyte.attr( 'string', { 'default': 'custom' } ),

			/**
             * @componentProperty {number} ltPropMinScale
             * @version 2.2.5
             * @default 0.01
             * @minValue 0.01
             * @maxValue Infinity
             */
			'ltPropMinScale' : Lyte.attr( 'number', { default : 0.01 } ),

			/**
             * @componentProperty {number} ltPropMaxScale
             * @version 2.2.5
             * @default Infinity
             * @minValue 0.01
             * @maxValue Infinity
             */
			'ltPropMaxScale' : Lyte.attr( 'number', { default : Infinity } ),

			/**
             * @componentProperty {boolean} ltPropWheelZoom
             * @version 2.2.5
             * @default false
             * 
             */
			'ltPropWheelZoom' : Lyte.attr( 'boolean', { default : false } ),

			/**
             * @componentProperty {center|imageCenter} ltPropZoomPosition
             * @version 2.2.5
             * @default center
             */
			'ltPropZoomPosition' : Lyte.attr( 'string', { default : 'center' } ),	//center, imageCenter

			/**
             * @componentProperty {boolean} ltPropAddOrientation
             * @version 2.2.15
             * @default false
             * 
             */
			'ltPropAddOrientation' : Lyte.attr('boolean', { default : false} ),
			'currentEle' : Lyte.attr('object'),
			'thumbnails' : Lyte.attr('array'),
			'triggerSetThumbnail' : Lyte.attr('number',{'default':0}),
			'isIframe' : Lyte.attr('boolean',{"default":false}),
			'download' : Lyte.attr('boolean',{"default":true})

		}		
	},

	trapFocus: function() {
		var content = LyteColorbox._content,
		isTrapFocusPresent = $L( content ).trapFocus,
		id = content.getAttribute( 'id' );

		if( !id ) {
			id = 'lyteColorBox' + ( new Date() ).getTime();
			content.setAttribute( 'id', id );
		}

		if( isTrapFocusPresent ) {
			content.setAttribute( 'id', id );
			$L( '#' + id ).trapFocus();
		}
	},

	setThumbnailSliderProp : function(){
		if(this.getData('ltPropThumbnail') && LyteColorbox._thumbDiv){
			$L.fastdom.measure( function(){
				var thumbnailNo = this.getData('ltPropThumbnailNumber'),
					thumbnails = LyteColorbox._thumbDiv.querySelectorAll('.lyteColorboxThumb'),
					parentDiv = LyteColorbox._thumbDiv.querySelector('.lyteColorboxThumbnails'),
					innerWrapper = LyteColorbox._thumbDiv.querySelector('.lyteColorboxThumbInnerWrapper'),
					thumbnailsOffset = window.getComputedStyle(thumbnails[0]),
					winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
					thumbnailWidth = (parseInt(thumbnailsOffset.width) + (thumbnailsOffset.marginLeft ? parseInt(thumbnailsOffset.marginLeft) : 0) + (thumbnailsOffset.marginRight ? parseInt(thumbnailsOffset.marginRight) : 0));
				$L.fastdom.mutate( function(){
					if(this.getData('ltPropType') === "custom"){
						parentDiv.style.width = (thumbnails.length < thumbnailNo ? thumbnails.length * thumbnailWidth : thumbnailNo * thumbnailWidth) + "px";
						innerWrapper.style.width = thumbnails.length * thumbnailWidth + "px";
						parentDiv.classList.remove('lyteColorboxHideVisibility');
					}
					else{
						var width = thumbnails.length * thumbnailWidth;
						if(width > winWidth){
							parentDiv.style.width = "100%";
						}
						innerWrapper.style.width = thumbnails.length * thumbnailWidth + "px";
						parentDiv.classList.remove('lyteColorboxHideVisibility');
					}
				}.bind(this) );
			}.bind(this) );
		}
	}.observes('ltPropThumbnailNumber','triggerSetThumbnail'),

	init : function(){
		this.$node.launch = function(element){
			LyteColorbox.launch.call( this, element);
		}.bind(this);
		this.$node.push = function(values){
			LyteColorbox.add(values);
		};
		this.$node.open = function(value){
			LyteColorbox.open(value);
		};
		this.$node.zoomBy = function(value){
			LyteColorbox.zoomByUtilFn(value);
		};
		this.$node.replace = function(index, obj){
			LyteColorbox.replace(index,obj);
		};
		this.$node.close = function(){
			LyteColorbox.close();
		};
		this.$node.delete = function(index){
			LyteColorbox.remove(index);
		};
		if(this.getData('ltPropYield')){
			this.setData('ltPropThumbnail',false);
		}
	},

	observeHeightAndWidth : function(){
		if(LyteColorbox._open && LyteColorbox._domEle.classList.contains('lyteCBoxPhoto')){
			LyteColorbox.checkAspectRatio();
		}
	}.observes('ltPropHeight','ltPropWidth'),

	toggleTumbnail : function(){
		var type = this.getData( 'ltPropType' ),
		container = LyteColorbox._box,
		thumbnail = type === 'custom' ? container.querySelector('.lyteColorboxThumbOuterWrapper') : container.querySelector( 'lyte-colorbox-thumbnail' );

		if( this.getData( 'ltPropThumbnail' ) ) {
			LyteColorbox._thumbDiv = thumbnail;
		}
		else{
			LyteColorbox._thumbDiv = null;
		}
	}.observes('ltPropThumbnail'),

	/**
	 * The method is going to initialze the colorbox component and add listeners to the elements that will be shown in the custom type colorbox
	 *
	 */
	intialFunc : function(){

		var type = this.getData( 'ltPropType' );

		// We've added this to prevent any initial errors from happening
		if( type === 'custom' ) {
			if(!this._box){
				this._init = false;
				var comp = this;
				// debugger
				this._content = comp.$node.querySelector('.lyteCBoxContent');
				this._overlay = comp.$node.querySelector('.lyteCBoxOverlay');
				this._title = comp.$node.querySelector('.lyteCBoxTitle');
				this._close = comp.$node.querySelector('.lyteCBoxClose');
				this._download = comp.$node.querySelector('.lyteCBoxDownload');
				this._next = comp.$node.querySelector('.lyteCBoxNext');
				this._prev = comp.$node.querySelector('.lyteCBoxPrevious');
				this._zoomIn = comp.$node.querySelector('.lyteCBoxZoomIn');
				this._zoomOut = comp.$node.querySelector('.lyteCBoxZoomOut');
				this._reset = comp.$node.querySelector('.lyteCBoxReset');
				this._box = comp.$node.querySelector('.lyteCBox') ? comp.$node.querySelector('.lyteCBox') : false;
			
				if(!comp.getData('ltPropYield') && comp.getData('ltPropThumbnail')){
					this._thumbDiv = comp.$node.querySelector('.lyteColorboxThumbOuterWrapper');
				}

				if(!this._box){
					this._box = LyteColorbox.createElement('div',null,'lyteCBox');
					var children = comp.$node.querySelector('lyte-yield').children;
					while(children.length > 0){
						_lyteUiUtils.appendChild(this._box,children[0]);
					}
					this._box.classList.add('lyteColorbox');
				}

				LyteColorbox._count = LyteColorbox._count+1;
				this._className = 'lyteCBoxWrapper__'+(LyteColorbox._count);
				this._boxElement = LyteColorbox._boxElement+LyteColorbox._count;
				this._box.classList.add(this._className);
				this._box._callee = comp.$node;
			
			}

			if (document.body && ((this._box.parentElement && this._box.parentElement.tagName != "BODY") || !this._box.parentElement) ) {
				_lyteUiUtils.appendChild(document.body,this._box);
				this.childComp = this._box;
			}

			LyteColorbox.setupForBindings( this );
			this.addBindings();

			this.unbindEventsForSelectors();
			var ele = this.getSelectorElements();

			if( ele.length > 0 ) {
				this.addClickEvents(ele, this._className);
			}
			else{
				console.warn("No selector(s) provided to colorbox.")
			}	
		}
		else {
			this.setupColorBoxForImages();
		}
		
	}.observes('ltPropSelectors.[]').on('didConnect'),

	convertToArray: function( children ) {
		return Array.prototype.slice.call( children );
	},

	createOwnContainer: function() {
		var children, arrayOfChildren;

		this._box = document.createElement( 'lyte-colorbox-container' );
		children = this.$node.querySelector( 'lyte-yield' ).children;
		arrayOfChildren = this.convertToArray( children );

		arrayOfChildren.forEach( function( child ) {
			_lyteUiUtils.appendChild( this._box, child );
		}.bind(this) );

		// TODO: We are not adding the lyteColorBox class. Ask sam if it is needed 
	},

	setupAlreadyComplete: function() {
		return this._box;
	},

	setupElements: function() {
		var comp = this,
		isContainerProvidedByTheUser;

		this._loadingIcon = comp.$node.querySelector( 'lyte-colorbox-loading-icon' );
		this._content = comp.$node.querySelector( 'lyte-colorbox-content' );
		this._title = comp.$node.querySelector( 'lyte-colorbox-title' );
		this._close = comp.$node.querySelector( 'lyte-colorbox-close' );
		this._download = comp.$node.querySelector( 'lyte-colorbox-download' );
		this._next = comp.$node.querySelector( 'lyte-colorbox-next' );
		this._prev = comp.$node.querySelector( 'lyte-colorbox-previous' );
		this._zoomIn = comp.$node.querySelector( 'lyte-colorbox-zoomin' );
		this._zoomOut = comp.$node.querySelector( 'lyte-colorbox-zoomout' );
		this._reset = comp.$node.querySelector( 'lyte-colorbox-reset' );
		this._header = comp.$node.querySelector( 'lyte-colorbox-header' );
		this._description = comp.$node.querySelector( 'lyte-colorbox-description' );
		this._box = comp.$node.querySelector( 'lyte-colorbox-container' ) ? comp.$node.querySelector( 'lyte-colorbox-container' ) : false;

		if( !this.getData( 'ltPropYield' ) 
			&& this.getData( 'ltPropThumbnail' ) 
		) {
			// TODO: Ask Sam if there is a need to expose thumbnails to the user
			this._thumbDiv = comp.$node.querySelector( 'lyte-colorbox-thumbnail' );
		}

		isContainerProvidedByTheUser = this._box ? true : false;

		if( !isContainerProvidedByTheUser ) {
			this.createOwnContainer();
		}

		LyteColorbox._count = LyteColorbox._count + 1;
		this._className = 'lyteCBoxWrapper__' + ( LyteColorbox._count );
		this._boxElement = LyteColorbox._boxElement + LyteColorbox._count;
		this._box.classList.add( this._className );
		this._box._callee = comp.$node;
	},

	stillNotAppendedToBody: function() {
		return document.body && ( ( this._box.parentElement && this._box.parentElement.tagName != "BODY" ) || !this._box.parentElement );
	},

	/**
	 * The method is going to initialze the colorbox component and add listeners to the elements that will be shown in the image type colorbox
	 *
	 */
	setupColorBoxForImages: function() {
		var listOfItemsThatOpenColorbox;

		if( !this.setupAlreadyComplete() ) {
			this._init = false;
			this.setupElements();
		}

		if( this.stillNotAppendedToBody() ) {
			_lyteUiUtils.appendChild( document.body, this._box );
			this.childComp = this._box;
		}

		LyteColorbox.setupForBindings( this );
		this.addBindings();

		this.unbindEventsForSelectors();
		listOfItemsThatOpenColorbox = this.getSelectorElements();

		if( listOfItemsThatOpenColorbox.length > 0 ) {
			// LyteColorbox.setupForBindings( this );
			// this.addBindings( listOfItemsThatOpenColorbox, this._className );
			this.addClickEvents( listOfItemsThatOpenColorbox, this._className );
		}
		else{
			console.warn("No selector(s) provided to colorbox.")
		}	
	},

	/**
	 * The method is going to add the zoom util icons and their behaviour for images and for others the same will be removed
	 *
	 */
	utilDivEvents : function(){
		if(!this.getData('isIframe')){
			LyteColorbox._zoomIn = this._zoomIn = this.childComp.querySelector('.lyteCBoxZoomIn');
			LyteColorbox._zoomOut = this._zoomOut = this.childComp.querySelector('.lyteCBoxZoomOut');
			LyteColorbox._reset = this._reset = this.childComp.querySelector('.lyteCBoxReset');
			if(LyteColorbox._zoomIn){
				LyteColorbox._zoomIn.addEventListener('click',function(){
					LyteColorbox.zoomIn();
				},true)
			}
			if(LyteColorbox._zoomOut){
				LyteColorbox._zoomOut.addEventListener('click',function(){
					LyteColorbox.zoomOut();
					this.triggerCheck();
				}.bind(this),true)
			}
			if(LyteColorbox._reset){
				LyteColorbox._reset.addEventListener('click',function(){
					LyteColorbox.reset(null ,true);
				},true)
			}
		}
		else{
			LyteColorbox._zoomIn = this._zoomIn = null;
			LyteColorbox._zoomOut = this._zoomOut = null;
			LyteColorbox._reset = this._reset = null;
		}
	}.observes('isIframe'),

	/**
	 * The method is going to show or remove download icon and behaviour based on if the download link is provided or not
	 *
	 */
	downloadDivEvents : function(){
		if(this.getData('download')){
			LyteColorbox._download = this._download = this.$node.querySelector('.lyteCBoxDownload');
			if(LyteColorbox._download){
				LyteColorbox._download.addEventListener('click',function(){
					LyteColorbox.download();
				},true);
			}
		}
		else{
			LyteColorbox._download = this._download = null;
		}
	}.observes('download'),

	callOnBeforeOpen : function(arrayObj,event){
		var returnVal;
		if(this.getMethods('onBeforeOpen')){
			returnVal = this.executeMethod('onBeforeOpen',arrayObj,this,event);
		}
		return returnVal;
	},

	callOnOpen : function(){
		if(this.getMethods('onOpen')){
			this.executeMethod('onOpen',this);
		}
	},

	callOnLoad : function(){
		if(this.getMethods('onLoad')){
			this.executeMethod('onLoad',arguments[0],arguments[1],this,this.getData('ltPropAddOrientation') ? arguments[2] : null);
		}
	},

	callOnComplete : function(){
		if(this.getMethods('onComplete')){
			this.executeMethod('onComplete',arguments[0],arguments[1],this);
		}
	},

	callOnFailure : function(){
		if(this.getMethods('onFailure')){
			this.executeMethod('onFailure',arguments[0],arguments[1],this,arguments[2]);
		}
	},

	getSelectorElements : function(){
		var selectors = this.getData('ltPropSelectors');
		var ele = [];
		for(var i = 0; i<selectors.length; i++){
			Lyte.arrayUtils(ele,'push',Array.from(document.querySelectorAll(selectors[i])));
		}
		return ele;
	},

	unbindEventsForSelectors: function(){
		var elements = document.querySelectorAll('.'+this._boxElement);
		if(elements.length > 0){
			for(var i = 0; i<elements.length; i++){
				elements[i].removeEventListener("click",this.clickHandler,true);
				elements[i].classList.remove(this._boxElement);
				delete elements[i]._className;
			}
		}
		this.setData('currentEle',null);
	},

	callOnClose : function(){
		if(this.getMethods('onClose')){
			this.executeMethod("onClose",this);
		}
	},

	didDestroy: function() {
		// debugger
		if(!LyteColorbox._first && /*LyteColorbox._count == 1*/$L('lyte-colorbox').length == 0){
			window.removeEventListener('resize',LyteColorbox.computeOffsetImpl);
			LyteColorbox._first = true;
		}
		this.unbindEventsForSelectors();
		delete this.childComp;
		this._box._callee = null;
		if(LyteColorbox._box){
			LyteColorbox._box._callee = null;
		}
		LyteColorbox._component = null;
		this._box.remove();

		if( this._header ) {
			this._header = null;
		}
		
		LyteColorbox._box = this._box = null;
		LyteColorbox._prev = this._prev = null;
		LyteColorbox._next = this._next = null;
		LyteColorbox._content = this._content = null;
		LyteColorbox._overlay = this._overlay = null;;
		LyteColorbox._title = this._title = null;
		LyteColorbox._close = this._close = null;
		LyteColorbox._download = this._download = null;
		LyteColorbox._thumbDiv = this._thumbDiv = null;
		LyteColorbox._description = this._description = null;
		LyteColorbox._zoomIn = this._zoomIn = null;
		LyteColorbox._zoomOut = this._zoomOut = null;
		LyteColorbox._reset = this._reset = null;
		LyteColorbox._loadingIcon = this._loadingIcon = null;
		LyteColorbox._domEle = null;
		LyteColorbox._el = null;
		LyteColorbox._boxEle = this._boxElement = null;
		LyteColorbox._open = null;
		LyteColorbox._active = null;
		LyteColorbox._closing = null;
		LyteColorbox._related = null;
		// LyteColorbox._count -= 1;
		LyteColorbox._diff = 0;
		document.body.classList.remove('lyteCBoxOH');
	},

	clickHandler : function(e) {
		if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
			e.preventDefault();
			LyteColorbox.setupForBindings(document.querySelector('.'+this._className)._callee.component);
			LyteColorbox.launch(LyteColorbox.getProperties(this), e);
		}
	},

	checkBeforeClose : function(event){
		var returnVal;
		if(this.getMethods('onBeforeClose')){
			returnVal = this.executeMethod('onBeforeClose', event, this);
		}
		if(returnVal === undefined || returnVal === true){
			LyteColorbox.close();
		}
	},

	/**
	 * The method is going to add event to the body or to the element that will be shown in the colorbox and matches the selectors provided by ltPropSelectors
	 *
	 */
	addBindings : function() {
		var comp, type;

		if (LyteColorbox._box) {

			if(!this._init){
				this._init = true;

				comp = LyteColorbox._component;
				type = comp.getData( 'ltPropType' );

				// Add this only for our new type of colorbox
				if( LyteColorbox._content && type !== 'custom' && false ) {
					LyteColorbox._content.addEventListener('click',function (event) {
						if( event.target.tagName !== 'IMG' && LyteColorbox._component.getData('ltPropOverlayClose') ) {
							// LyteColorbox.close();
							this.checkBeforeClose(event);
						}
					}.bind( this ),true);
				}
				
				if(LyteColorbox._next){
					LyteColorbox._next.addEventListener('click',function (event) {
						LyteColorbox.next(event);
					},true);
				}
				if(LyteColorbox._prev){
					LyteColorbox._prev.addEventListener('click',function (event) {
						LyteColorbox.prev(event);
					},true);
				}
				if(LyteColorbox._close){
					LyteColorbox._close.addEventListener('click',function (event) {
						// LyteColorbox.close();
						this.checkBeforeClose(event);
					}.bind( this ),true);
				}
				if(LyteColorbox._overlay){
					LyteColorbox._overlay.addEventListener('click',function (event) {
						if (LyteColorbox._component.getData('ltPropOverlayClose')) {
							// LyteColorbox.close();
							this.checkBeforeClose(event);
						}
					}.bind( this ),true);
				}
				if(LyteColorbox._download){
					LyteColorbox._download.addEventListener('click',function(){
						LyteColorbox.download();
					},true);
				}
				if(LyteColorbox._zoomIn){
					LyteColorbox._zoomIn.addEventListener('click',function(){
						LyteColorbox.zoomIn();
					},true)
				}
				if(LyteColorbox._zoomOut){
					LyteColorbox._zoomOut.addEventListener('click',function(){
						LyteColorbox.zoomOut();
						this.triggerCheck();
					}.bind(this),true)
				}
				if(LyteColorbox._reset){
					LyteColorbox._reset.addEventListener('click',function(){
						LyteColorbox.reset(null ,true);
					},true)
				}

				if( LyteColorbox._content && this.data.ltPropWheelZoom ){
					LyteColorbox._content.addEventListener( 'wheel', LyteColorbox.wheel.bind( LyteColorbox ), true );
				}

				if(LyteColorbox._content){	//Click and drag
					LyteColorbox._content.addEventListener('mousedown',function(e){
						this.mousedownFn(e);
					}.bind(this),true);

					LyteColorbox._content.addEventListener('touchstart',function(e){
						this.mousedownFn(e);
					}.bind(this),true);
				}

				// Key Bindings
				if(!LyteColorbox._boundKeydown){
					LyteColorbox._boundKeydown = true;
					document.body.addEventListener('keyup', function (e) {
						if(LyteColorbox._intervalId){
							clearInterval(LyteColorbox._intervalId);
							LyteColorbox._intervalId = false;
						}
					}, true);
					document.body.addEventListener('keydown', function (e) {
						var key = e.keyCode;
						if (LyteColorbox._open && LyteColorbox._component.getData('ltPropEscKey') && key === 27) {
							e.preventDefault();
							// LyteColorbox.close();
							LyteColorbox._component.checkBeforeClose(e);
						}
						if (LyteColorbox._open && LyteColorbox._component.getData('ltPropArrowKey') && LyteColorbox._related[1] && !e.altKey) {
							if (key === 37) {
								if(LyteColorbox._intervalId){
									return;
								}
								LyteColorbox._intervalId = setInterval(function(){
									LyteColorbox._intervalId = false;
								},100);
								// LyteColorbox._keydownPressed = true;
								var target = e.target;
								if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable){
									return;
								}
								e.preventDefault();
								// console.log(e.target);
								if(LyteColorbox._prev){
									LyteColorbox.prev(e);
								}
								else{
									if(LyteColorbox._related instanceof Array && LyteColorbox._related.length > 1){
										LyteColorbox.prev(e);
									}
								}
							} else if (key === 39) {
								if(LyteColorbox._intervalId){
									return;
								}
								// console.log("Before setting",LyteColorbox._intervalId);
								LyteColorbox._intervalId = setInterval(function(){
									LyteColorbox._intervalId = false;
								},100);
								// console.log("After setting",LyteColorbox._intervalId);
								// LyteColorbox._keydownPressed = true;
								var target = e.target;
								if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable){
									return;
								}
								e.preventDefault();
								// console.log(e.target);
								if(LyteColorbox._next){
									LyteColorbox.next(e);
								}
								else{
									if(LyteColorbox._related instanceof Array && LyteColorbox._related.length > 1){
										LyteColorbox.next(e);
									}
								}
							}
						}
					},true);
				}

				if(!LyteColorbox._boundResize){
					LyteColorbox._boundResize = true;
					window.addEventListener('resize',function(){
						if(LyteColorbox._open){
							if(LyteColorbox._domEle && LyteColorbox._domEle.classList.contains('lyteCBoxPhoto')){
								LyteColorbox.checkAspectRatio();
							}
							LyteColorbox._diff = 0;
						}
					},true);
				}

			}
			
			return true;
		}
		return false;
	},

	addClickEvents : function(ele, className){
		for(var i = 0; i<ele.length; i++){
			ele[i].addEventListener("click",this.clickHandler,true);
			ele[i].classList.add(this._boxElement);
			ele[i]._className = className;
		}
	},

	triggerCheck : function(stopTimeout){
		// if(this.timeoutId || (stopTimeout && this.timeoutId)){
		// 	clearTimeout(this.timeoutId);
		// 	this.timeoutId = undefined;
		// }
		// this.timeoutId = setTimeout(function(){
		// 	LyteColorbox.checkForLeftAndTopAfterZoomOut();
		// 	this.timeoutId = undefined;
		// },300);
		LyteColorbox._domEle.addEventListener('transitionend',LyteColorbox.checkForLeftAndTopAfterZoomOut);
	},

	mousedownFn : function(e){
		var ele = null;

		if(e.which === 3){
			return;
		}
		var target = e.target;
		while(target){
			if($L(target).hasClass("lyteCBoxPhoto")){
				ele = target;
				break;
			}
			target = target.parentElement;
		}
		if(ele){
			// TODO: Removed this because this was preventing a blur from happening in the colorbox
			// But preventDefault is required in firefox to restirct its default move that happens when an image is clicked and dragged
			if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1){
			    e.preventDefault();
			}
			if(ele.classList.contains('lyteCBoxAnimateOnUp')){
				ele.classList.remove('lyteCBoxAnimateOnUp');
			}
			var parentOffset = ele.parentElement.getBoundingClientRect();
			var eleOffset = ele.getBoundingClientRect();
			//If after zooming the image size has outgrown it parent
			if(eleOffset.top < parentOffset.top || eleOffset.left < parentOffset.left || eleOffset.bottom > parentOffset.bottom || eleOffset.right > parentOffset.right){
				if(eleOffset.top < parentOffset.top || eleOffset.bottom > parentOffset.bottom){	//check top value in mouseup
					ele._top = true;
				}
				if(eleOffset.left < parentOffset.left || eleOffset.right > parentOffset.right){	//check left value in mouseup
					ele._left = true;
				}
				if(e.type == "touchstart"){
					ele._offset.x = e.touches[0].clientX;
					ele._offset.y = e.touches[0].clientY;

					// ele._offset = {
					// 				x : e.touches[0].clientX,
					// 				y : e.touches[0].clientY
					// 			};
					document.addEventListener('touchmove',LyteColorbox.mm = function(e){
						this.mousemoveFn(e);
					}.bind(this));
					document.addEventListener('touchend',LyteColorbox.mu = function(e){
						this.mouseupFn(e);
					}.bind(this));
				}
				else{
					ele._offset.x = e.clientX;
					ele._offset.y = e.clientY;
					// ele._offset = {
					// 				x : e.clientX,
					// 				y : e.clientY
					// 			};
					document.addEventListener('mousemove',LyteColorbox.mm = function(e){
						this.mousemoveFn(e);
					}.bind(this));
					document.addEventListener('mouseup',LyteColorbox.mu = function(e){
						this.mouseupFn(e);
					}.bind(this));
				}
			}
			LyteColorbox._draggedEle = ele;
		}
	},

	mousemoveFn : function(e){
	
		if(LyteColorbox._draggedEle){
			var ele = LyteColorbox._draggedEle;
			e.preventDefault();
			var _mousePosition;
			if(e.type == "touchmove"){
				_mousePosition = {
									x : e.touches[0].clientX,
									y : e.touches[0].clientY
								};
			}
			else{
				_mousePosition = {
									x : e.clientX,
									y : e.clientY
								};
			}
			var parent = ele.offsetParent;
			var parentOffset = parent.getBoundingClientRect();
			var leftVal = _mousePosition.x - ele._offset.x/* - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue*/;
			var topVal = _mousePosition.y - ele._offset.y/* - parentOffset.top - parseInt(_marginTop) + _scrollTop*/;
			if(ele._left){
				ele.style.left = (parseFloat(ele.style.left || 0) + leftVal) + "px";
			}
			if(ele._top){
				ele.style.top = (parseFloat(ele.style.top || 0)+topVal) + "px";
			}
			ele._offset.x = _mousePosition.x;
			ele._offset.y = _mousePosition.y;
		}
	},

	mouseupFn : function(e){
		if(e.type == "touchend"){
			document.removeEventListener('touchmove',LyteColorbox.mm);
			document.removeEventListener('touchend',LyteColorbox.mu);
		}
		else{
			document.removeEventListener('mousemove',LyteColorbox.mm);
			document.removeEventListener('mouseup',LyteColorbox.mu);
		}
		delete LyteColorbox.mm;
		delete LyteColorbox.mu;
		if(LyteColorbox._draggedEle){
			var ele = LyteColorbox._draggedEle;
			var parentOffset = ele.parentElement.getBoundingClientRect();
			var eleOffset = ele.getBoundingClientRect();
			var diff;
			if(ele._left){
				ele.classList.add('lyteCBoxAnimateOnUp');
				if(eleOffset.left > parentOffset.left){
					diff = eleOffset.left - parentOffset.left;
					ele.style.left = (parseFloat(ele.style.left || 0) - diff) + "px";
				}
				if(eleOffset.right < parentOffset.right){
					diff = parentOffset.right - eleOffset.right;
					ele.style.left = (parseFloat(ele.style.left || 0) + diff) + "px";
				}
			}
			// else{
			// 	ele.style.left = "0px";
			// }
			if(ele._top){
				if(!(ele.classList.contains('lyteCBoxAnimateOnUp'))){
					ele.classList.add('lyteCBoxAnimateOnUp');
				}
				if(eleOffset.top > parentOffset.top){
					diff = eleOffset.top - parentOffset.top;
					ele.style.top = (parseFloat(ele.style.top || 0) - diff) + "px";
				}
				if(eleOffset.bottom < parentOffset.bottom){
					diff = parentOffset.bottom - eleOffset.bottom;
					ele.style.top = (parseFloat(ele.style.top || 0) + diff) + "px";
				}
			}
			// else{
			// 	ele.style.top = "0px";
			// }
			// if(!(ele.classList.contains('lyteCBoxAnimateOnUp'))){
			// 	debugger
			// }
			ele = null;
			delete LyteColorbox._draggedEle;
			// mm = null;
			// mu = null;
		}
	},

	moveToImage: function( event ) {
		var type = this.getData( 'ltPropType' ), dir = 0;

		var target = event.target;
		while(target.parentElement){
			if(target.classList.contains('lyteColorboxThumb')){
				break;
			}
			target = target.parentElement;
		}
		if(target.classList.contains('lyteColorboxThumb')){
			var children = Array.from(target.parentElement.children).filter(function(ele){ return ele.tagName != "TEMPLATE" });
			for(var i = 0; i < children.length; i++){
				if(children[i].isEqualNode(target)){
					if(i > LyteColorbox._index){
						dir = 1;
						if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._related[(LyteColorbox._index + 1)])) {
							if(LyteColorbox._component.getData('ltPropAnimation') != "slide"){
								LyteColorbox.hideElement();
								// LyteColorbox.toggleLoadingIcon();
							}else{
								LyteColorbox._nextItem = true;
							}
							LyteColorbox.toggleLoadingIcon();
							if( type === 'custom' ) {
								LyteColorbox.reset();
							}
							
							LyteColorbox._index = i;
							LyteColorbox._domEle = null;
							LyteColorbox.load(LyteColorbox._el = LyteColorbox._related[LyteColorbox._index]);
						}
					}
					else if(i < LyteColorbox._index){
						dir = -1;
						if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._index)) {
							if(LyteColorbox._component.getData('ltPropAnimation') != "slide"){
								LyteColorbox.hideElement();
								// LyteColorbox.toggleLoadingIcon();
							}else{
								LyteColorbox._prevItem = true;
							}
							LyteColorbox.toggleLoadingIcon();
							if( type === 'custom' ) {
								LyteColorbox.reset();
							}
							LyteColorbox._index = i;
							LyteColorbox._domEle = null;
							LyteColorbox.load(LyteColorbox._el = LyteColorbox._related[LyteColorbox._index]);
						}
					}
				}
			}
			this.getMethods("onNavigate") && this.executeMethod('onNavigate',event,this.$node,LyteColorbox._index+1, dir );
		}
	},

	actions : {
		clickOnThumbnails : function(event){
			var promise, that = this;

			if( this.getMethods( 'onBeforeNavigate' ) ) {
				promise = this.executeMethod( 'onBeforeNavigate', event, this.$node, LyteColorbox._index );
			}

			if( promise ) {
				promise.then( function() {
					that.moveToImage( event );
				} );
			}
			else {
				this.moveToImage( event );
			}
		}
	}

});

// //findIndex
// function findIndex( array, condition) {
//     var index;

//     if( condition.constructor == Function ) {
//         for( var i = 0; i < array.length; i++ ) {
//             var ret = condition.call( array[ i ], array[ i ] );
//             if( ret ) {
//                 return i;
//             }
//         }
//     } else {
//        return Array.prototype.indexOf.call( array, condition );
//     }    
// }
if (!Array.prototype.findIndex) {
  Object.defineProperty(Array.prototype, 'findIndex', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return k.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return -1.
      return -1;
    },
    configurable: true,
    writable: true
  });
}

/**
 * @syntax nonYielded
 * <lyte-colorbox>
 * </lyte-colorbox> 
 */

/**
 * @syntax 
 * @attribute ltPropType=custom
 * @attribute ltPropYield=true
 * <lyte-colorbox lt-prop = '{"selectors" : ["selector1"]}' lt-prop-yield = "true"> 
 *	  <template is = "registerYield" yield-name = "colorBoxYield"> 
 *	  	  <div class = "lyteCBoxOverlay"> </div> 
 *	  	  <div class = "lyteCBoxContent customColorpickerContent"> </div> 
 *	  	  <div class = "lyteCBoxClose"> 
 *	  	  	  <svg viewport = "0 0 28 28" version = "1.1" xmlns = "http://www.w3.org/2000/svg"> 
 *	  	  	  	  <line x1 = "1" y1 = "27" x2 = "27" y2 = "1" stroke = "white" stroke-width = "2"></line> 
 *	  	  	  	  <line x1 = "1" y1 = "1" x2 = "27" y2 = "27" stroke = "white" stroke-width = "2"> </line> 
 *	  	  	  </svg> 
 *	  	  </div> 
 *	  	  <div class = "customHeaderBlock"> 
 *	  	  	  <div class = "customHeader"> 
 *	  	  	  	  <span> <img src = "custom-pic.png" width = "40px" height = "40px"> </span> 
 *	  	  	  	  <span>  Custom ColorBox</span> 
 *	  	  	  </div> 
 *	  	  	  <div class = "lyteCBoxTitle customTitle">  Title Here!</div> 
 *	  	  	  <div class = "lyteCBoxDownload"> 
 *	  	  	  	  <img src = "download-arrow.svg"> 
 *	  	  	  </div> 
 *	  	  </div> 
 *	  </template> 
 * </lyte-colorbox> 
 */

/**
 * @syntax 
 * @attribute ltPropType=image
 * @attribute ltPropYield=true
 * <lyte-colorbox lt-prop-yield="true" lt-prop='{"type" : "image","selectors" : [".group1"]}' >
 * 	<template is="registerYield" yield-name="colorBoxYield">
 * 		<div>
 * 			<lyte-colorbox-header>
 * 				<lyte-colorbox-title></lyte-colorbox-title>
 * 				<lyte-colorbox-download>
 * 					<span class="lyteColorboxDownloadImg"></span>
 * 				</lyte-colorbox-download>
 * 				<lyte-colorbox-close></lyte-colorbox-close>
 * 			</lyte-colorbox-header>
 * 			<lyte-colorbox-content>
 * 				<span class="lyteColorboxLoadingImg"></span>
 * 			</lyte-colorbox-content>
 * 			<lyte-colorbox-previous>
 * 				<div class="lyteColorboxPreviousIcon"></div>
 * 			</lyte-colorbox-previous>
 * 			<lyte-colorbox-next>
 * 				<div class="lyteColorboxNextIcon"></div>
 * 			</lyte-colorbox-next>
 * 			<lyte-colorbox-description>
 * 			</lyte-colorbox-description>
 * 			<div class="lyteColorboxUtilDiv">
 * 				<lyte-colorbox-zoomin></lyte-colorbox-zoomin>
 * 				<lyte-colorbox-reset></lyte-colorbox-reset>
 * 				<lyte-colorbox-zoomout></lyte-colorbox-zoomout>
 * 			</div>
 * 			<lyte-colorbox-loading-icon></lyte-colorbox-loading-icon>
 * 		</div>
 * 	</template>
 * </lyte-colorbox>
 */

/*------------------------   NOTES   ------------------------*/
/*
  Things needed to document:
  1. No fill color will return transparent as color value on select. - done
*/

if(!ColorPicker_Util){
	var ColorPicker_Util = {
		component : null,
		baseConverter : function(numberToConvert, oldBase, newBase) {
	        if (newBase == 10) {
	            return parseInt(numberToConvert, 16);
	        }
	        if (newBase == 16) {
	            return parseInt(numberToConvert).toString(16);
	        }
	        numberToConvert = numberToConvert + "";
	        numberToConvert = numberToConvert.toUpperCase();
	        var listOfCharacters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	        var dec = 0;
	        for (var i = 0; i <= numberToConvert.length; i++) {
	            dec += (listOfCharacters.indexOf(numberToConvert.charAt(i))) * (Math.pow(oldBase, (numberToConvert.length - i - 1)));
	        }
	        numberToConvert = "";
	        var magnitude = Math.floor((Math.log(dec)) / (Math.log(newBase)));
	        for (var i = magnitude; i >= 0; i--) {
	            var amount = Math.floor(dec / Math.pow(newBase, i));
	            numberToConvert = numberToConvert + listOfCharacters.charAt(amount);
	            dec -= amount * (Math.pow(newBase, i));
	        }
	        if (numberToConvert.length == 0){
	            numberToConvert = 0;
	        }
	        if (!numberToConvert){
	            numberToConvert = 0;
	        }
	        return numberToConvert;
	    },
	    convert3DigitTo6DigitRgbCode : function(rgbColor){
	    	return (rgbColor[0]+rgbColor[0]+rgbColor[1]+rgbColor[1]+rgbColor[2]+rgbColor[2]);
	    },
	    getHsvByRgbCode : function(rgbColor) {
	        var rgbColor = rgbColor.replace('#', ''),
	        red = ColorPicker_Util.baseConverter(rgbColor.substr(0, 2), 16, 10),
	        green = ColorPicker_Util.baseConverter(rgbColor.substr(2, 2), 16, 10),
	        blue = ColorPicker_Util.baseConverter(rgbColor.substr(4, 2), 16, 10),
	        maxValue, minValue, hue, saturation, valueBrightness;
	        if (red == 0 && green == 0 && blue == 0) {
	            var returnArray = {};
	            returnArray.hue = 0;
	            returnArray.saturation = 0;
	            returnArray.brightness = 0;
	            return returnArray;
	        }
	        red = red / 255;
	        green = green / 255;
	        blue = blue / 255;
	        maxValue = Math.max(red, green, blue);
	        minValue = Math.min(red, green, blue);
	       	hue = 0;
	        if (maxValue == minValue) {
	            hue = 0;
	            saturation = 0;
	        } else {
	            if (red == maxValue) {
	                hue = (green - blue) / (maxValue - minValue) / 1;
	            } else if (green == maxValue) {
	                hue = 2 + (blue - red) / 1 / (maxValue - minValue) / 1;
	            } else if (blue == maxValue) {
	                hue = 4 + (red - green) / (maxValue - minValue) / 1;
	            }
	            saturation = (maxValue - minValue) / maxValue;
	        }
	        hue = hue * 60;
	        valueBrightness = maxValue;
	        if (hue < 0){
	            hue += 360;
	        }
	        var returnArray = {};
	        returnArray.hue = hue;
	        returnArray.saturation = saturation;
	        returnArray.brightness = valueBrightness;
	        return returnArray;
	    },
	    getRgbCodeByRgbColors : function(red, green, blue) {
	        var red = ColorPicker_Util.baseConverter(red, 10, 16),
	        green = ColorPicker_Util.baseConverter(green, 10, 16),
	        blue = ColorPicker_Util.baseConverter(blue, 10, 16),
	        rgbColor;
	        red = red + "";
	        green = green + "";
	        blue = blue + "";
	        while (red.length < 2) {
	            red = "0" + red;
	        }
	        while (green.length < 2) {
	            green = "0" + green;
	        }
	        while (blue.length < 2) {
	            blue = "0" + "" + blue;
	        }
	        rgbColor = red + "" + green + "" + blue;
	        return rgbColor.toUpperCase();
	    },
	    getRgbColorsByRgbCode : function(rgbCode) {
	        var retArray = {};
	        retArray.red = ColorPicker_Util.baseConverter(rgbCode.substr(0, 2), 16, 10);
	        retArray.green = ColorPicker_Util.baseConverter(rgbCode.substr(2, 2), 16, 10);
	        retArray.blue = ColorPicker_Util.baseConverter(rgbCode.substr(4, 2), 16, 10);
	        return retArray;
	    },
	    getRgbColorsByHsv : function(hue, saturation, valueBrightness) {
	    	if (hue == 360){
	            hue = 0;
	        }
	        var Hi = Math.floor(hue / 60),
	        red,green,blue,f,p,q,t;
	        // if (hue == 360){
	        //     hue = 0;
	        // }
	        f = hue / 60 - Hi;
	        if (saturation > 1){
	            saturation /= 100;
	        }
	        if (valueBrightness > 1){
	            valueBrightness /= 100;
	        }
	        p = (valueBrightness * (1 - saturation));
	        q = (valueBrightness * (1 - (f * saturation)));
	        t = (valueBrightness * (1 - ((1 - f) * saturation)));
	        switch (Hi) {
	        case 0:
	            red = valueBrightness;
	            green = t;
	            blue = p;
	            break;
	        case 1:
	            red = q;
	            green = valueBrightness;
	            blue = p;
	            break;
	        case 2:
	            red = p;
	            green = valueBrightness;
	            blue = t;
	            break;
	        case 3:
	            red = p;
	            green = q;
	            blue = valueBrightness;
	            break;
	        case 4:
	            red = t;
	            green = p;
	            blue = valueBrightness;
	            break;
	        default:
	            red = valueBrightness;
	            green = p;
	            blue = q;
	            break;
	        }
	        if (saturation == 0) {
	            red = valueBrightness;
	            green = valueBrightness;
	            blue = valueBrightness;
	        }
	        red *= 255;
	        green *= 255;
	        blue *= 255;
	        red = Math.round(red);
	        green = Math.round(green);
	        blue = Math.round(blue);
	        return {
	            red: red,
	            green: green,
	            blue: blue
	        }
	    },
	    getRgbCodeByHsv : function(hue, saturation, valueBrightness) {
	        while (hue >= 360){
	            hue -= 360;
	        }
	        var colors = ColorPicker_Util.getRgbColorsByHsv(hue, saturation, valueBrightness);
	        return ColorPicker_Util.getRgbCodeByRgbColors(colors.red, colors.green, colors.blue);
	    },
	    getCmykByRgbColors: function(rgb){
				var c = 1 - rgb[0] / 255;
			    var m = 1 - rgb[1] / 255;
			    var y = 1 - rgb[2] / 255,k;

			    var min_cmy = Math.min(c, m, y);
			    c = (c - min_cmy) / (1 - min_cmy);
			    m = (m - min_cmy) / (1 - min_cmy);
			    y = (y - min_cmy) / (1 - min_cmy);
			    k = min_cmy;

			    c = isNaN( c )? 0 :c;
			    m = isNaN( m )? 0 :m;
			    y = isNaN( y )? 0 :y;

				return [c, m, y, k];
			},
			getRgbColorsByCmyk: function(c, m, y, k){
				if (c > 1){
		            c /= 100;
		        }
		        if (m > 1){
		            m /= 100;
		        }
		        if (y > 1){
		            y /= 100;
		        }
		        if (k > 1){
		            k /= 100;
		        }
				var red = 255 * (1-c) * (1-k),   //The red (R) color is calculated from the cyan (C) and black (K) colors
				green = 255 * (1-m) * (1-k),   //The green color (G) is calculated from the magenta (M) and black (K) colors:
				blue = 255 * (1-y) * (1-k);	  //The blue color (B) is calculated from the yellow (Y) and black (K) colors:

				red = Math.round(red);
		        green = Math.round(green);
		        blue = Math.round(blue);
		        return {
		            red: red,
		            green: green,
		            blue: blue
		        }
			},
			getRgbCodeByCmyk: function(c, m, y, k){
				var colors = ColorPicker_Util.getRgbColorsByCmyk(c, m, y, k);
				return ColorPicker_Util.getRgbCodeByRgbColors(colors.red, colors.green, colors.blue);
			},
			getDecimalToHexAlphaCode: function(alpha){
				if(alpha > 100){
					alpha = 100;
				}
				if(alpha < 0){
					alpha = 0;
				}
				alpha = Math.round(alpha * 255 /100);
				return ColorPicker_Util.baseConverter(alpha, 10, 16);
				// return (alpha + 0x10000).toString(16).substr(-2).toUpperCase();
				// for (var i = 0.1; i >= 0; i -= 0.01) {
				//     i = Math.round(i * 100) / 100;
				//     var alpha = Math.round(i * 255);
				//     var hex = (alpha + 0x10000).toString(16).substr(-2).toUpperCase();
				//     var perc = Math.round(i * 100);
				//     console.log(perc + "% — " + hex + " (" + alpha + ")");
				// }
			},
			getHexToDecimalAlphaCode: function(alpha){
				var alpha = ColorPicker_Util.baseConverter(alpha, 16, 10);
				if(alpha > 255){
					alpha = 255;
				}
				if(alpha < 0){
					alpha = 0;
				}
				return Math.round(alpha * 100 / 255);
			},
	    getLeftPos : function(el) {
	        if (document.getBoxObjectFor) {
	            if (el.tagName != 'INPUT' && el.tagName != 'SELECT' && el.tagName != 'TEXTAREA'){
	                return document.getBoxObjectFor(el).x
	            }
	        }
	        var ret = el.offsetLeft;
	        while ((el = el.offsetParent) != null) {
	            if (el.tagName != 'HTML') {
	                ret += el.offsetLeft;
	                if (document.all){
	                    ret += el.clientLeft;
	                }
	            }
	        }
	        return ret;
	    },
	    getTopPos : function(el) {
	        if (document.getBoxObjectFor) {
	            if (el.tagName != 'INPUT' && el.tagName != 'SELECT' && el.tagName != 'TEXTAREA'){
	                return document.getBoxObjectFor(el).y
	            }
	        }
	        var ret = el.offsetTop;
	        while ((el = el.offsetParent) != null) {
	            if (el.tagName != 'HTML') {
	                ret += (el.offsetTop - el.scrollTop);
	                if (document.all){
	                    ret += el.clientTop;
	                }
	            }
	        }
	        return ret;
	    },
		getColorPicker : function(arg){
			var ele = arg.closest('colorpicker-ui')/*arg.closest('lyte-colorpicker')*/;
			// console.log(arg);
			// console.log(ele);
			// if(!ele){
			// 	var components = LytePopup.components;
			// 	for(var i =components.length - 1; i>=0; i--){
			// 		if(components[i].$node.parentElement.tagName == 'LYTE-COLORPICKER' && components[i].childComp.style.visibility == 'visible'){
			// 			ele = components[i].childComp;
			// 			break;
			// 		}
			// 	}
			// 	if(ele){
			// 		var div = ele.querySelector('.popoverWrapper');
			// 		if(div && div.classList.length > 1){
			// 			var className = div.className.split(" ")[1];
			// 			var colorpickers = document.querySelectorAll('lyte-colorpicker');
			// 			for(var i = 0 ; i<colorpickers.length ; i++){
			// 				if(colorpickers[i].component.getData('cpWrapperClass') === className){
			// 					ele = colorpickers[i];
			// 					break;
			// 				}
			// 			}
			// 		}
			// 	}
			// }
			return ele;
		},
		splitIntoSubArray : function(arr, count) {
			var newArray = [];
			while (arr.length > 0) {
		    	newArray.push(arr.splice(0, count)); 
			}
			return newArray;
		}
	}
}

if(!ColorPicker_EventUtil){
	var ColorPicker_EventUtil = {
		__stopPropagation : false,
		__eventBound : false,
		__initOpacityMove: function(e,_this) {
			if(_this){
				if(e.type == "mousedown"){
					document.addEventListener('mousemove',ColorPicker_EventUtil.__mm = function(event){
						ColorPicker_EventUtil.__moveOnOpacityTrack(event,_this);
					});
					document.addEventListener('mouseup',ColorPicker_EventUtil.__mu = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
				if(e.type == "touchstart"){
					document.addEventListener('touchmove',ColorPicker_EventUtil.__tm = function(event){
						ColorPicker_EventUtil.__moveOnOpacityTrack(event,_this);
					});
					document.addEventListener('touchend',ColorPicker_EventUtil.__te = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
				_this.setData('opacityStatus', 1);
				_this.setData('calledForHueMove',true);
		        // _this.setData('poxYHue', ColorPicker_Util.getTopPos(_this.getData('divElHueBar')));
		        var opacitySlider = _this.$node.querySelector('.opacityslider__track');
		        _this.setData('opacityTrackSize', opacitySlider.offsetWidth /*_this.getData('cpInline') ? opacitySlider.offsetWidth : _this.childComp.querySelector('.opacityslider__track').offsetWidth*/);
		        _this.setData('posXOpacity', ColorPicker_Util.getLeftPos(opacitySlider /*_this.getData('cpInline') ? opacitySlider : _this.childComp.querySelector('.opacityslider__track')*/));
		        ColorPicker_EventUtil.__moveOnOpacityTrack(e,_this);
		        return false;
			}
	    },

		__initHueMove: function(e,_this) {
			if(_this){
				if(e.type == "mousedown"){
					document.addEventListener('mousemove',ColorPicker_EventUtil.__mm = function(event){
						ColorPicker_EventUtil.__moveOnHueBar(event,_this);
					});
					document.addEventListener('mouseup',ColorPicker_EventUtil.__mu = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
				if(e.type == "touchstart"){
					document.addEventListener('touchmove',ColorPicker_EventUtil.__tm = function(event){
						ColorPicker_EventUtil.__moveOnHueBar(event,_this);
					});
					document.addEventListener('touchend',ColorPicker_EventUtil.__te = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
				_this.setData('setPrevCmyk',false);
				_this.setData('hueStatus', 1);
				_this.setData('calledForHueMove',true);
		        // _this.setData('poxYHue', ColorPicker_Util.getTopPos(_this.getData('divElHueBar')));
		        var colorSlider = _this.$node.querySelector('.colorSlider_hueBar');
		        _this.setData('hueBarSize', colorSlider.offsetWidth /*_this.getData('cpInline') ? colorSlider.offsetWidth : _this.childComp.querySelector('.colorSlider_hueBar').offsetWidth*/);
		        _this.setData('poxXHue', ColorPicker_Util.getLeftPos(colorSlider /*_this.getData('cpInline') ? colorSlider : _this.childComp.querySelector('.colorSlider_hueBar')*/));
		        ColorPicker_EventUtil.__moveOnHueBar(e,_this);
		        return false;
			}
	    },

		__initPaletteMove : function(e,_this) {
	    	if(_this){
	    		_this.setData('setPrevCmyk',false);
	    		if(e.type == "mousedown"){
					document.addEventListener('mousemove',ColorPicker_EventUtil.__mm = function(event){
						ColorPicker_EventUtil.__moveOnPalette(event,_this);
					});
					document.addEventListener('mouseup',ColorPicker_EventUtil.__mu = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
				if(e.type == "touchstart"){
					document.addEventListener('touchmove',ColorPicker_EventUtil.__tm = function(event){
						ColorPicker_EventUtil.__moveOnPalette(event,_this);
					});
					document.addEventListener('touchend',ColorPicker_EventUtil.__te = function(event){
						ColorPicker_EventUtil.__endDrag(event,_this);
					});
				}
	    		var posdivElPalette = _this.getData('posdivElPalette');
		    	var circleOffsetBecauseOfWinWidget = _this.getData('circleOffsetBecauseOfWinWidget');
		    	var divElPalette =  _this.$node.querySelector('#colorDiv') /*_this.getData('cpInline') ? _this.$node.querySelector('#colorDiv') : _this.childComp.querySelector('#colorDiv')*/;
		    	var divElPaletteOffset = divElPalette.getBoundingClientRect();
		    	var circleOffsetSize = _this.getData('circleOffsetSize');
		        if (document.all){
		            e = event || window.event;
		        }
		        _this.__ffHackWinWidget();
		        posdivElPalette.x = divElPaletteOffset.left /*ColorPicker_Util.getLeftPos(divElPalette)*/ + circleOffsetBecauseOfWinWidget;
		        posdivElPalette.y = divElPaletteOffset.top /*ColorPicker_Util.getTopPos(divElPalette)*/ + circleOffsetBecauseOfWinWidget;
		        _this.setData('paletteSize',{'height' : divElPalette.offsetHeight, 'width' : divElPalette.offsetWidth});
		        _this.setData('posdivElPalette',posdivElPalette);
		        _this.setData('dragStatus', 1);
		        _this.setData('paletteMaxX', (divElPalette.offsetWidth - circleOffsetSize));
		        _this.setData('paletteMaxY', (divElPalette.offsetHeight - circleOffsetSize));
		        ColorPicker_EventUtil.__moveOnPalette(e,_this);
		        posdivElPalette = null;
		        divElPalette = null;
		        return false;
	    	}
	    },

	    __moveOnPalette : function(e,_this) {
	    	if(_this){
	    		if(e.type == "mousedown" || e.type == "mousemove"){
	    			e.preventDefault();
	    		}
		    	var posdivElPalette = _this.getData('posdivElPalette');
		    	var circleOffsetSize = _this.getData('circleOffsetSize');
		    	var divElPaletteCircle = _this.$node.querySelector('.colorSlider_palette_circle') /*_this.getData('cpInline') ? _this.$node.querySelector('.colorSlider_palette_circle') : _this.childComp.querySelector('.colorSlider_palette_circle')*/;
		        if (_this.getData('dragStatus') != 1){
		            return;
		        }
		        if (_this.getData('clickOnPaletteInProgress')){
		            return;
		        }
		        _this.setData('clickOnPaletteInProgress', true);
		        _this.setData('dragged',true);
		        if (document.all){
		            e = event;
		        }
		        var leftEl = posdivElPalette.x;
		        var topEl = posdivElPalette.y;
		        var left,top;
		        if(e.type == "mousedown" || e.type == "mousemove"){
		        	left = e.clientX/* + document.documentElement.scrollLeft*/ - leftEl - circleOffsetSize;
		        	top = e.clientY/* + document.documentElement.scrollTop*/ - topEl - circleOffsetSize;
		        }
		        if(e.type == "touchstart" || e.type == "touchmove"){
		        	left = e.touches[0].clientX/* + document.documentElement.scrollLeft*/ - leftEl - circleOffsetSize;
		        	top = e.touches[0].clientY/* + document.documentElement.scrollTop*/ - topEl - circleOffsetSize;
		        }
		        if (left < circleOffsetSize * -1){
		            left = circleOffsetSize * -1;
		        }
		        if (top < circleOffsetSize * -1){
		            top = circleOffsetSize * -1;
		        }
		        if (left > _this.getData('paletteMaxX')){
		            left = _this.getData('paletteMaxX');
		        }
		        if (top > _this.getData('paletteMaxY')){
		            top = _this.getData('paletteMaxY');
		        }
		        // if(_this.getData('cpInline')){
		        // 	var xscroll = window.pageXOffset;
          //           var yscroll = window.pageYOffset;
          //           left += xscroll;
          //           top += yscroll;
		        // }
		        divElPaletteCircle.style.left = left + 'px';
		        divElPaletteCircle.style.top = top + 'px';
		        _this.setData('currentSaturation', Math.round(((left + circleOffsetSize) / _this.getData('paletteSize').width) * 100));
		        _this.setData('currentBrightness', 100 - Math.round(((top + circleOffsetSize) / _this.getData('paletteSize').height) * 100));
		        _this.__setCurrentRgbCode();
		        // _this.__setBgColorPreviewDiv();
		        _this.__updateRgbInForm();
		        _this.__changeColorInOpacityTrack();
				_this.__setOpacityColorPreviewDiv();
		        _this.executeOnChange();
		        _this.setData('clickOnPaletteInProgress', false);
		        posdivElPalette = null;
		        divElPaletteCircle = null;
		        circleOffsetSize = null;
	    	}
	    },

	    __moveOnHueBar: function(e,_this) {
	    	if(_this){
	    		if(e.type == "mousedown" || e.type == "mousemove"){
	    			e.preventDefault();
	    		}
		        if (_this.getData('hueStatus') != 1){
		            return;
		        }
		        _this.setData('dragged',true);
		        if (document.all){
		            e = event;
		        }
		        var sliderOffset = _this.getData('sliderOffset');
		        var leftPos = _this.getData('poxXHue');
		        var diff;
		        if(e.type == "mousedown" || e.type == "mousemove"){
		        	diff = e.clientX + document.documentElement.scrollLeft - leftPos - sliderOffset;
		        }
		        if(e.type == "touchstart" || e.type == "touchmove"){
		        	diff = e.touches[0].clientX + document.documentElement.scrollLeft - leftPos - sliderOffset;
		        }
		        if (diff > _this.getData('hueBarSize') - sliderOffset){
		            diff = _this.getData('hueBarSize') - sliderOffset;
		        }
		        if (diff < 0 - sliderOffset){
		            diff = 0 - sliderOffset;
		        }
		        var ele = _this.$node /*_this.getData('cpInline') ? _this.$node : _this.childComp*/;
	        	ele.querySelector('.colorSlider_sliderHandle').style.left = diff + 'px';
		        var hue = Math.round((_this.getData('hueBarSize') - (diff + sliderOffset)) * (360 / _this.getData('hueBarSize')));
		        if (hue >= 360){
		            hue = 360;
		        }
		        _this.setData('currentHue', hue);
		        _this.__setCurrentRgbCode();
		        _this.__setPaletteBgColor();
		        // _this.__setBgColorPreviewDiv();
		        _this.__updateRgbInForm();
		        _this.__changeColorInOpacityTrack();
				_this.__setOpacityColorPreviewDiv();
		        _this.executeOnChange();
	    	}
	    },

	    __moveOnOpacityTrack: function(e,_this) {
	    	if(_this){
	    		if(e.type == "mousedown" || e.type == "mousemove"){
	    			e.preventDefault();
	    		}
		        if (_this.getData('opacityStatus') != 1){
		            return;
		        }
		        // _this.setData('dragged',true);
		        if (document.all){
		            e = event;
		        }
		        var leftPos = _this.getData('posXOpacity');
		        var sliderOffset = _this.getData('sliderOffset');
		        var diff;
		        if(e.type == "mousedown" || e.type == "mousemove"){
		        	diff = e.clientX + document.documentElement.scrollLeft - leftPos - sliderOffset;
		        }
		        if(e.type == "touchstart" || e.type == "touchmove"){
		        	diff = e.touches[0].clientX + document.documentElement.scrollLeft - leftPos - sliderOffset;
		        }
		        if (diff > _this.getData('opacityTrackSize') - sliderOffset){
		            diff = _this.getData('opacityTrackSize') - sliderOffset;
		        }
		        if (diff < 0 - sliderOffset){
		            diff = 0 - sliderOffset;
		        }
		        var diffPercent = parseInt(((diff + sliderOffset) / _this.getData('opacityTrackSize')) * 100);
		        var ele = _this.$node/*_this.getData('cpInline') ? _this.$node : _this.childComp*/;
		        ele.querySelector('.opacityslider__circlethumb').style.left = diff + 'px';
		        _this.setData("opacity", diffPercent);
		        _this.__setOpacityColorPreviewDiv();
		        _this.__updateOpacityInForm();
		        _this.executeOnChange();
	    	}
	    },

	    __endDrag : function(e,_this) {
	    	if(_this && _this.$node){
	    		if(_this.getData('dragStatus') == 0 && _this.getData('hueStatus') == 0 && _this.getData('opacityStatus') == 0){
		    		return;
		    	}
	    		if(e.type == "mouseup"){
					document.removeEventListener('mousemove',ColorPicker_EventUtil.__mm);
					document.removeEventListener('mouseup',ColorPicker_EventUtil.__mu);
					ColorPicker_EventUtil.__mm = undefined;
					ColorPicker_EventUtil.__mu = undefined;
				}
				if(e.type == "touchend"){
					document.removeEventListener('touchmove',ColorPicker_EventUtil.__tm);
					document.removeEventListener('touchend',ColorPicker_EventUtil.__te);
					ColorPicker_EventUtil.__tm = undefined;
					ColorPicker_EventUtil.__te = undefined;
				}
		    	ColorPicker_EventUtil.__stopPropagation = true;
		        if (_this.getData('dragStatus') == 1) {
		            // _this.__updateHsvInForm();
		            _this.__updateRgbInForm();
		        }
		        _this.setData('dragStatus', 0);
		        _this.setData('hueStatus', 0);
		        _this.setData('opacityStatus',0);
		        if(_this.getData('dragged')){
		        	_this.setData('dragged', false);
		        }
		        if(_this.getData('counter') != 0){
		        	_this.setData('counter',0);
		        }
		        if(_this.getData('restrictOnChange')){
		        	_this.setData('restrictOnChange',false);
		        }
		        var popup = _this.getData('cpInline') ? _this.$node.closest('.lytePopover') : null;
		        if(popup){
		        	popup._callee.ltProp('stopClick', true);
		        }
		        _this.executeOnSelect(e);

	    	}
	    	ColorPicker_Util.component = null;
	    }
	}
}



Lyte.Component.register("colorpicker-ui", {
_template:"<template tag-name=\"colorpicker-ui\"> <template is=\"if\" value=\"{{cpBasicColorPicker}}\"><template case=\"true\"> <div class=\"lyteColorPicker__default\"> <template is=\"if\" value=\"{{cpNoFillButton}}\"><template case=\"true\"> <div class=\"lyteColorPicker__nocolorbutton\" onclick=\"{{action(&quot;noFillExecute&quot;,event)}}\"> <span class=\"lyteColorPicker__noFill\"> </span> <span class=\"lyteColorPicker__text\">{{cpNoFillLabel}}</span> </div> </template></template> <template is=\"if\" value=\"{{cpUsedColors}}\"><template case=\"true\"> <div class=\"lyteColorPicker__palettecontainer usedColor__container\"> <div class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Recently.Used.Colors\")}}</div> <div class=\"lyteColorPicker__palette\"> <ul class=\"used__colors\"> <template is=\"for\" items=\"{{usedColors}}\" item=\"color\" index=\"indexVal\"> <li class=\"lyteColorPicker__colorpan {{lyteUiAddPE(color)}}\" lt-prop-title=\"{{lyteUiRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;,event,color)}}\">{{color}}</li> <template is=\"if\" value=\"{{lyteUiCPInsertBreak(indexVal)}}\"><template case=\"true\"> <br> </template></template> </template> </ul> </div> </div> </template></template> <div class=\"lyteColorPicker__palettecontainer LCP_predefinedPallete\"> <div class=\"lyteColorPicker__paletteheading\">{{cpPaletteLabel}}</div> <div class=\"lyteColorPicker__palette\"> <div> <template is=\"for\" items=\"{{cpAvailableColors}}\" item=\"colorArray\" index=\"indexVal\"> <ul class=\"lyteColorPicker__shades default__colors\"> <template is=\"for\" items=\"{{colorArray}}\" item=\"color\" index=\"indexVal\"> <li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteUiRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;,event,color)}}\">{{color}}</li> </template> </ul> </template> </div> </div> </div> <template is=\"if\" value=\"{{cpStandardColors}}\"><template case=\"true\"> <div class=\"lyteColorPicker__palettecontainer LCP_standardColorCont\"> <div class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Standard.Colors\")}}</div> <div class=\"lyteColorPicker__palette\"> <ul class=\"standard__colors\"> <template is=\"for\" items=\"{{cpStandardColorArray}}\" item=\"color\" index=\"indexVal\"> <li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteUiRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;,event,color)}}\">{{color}}</li> </template> </ul> </div> </div> </template></template> <template is=\"if\" value=\"{{cpAdvancedColorButton}}\"><template case=\"true\"> <div class=\"lyteColorPicker__navigatable lyteColorPicker__morecolorbutton\" onclick=\"{{action(&quot;goToAdvancedCP&quot;,event)}}\"> <span class=\"lyteColorPicker__icon\"></span> <span class=\"lyteColorPicker__text\">{{lyteUiI18n(\"Advanced.Colors\")}}</span> <span class=\"lyteColorpickerForwardArrow h-alignright LCP_rightArrow\"></span> </div> </template></template> </div> </template><template case=\"false\"> <div class=\"lyteColorPicker--advanced\"> <div class=\"lyteColorPicker__maparea\"> <div class=\"colorDiv\" id=\"colorDiv\"> <div id=\"lyteCPImgDiv\"></div> <div class=\"colorSlider_palette_circle colorSlider_palette_circleBlack\"></div> </div> </div> <div class=\"lyteColorPicker__previewDiv lyteColorPicker__sliderDiv\"> <div> <div class=\"colorSlider_hue\"> <div class=\"colorSlider_sliderHandle\"> </div> <div class=\"colorSlider_hueBar_border\"> <div class=\"colorSlider_hueBar\"></div> </div> </div> <div class=\"lyteColorPicker__opacityslider\"> <div class=\"opacityslider__circlethumb\"></div> <div class=\"lyteColorPicker__transparentbg\"> <div class=\"opacityslider__track\"></div> </div> </div> </div> <div class=\"lyteCP__transparentbg\"> <div class=\"previewDiv\" onmouseover=\"{{action(&quot;onOverColorPreviewDiv&quot;,event)}}\" onclick=\"{{action(&quot;copyValueToClipboard&quot;)}}\" lt-prop-title=\"{{lyteUiI18n('Copy.Color.value.to.Clipboard')}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;}\"></div> </div> </div> <div class=\"lyteColorPicker__previewDiv\"> <div class=\"selectFormat\"> <lyte-dropdown class=\"cPDropDown\" lt-prop-yield=\"true\" lt-prop-freeze=\"false\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method(&quot;changeFormatView&quot;)}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button class=\"colorPickerDD\"> <span class=\"lyteMarginRight lyteDropdownLabel\">{{dropButtonValue}}</span> <lyte-icon class=\"dropdown\"></lyte-icon> </lyte-drop-button> <lyte-drop-box class=\"lyteCPDropbox\"> <lyte-drop-body> <template is=\"for\" items=\"{{cpColorFormats}}\" item=\"item\" index=\"indexVal\"> <lyte-drop-item data-value=\"{{item}}\"> {{item}} </lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </div><div class=\"showValue\"> <lyte-table lt-prop-yield=\"true\" class=\"cpValFormatIp\" lt-prop-prevent-scrollbar=\"true\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-table-structure> <lyte-tbody> <template is=\"if\" value=\"{{ifEquals(dropButtonValue,lyteUiI18n(&quot;HEX&quot;))}}\"><template case=\"true\"> <lyte-tr> <lyte-td> <lyte-input id=\"lyteCPShowValue\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-maxlength=\"7\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;HEX&quot;)}}\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;HEX&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;HEX&quot;)}}\" lt-prop-direction=\"vertical\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__A\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;A&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;A&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;A&quot;)}}\" lt-prop-direction=\"vertical\"> </lyte-input> </lyte-td> </lyte-tr> <lyte-tr class=\"lyteCPHexText\"> <lyte-td>HEX</lyte-td> <lyte-td class=\"lyteColorPicker_alpha\">{{lyteUiSetAlphaLabel(cpOpacityLabel)}}</lyte-td> </lyte-tr> </template><template case=\"false\"><template is=\"if\" value=\"{{ifEquals(dropButtonValue,lyteUiI18n(&quot;RGB&quot;))}}\"><template case=\"true\"> <lyte-tr> <lyte-td> <lyte-input id=\"lyteCP__R\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;R&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;R&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;R&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__G\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;G&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;G&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;G&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__B\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;B&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;B&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;B&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__A\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;A&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;A&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;A&quot;)}}\" lt-prop-direction=\"vertical\"> </lyte-input> </lyte-td> </lyte-tr> <lyte-tr> <lyte-td>R</lyte-td> <lyte-td>G</lyte-td> <lyte-td>B</lyte-td> <lyte-td class=\"lyteColorPicker_alpha\">{{lyteUiSetAlphaLabel(cpOpacityLabel)}}</lyte-td> </lyte-tr> </template><template case=\"false\"><template is=\"if\" value=\"{{ifEquals(dropButtonValue,lyteUiI18n(&quot;HSV&quot;))}}\"><template case=\"true\"> <lyte-tr> <lyte-td> <lyte-input id=\"lyteCP__H\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;H&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;H&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;H&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__S\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;S&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;S&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;S&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__V\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;V&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;V&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;V&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__A\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-maxlength=\"3\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;A&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;A&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;A&quot;)}}\" lt-prop-direction=\"vertical\"> </lyte-input> </lyte-td> </lyte-tr> <lyte-tr> <lyte-td>H</lyte-td> <lyte-td>S</lyte-td> <lyte-td>V</lyte-td> <lyte-td class=\"lyteColorPicker_alpha\">{{lyteUiSetAlphaLabel(cpOpacityLabel)}}</lyte-td> </lyte-tr> </template><template case=\"false\"><template is=\"if\" value=\"{{ifEquals(dropButtonValue,lyteUiI18n(&quot;CMYK&quot;))}}\"><template case=\"true\"> <lyte-tr> <lyte-td> <lyte-input id=\"lyteCP__C\" class=\"lyteCP_CMYK\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;C&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;C&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;C&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__M\" class=\"lyteCP_CMYK\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;M&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;M&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;M&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__Y\" class=\"lyteCP_CMYK\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;Y&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;Y&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;Y&quot;)}}\"> </lyte-input> </lyte-td> <lyte-td> <lyte-input id=\"lyteCP__K\" class=\"lyteCP_CMYK\" lt-prop-type=\"text\" lt-prop-maxlength=\"3\" lt-prop-appearance=\"box\" lt-prop-direction=\"vertical\" onkeydown=\"{{action(&quot;inputKeyDown&quot;,event,this,&quot;K&quot;)}}\" on-value-change=\"{{method(&quot;inputValueChanged&quot;,&quot;K&quot;)}}\" on-blur=\"{{method(&quot;onInputBlur&quot;,&quot;K&quot;)}}\"> </lyte-input> </lyte-td> </lyte-tr> <lyte-tr> <lyte-td>C</lyte-td> <lyte-td>M</lyte-td> <lyte-td>Y</lyte-td> <lyte-td>K</lyte-td> </lyte-tr> </template></template></template></template></template></template></template></template> </lyte-tbody> </lyte-table-structure> </template> </lyte-table> <input id=\"lyteCPHiddenInput\" tabindex=\"-1\" aria-hidden=\"true\"> </div> </div> <template is=\"if\" value=\"{{cpInline}}\"><template case=\"true\"> <template is=\"if\" value=\"{{cpMoreColorOptionSelected}}\"><template case=\"true\"> <div class=\"lyteColorPicker__commandbar\"> <lyte-button class=\"LCP_backbtn\" lt-prop-size=\"small\" lt-prop-appearance=\"default\" onclick=\"{{action(&quot;fromAdvCPtoBasic&quot;,event)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{cpBackBtnText}}</template> </lyte-button> </div> </template></template> </template><template case=\"false\"> <div class=\"lyteColorPicker__commandbar\"> <template is=\"if\" value=\"{{cpMoreColorOptionSelected}}\"><template case=\"true\"> <lyte-button class=\"LCP_backbtn\" lt-prop-size=\"small\" lt-prop-appearance=\"default\" onclick=\"{{action(&quot;fromAdvCPtoBasic&quot;,event)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{cpBackBtnText}}</template> </lyte-button> <lyte-button class=\"LCP_done\" lt-prop-size=\"small\" lt-prop-appearance=\"primary\" onclick=\"{{action(&quot;callOnSelect&quot;,event,true)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{cpDoneBtnText}}</template> </lyte-button> </template><template case=\"false\"> <lyte-button class=\"LCP_cancel\" lt-prop-size=\"small\" style=\"margin-left: auto; margin-right: 7px;\" lt-prop-appearance=\"default\" onclick=\"{{action(&quot;closeColorPicker&quot;,event)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{cpCancelBtnText}}</template> </lyte-button> <lyte-button class=\"LCP_done\" lt-prop-size=\"small\" lt-prop-appearance=\"primary\" onclick=\"{{action(&quot;callOnSelect&quot;,event,true)}}\"> <template is=\"registerYield\" yield-name=\"text\">{{cpApplyBtnText}}</template> </lyte-button> </template></template> </div> </template></template> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,3,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}]}},"default":{}},{"type":"text","position":[1,5,1,0]},{"type":"attr","position":[1,5,3,1,1]},{"type":"for","position":[1,5,3,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,3,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,3,3,1]},{"type":"attr","position":[1,5,1,1]},{"type":"registerYield","position":[1,5,1,1,1],"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1,5,1,1]},{"type":"registerYield","position":[1,5,2,1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"componentDynamic","position":[1,3,1]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]},{"type":"componentDynamic","position":[3,1]},{"type":"text","position":[3,3,0]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"componentDynamic","position":[1,3,1]},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[1,5,1]},{"type":"componentDynamic","position":[1,5,1]},{"type":"componentDynamic","position":[1,5]},{"type":"attr","position":[1,7,1]},{"type":"componentDynamic","position":[1,7,1]},{"type":"componentDynamic","position":[1,7]},{"type":"componentDynamic","position":[1]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3,5]},{"type":"text","position":[3,7,0]},{"type":"componentDynamic","position":[3,7]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"componentDynamic","position":[1,3,1]},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[1,5,1]},{"type":"componentDynamic","position":[1,5,1]},{"type":"componentDynamic","position":[1,5]},{"type":"attr","position":[1,7,1]},{"type":"componentDynamic","position":[1,7,1]},{"type":"componentDynamic","position":[1,7]},{"type":"componentDynamic","position":[1]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3,5]},{"type":"text","position":[3,7,0]},{"type":"componentDynamic","position":[3,7]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"componentDynamic","position":[1,3,1]},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[1,5,1]},{"type":"componentDynamic","position":[1,5,1]},{"type":"componentDynamic","position":[1,5]},{"type":"attr","position":[1,7,1]},{"type":"componentDynamic","position":[1,7,1]},{"type":"componentDynamic","position":[1,7]},{"type":"componentDynamic","position":[1]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3,5]},{"type":"componentDynamic","position":[3,7]},{"type":"componentDynamic","position":[3]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,5,2,1]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"registerYield","position":[1,1,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[1,1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[3]}]}},"default":{}}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["cpDraggable","cpCloseOnBodyClick","cpCloseOnSelection","cpAdvancedColorButton","cpAppearance","cpStandardColors","cpUsedColors","cpBasicColorPicker","cpSelectedColor","cpOriginElement","cpWrapperClass","cpCurrentRgbCode","cpBoundary","cpScrollable","cpNoFillButton","cpNoFillLabel","cpPaletteLabel","cpInline","cpColorFormats","cpDoneBtnText","cpCancelBtnText","cpBackBtnText","cpApplyBtnText","cpStandardColorArray","cpDuration","cpBoardColor","cpAvailableColors","cpMoreColorOptionSelected","cpOpacityLabel","cpUsedColorsNumber","stopObserverOnBoardColorChange","usedColors","polygonPoints","noFillPath","moreColorsPath","currentHue","currentBrightness","currentSaturation","paletteSize","circleOffsetSize","circleOffsetBecauseOfWinWidget","posdivElPalette","dragStatus","paletteMaxX","paletteMaxY","clickOnPaletteInProgress","component","hueStatus","poxYHue","poxXHue","dropButtonValue","basicDimensions","calledForHueMove","advCPDimensions","changedColor","tooltipTextChanged","inputChangeEvnt","hueBarSize","opacityStatus","opacityTrackSize","posXOpacity","opacity","sliderOffset","dragged","counter","cmykColors","setPrevCmyk","restrictOnChange","prevColor","colorFormat"],
	data : function(){
		return {
			//Component Variables
			"cpDraggable" : Lyte.attr("boolean",{"default" : false}),
			"cpCloseOnBodyClick" : Lyte.attr("boolean",{"default" : true}),
			"cpCloseOnSelection" : Lyte.attr("boolean",{"default" : false}),
			"cpAdvancedColorButton" : Lyte.attr("boolean",{"default" : true}),
			"cpAppearance" : Lyte.attr("string",{"default" : "callout"}),
			// "cpColorPreview" : Lyte.attr("boolean",{"default" : true}),
			"cpStandardColors" : Lyte.attr("boolean",{"default" : true}),
			"cpUsedColors" : Lyte.attr("boolean",{"default" : true}),
			"cpBasicColorPicker" : Lyte.attr("boolean",{"default" : true}),
			"cpSelectedColor" : Lyte.attr("object",{"default" : null}),
			"cpOriginElement" : Lyte.attr("string",{"default" : ""}),
			"cpWrapperClass" : Lyte.attr("string",{"default":"lyteColorPickerPopover"}),
			"cpCurrentRgbCode" : Lyte.attr("string",{ "default" : "90c3d4"}),
			"cpBoundary" : Lyte.attr("object",{"default" : null}),
			"cpScrollable":Lyte.attr("boolean",{"default": true}),
			"cpNoFillButton":Lyte.attr("boolean",{"default":false}),
			"cpNoFillLabel":Lyte.attr("string",{"default":""}),
			"cpPaletteLabel": Lyte.attr("string",{"default":""}),
			"cpInline" : Lyte.attr("boolean",{"default" : false}),
			"cpColorFormats" : Lyte.attr("array"),
			"cpDoneBtnText" : Lyte.attr("string",{"default" : "Done"}),
			"cpCancelBtnText" : Lyte.attr("string",{"default" : "Cancel"}),
			"cpBackBtnText" : Lyte.attr("string",{"default" : "Back"}),
			"cpApplyBtnText" : Lyte.attr("string",{"default" : "Apply"}),
			"cpStandardColorArray" : Lyte.attr("array",{"default" : []}),
			"cpDuration" : Lyte.attr("number",{"default":600}),
			"cpBoardColor" : Lyte.attr("string"),
			"cpAvailableColors" : Lyte.attr("array",{"default" : []}),
			"cpMoreColorOptionSelected" : Lyte.attr("boolean",{"default" : false}),
			"cpOpacityLabel" : Lyte.attr("string"),
			"cpUsedColorsNumber" : Lyte.attr("number",{"default":10}),
			//Local variables
			"stopObserverOnBoardColorChange" : Lyte.attr("boolean",{"default" : false}),
			
			
			"usedColors" : Lyte.attr("array"),
			
			"polygonPoints" : Lyte.attr("string",{"default" : "4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5"}),
			"noFillPath" : Lyte.attr("string",{"default" : "M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,1c1.8,0,3.3,0.7,4.6,1.7l-9.9,9.9C1.7,11.3,1,9.8,1,8 C1,4.1,4.1,1,8,1z M8,15c-1.8,0-3.3-0.7-4.6-1.7l9.9-9.9C14.3,4.7,15,6.2,15,8C15,11.9,11.9,15,8,15z"}),
			"moreColorsPath" : Lyte.attr("string", {"default" : "M299.7-0.2C128.3-0.2-7,134,0.2,305.2C7.4,476.9,138,577.3,259.7,595.9c88.2,13.4,107.8-45.1,87.3-67.3 c-35.5-38.3-22.6-68.6-7.3-82.5c17.4-15.7,50.3-17.3,77.3-13.8c65.5,8.5,175-40,182.2-144.8C611,116.5,471.1-0.2,299.7-0.2z M118.1,299.7c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1 C168.2,277.3,145.8,299.7,118.1,299.7z M217.6,166.6c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1 c27.7,0,50.1,22.4,50.1,50.1C267.7,144.1,245.2,166.6,217.6,166.6z M384.9,166.9c-27.7,0-50.1-22.4-50.1-50.1 c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C435,144.4,412.6,166.9,384.9,166.9z M485.2,299.9 c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C535.2,277.5,512.8,299.9,485.2,299.9z"}),
			

			//AdvColorPicker Local Variables
			"currentHue" : Lyte.attr("number",{ "default" : 0}),
			"currentBrightness" : Lyte.attr("number",{ "default" : 100}),
			"currentSaturation" : Lyte.attr("number",{ "default" : 100}),
			"paletteSize" : Lyte.attr("object"/*,{ "default" : {'height':160,'width':260}}*/),
			"circleOffsetSize" : Lyte.attr("number",{ "default" : 6}),
			"circleOffsetBecauseOfWinWidget" : Lyte.attr("number",{ "default" : 0}),
			"posdivElPalette" : Lyte.attr("object",{ "default" : {}}),
			"dragStatus" : Lyte.attr("number",{ "default" : 0}),
			"paletteMaxX" : Lyte.attr("number",{ "default" : 0}),
			"paletteMaxY" : Lyte.attr("number",{ "default" : 0}),
			"clickOnPaletteInProgress" : Lyte.attr("boolean",{ "default" : false}),
			"component" : Lyte.attr("object",{"default" : null}),
			"hueStatus" : Lyte.attr("number",{ "default" : 0}),
			"poxYHue" : Lyte.attr("number", { "default" : 0}),
			"poxXHue" : Lyte.attr("number", { "default" : 0}),
			"dropButtonValue" : Lyte.attr("string",{"default" : "HEX"}),
			"basicDimensions" : Lyte.attr("object",{"default" : {"width" : 222,"height" : 362}}),
			"calledForHueMove" : Lyte.attr("boolean",{"default":false}),
			"advCPDimensions" : Lyte.attr("object",{"default" : {"width" : 280,"height" : 322}}),
			"changedColor" : Lyte.attr("object"),
			"tooltipTextChanged" : Lyte.attr('boolean',{'default' : false}),
			"inputChangeEvnt" : Lyte.attr("boolean",{"default" : false}),
			"hueBarSize" : Lyte.attr("number"),
			"opacityStatus" : Lyte.attr("number",{"default":0}),
			"opacityTrackSize" : Lyte.attr("number"),
			"posXOpacity" : Lyte.attr("number", { "default" : 0}),
			"opacity" : Lyte.attr("number"),
			"sliderOffset" : Lyte.attr("number",{"default" : 4}),
			"dragged" : Lyte.attr("boolean", {"default" : false}),
			"counter" : Lyte.attr("number"),
			"cmykColors" : Lyte.attr("array",{"default":[]}),
			"setPrevCmyk" : Lyte.attr("boolean",{"default":"false"}),
			"restrictOnChange" : Lyte.attr("boolean",{"default": false}),
			"prevColor" : Lyte.attr("object", {"default":{}}),
			"colorFormat" : Lyte.attr("object", {"default" : {"R" : "Red", "G" : "Green", "B" : "Blue", "H" : "Hue", "S" : "Saturation", "V" : "Brightness", "C" : "Cyan", "M" : "Magenta", "Y" : "Yellow", "K" : "Key", "A" : "Opacity"}})
		}		
	},
	
	didConnect : function(){
		this.setData('component',this);
	},

	//Observes color chnage and sets the color for advanced colorpicker
	observeColorChange : function(){
		// console.log(this.getData('cpBoardColor'));
		if(!(this.getData('cpBasicColorPicker')) && !(this.getData('stopObserverOnBoardColorChange')) && this.inputEle && this.isCurrentRgbCodeDifferent()){
			// console.log("triggered boardColor change");
			var boardColor = this.getData('cpBoardColor');
			this.__setCurrentRgbCodeFromBoardColor();
			this.setData('inputChangeEvnt',true);
			this.setRgbColor('#' + this.getData('cpCurrentRgbCode'));
			this.__updateRgbInForm();
			if( (/rgba/.test(boardColor) || (/#/.test(boardColor) && boardColor.length == 9)) ){
				this.__updateOpacityInForm();
			}
		}
		if(this.getData('stopObserverOnBoardColorChange')){
			this.setData('stopObserverOnBoardColorChange',false);
		}
	}.observes('cpBoardColor'),

	isCurrentRgbCodeDifferent : function(){
		var boardColor = this.getData('cpBoardColor'),
			currentRgbCode = this.getData('cpCurrentRgbCode'), code;
		if(/#/.test(boardColor)){
			if(boardColor.length == 9){
				code = boardColor.substring(1,7);
			}
			if(boardColor.length == 7){
				code = boardColor.substring(1);
			}
			else if(boardColor.length == 4){
				code = ColorPicker_Util.convert3DigitTo6DigitRgbCode(boardColor.substring(1));
			}
		}
		else if(/rgba/.test(boardColor)){
			var rgbColor = boardColor.substring(5,boardColor.length-1).split(",");
			code = ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2]);
		}
		else if(/rgb/.test(boardColor)){
			var rgbColor = boardColor.substring(4,boardColor.length-1).split(",");
			code = ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2]);
		}

		if(code && code.toUpperCase() == currentRgbCode.toUpperCase()){
			return false;
		}
		return true;
	},

	addPasteEvent : function(){
		var comp = this.$node,
			format = this.getData('dropButtonValue'),
			self = this;
		if(format === _lyteUiUtils.i18n("HEX")){
			comp.querySelector('#lyteCPShowValue input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "HEX");
			});
			comp.querySelector('#lyteCP__A input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "A");
			});
		}
		else if(format === _lyteUiUtils.i18n("RGB")){
			comp.querySelector('#lyteCP__R input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "R");
			});
			comp.querySelector('#lyteCP__G input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "G");
			});
			comp.querySelector('#lyteCP__B input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "B");
			});
			comp.querySelector('#lyteCP__A input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "A");
			});
		}
		else if(format === _lyteUiUtils.i18n("HSV")){
			comp.querySelector('#lyteCP__H input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "H");
			});
			comp.querySelector('#lyteCP__S input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "S");
			});
			comp.querySelector('#lyteCP__V input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "V");
			});
			comp.querySelector('#lyteCP__A input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "A");
			});
		}
		else if(format === _lyteUiUtils.i18n("CMYK")){
			comp.querySelector('#lyteCP__C input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "C");
			});
			comp.querySelector('#lyteCP__M input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "M");
			});
			comp.querySelector('#lyteCP__Y input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "Y");
			});
			comp.querySelector('#lyteCP__K input').addEventListener('paste', function(e){
				self.actions.onPaste(e, "K");
			});
		}

	},

	initializeAdvColorPicker : function(event,ele,restrictCmykChange){
		this.setData('dropButtonValue', this.getData('cpColorFormats')[0]);
		var imageObj = ele.querySelector('#lyteCPImgDiv')
		var divElPalette = ele.querySelector('#colorDiv');
		var divElPaletteCircle = ele.querySelector('.colorSlider_palette_circle');
		var cpDiv = ele.querySelector('.lyteColorPicker--advanced');
		if(!cpDiv.addedEvents){
			ele.querySelector('.colorSlider_hue').addEventListener('mousedown', function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initHueMove(event,ColorPicker_Util.component);
			});
			divElPalette.addEventListener('mousedown',function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initPaletteMove(event,ColorPicker_Util.component);
			});
			ele.querySelector('.colorSlider_hueBar').addEventListener('mousedown', function(event) {
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
	            ColorPicker_EventUtil.__moveOnHueBar(event,ColorPicker_Util.component);
	        });
	        ele.querySelector('.colorSlider_hue').addEventListener('touchstart', function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initHueMove(event,ColorPicker_Util.component);
			});
			divElPalette.addEventListener('touchstart',function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initPaletteMove(event,ColorPicker_Util.component);
			});
			ele.querySelector('.colorSlider_hueBar').addEventListener('touchstart', function(event) {
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
	            ColorPicker_EventUtil.__moveOnHueBar(event,ColorPicker_Util.component);
	        });
			//for opacityslider circle
			ele.querySelector('.lyteColorPicker__opacityslider').addEventListener('mousedown', function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initOpacityMove(event,ColorPicker_Util.component);
			});
			ele.querySelector('.lyteColorPicker__opacityslider').addEventListener('touchstart', function(event){
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
				return ColorPicker_EventUtil.__initOpacityMove(event,ColorPicker_Util.component);
			});
			//for opacityslider track
			ele.querySelector('.opacityslider__track').addEventListener('mousedown', function(event) {
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
	            ColorPicker_EventUtil.__moveOnOpacityTrack(event,ColorPicker_Util.component);
	        });
	        ele.querySelector('.opacityslider__track').addEventListener('touchstart', function(event) {
				ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
	            ColorPicker_EventUtil.__moveOnOpacityTrack(event,ColorPicker_Util.component);
	        });
	        cpDiv.addedEvents = true;
		}

        this.setData('paletteSize',{'height' : divElPalette.offsetHeight, 'width' : divElPalette.offsetWidth});
        this.setData('hueBarSize',ele.querySelector('.colorSlider_hueBar').offsetWidth);
        this.setData('opacityTrackSize',ele.querySelector('.opacityslider__track').offsetWidth);
        if(this.getData('opacity') === undefined || (this.getData('opacity') && this.getData('opacity') < 0)){
        	this.setData('opacity',100);
        }
        if(this.getData('cpBoardColor')){
        	this.__setCurrentRgbCodeFromBoardColor();
        }
        if(this.getData('inputChangeEvnt')){
        	this.setData('inputChangeEvnt',false);
        }
		this.setRgbColor("#"+this.getData("cpCurrentRgbCode"),null,restrictCmykChange);
		this.addPasteEvent();
		ele = null;
		divElPalette = null;
		divElPaletteCircle = null;
		imageObj = null;
	},

	
	initializeBasicColorPicker : function(event,ele){
		var liELes = ele.querySelectorAll('.default__colors > li');
		for(var v =0; v<liELes.length ; v++){
			liELes[v].style.background = liELes[v].textContent;
		}
		if(this.getData('cpStandardColors')){
			liELes = ele.querySelectorAll('.standard__colors > li');
			for(var v =0; v<liELes.length ; v++){
				liELes[v].style.background = liELes[v].textContent;
			}
		}
		if(this.getData('cpUsedColors')){
			liELes = ele.querySelectorAll('.used__colors > li');
			for(var v =0; v<liELes.length ; v++){
				liELes[v].style.background = liELes[v].textContent;
			}
		}
		if(this.getData('cpColorPreview')){
			if(this.getData('cpCurrentRgbCode')){
				var color = ColorPicker_Util.getRgbColorsByRgbCode(this.getData('cpCurrentRgbCode'));
			}
		}
		liELes = null;
	},

	executeOnBeforeOpen : function(){
		if(this.getMethods('onBeforeOpen')){
			this.executeMethod('onBeforeOpen');
		}
	},

	executeOnSelect : function(event, close){
		var colors = this.getData('usedColors');
		// var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
		// this.setData('cpSelectedColor',{'hex' : '#'+this.getData('cpCurrentRgbCode'), 
		// 									'rgb' : "rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")", 
		// 									'opacity' : this.getData('opacity'),
		// 									'hex-alpha' : '#'+this.getData('cpCurrentRgbCode')+ColorPicker_Util.getDecimalToHexAlphaCode(this.getData('opacity')),
		// 									'rgba' : "rgba("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+", "+(this.getData('opacity')/100)+")"});
		this.__setSelectedColor();
		var color = this.getData('cpSelectedColor').rgba;
		if(colors.indexOf(color) != -1){
			// colors.splice(colors.indexOf(color), 1);
			Lyte.arrayUtils(this.getData('usedColors'),'removeAt',colors.indexOf(color),1);
		}
		else{
			Lyte.arrayUtils(this.getData('usedColors'),'removeAt',this.getData('cpUsedColorsNumber') - 1,1);
		}
		Lyte.arrayUtils(this.getData('usedColors'),'insertAt',0,color);
		var node = this.$node.querySelectorAll(".usedColor__container li")[0] /*(this.getData('cpInline') ? this.$node : this.childComp).querySelectorAll(".usedColor__container li")[0]*/;
		if(node){
			node.style.background = color;
		}
		// this.setData('usedColors',colors);
		if(this.getMethods("onSelect")){
			this.executeMethod("onSelect",event,close,this.getData('calledForHueMove'));	
		}
		if(this.getData('calledForHueMove')){
			this.setData('calledForHueMove',false);
		}
	},

	executeOnOpen : function(){
		if(this.getMethods('onOpen')){
			this.executeMethod('onOpen');
		}
	},

	executeOnClose : function(event){
		if(this && this.inputEle){
			// var inputEle = this.inputEle;
			this.inputEle = null;
			// inputEle.remove();
		}
		if(this.$node.closest('lyte-wormhole')){
			this.$node.closest('lyte-wormhole')._callee.parentElement.setData('ltPropShow',false);
		}
		// if(this.getMethods('onClose')){
		// 	this.executeMethod('onClose',event);
		// }
	},

	executeOnChange : function(){
		// var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData('cpCurrentRgbCode'));
  //       var selectedColor = {
  //       	"hex" : "#"+this.getData('cpCurrentRgbCode'),
  //       	"rgb" : "rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")",
  //       	"opacity" : this.getData('opacity'),
  //       	"hex-alpha" : "#"+this.getData('cpCurrentRgbCode')+ColorPicker_Util.getDecimalToHexAlphaCode(this.getData('opacity')),
  //       	"rgba" : "rgba("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+", "+(this.getData('opacity')/100)+")"
  //       };
  //       this.setData("cpSelectedColor",selectedColor);
  		this.__setSelectedColor();
  		if( !(this.isColorValueEqual()) ){
  			this.setData('prevColor', this.getData('cpSelectedColor'));
  			if(this.getMethods('onChange')){
				this.executeMethod('onChange',event,this.getData('cpSelectedColor'),this);
			}
  		}
	},

	isColorValueEqual : function(){
		var prevColor = this.getData('prevColor'),
			currColor = this.getData('cpSelectedColor');
		if(Object.keys(prevColor).length === Object.keys(currColor).length){
			for(key in prevColor){
				if(prevColor[key] != currColor[key]){
					return false;
				}
			}
			return true;
		}
		return false;
	},

	validateInputValue : function(type, lyteInp){
		var value = lyteInp.getData('ltPropValue');
		if(type === "HEX"){
			if(value.length == 4 || value.length == 7){
				if(lyteInp.classList.contains('lyteCp__Invalid')){
					lyteInp.classList.remove('lyteCp__Invalid');
				}
			}
			else{
				lyteInp.classList.add('lyteCp__Invalid');
				if(this.getMethods('onInputError')){
					this.executeMethod('onInputError', type == "HEX" ? "HEX" : this.getData('colorFormat')[type]);
				}
			}
		}
		else if(type == "R" || type == "G" || type == "B" || type == "H" || type == "S" || type == "V" || type == "C" || type == "M" || type == "Y" || type == "K" || type == "A"){
			if(value.length > 0 && value.length < 4){
				if(lyteInp.classList.contains('lyteCp__Invalid')){
					lyteInp.classList.remove('lyteCp__Invalid');
				}
			}
			else{
				lyteInp.classList.add('lyteCp__Invalid');
				if(this.getMethods('onInputError')){
					this.executeMethod('onInputError', type == "HEX" ? "HEX" : this.getData('colorFormat')[type]);
				}
			}
		}

	},

	/*----------------- Start of Utility Methods for Color Picker ---------------*/

	__setSelectedColor : function() {
		var rgbCode = this.getData('cpCurrentRgbCode');
		var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(rgbCode);
		var cmykColors = this.getData('cmykColors');
		if(this.getData('dropButtonValue') != "CMYK"){
			var rgbCol = ColorPicker_Util.getRgbColorsByHsv(this.getData('currentHue'), this.getData('currentSaturation') / 100, this.getData('currentBrightness') / 100);
    		var derivedCmykColors = ColorPicker_Util.getCmykByRgbColors([rgbCol.red,rgbCol.green,rgbCol.blue]);
    		if(!cmykColors.length){
    			cmykColors = derivedCmykColors
    			this.setData('cmykColors', cmykColors);
    		}
    		else{
    			var calculatedRgbCode1 = ColorPicker_Util.getRgbCodeByCmyk(derivedCmykColors[0], derivedCmykColors[1], derivedCmykColors[2], derivedCmykColors[3]);
    			var calculatedRgbCode2 = ColorPicker_Util.getRgbCodeByCmyk(cmykColors[0], cmykColors[1], cmykColors[2], cmykColors[3]);
    			if(calculatedRgbCode1 != calculatedRgbCode2 && calculatedRgbCode1 == rgbCode){
    				cmykColors = derivedCmykColors;
    				this.setData('cmykColors', cmykColors);
    			}
    		}
		}
        var selectedColor = {
        	"hex" : "#"+rgbCode,
        	"rgb" : "rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")",
        	"opacity" : this.getData('opacity'),
        	"hex-alpha" : "#"+rgbCode+ColorPicker_Util.getDecimalToHexAlphaCode(this.getData('opacity')),
        	"rgba" : "rgba("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+", "+(this.getData('opacity')/100)+")",
        	"cmyk" : cmykColors
        };
        this.setData("cpSelectedColor",selectedColor);
	},

	setRgbColor : function(rgbColor, hue, restrictCmykChange) {
        var hsv = ColorPicker_Util.getHsvByRgbCode(rgbColor);
        this.setData('currentHue', hue ? hue : hsv.hue);
        this.setData('currentBrightness', hsv.brightness * 100);
        this.setData('currentSaturation', hsv.saturation * 100);
        this.__changeViewAfterColorChange(restrictCmykChange);
        this.__setSelectedColor();
    },

    __changeViewAfterColorChange : function(restrictCmykChange) {
        this.__setCurrentRgbCode();
        this.__setPaletteBgColor();
        this.__setSliderPos();
        // this.__setBgColorPreviewDiv();
        if(!this.getData('inputChangeEvnt')){
        	this.__updateRgbInForm(restrictCmykChange);
        }else{
        	this.setData('inputChangeEvnt',false);
        }       
        /*this.__updateHsvInForm();*/
        this.__setSmallCirclePosition();
        // this.__setOpacitySliderPos();
		this.__changeColorInOpacityTrack();
		this.__setOpacityColorPreviewDiv();
		this.__updateOpacityInForm();
    },

	__setCurrentRgbCodeFromBoardColor : function(){
    	var color = this.getData('cpBoardColor');
		if(/#/.test(color)){
			if(color.length == 9){
				this.setData('opacity', ColorPicker_Util.getHexToDecimalAlphaCode(color.substring(7)));
				this.setData('cpCurrentRgbCode',color.substring(1,7));
			}
			else if(color.length == 7){
				this.setData('cpCurrentRgbCode',color.substring(1));
			}
			else if(color.length == 4){
				this.setData('cpCurrentRgbCode',ColorPicker_Util.convert3DigitTo6DigitRgbCode(color.substring(1)));
			}
		}
		else if(/rgba/.test(color)){
			var rgbColor = color.substring(5,color.length-1).split(",");
			this.setData('opacity',rgbColor[3]*100);
			this.setData('cpCurrentRgbCode',ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2]));
		}
		else if(/rgb/.test(color)){
			var rgbColor = color.substring(4,color.length-1).split(",");
			this.setData('cpCurrentRgbCode',ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2]));
		}
    },

	__setCurrentRgbCode : function(code) {
		var rgbCode = code ? code : ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), this.getData('currentSaturation') / 100, this.getData('currentBrightness') / 100);
		this.setData('stopObserverOnBoardColorChange', true);
		this.setData('cpBoardColor', '#'+rgbCode);
        this.setData('cpCurrentRgbCode', rgbCode);
        if(this.getData('stopObserverOnBoardColorChange')){
        	this.setData('stopObserverOnBoardColorChange', false);
        }
    },

    __setPaletteBgColor : function() {
        try {
        	// if(this.getData('cpInline')){
        		this.$node.querySelector('#colorDiv').style.backgroundColor = '#' + ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), 1, 1);
        	// }
        	// else{
         //    	this.childComp.querySelector('#colorDiv').style.backgroundColor = '#' + ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), 1, 1);
        	// }
        } catch (e) {}
    },

    __setSliderPos: function() {
        var leftPos = Math.round(this.getData('hueBarSize') - ((this.getData('currentHue') / 360) * this.getData('hueBarSize')));
        // if(this.getData('cpInline')){
        	this.$node.querySelector('.colorSlider_sliderHandle').style.left = leftPos - this.getData('sliderOffset') + "px";
        // }
        // else{
        // 	this.childComp.querySelector('.colorSlider_sliderHandle').style.left = leftPos - this.getData('sliderOffset') + "px";
        // }
    },

    __setSmallCirclePosition : function() {
    	var currentBrightness = this.getData('currentBrightness');
    	var currentSaturation = this.getData('currentSaturation');
    	var paletteSize = this.getData('paletteSize');
    	var circleOffsetSize = this.getData('circleOffsetSize');
    	var divElPaletteCircle = this.$node.querySelector('.colorSlider_palette_circle') /*this.getData('cpInline') ? this.$node.querySelector('.colorSlider_palette_circle') : this.childComp.querySelector('.colorSlider_palette_circle')*/;
        var leftPos = Math.round(currentSaturation * (paletteSize.width / 100)) - circleOffsetSize;
        var topPos = paletteSize.height - Math.round(currentBrightness * (paletteSize.height / 100)) - circleOffsetSize;
        divElPaletteCircle.style.left = leftPos + 'px';
        divElPaletteCircle.style.top = topPos + 'px';
        divElPaletteCircle.className = divElPaletteCircle.className.replace('colorSlider_palette_circleBlack', '');
        if (currentBrightness > 80) {
            divElPaletteCircle.className = divElPaletteCircle.className + 'colorSlider_palette_circleBlack';
        }
        divElPaletteCircle = null;
    },

    __ffHackWinWidget : function() {
    	var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
        if (ele.querySelector('.lyteColorPicker--advanced').parentNode.className && ele.querySelector('.lyteColorPicker--advanced').parentNode.className.indexOf('windowContent') >= 0 && !document.all) {
            this.setData('circleOffsetBecauseOfWinWidget', 0);
        }
    },

    __setBgColorPreviewDiv : function() {
    	// if(this.getData('cpInline')){
    		this.$node.querySelector('.previewDiv').style.backgroundColor = '#' + this.getData('cpCurrentRgbCode');
    	// }
    	// else{
    	// 	this.childComp.querySelector('.previewDiv').style.backgroundColor = '#' + this.getData('cpCurrentRgbCode');
    	// }
    },

    __updateRgbInForm : function(restrictCmykChange){
    	var comp = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
    	var format = comp.querySelector('.selectFormat').querySelector('lyte-dropdown').getData('ltPropSelected');
    	this.setData('dropButtonValue',format);
    	
    	if(format === _lyteUiUtils.i18n("HEX")){
    		comp.querySelector('#lyteCPShowValue').setData("ltPropValue",("#" + this.getData("cpCurrentRgbCode")));
    		this.inputEle.value = ("#" + this.getData("cpCurrentRgbCode") + ColorPicker_Util.getDecimalToHexAlphaCode(this.getData('opacity')));
    		this.setData('counter', 1);
    		if(!restrictCmykChange && this.getData('setPrevCmyk')){
				this.setData('setPrevCmyk',false);
			}
    	}
    	else if(format === _lyteUiUtils.i18n("RGB")){
    		var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
    		comp.querySelector('#lyteCP__R').component.setData('ltPropValue',rgbColor.red+"");
    		comp.querySelector('#lyteCP__G').component.setData('ltPropValue',rgbColor.green+"");
    		comp.querySelector('#lyteCP__B').component.setData('ltPropValue',rgbColor.blue+"");
    		this.setData('counter', 3);
    		// comp.querySelector('#lyteCPShowValue_RGB').component.setData('ltPropValue',"rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")");
    		this.inputEle.value = "rgba("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+", "+(this.getData('opacity')/100)+")";
    		// this.getData('rgbFieldCode').component.$node.cp("value",("rgb("+rgbColor.red+","+rgbColor.green+","+rgbColor.blue+")"));
    		if(!restrictCmykChange && this.getData('setPrevCmyk')){
				this.setData('setPrevCmyk',false);
			}
    	}
    	else if(format === _lyteUiUtils.i18n("HSV")){
    		var hue = Math.round(this.getData('currentHue'));
    		var saturation = Math.round(this.getData('currentSaturation'));
    		var valueBrightness = Math.round(this.getData('currentBrightness'));
    		comp.querySelector('#lyteCP__H').component.setData('ltPropValue',hue+"");
    		comp.querySelector('#lyteCP__S').component.setData('ltPropValue',saturation+"");
    		comp.querySelector('#lyteCP__V').component.setData('ltPropValue',valueBrightness+"");
    		this.setData('counter', 3);
    		this.inputEle.value = "hsv("+hue+"°,"+saturation+"%,"+valueBrightness+"%,"+(this.getData('opacity')/100)+")";
    		// this.getData('rgbFieldCode').component.$node.cp("value",("hsv("+hue+"°,"+saturation+"%,"+valueBrightness+"%)"));
    		if(!restrictCmykChange && this.getData('setPrevCmyk')){
				this.setData('setPrevCmyk',false);
			}
    	}
    	else if(format === _lyteUiUtils.i18n("CMYK")){
    		// console.log(this.getData('currentHue'),this.getData('currentSaturation')/100,this.getData('currentBrightness') / 100)
    		var rgbColor = ColorPicker_Util.getRgbColorsByHsv(this.getData('currentHue'), this.getData('currentSaturation') / 100, this.getData('currentBrightness') / 100);
    		var cmykColors;
    		if(this.getData('setPrevCmyk') && this.getData('cmykColors').length == 4){
    			cmykColors = this.getData('cmykColors');
    		}
    		else{
    			cmykColors = ColorPicker_Util.getCmykByRgbColors([rgbColor.red,rgbColor.green,rgbColor.blue]);
    			if(!restrictCmykChange && this.getData('setPrevCmyk')){
    				this.setData('setPrevCmyk',false);
    			}
    		}
    		// console.log(rgbColor, cmykColors);
    		comp.querySelector('#lyteCP__C').component.setData('ltPropValue',Math.round(cmykColors[0]*100)+"");
    		comp.querySelector('#lyteCP__M').component.setData('ltPropValue',Math.round(cmykColors[1]*100)+"");
    		comp.querySelector('#lyteCP__Y').component.setData('ltPropValue',Math.round(cmykColors[2]*100)+"");
    		comp.querySelector('#lyteCP__K').component.setData('ltPropValue',Math.round(cmykColors[3]*100)+"");
    		this.setData('cmykColors', cmykColors);
    		this.setData('counter', 4);
    		this.inputEle.value = "cmyk("+Math.round(cmykColors[0]*100)+"%,"+Math.round(cmykColors[1]*100)+"%,"+Math.round(cmykColors[2]*100)+"%,"+Math.round(cmykColors[3]*100)+"%)";
    		// this.getData('rgbFieldCode').component.$node.cp("value",("cmyk("+Math.round(cmykColors[0]*100)+"%,"+Math.round(cmykColors[1]*100)+"%,"+Math.round(cmykColors[2]*100)+"%,"+Math.round(cmykColors[3]*100)+"%)"));
    	}
    },

    __setOpacitySliderPos : function(){
    	var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
    	var leftPos = (this.getData('opacity')*this.getData('opacityTrackSize'))/100;
    	ele.querySelector('.opacityslider__circlethumb').style.left = leftPos - this.getData('sliderOffset') + "px";
    },

    __changeColorInOpacityTrack : function(){
    	var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
    	ele.querySelector('.opacityslider__track').style.backgroundImage = "linear-gradient(to right, transparent, #"+this.getData('cpCurrentRgbCode')+")";
    },

    __setOpacityColorPreviewDiv : function(){
    	var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
    	var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
    	ele.querySelector('.previewDiv').style.backgroundColor = "rgba("+rgbColor.red+","+rgbColor.green+","+rgbColor.blue+","+(this.getData('opacity')/100)+")";
    },

    __updateOpacityInForm : function(){
    	var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
    	if(ele.querySelector('#lyteCP__A')){
    		ele.querySelector('#lyteCP__A').component.setData('ltPropValue',this.getData('opacity'));
    		if(this.getData('dropButtonValue') == _lyteUiUtils.i18n("HEX")){
    			this.inputEle.value = ("#" + this.getData("cpCurrentRgbCode") + ColorPicker_Util.getDecimalToHexAlphaCode(this.getData('opacity')));
    		}
    		if(this.getData('dropButtonValue') == _lyteUiUtils.i18n("RGB")){
    			var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
    			this.inputEle.value = "rgba("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+", "+(this.getData('opacity')/100)+")";
    		}
    		if(this.getData('dropButtonValue') == _lyteUiUtils.i18n("HSV")){
    			var hue = Math.round(this.getData('currentHue'));
	    		var saturation = Math.round(this.getData('currentSaturation'));
	    		var valueBrightness = Math.round(this.getData('currentBrightness'));
    			this.inputEle.value = "hsv("+hue+"°,"+saturation+"%,"+valueBrightness+"%,"+(this.getData('opacity')/100)+")";
    		}
    	}
    },

	/*----------------- End of Utility Methods for Color Picker ---------------*/

	didDestroy : function(){
    	if(this.tId){
    		clearInterval(this.tId);
    		this.tId = false;
    	}
    },

	methods : {
		inputValueChanged : function(type,changedProp,lyteInp){
			// console.log("INPUT value changed");
			var comp = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
			if(type === "HEX"){
				if(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/i.test(changedProp.newValue)){
					this.setData('inputChangeEvnt',true);
					if(changedProp.newValue.length == 7){
						this.__setCurrentRgbCode(changedProp.newValue.substring(1));
						// this.setData('cpCurrentRgbCode',changedProp.newValue.substring(1));
						// this.setRgbColor(changedProp.newValue);
					}
					else if(changedProp.newValue.length == 4){
						this.__setCurrentRgbCode(ColorPicker_Util.convert3DigitTo6DigitRgbCode(changedProp.newValue.substring(1)));
						// this.setData('cpCurrentRgbCode',ColorPicker_Util.convert3DigitTo6DigitRgbCode(changedProp.newValue.substring(1)));
						// this.setRgbColor('#' + ColorPicker_Util.convert3DigitTo6DigitRgbCode(changedProp.newValue.substring(1)));
					}
					if(!(this.getData('dragged')) && this.getData('dragStatus') != 1 && this.getData('hueStatus') != 1 && !(this.getData('counter'))){
						this.setRgbColor('#' + this.getData('cpCurrentRgbCode'));
						this.executeOnChange();
					}
					else{
						this.setData('dragged',false);
						if(this.getData('counter')){
							this.setData('counter', this.getData('counter') - 1);
							if(!(this.getData('counter'))){
								this.setData('restrictOnChange',true);
								this.__updateOpacityInForm();
								// this.setData('counter', 1);
							}
						}
					}
				}
				else if(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/i.test(changedProp.newValue)){
					this.setData('inputChangeEvnt',true);
					if(changedProp.newValue.length == 6){
						this.__setCurrentRgbCode(changedProp.newValue);
						// this.setData('cpCurrentRgbCode',changedProp.newValue);
					}
					else if(changedProp.newValue.length == 3){
						this.__setCurrentRgbCode(ColorPicker_Util.convert3DigitTo6DigitRgbCode(changedProp.newValue));
						// this.setData('cpCurrentRgbCode',ColorPicker_Util.convert3DigitTo6DigitRgbCode(changedProp.newValue));
					}
					if(!(this.getData('dragged')) && this.getData('dragStatus') != 1 && this.getData('hueStatus') != 1 && !(this.getData('counter'))){
						this.setRgbColor('#' + this.getData('cpCurrentRgbCode'));
						this.executeOnChange();
					}
					else{
						this.setData('dragged',false);
						if(this.getData('counter')){
							this.setData('counter', this.getData('counter') - 1);
							if(!(this.getData('counter'))){
								this.setData('restrictOnChange',true);
								this.__updateOpacityInForm();
								// this.setData('counter', 1);
							}
						}
					}
				}
			}
			if(type === "R" || type === "G" || type === "B"){
				this.setData('inputChangeEvnt',true);
				var red = comp.querySelector('#lyteCP__R').component.getData('ltPropValue'),
					green = comp.querySelector('#lyteCP__G').component.getData('ltPropValue'),
					blue = comp.querySelector('#lyteCP__B').component.getData('ltPropValue');
				if(red && green && blue){
					this.__setCurrentRgbCode(ColorPicker_Util.getRgbCodeByRgbColors(red, green, blue));
					// this.setData('cpCurrentRgbCode',ColorPicker_Util.getRgbCodeByRgbColors(red, green, blue));
					if(!(this.getData('dragged')) && this.getData('dragStatus') != 1 && this.getData('hueStatus') != 1 && !(this.getData('counter'))){
						this.setRgbColor('#' + this.getData('cpCurrentRgbCode'));
						this.executeOnChange();
					}
					else{
						this.setData('dragged',false);
						if(this.getData('counter')){
							this.setData('counter', this.getData('counter') - 1);
							if(!(this.getData('counter'))){
								this.setData('restrictOnChange',true);
								this.__updateOpacityInForm();
								// this.setData('counter', 1);
							}
						}
					}
				}
			}
			if(type === "H" || type === "S" || type === "V"){
				this.setData('inputChangeEvnt',true);
				var hue = comp.querySelector('#lyteCP__H').component.getData('ltPropValue'),
					saturation = comp.querySelector('#lyteCP__S').component.getData('ltPropValue'),
					valueBrightness = comp.querySelector('#lyteCP__V').component.getData('ltPropValue');
				if(hue && saturation && valueBrightness){
					this.__setCurrentRgbCode(ColorPicker_Util.getRgbCodeByHsv(hue, saturation, valueBrightness));
					// this.setData('cpCurrentRgbCode',ColorPicker_Util.getRgbCodeByHsv(hue, saturation, valueBrightness));
					if(!(this.getData('dragged')) && this.getData('dragStatus') != 1 && this.getData('hueStatus') != 1 && !(this.getData('counter'))){
						this.setRgbColor('#' + this.getData('cpCurrentRgbCode'), type === "H" && hue == 360 ? 360 : undefined);
						this.executeOnChange();
					}
					else{
						this.setData('dragged',false);
						if(this.getData('counter')){
							this.setData('counter', this.getData('counter') - 1);
							if(!(this.getData('counter'))){
								this.setData('restrictOnChange',true);
								this.__updateOpacityInForm();
								// this.setData('counter', 1);
							}
						}
					}
				}
			}
			if(type === "C" || type === "M" || type === "Y" || type === "K"){
				this.setData('inputChangeEvnt',true);
				var c = comp.querySelector('#lyteCP__C').component.getData('ltPropValue'),
					m = comp.querySelector('#lyteCP__M').component.getData('ltPropValue'),
					y = comp.querySelector('#lyteCP__Y').component.getData('ltPropValue'),
					k = comp.querySelector('#lyteCP__K').component.getData('ltPropValue');
				if(c && m && y && k){
					this.setData('cmykColors', [c/100,m/100,y/100,k/100]);
					this.__setCurrentRgbCode(ColorPicker_Util.getRgbCodeByCmyk(c, m, y, k));
					// this.setData('cpCurrentRgbCode',ColorPicker_Util.getRgbCodeByCmyk(c, m, y, k));
					if(!(this.getData('dragged')) && this.getData('dragStatus') != 1 && this.getData('hueStatus') != 1 && !(this.getData('counter'))){
						this.setRgbColor('#' + this.getData('cpCurrentRgbCode'));
						this.executeOnChange();
					}
					else{
						this.setData('dragged',false);
						if(this.getData('counter')){
							this.setData('counter', this.getData('counter') - 1);
						}
					}
				}
			}
			if(type === "A"){
				var a = comp.querySelector('#lyteCP__A').component.getData('ltPropValue');
				if(a){
					this.setData('opacity', parseInt(a));
					if(this.getData('opacityStatus') != 1){
						this.__setOpacitySliderPos();
						this.__setOpacityColorPreviewDiv();
						if(!this.getData('restrictOnChange')){
							this.executeOnChange();
						}
						else{
							this.setData('restrictOnChange',false);
						}
					}
				}
			}
			this.validateInputValue(type, lyteInp);
		},

		onInputBlur : function(type, event, lyteInp){
			switch(type){
				case "HEX" : 
					lyteInp.setData("ltPropValue",("#" + this.getData("cpCurrentRgbCode")));
					break;
				case "R" :
					var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
    				lyteInp.setData('ltPropValue',rgbColor.red+"");
					break;
				case "G" :
					var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
					lyteInp.setData('ltPropValue',rgbColor.green+"");
					break;
				case "B" :
					var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("cpCurrentRgbCode"));
					lyteInp.setData('ltPropValue',rgbColor.blue+"");
					break;
				case "H" :
		    		lyteInp.setData('ltPropValue',Math.round(this.getData('currentHue'))+"");
					break;
				case "S" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('currentSaturation'))+"");
					break;
				case "V" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('currentBrightness'))+"");
					break;
				case "C" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('cmykColors')[0] * 100)+"");
					break;
				case "M" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('cmykColors')[1] * 100)+"");
					break;
				case "Y" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('cmykColors')[2] * 100)+"");
					break;
				case "K" :
					lyteInp.setData('ltPropValue',Math.round(this.getData('cmykColors')[3] * 100)+"");
					break;
				case "A" :
					lyteInp.setData('ltPropValue', this.getData('opacity'));
					break;
			}
			
		},
		
		changeFormatView : function(e,value){
			if(e.currentTarget.tagName == 'LYTE-DROP-BOX'){
	    		this.__updateRgbInForm(true);
	    		this.addPasteEvent();
			}
	    }
	},

	actions : {
		onPaste : function(event, prop){
			// console.log("onPaste triggered", prop);
			var input = event.target,
				start = input.selectionStart,
				end = input.selectionEnd,
				value = input.value;
			if(start == end){
				value = value + (event.clipboardData || window.clipboardData).getData('text').trim();
			}
			else{
				var paste = value.substring(0,start) + (event.clipboardData || window.clipboardData).getData('text').trim();
				var restMsg = value.substring(end);
				if(restMsg.length > 0){
					paste += restMsg;
				}
				value = paste;
			}
			if(prop === "HEX"){
				if( (value.length == 1 && value[0] != '#') || value.length > 7 || (value.length > 0 && (value[0] != '#' || value.substring(1).indexOf('#') != -1)) ){
					event.preventDefault();
					event.stopPropagation();
				}
			}
			else if(prop == "R" || prop == "G" || prop == "B"){
				if(value === "" || isNaN(value) || (value && (parseInt(value) < 0 || parseInt(value) >255))){
					event.preventDefault();
					event.stopPropagation();
				}
			}
			else if(prop == "H"){
				if(value === "" || isNaN(value) || (value && (parseInt(value) < 0 || parseInt(value) >360))){
					event.preventDefault();
					event.stopPropagation();
				}
			}
			else if(prop == "S" || prop == "V" || prop == "C" || prop == "M" || prop == "Y" || prop == "K" || prop == "A"){
				if(value === "" || isNaN(value) || (value && (parseInt(value) < 0 || parseInt(value) >100))){
					event.preventDefault();
					event.stopPropagation();
				}
			}
		},
		inputKeyDown : function(event, comp, type){
			// console.log(arguments);
			//BACKSPACE - key code -> 8
			//DELETE - key code -> 46
			var arrowkeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
			if(type == "HEX"){
				if((event.shiftKey && (event.keyCode || event.which) == 51) || 
					(!(event.shiftKey || event.metaKey) && (event.keyCode || event.which) >= 48 && (event.keyCode || event.which) <= 57) || 
					((event.keyCode || event.which) >= 65 && (event.keyCode || event.which) <= 70) || 
					((event.keyCode || event.which) >= 97 && (event.keyCode || event.which) <= 102) || 
					((event.keyCode || event.which) >= 96 && (event.keyCode || event.which) <= 105) ||
					((event.keyCode || event.which) == 8) || ((event.keyCode || event.which) == 35) || 
					((event.keyCode || event.which) >= 37 && (event.keyCode || event.which) <= 40) || 
					((event.keyCode || event.which) == 46)){
					var input = comp.querySelector('input'),
						start = input.selectionStart,
						end = input.selectionEnd,
						value = input.value;
					if((event.keyCode || event.which) == 8){
						if(start == value.length){
							value = value.slice(0,-1);
						}
						// else if(start == 1){
						// 	value = value.slice(1);
						// }
						else if(start > 0){
							value = value.slice(0,start-1)+value.slice(start);
						}
						return;
					}
					if((event.keyCode || event.which) == 46){
						if(start < value.length){
							value = value.slice(0,start) + value.slice(start+1);
						}
						return;
					}
					if(arrowkeys.indexOf(event.key) != -1){
						return;
					}
					else if( !( (event.ctrlKey || event.metaKey) && ((event.keyCode || event.which) == 65 || (event.keyCode || event.which) == 67) ) ){
						var char = arrowkeys.indexOf(event.key) != -1 ? "" : event.key;
						if(((event.keyCode || event.which) >= 96 && (event.keyCode || event.which) <= 105)){
							var key = event.keyCode || event.which;
							key -= 48;
							char = String.fromCharCode(key);
						}
						// for start == end, just add the char at the cursor position and check for value
						// for start != end, some characters are selected in the input, so those characters will be replaced with the new char and then check for the value
						value = start == end ? value.slice(0,start) + char + value.slice(start) : value.slice(0,start) + value.slice(end) + char;
					}
					if( (value.length == 1 && value[0] != '#') || (value.length > 0 && (value[0] != '#' || value.substring(1).indexOf('#') != -1)) ){
						event.preventDefault();
						event.stopPropagation();
					}
				}
				else if( !((event.ctrlKey || event.metaKey) && (event.keyCode || event.which) == 86) ){
					event.preventDefault();
					event.stopPropagation();
				}
			}
			else if((!(event.shiftKey || event.metaKey) && (event.keyCode || event.which) >= 48 && (event.keyCode || event.which) <= 57) || 
					((event.keyCode || event.which) == 8) || ((event.keyCode || event.which) == 46) || 
					((event.keyCode || event.which) >= 37 && (event.keyCode || event.which) <= 40) ||
					((event.keyCode || event.which) >= 96 && (event.keyCode || event.which) <= 105) ||
					((event.ctrlKey || event.metaKey) && ((event.keyCode || event.which) == 65 || (event.keyCode || event.which) == 67))){
				var input = comp.querySelector('input'),
					start = input.selectionStart,
					end = input.selectionEnd,
					value = input.value;
				if((event.keyCode || event.which) == 8){
					if(start == value.length){
						value = value.slice(0,-1);
					}
					// else if(start == 1){
					// 	value = value.slice(1);
					// }
					else if(start > 0){
						value = value.slice(0,start-1)+value.slice(start);
					}
					return;
				}
				if((event.keyCode || event.which) == 46){
					if(start < value.length){
						value = value.slice(0,start) + value.slice(start+1);
					}
					return;
				}
				else if( !( (event.ctrlKey || event.metaKey) && ((event.keyCode || event.which) == 65 || (event.keyCode || event.which) == 67) ) ){
					var char = arrowkeys.indexOf(event.key) != -1 ? "" : event.key;
					if(((event.keyCode || event.which) >= 96 && (event.keyCode || event.which) <= 105)){
						var key = event.keyCode || event.which;
						key -= 48;
						char = String.fromCharCode(key);
					}
					// for start == end, just add the char at the cursor position and check for value
					// for start != end, some characters are selected in the input, so those characters will be replaced with the new char and then check for the value
					value = start == end ? value.slice(0,start) + char + value.slice(start) : value.slice(0,start) + value.slice(end) + char;
				}
				if(type == "R" || type == "G" || type == "B"){
					if(value && (parseInt(value) < 0 || parseInt(value) >255)){
						event.preventDefault();
						event.stopPropagation();
					}
				}
				else if(type == "H"){
					if(value && (parseInt(value) < 0 || parseInt(value) >360)){
						event.preventDefault();
						event.stopPropagation();
					}
				}
				else if(type == "S" || type == "V" || type == "C" || type == "M" || type == "Y" || type == "K" || type == "A"){
					if(value && (parseInt(value) < 0 || parseInt(value) >100)){
						event.preventDefault();
						event.stopPropagation();
					}
				}
			}
			else if( !((event.ctrlKey || event.metaKey) && (event.keyCode || event.which) == 86) ){
				event.preventDefault();
				event.stopPropagation();
			}
		},

		callOnSelect : function(event,close){
			this.executeOnSelect(event,close);
		},

		selectColor : function(event,color){
			if(color == "rgba(0, 0, 0, 0)"){
				return;
			}
			var ele;
			var node = this.$node.querySelector('.lyteCPSelectedColor');
			// if(this.getData('cpInline')){
			// 	ele = this.$node.querySelector('.lyteColorPicker');
			// 	node = ele.querySelector('.cpSelectedColor');
			// }
			// else{
			// 	ele = document.querySelector('.'+this.getData('cpWrapperClass'));
			// 	node = ele.querySelector('.cpSelectedColor');
			// }
			if(node){
				node.classList.remove('lyteCPSelectedColor');
			}
			event.target.classList.add('lyteCPSelectedColor');
			var rgbColor;
			if(/rgba/.test(color)){
				rgbColor = color.substring(5,color.length-1).split(",");
				this.setData('opacity',rgbColor[3]*100);
			}
			else{
				rgbColor = color.substring(4,color.length-1).split(",");
				this.setData('opacity',100);
			}
			this.__setCurrentRgbCode(ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2]));
			var hsv = ColorPicker_Util.getHsvByRgbCode('#'+this.getData('ltPropCurrentRgbCode'));
	        this.setData('currentHue', hsv.hue);
	        this.setData('currentBrightness', hsv.brightness * 100);
	        this.setData('currentSaturation', hsv.saturation * 100);
			// this.__setSelectedColor();
			this.executeOnSelect(event);
		},

		goToAdvancedCP : function(event){
			var ele = this.$node;
			var color = this.getData('cpSelectedColor');
			if(color != null){
				this.setData("cpCurrentRgbCode",color.hex ? color.hex.substring(1) : "FF0000");
				if('cmyk' in color){
					this.setData('cmykColors', color.cmyk);
					this.setData('setPrevCmyk',true);
				}
				else{
					this.setData('cmykColors',[])
				}
			}
			this.setData('cpMoreColorOptionSelected',true);
			var advCPDimensions = this.getData('advCPDimensions');
			if(this.getData('cpInline')){
				// ele = this.$node.querySelector('.lyteColorPicker');
				this.setData('cpBasicColorPicker',false);
			}
			else{
				// ele = document.querySelector('.'+this.getData('cpWrapperClass'));
				var popOver = ele.closest('.lytePopover') /*ele.querySelector('.lytePopover')*/;
				var popOverOffset = popOver.getBoundingClientRect();
				var height = popOverOffset.height;
				this.setData('basicDimensions',{"width" : popOverOffset.width, "height" : height/*, "usedColorsHeight" : usedColorsHeight*/});
				
				popOver.style.width = advCPDimensions.width + "px";
				popOver.style.maxWidth = advCPDimensions.width + "px";
				this.setData('cpBasicColorPicker',false);
				popOver._callee.component.computeOffsetImpl();
				popOverOffset = null;
				height = null;
				popOver = null;
			}
			this.inputEle = ele.querySelector('#lyteCPHiddenInput');
			// this.inputEle.id = "lyteCPHiddenInput";
			// document.body.append(this.inputEle);
			// this.inputEle.style.top = "-100px";
			// this.inputEle.style.position = "absolute";
			this.initializeAdvColorPicker(event,ele,true);
			ele = null;
			color = null;
			advCPDimensions = null;
		},

		noFillExecute : function(event){
			var color = 'transparent';
			var selectedColor = {
				"hex" : undefined,
				"rgb" : color,
				"opacity" : 0
			};
			this.setData('cpSelectedColor',selectedColor);
			// this.executeOnSelect(event);
			if(this.getMethods("onSelect")){
				this.executeMethod("onSelect",event,undefined, this.getData('calledForHueMove'));	
			}
			if(this.getData('calledForHueMove')){
				this.setData('calledForHueMove',false);
			}
			// if(this.getData('cpCloseOnSelection') && !this.getData('calledForHueMove')){
			// 	this.setData('cpShow',false);
			// }
		},

		defaultColorExecute : function(event){
			var color = 'rgb(0, 0, 0)';
			var rgbColor = color.substring(4,color.length-1).split(",");
			var selectedColor = {
				"hex" : ("#" + ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2])),
				"rgb" : color,
				"opacity" : this.getData('opacity')
			};
			this.setData('cpSelectedColor',selectedColor);
			this.executeOnSelect(event);
		},

		closeColorPicker : function(event){
			this.executeOnClose(event);
		},

		fromAdvCPtoBasic : function(event){
			this.setData('cpMoreColorOptionSelected',false);
			var ele = this.$node;
			var basicDimensions = this.getData('basicDimensions');
			if(this.getData('cpInline')){
				// ele = this.$node.querySelector('.lyteColorPicker');
				// ele.style.width = basicDimensions.width + "px";
				this.setData('cpBasicColorPicker',true);
			}
			else{
				// ele = document.querySelector('.'+this.getData('cpWrapperClass'));
				var popOver = ele.closest('.lytePopover') /*ele.querySelector('.lytePopover')*/;
				var content = popOver.querySelector('lyte-popover-content');
				var contentHeight = 0;
				var height = 0;
				popOver.style.width = basicDimensions.width + "px";
				popOver.style.maxWidth = basicDimensions.width + "px";
				this.setData('cpBasicColorPicker',true);
				popOver._callee.component.computeOffsetImpl();
			}
			// if(this.inputEle){
			// 	var inputEle = this.inputEle;
			// 	this.inputEle = null;
			// 	inputEle.remove();
			// }
			this.initializeBasicColorPicker(event,ele);
			popOver = null;
		},
		copyValueToClipboard : function(prop){
			var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
			// if(prop == "fromAdv"){
			var colorCodeFormat = ele.querySelector('lyte-dropdown').ltProp('selected');
			this.inputEle.select();

			try {
				var successful = document.execCommand('copy');
				if(!this.getData('tooltipTextChanged')){
					ele.querySelector('.previewDiv').setAttribute('lt-prop-title',_lyteUiUtils.i18n('Color.value.copied'));
					this.setData('tooltipTextChanged',true);
					ele.querySelector('.previewDiv').dispatchEvent(new Event('mousemove'));
				}

			} catch (err) {
				// console.log('Oops, unable to copy');
			}
		},

		onOverColorPreviewDiv : function(event){
			var ele = this.$node /*this.getData('cpInline') ? this.$node : this.childComp*/;
			// if(type === "fromAdv"){
			// 	if(prop === "over"){
					if(this.getData('tooltipTextChanged')){
						ele.querySelector('.previewDiv').setAttribute('lt-prop-title',_lyteUiUtils.i18n('Copy.Color.value.to.Clipboard'));
						this.setData('tooltipTextChanged',false);
					}
					// ele.querySelector('.previewDiv').querySelector('#copyColorValueImg').style.display = "block";
				// }
				// if(prop === "out"){
				// 	ele.querySelector('.previewDiv').querySelector('#copyColorValueImg').style.display = "none";
				// }
			// }
			// var node;
			// if(this.getData('cpInline')){
			// 	node = this.$node.querySelector('#basciPreviewDivImg');
			// }
			// else{
			// 	node = this.$node.querySelector('lyte-popover').component.childComp.querySelector('#basciPreviewDivImg');
			// }
			// if(type === "fromBasic"){
			// 	if(prop === "over"){
			// 		node.style.display = "block";
			// 	}
			// 	if(prop === "out"){
			// 		node.style.display = "none";
			// 	}
			// }
		}
	}
});


/**
 * Renders a colorpicker
 * @component lyte-colorpicker
 * @version 1.0.0
 * @dependencies lyte-wormhole,lyte-button,lyte-popover,lyte-dropdown,lyte-input,lyte-table,lyte-draggable
 * @methods onBeforeOpen,onOpen,onSelect,onClose,onChange,onInputError
 */

Lyte.Component.register("lyte-colorpicker", {
_template:"<template tag-name=\"lyte-colorpicker\"> <template is=\"if\" value=\"{{ltPropInline}}\"><template case=\"true\"> <div class=\"lyteColorPicker\"> <div class=\"lyteColorPicker__showhidecontainer\"> <colorpicker-ui cp-advanced-color-button=\"{{ltPropAdvancedColorButton}}\" cp-standard-colors=\"{{ltPropStandardColors}}\" cp-used-colors=\"{{ltPropUsedColors}}\" cp-basic-color-picker=\"{{lbind(ltPropBasicColorPicker)}}\" cp-wrapper-class=\"{{ltPropWrapperClass}}\" cp-current-rgb-code=\"{{ltPropCurrentRgbCode}}\" cp-no-fill-button=\"{{ltPropNoFillButton}}\" cp-no-fill-label=\"{{ltPropNoFillLabel}}\" cp-palette-label=\"{{ltPropPaletteLabel}}\" cp-inline=\"{{ltPropInline}}\" cp-color-formats=\"{{lbind(ltPropColorFormats)}}\" cp-done-btn-text=\"{{lbind(ltPropDoneBtnText)}}\" cp-cancel-btn-text=\"{{lbind(ltPropCancelBtnText)}}\" cp-back-btn-text=\"{{lbind(ltPropBackBtnText)}}\" cp-apply-btn-text=\"{{lbind(ltPropApplyBtnText)}}\" cp-standard-color-array=\"{{ltPropStandardColorArray}}\" cp-board-color=\"{{lbind(ltPropBoardColor)}}\" cp-selected-color=\"{{lbind(ltPropSelectedColor)}}\" cp-available-colors=\"{{availableColors}}\" used-colors=\"{{lbind(ltPropUsedColorsList)}}\" cp-more-color-option-selected=\"{{lbind(moreColorOptionSelected)}}\" cp-opacity-label=\"{{ltPropOpacityLabel}}\" cp-used-colors-number=\"{{ltPropUsedColorsNumber}}\" opacity=\"{{ltPropOpacity}}\" cp-close-on-selection=\"{{ltPropCloseOnSelection}}\" cp-close-on-body-click=\"{{ltPropCloseOnBodyClick}}\" on-select=\"{{method(&quot;executeOnSelect&quot;)}}\" on-change=\"{{method(&quot;executeOnChange&quot;)}}\" on-close=\"{{method(&quot;executeOnClose&quot;)}}\" on-input-error=\"{{method(&quot;executeOnInputError&quot;)}}\"></colorpicker-ui> </div> </div> </template><template case=\"false\"> <lyte-popover class=\"lyteColorPicker popColorPicker\" on-close=\"{{method(&quot;closePopColorPicker&quot;)}}\" on-show=\"{{method(&quot;showColorPickerPopover&quot;,event)}}\"> <template is=\"registerYield\" yield-name=\"popover\"> <lyte-popover-content class=\"lyteColorPicker__showhidecontainer\"> <colorpicker-ui cp-advanced-color-button=\"{{ltPropAdvancedColorButton}}\" cp-standard-colors=\"{{ltPropStandardColors}}\" cp-used-colors=\"{{ltPropUsedColors}}\" cp-basic-color-picker=\"{{lbind(ltPropBasicColorPicker)}}\" cp-wrapper-class=\"{{ltPropWrapperClass}}\" cp-current-rgb-code=\"{{ltPropCurrentRgbCode}}\" cp-no-fill-button=\"{{ltPropNoFillButton}}\" cp-no-fill-label=\"{{ltPropNoFillLabel}}\" cp-palette-label=\"{{ltPropPaletteLabel}}\" cp-inline=\"{{ltPropInline}}\" cp-color-formats=\"{{lbind(ltPropColorFormats)}}\" cp-done-btn-text=\"{{lbind(ltPropDoneBtnText)}}\" cp-cancel-btn-text=\"{{lbind(ltPropCancelBtnText)}}\" cp-back-btn-text=\"{{lbind(ltPropBackBtnText)}}\" cp-apply-btn-text=\"{{ltPropApplyBtnText}}\" cp-standard-color-array=\"{{ltPropStandardColorArray}}\" cp-board-color=\"{{lbind(ltPropBoardColor)}}\" cp-selected-color=\"{{lbind(ltPropSelectedColor)}}\" cp-available-colors=\"{{availableColors}}\" used-colors=\"{{lbind(ltPropUsedColorsList)}}\" cp-more-color-option-selected=\"{{lbind(moreColorOptionSelected)}}\" cp-opacity-label=\"{{ltPropOpacityLabel}}\" cp-used-colors-number=\"{{ltPropUsedColorsNumber}}\" opacity=\"{{ltPropOpacity}}\" cp-close-on-selection=\"{{ltPropCloseOnSelection}}\" cp-close-on-body-click=\"{{ltPropCloseOnBodyClick}}\" on-select=\"{{method(&quot;executeOnSelect&quot;)}}\" on-change=\"{{method(&quot;executeOnChange&quot;)}}\" on-close=\"{{method(&quot;executeOnClose&quot;)}}\" on-input-error=\"{{method(&quot;executeOnInputError&quot;)}}\"></colorpicker-ui> </lyte-popover-content> </template> </lyte-popover> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropDraggable","ltPropCloseOnBodyClick","ltPropCloseOnSelection","ltPropAdvancedColorButton","ltPropAppearance","ltPropStandardColors","ltPropUsedColors","ltPropBasicColorPicker","ltPropSelectedColor","ltPropOriginElement","ltPropWrapperClass","ltPropCurrentRgbCode","ltPropBoundary","ltPropScrollable","ltPropNoFillButton","ltPropNoFillLabel","ltPropPaletteLabel","ltPropInline","ltPropColorFormats","ltPropDoneBtnText","ltPropCancelBtnText","ltPropBackBtnText","ltPropApplyBtnText","ltPropStandardColorArray","ltPropDuration","ltPropBoardColor","ltPropOpacityLabel","ltPropPopover","ltPropUsedColorsNumber","ltPropUsedColorsList","ltPropOpacity","moreColorOptionSelected","availableColors","usedColors","colorpicker","dropButtonValue"],
	data: function () {
		return {
			//Component Variables

			/**
						 * @componentProperty {boolean} ltPropShow
						 * @version 1.0.0
						 * @default false
						 * 
						 */
			"ltPropShow": Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {boolean} ltPropDraggable
						 * @version 1.0.0
						 * @default false
						 * 
						 */
			"ltPropDraggable": Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {boolean} ltPropCloseOnBodyClick
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropCloseOnBodyClick": Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {boolean} ltPropCloseOnSelection
						 * @version 1.0.0
						 * @default false
						 * 
						 */
			"ltPropCloseOnSelection": Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {boolean} ltPropAdvancedColorButton
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropAdvancedColorButton": Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {string} ltPropAppearance
						 * @version 1.0.0
						 * @default callout
						 * @options callout,box
						 */
			"ltPropAppearance": Lyte.attr("string", { "default": "callout" }),

			/**
						 * @componentProperty {boolean} ltPropStandardColors
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropStandardColors": Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {boolean} ltPropUsedColors
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropUsedColors": Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {boolean} ltPropBasicColorPicker
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropBasicColorPicker": Lyte.attr("boolean", { "default": true }),

			/**
						 * @experimental ltPropSelectedColor
						 */
			"ltPropSelectedColor": Lyte.attr("object", { "default": null }),

			/**
						 * @componentProperty {string} ltPropOriginElement
						 * @version 1.0.0
						 */
			"ltPropOriginElement": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {string} ltPropWrapperClass
						 * @version 1.0.0
						 * @default lyteColorPickerPopover
						 */
			"ltPropWrapperClass": Lyte.attr("string", { "default": "lyteColorPickerPopover" }),

			/**
						 * @experimental ltPropCurrentRgbCode
						 */
			"ltPropCurrentRgbCode": Lyte.attr("string", { "default": "90c3d4" }),

			/**
			 * @typedef {object} boundary
			 * @property {string} left
			 * @property {string} right
			 * @property {string} top
			 * @property {string} bottom
			 */
			/**
						 * @componentProperty {boundary} ltPropBoundary
						 * @version 1.0.0
						 * @default {}
						 */
			"ltPropBoundary": Lyte.attr("object", { "default": null }),

			/**
						 * @componentProperty {boolean} ltPropScrollable
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			"ltPropScrollable": Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {boolean} ltPropNoFillButton
						 * @version 1.0.0
						 * @default false
						 * 
						 */
			"ltPropNoFillButton": Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {string} ltPropNoFillLabel
						 * @version 1.0.0
						 * @default No Fill
						 */
			"ltPropNoFillLabel": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {string} ltPropPaletteLabel
						 * @version 1.0.0
						 * @default Theme Colors
						 */
			"ltPropPaletteLabel": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {boolean} ltPropInline
						 * @version 1.0.0
						 * @default false
						 * 
						 */
			"ltPropInline": Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {array} ltPropColorFormats
						 * @version 2.0.0
						 * @default ["HEX","RGB","HSV","CMYK"]
						 */
			"ltPropColorFormats": Lyte.attr("array", { "default": ["HEX", "RGB", "HSV", "CMYK"] }),

			/**
						 * @componentProperty {string} ltPropDoneBtnText
						 * @version 2.0.0
						 * @default Done
						 */
			"ltPropDoneBtnText": Lyte.attr("string", { "default": "Done" }),

			/**
						 * @componentProperty {string} ltPropCancelBtnText
						 * @version 2.0.0
						 * @default Cancel
						 */
			"ltPropCancelBtnText": Lyte.attr("string", { "default": "Cancel" }),

			/**
						 * @componentProperty {string} ltPropBackBtnText
						 * @version 2.0.0
						 * @default Back
						 */
			"ltPropBackBtnText": Lyte.attr("string", { "default": "Back" }),

			/**
						 * @componentProperty {string} ltPropApplyBtnText
						 * @version 2.0.0
						 * @default Apply
						 */
			"ltPropApplyBtnText": Lyte.attr("string", { "default": "Apply" }),

			/**
						 * @componentProperty {array} ltPropStandardColorArray
						 * @version 2.0.0
						 */
			"ltPropStandardColorArray": Lyte.attr("array", { "default": [] }),

			/**
						 * @componentProperty {number} ltPropDuration
						 * @version 2.0.0
						 * @default 600
						 */
			"ltPropDuration": Lyte.attr("number", { "default": 600 }),

			/**
						 * @componentProperty {string} ltPropBoardColor
						 * @version 2.2.4
						 * @default #90c3d4
						 */
			"ltPropBoardColor": Lyte.attr("string", { "default": "#90c3d4" }),

			/**
						 * @componentProperty {string} ltPropOpacityLabel
						 * @version 2.2.22
						 * @default Alpha
						 */
			"ltPropOpacityLabel": Lyte.attr("string"),

			/**
						 * @componentProperty {object} ltPropPopover
						 * @version 2.2.23
						 */
			"ltPropPopover": Lyte.attr("object", { "default": {} }),

			/**
						 * @componentProperty {number} ltPropUsedColorsNumber
						 * @version 3.8.0
						 * @default 10
						 */
			"ltPropUsedColorsNumber": Lyte.attr("number", { "default": 10 }),

			/**
						 * @componentProperty {array} ltPropUsedColorsList
						 * @version 3.8.0
						 * @default 10
						 */
			"ltPropUsedColorsList": Lyte.attr("array", { "default": [] }),

			/**
						 * @componentProperty {number} ltPropOpacity
						 * @version 3.20.0
						 * @default 100
						 */
			"ltPropOpacity": Lyte.attr("number", { "default": 100 }),
			//Local variables
			"moreColorOptionSelected": Lyte.attr("boolean", { "default": false }),
			"availableColors": Lyte.attr("array", { "default": [] }),
			"usedColors": Lyte.attr("array"),
			"colorpicker": Lyte.attr("object", { "default": null }),
			"dropButtonValue": Lyte.attr("string", { "default": "HEX" })
		}
	},
	init: function () {
		var availableColors = [['rgb(255, 255, 255)', 'rgb(239, 22, 22)', 'rgb(239, 130, 22)', 'rgb(239, 177, 22)', 'rgb(93, 195, 90)', 'rgb(56, 215, 187)', 'rgb(22, 208, 239)', 'rgb(57, 142, 243)', 'rgb(197, 22, 239)', 'rgb(239, 22, 111)'],
		['rgb(230, 230, 230)', 'rgb(253, 232, 232)', 'rgb(253, 243, 232)', 'rgb(253, 247, 232)', 'rgb(239, 249, 239)', 'rgb(235, 251, 248)', 'rgb(232, 250, 253)', 'rgb(235, 244, 254)', 'rgb(249, 232, 253)', 'rgb(253, 232, 241)'],
		['rgb(204, 204, 204)', 'rgb(252, 208, 208)', 'rgb(252, 230, 208)', 'rgb(252, 239, 208)', 'rgb(223, 243, 222)', 'rgb(215, 247, 241)', 'rgb(208, 246, 252)', 'rgb(215, 232, 253)', 'rgb(243, 208, 252)', 'rgb(252, 208, 226)'],
		['rgb(153, 153, 153)', 'rgb(249, 162, 162)', 'rgb(249, 205, 162)', 'rgb(249, 224, 162)', 'rgb(190, 231, 189)', 'rgb(175, 239, 228)', 'rgb(162, 236, 249)', 'rgb(176, 210, 250)', 'rgb(232, 162, 249)', 'rgb(249, 162, 197)'],
		['rgb(102, 102, 102)', 'rgb(245, 115, 115)', 'rgb(245, 180, 115)', 'rgb(245, 208, 115)', 'rgb(158, 219, 156)', 'rgb(136, 231, 214)', 'rgb(115, 227, 245)', 'rgb(136, 187, 248)', 'rgb(220, 115, 245)', 'rgb(245, 115, 169)'],
		['rgb(51, 51, 51)', 'rgb(242, 69, 69)', 'rgb(242, 155, 69)', 'rgb(242, 193, 69)', 'rgb(125, 207, 123)', 'rgb(96, 223, 201)', 'rgb(69, 217, 242)', 'rgb(97, 165, 245)', 'rgb(209, 69, 242)', 'rgb(242, 69, 140)'],
		['rgb(25, 25, 25)', 'rgb(171, 12, 12)', 'rgb(171, 91, 12)', 'rgb(171, 125, 12)', 'rgb(56, 146, 53)', 'rgb(32, 158, 136)', 'rgb(12, 148, 171)', 'rgb(12, 97, 198)', 'rgb(140, 12, 171)', 'rgb(171, 12, 77)'],
		['rgb(0, 0, 0)', 'rgb(73, 5, 5)', 'rgb(73, 39, 5)', 'rgb(73, 54, 5)', 'rgb(24, 63, 23)', 'rgb(14, 68, 58)', 'rgb(5, 64, 73)', 'rgb(5, 42, 85)', 'rgb(60, 5, 73)', 'rgb(73, 5, 33)']];
		this.setData('availableColors', availableColors);
		if(this.getData('ltPropStandardColorArray').length == 0){
			var standardColorArray = ['rgb(192, 0, 0)', 'rgb(255, 0, 0)', 'rgb(255, 192, 0)', 'rgb(255, 255, 0)', 'rgb(146, 208, 80)', 'rgb(0, 176, 80)', 'rgb(0, 176, 240)', 'rgb(0, 112, 192)', 'rgb(0, 32, 96)', 'rgb(112, 48, 160)'];
			this.setData('ltPropStandardColorArray', standardColorArray);
		}
		var formatArray = this.getData('ltPropColorFormats');
		for (var i = 0; i < formatArray.length; i++) {
			formatArray[i] = _lyteUiUtils.i18n(formatArray[i]) || formatArray[i];
		}
		this.setData('ltPropColorFormats', formatArray);
		var usedColorsList = [], len = this.getData('ltPropUsedColorsNumber');
		if (this.getData('ltPropUsedColorsList').length > 0) {
			usedColorsList = this.getData('ltPropUsedColorsList').slice();
		}
		for (var i = usedColorsList.length; i < len; i++) {
			usedColorsList.push('noColor');
		}
		this.setData('ltPropUsedColorsList', usedColorsList.slice(0, len));
	},

	showColorPicker: function () {
		if (!this.getData('ltPropNoFillLabel')) {
			this.setData('ltPropNoFillLabel', _lyteUiUtils.i18n("No.Fill"));
		}
		if (!this.getData('ltPropPaletteLabel')) {
			this.setData('ltPropPaletteLabel', _lyteUiUtils.i18n("Theme.Colors"));
		}
		if (this.getData('ltPropInline')) {
			this.executeOnBeforeOpen();
			this.$node.style.display = "inline-block";
			this.setData('colorpicker', this.$node.querySelector('colorpicker-ui').component);
			if (this.getData('ltPropColorFormats').length > 0) {
				this.setData('dropButtonValue', this.getData('ltPropColorFormats')[0]);
			}
			if (this.getData('ltPropBasicColorPicker')) {
				this.getData('colorpicker').initializeBasicColorPicker(event || window.event, this.$node);
			}
			else {
				this.getData('colorpicker').inputEle = this.getData('colorpicker').$node.querySelector('#lyteCPHiddenInput');
				this.getData('colorpicker').initializeAdvColorPicker(event || window.event, this.$node);
			}
			this.executeOnOpen();
		}
		else {
			var popOver = this.$node.querySelector('.popColorPicker');
			if (this.getData('ltPropShow')) {
				if (this.getData('ltPropColorFormats').length > 0) {
					this.setData('dropButtonValue', this.getData('ltPropColorFormats')[0]);
				}
				popOver.ltProp("showCloseButton", false);
				if (this.getData('ltPropBoundary')) {
					popOver.ltProp("boundary", this.getData('ltPropBoundary'));
				}
				var keys = Object.keys(this.getData('ltPropPopover'));
				for (var j = 0; j < keys.length; j++) {
					popOver.ltProp(keys[j], this.getData('ltPropPopover')[keys[j]]);
				};
				popOver.ltProp({
					"windowSpacing": { left: 1, right: 1, top: 1, bottom: 1 },
					"contentPadding": "0px",
					"originElem": this.getData("ltPropOriginElement"),
					"wrapperClass": this.getData("ltPropWrapperClass"),
					"type": this.getData("ltPropAppearance"),
					"duration": this.getData("ltPropDuration"),
					"closeOnBodyClick": false,
					"freeze": false,
					"scrollable": this.getData("ltPropScrollable"),
					"draggable": false,
					"show": true
				});
				this.executeOnBeforeOpen();
			}
			else {
				
				if (popOver.ltProp) {
					popOver.ltProp('show', false);
				}

			}
		}
	}.observes('ltPropShow', 'ltPropInline').on('didConnect'),

	observeOpacityChanges : function(){
		var colorpicker = this.getData('colorpicker'), opacity = this.getData('ltPropOpacity');
		if(colorpicker && opacity >= 0 && opacity <= 100){
			colorpicker.setData('opacity', opacity);
			colorpicker.__updateOpacityInForm();
		}
	}.observes('ltPropOpacity'),

	executeOnBeforeOpen: function () {
		if (this.getMethods('onBeforeOpen')) {
			this.executeMethod('onBeforeOpen', this);
		}
	},
	executeOnOpen: function () {
		if (this.getMethods('onOpen')) {
			this.executeMethod('onOpen', this);
		}
	},
	executeOnCloseFn: function (event) {
		if (this.getMethods('onClose')) {
			this.executeMethod('onClose', event, this);
		}
	},

	didDestroy: function () {
		this.setData('colorpicker', null);
	},

	methods: {
		closePopColorPicker: function (event) {
			this.executeOnCloseFn(event);
			if (this.getData('moreColorOptionSelected')) {
				var self = this;
				self.tId = setTimeout(function () {
					self.getData('colorpicker').setData('cpBasicColorPicker', true);
					self.getData('colorpicker').setData('cpMoreColorOptionSelected', false);
					self.tId = false;
				}, 400);
			}
			var ele = this.childComp.querySelector('.' + this.getData('ltPropWrapperClass'));
			if (ele && ele.classList.contains('lyteColorpickerVisible')) {
				ele.classList.remove('lyteColorpickerVisible');
			}

			this.setData('ltPropShow', false);
		},
		showColorPickerPopover: function () {
			this.childComp = this.$node.querySelector('lyte-popover').component.childComp;
			var ele = this.childComp.querySelector('.' + this.getData('ltPropWrapperClass'));
			ele.classList.add('lyteColorpickerVisible');
			this.setData('colorpicker', ele.querySelector('colorpicker-ui').component);

			//Sometimes the content is not properly rendered when the 
			ele.querySelector('lyte-popover-content').style.height = "auto";
			var colorpicker = this.getData('colorpicker');
			if (this.getData('ltPropBasicColorPicker')) {
				colorpicker.initializeBasicColorPicker(event, ele);
			}
			else {
				colorpicker.inputEle = colorpicker.$node.querySelector('#lyteCPHiddenInput');
				colorpicker.initializeAdvColorPicker(event, ele);
			}
			if (this.getData('ltPropDraggable')) {
				var drag = ele.querySelector('.lytePopover');
				var handle = ele.querySelector('lyte-popover-header') || ele.querySelector('lyte-popover-content');
				drag.id = "draggableColor";
				handle.id = "draghandle";
				$L('#draggableColor').draggable({
					handle: ['#draghandle']
				})
			}
			this.$node.querySelector('lyte-popover').component.computeOffsetImpl();
			this.executeOnOpen();
			ele = null;
		},
		executeOnClose: function (event) {
			this.executeOnCloseFn(event);
		},
		executeOnSelect: function (event, close, calledForHueMove) {
			if (this.getMethods("onSelect")) {
				this.executeMethod("onSelect", event, this.getData('ltPropSelectedColor'), this);
			}
			if (((this.getData('ltPropCloseOnSelection') && this.getData('ltPropBasicColorPicker')) || close === true) && !calledForHueMove) {
				this.setData('ltPropShow', false);
			}
		},
		executeOnChange: function (event) {
			if (this.getMethods('onChange')) {
				this.executeMethod('onChange', event, this.getData('ltPropSelectedColor'), this);
			}
		},
		executeOnInputError: function (type) {
			if (this.getMethods('onInputError')) {
				this.executeMethod('onInputError', type);
			}
		}
	}
});

document.addEventListener('click', function (event) {
	if (ColorPicker_EventUtil.__stopPropagation) {
		ColorPicker_EventUtil.__stopPropagation = false;
		return;
	}
	var ele = event.target;
	while (!ele.classList.contains('lyteColorpickerVisible') && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML') {
		ele = ele.parentElement;
		if (!ele) {
			return
		}
	}

	if (ele.tagName == 'HTML') {
		var colorpicker = document.querySelector('.lyteColorpickerVisible');
		if (colorpicker && colorpicker.parentElement.parentElement._callee.parentElement.component.getData('ltPropCloseOnBodyClick')) {
			colorpicker.parentElement.parentElement._callee.parentElement.ltProp('show', false);
		}
	}

}, true);

/**
 * @syntax nonYielded
 * <lyte-colorpicker lt-prop-basic-color-picker = "true">
 * </lyte-colorpicker>
 */

/**
 * Renders a combobox
 * @component lyte-combobox
 * @version  3.0.0
 * @dependencies lyte-dropdown,lyte-input,lyte-tooltip
 * /plugins/lyte-search.js
 * /theme/compiledCSS/default/ltr/lyte-ui-scrollbar.css
 * /components/lyte-input.js
 * /theme/compiledCSS/default/ltr/lyte-ui-input.css
 * /components/lyte-dropdown.js
 * /theme/compiledCSS/default/ltr/lyte-ui-dropdown.css
 * /components/lyte-tooltip.js
 * /theme/compiledCSS/default/ltr/lyte-ui-tooltip.css
 * @methods onOptionSelect,onSearch,onShow,onBeforeShow,onHide,onBeforeHide,onUserScroll,onClear
 * @utility toggle,open,close
 * @import lyte-dropdown
 * @ignoreProperties ltPropYield, ltPropType, ltPropShow, ltPropOptions, ltPropDisabledList,ltPropSelected, ltPropTooltip
 * @ignoreUtility toggle,open,close
 */
Lyte.Component.register('lyte-combobox', {
_template:"<template tag-name=\"lyte-combobox\"> <lyte-dropdown class=\"{{ltPropDropdownClass}} {{if(ifEquals(ltPropType,'buttonSearch'),'lyteComboboxButtonSearch','lyteComboboxBoxSearch')}} {{if(isSearch,'lyteComboboxSearchPresent')}}\" lt-prop=\"{{stringify(ltPropDropdown)}}\" lt-prop-selected=\"{{ltPropDropdownSelected}}\" lt-prop-options=\"{{ltPropOptions}}\" lt-prop-disabled-list=\"{{ltPropDisabledList}}\" on-option-selected=\"{{method('optionSelect')}}\" on-show=\"{{method('dropBoxOpen')}}\" on-animation-end=\"{{method('onAnimateEnd')}}\" on-before-show=\"{{method('beforeDropboxShow')}}\" on-hide=\"{{method('hideDropbox')}}\" on-before-hide=\"{{method('beforeHideDropbox')}}\" on-scroll=\"{{method('scrollDropBox')}}\" lt-prop-freeze=\"{{if(expHandlers(ltPropType,'==','buttonSearch'),false,true)}}\" lt-prop-yield=\"true\"> <template is=\"registerYield\" yield-name=\"yield\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'!')}}\"><template case=\"true\"> <lyte-drop-button> <template is=\"if\" value=\"{{expHandlers(selectValue,'!')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropDropdown.displayValue}}\"><template case=\"true\"> <span class=\"lyteMarginRight lyteDropdownLabel\" onmouseenter=\"{{action('toolTipConfig',this)}}\" lt-prop-title=\"{{if(showToolTip,ltPropDropdown.displayValue,'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\">{{ltPropDropdown.displayValue}}</span> </template><template case=\"false\"><template is=\"if\" value=\"{{ltPropDropdown.placeholder}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderNormal\">{{ltPropDropdown.placeholder}}</span> </template><template case=\"false\"> <span class=\"lyteMarginRight lyteDropdownLabel\" onmouseenter=\"{{action('toolTipConfig',this)}}\" lt-prop-title=\"{{if(showToolTip,initialValue,'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\">{{initialValue}}</span> </template></template></template></template> </template><template case=\"false\"> <span class=\"lyteMarginRight lyteDropdownLabel\" onmouseenter=\"{{action('toolTipConfig',this)}}\" lt-prop-title=\"{{if(showToolTip,selectValue,'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\">{{selectValue}}</span> </template></template> <template is=\"if\" value=\"{{expHandlers(isSearch,'&amp;&amp;',expHandlers(ltPropType,'==','buttonSearch'))}}\"><template case=\"true\"> <lyte-input class=\"lyteComboboxBtnSearchInput\" lt-prop-type=\"search\" lt-prop-close-icon=\"true\" lt-prop-appearance=\"{{ltPropDropboxSearchAppearance}}\" lt-prop-class=\"lyteComboboxBtnSearchOrigIpt\" lt-prop-placeholder=\"{{ltPropSearchplaceholder}}\" on-value-change=\"{{method('searchList')}}\" on-clear=\"{{method('onSearchClear')}}\" oninput=\"{{action('oninput',this)}}\"></lyte-input> </template></template> <lyte-icon class=\"dropdown\"></lyte-icon> </lyte-drop-button> <lyte-drop-box class=\"{{ltPropBoxClass}}\"> <template is=\"if\" value=\"{{expHandlers(isSearch,'&amp;&amp;',expHandlers(ltPropType,'==','boxSearch'))}}\"><template case=\"true\"> <lyte-drop-header> <lyte-input lt-prop-close-icon=\"true\" lt-prop-type=\"search\" class=\"lyteComboboxDropboxSearch\" lt-prop-class=\"lyteComboboxDropboxSearchOrigIpt\" lt-prop-appearance=\"{{ltPropDropboxSearchAppearance}}\" lt-prop-placeholder=\"{{ltPropSearchplaceholder}}\" on-value-change=\"{{method('searchList')}}\" on-clear=\"{{method('onSearchClear')}}\"></lyte-input> </lyte-drop-header> </template></template> <lyte-drop-body> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\"> <lyte-drop-group> <lyte-drop-label>{{lyteUiReturnOnlyKey(item)}}</lyte-drop-label> <template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteUiReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\"> <template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{subitem[ltPropDropdown.systemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem[ltPropDropdown.systemValue])}}\">{{subitem[ltPropDropdown.userValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{subitem}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem)}}\">{{subitem}}</lyte-drop-item> </template></template> </template> </lyte-drop-group> </template><template case=\"false\"> <template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{item[ltPropDropdown.systemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item[ltPropDropdown.systemValue])}}\">{{item[ltPropDropdown.userValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{item}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item)}}\">{{item}}</lyte-drop-item> </template></template> </template></template> </template> <template is=\"if\" value=\"{{showNoResult}}\"><template case=\"true\"> <div class=\"lyteDropdownNoResult lyteComboboxNoResult\"> {{ltPropNoResultMessage}} </div> </template></template> </lyte-drop-body> </lyte-drop-box> </template><template case=\"false\"> <lyte-drop-button> <lyte-yield is=\"registerYield\" yield-name=\"headerYield\"> </lyte-yield> <template is=\"if\" value=\"{{expHandlers(isSearch,'&amp;&amp;',expHandlers(ltPropType,'==','buttonSearch'))}}\"><template case=\"true\"> <lyte-input class=\"lyteComboboxBtnSearchInput\" lt-prop-close-icon=\"true\" lt-prop-appearance=\"{{ltPropDropboxSearchAppearance}}\" lt-prop-type=\"search\" lt-prop-class=\"lyteComboboxBtnSearchOrigIpt\" lt-prop-placeholder=\"{{ltPropSearchplaceholder}}\" on-value-change=\"{{method('searchList')}}\" on-clear=\"{{method('onSearchClear')}}\"></lyte-input> </template></template> </lyte-drop-button> <lyte-drop-box class=\"{{ltPropBoxClass}}\"> <template is=\"if\" value=\"{{expHandlers(isSearch,'&amp;&amp;',expHandlers(ltPropType,'==','boxSearch'))}}\"><template case=\"true\"> <lyte-drop-header> <lyte-input class=\"lyteComboboxDropboxSearch\" lt-prop-close-icon=\"true\" lt-prop-appearance=\"{{ltPropDropboxSearchAppearance}}\" lt-prop-class=\"lyteComboboxDropboxSearchOrigIpt\" lt-prop-placeholder=\"{{ltPropSearchplaceholder}}\" on-value-change=\"{{method('searchList')}}\" lt-prop-type=\"search\" on-clear=\"{{method('onSearchClear')}}\"></lyte-input> </lyte-drop-header> </template></template> <lyte-drop-body> <lyte-yield is=\"registerYield\" yield-name=\"bodyYield\"> </lyte-yield> <template is=\"if\" value=\"{{showNoResult}}\"><template case=\"true\"> <div class=\"lyteDropdownNoResult lyteComboboxNoResult\"> {{ltPropNoResultMessage}} </div> </template></template> </lyte-drop-body> <lyte-yield is=\"registerYield\" yield-name=\"footerYield\"> </lyte-yield> </lyte-drop-box> </template></template> </template> </lyte-dropdown> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1,5]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[3,3,1]},{"type":"for","position":[3,3,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"attr","position":[3,3,3]},{"type":"if","position":[3,3,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]}]}},"default":{}},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"insertYield","position":[3,3,1]},{"type":"attr","position":[3,3,3]},{"type":"if","position":[3,3,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]}]}},"default":{}},{"type":"componentDynamic","position":[3,3]},{"type":"insertYield","position":[3,5]},{"type":"componentDynamic","position":[3]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropDropdown","ltPropOptions","ltPropDropdownSelected","ltPropNoResultMessage","ltPropDisabledList","ltPropYield","ltPropType","ltPropDropboxSearchAppearance","ltPropSearchplaceholder","ltPropMinSearchValue","ltPropTooltip","ltPropBoxClass","ltPropDropdownClass","selectValue","initialValue","showNoResult","isSearch"],
	data : function(){
		return {
			/** 
			 * @componentProperty {object} ltPropDropdown={}
			 * @version 3.0.0
			 */
			'ltPropDropdown' : Lyte.attr( 'object', {
			 	'default' : {}
			} ),
			/** 
			 * @componentProperty {array} ltPropOptions=[]
			 * @version 3.0.0
			 */
			'ltPropOptions' : Lyte.attr( 'array', {
				'default' : []
			} ),
			/** 
			 * @componentProperty {string} ltPropDropdownSelected
			 * @version 3.0.0
			 */
			'ltPropDropdownSelected' : Lyte.attr( 'string' ),
			/** 
			 * @componentProperty {string} ltPropNoResultMessage=No Results Found
			 * @version 3.0.0
			 */
			'ltPropNoResultMessage' : Lyte.attr( 'string', {
			 'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'noResultMessage', _lyteUiUtils.i18n( 'no.results.found' ) ) 


			} ),
			/** 
			 * @componentProperty {array} ltPropDisabledList=[]
			 * @version 3.0.0
			 */
			'ltPropDisabledList': Lyte.attr('array',{"default":[]}),
			/** 
			 * @componentProperty {boolean} ltPropYield=false
			 * @version 3.0.0
			 */
			'ltPropYield' : Lyte.attr( 'boolean', {
			 'default' : false 
			} ),
			/** 
			 * @componentProperty {boxSearch | buttonSearch} ltPropType=boxSearch
			 * @version 3.0.0
			 */
			'ltPropType' : Lyte.attr( 'string' ,{
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'type', 'boxSearch' )
			} ),
			/** 
			 * @componentProperty {flat | box} ltPropDropboxSearchAppearance=flat
			 * @version 3.0.0
			 */
			'ltPropDropboxSearchAppearance' : Lyte.attr( 'string', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'dropboxSearchAppearance', 'flat' )
			} ),
			/** 
			 * @componentProperty {string} ltPropSearchplaceholder=''
			 * @version 3.0.0
			 */
			'ltPropSearchplaceholder' : Lyte.attr( 'string', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'searchplaceholder', '' )
			} ),
			/** 
			 * @componentProperty {number} ltPropMinSearchValue
			 * @version 3.0.0
			 */
			'ltPropMinSearchValue' : Lyte.attr( 'number' ),
			/**
   			 * @componentProperty {object} ltPropTooltip
   			 * @component lyte-tooltip ltPropTooltipConfig
   			 * @default {'position': 'bottom', 'appearance': 'box', 'margin': 5, 'keeptooltip': true} 
			 */
			'ltPropTooltip': Lyte.attr( 'object', { 'default':_lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'tooltip', { 
	   				'position': 'bottom', 
	   				'appearance': 'box',
	   				'margin': 5,
	   				'keeptooltip': true 
   				} )
   			} ),
   			'ltPropBoxClass' :	Lyte.attr('string',{'default':_lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'boxClass', '' )}),
   			'ltPropDropdownClass' :	Lyte.attr('string',{'default':_lyteUiUtils.resolveDefaultValue( 'lyte-combobox', 'dropdownClass', '' )}),
			'selectValue' : Lyte.attr( 'string' ), 
			'initialValue': Lyte.attr( 'string' ), 
			'showNoResult' : Lyte.attr( 'boolean', {
				'default' : false
			} ),
			'isSearch' : Lyte.attr('boolean', {
			 'default' : false 
			} )
		}		
	},
	init : function() {
		var options = this.getData( 'ltPropOptions' ),
			dropDown = this.getData('ltPropDropdown')
		if( options && options.length >0 ) {
			this.checkForSearch()
		}
		this._currentDisplay = dropDown.displayValue
	},
	didConnect : function() {
		var dropBody = this.$node.querySelector( 'lyte-drop-body' ),
		 dropBox = this.$node.querySelector( 'lyte-drop-button' ),
		 disabledList = this.getData( 'ltPropDisabledList' );

		if( this.getData( 'isSearch') ) {
			var searchEle = this.$node.querySelector( 'lyte-input' )
			if( this.getData( 'ltPropType' ) == 'boxSearch' ) {
				var dropDown = this.$node.querySelector( 'lyte-dropdown' ),
				dropBox = dropDown.component.childComp || dropDown.querySelector( 'lyte-drop-box' )
				searchEle = dropBox.querySelector( 'lyte-input' )
			}
			if( searchEle ){
				$L( searchEle ).search( { 'scope' : dropBody, 'search' : 'lyte-drop-item', 'related' : 'lyte-drop-group' ,'onSearch' : this.Search.bind( this ),trim : true } )
			}
			this._searchEle = searchEle
		}
		var options = this.getData( 'ltPropOptions' )
		if( options && options.length >0 ) {
			if( !this.getData( 'ltPropYield' ) ) {
				this.setDropdownValue()
			}
			
		}
		this.$node.open = function() {
			var dropDown = this.querySelector('lyte-dropdown')
			dropDown.open();

			}

		this.$node.close = function() {
			var dropDown = this.querySelector('lyte-dropdown')
			dropDown.close();


		}
		this.$node.toggle = function() {
			var dropDown = this.querySelector('lyte-dropdown')
			dropDown.toggle();

			}

	},
	checkForSearch : function(){
		var option = this.getData('ltPropOptions'),
		minValue = this.getData('ltPropMinSearchValue'),
		count = 0,
		options = this.getData('ltPropOptions'),
		firstElement = options[ 0 ]

		if( firstElement.constructor == Object ){
			if( Object.keys( firstElement ).length == 1 ) {
	              	value = firstElement[ Object.keys( firstElement )[ 0 ] ];
	              	if( value.constructor == Array ) {
	                   	for(var i =0;i<option.length;i++){
	                   		for(var key in option[i]){
								count += option[i][key].length
								if(count >= minValue){
											this.setData('isSearch',true)
											return
								}
							}
						}
					}
	        } else {
				if(options.length >= minValue){
					this.setData('isSearch',true)
					return
				}
			}
		} else{
			if(options.length >= minValue){
					this.setData('isSearch',true)
					return
			}
		}
		
	},
	setDropdownValue : function() {
		var dropDown = this.getData( 'ltPropDropdown' ),
		name = dropDown.userValue,
		value = dropDown.systemValue,
		drop = this.$node.querySelector( 'lyte-dropdown' )
		if(	 dropDown.placeholder == undefined  && dropDown.displayValue == undefined  && (!this.getData( 'ltPropDropdownSelected')) )  {
			var displayName = drop.getInitialSelected();
			this.setData( 'ltPropDropdownSelected', displayName )
		}
		if(dropDown.placeholder==undefined && dropDown.displayValue && !this.getData('ltPropDropdownSelected')){
			var displayName = drop.getInitialSelected();
			this.setData( 'ltPropDropdownSelected', displayName )
			this.setData( 'selectValue', dropDown.displayValue )

		}
		if( this.getData( 'ltPropDropdownSelected' ) && dropDown.displayValue == undefined ) {
			var displayName = drop.getDisplayValue();
			this.setData( 'selectValue', displayName )
		}
		
	},
	displayObs : function(){
		if( this._currentDisplay != this.getData('ltPropDropdown').displayValue ){
			this.setData('selectValue',this.getData('ltPropDropdown').displayValue)
			this._currentDisplay = this.getData('ltPropDropdown').displayValue
		}
	}.observes('ltPropDropdown.displayValue'),
	addComboboxClass : function(dropBox){
		dropBox.classList.add('lyteComboboxFiltering')
	},
	removeComboboxClass : function(dropBox){
		dropBox.classList.remove('lyteComboboxFiltering')
	},
	optionObs : function() {
		var options = this.getData( 'ltPropOptions' ),
		 dropDown = this.$node.querySelector('lyte-dropdown')
		this.setData( 'isSearch', false )
		this._searchEle = null
		this.setData('selectValue',undefined)
		this.setData('showNoResult',false)
		if( dropDown ) {
			dropDown.component.showNoResultDiv()
		}
		if( options && options.length >0 ){
			if( !this.getData( 'ltPropYield' ) ) {
				this.setDropdownValue()
			}
			this.checkForSearch()
		}
		if( this.getData( 'isSearch' ) && dropDown ) {
			
			 var searchEle = this.$node.querySelector( 'lyte-input' ),
			 dropBox = dropDown.component.childComp || dropDown.querySelector( 'lyte-drop-box' ),
			 dropBody = dropBox.querySelector( 'lyte-drop-body' )

			if( this.getData( 'ltPropType' ) == 'boxSearch' ) {
				searchEle = dropBox.querySelector( 'lyte-input' )

			}
			this._searchEle = searchEle
			$L( searchEle ).search( { 'scope' : dropBody, 'search' : 'lyte-drop-item', 'related' : 'lyte-drop-group' ,'onSearch' : this.Search.bind( this ),trim:true } )
		}
		
	}.observes( 'ltPropOptions.[]' ),
	disabledListObs : function() {
		var dropDown = this.$node.querySelector(' lyte-dropdown' )
		dropDown.setData( 'ltPropDisabledList', this.getData( 'ltPropDisabledList' ) )
	}.observes('ltPropDisabledList.[]'),
	dropDownSelectedObs : function(){
		if( this.getData('ltPropDropdownSelected') != "" && this.getData('ltPropDropdownSelected') != undefined ){
			var dropDown = this.$node.querySelector( 'lyte-dropdown' ) 
			this.setData( 'selectValue', dropDown.getDisplayValue())
		} else{
			this.setData( 'selectValue', undefined )
		}
	}.observes( 'ltPropDropdownSelected'),
	Search  : function( visibleList, event, value ) {
		this.setData( "showNoResult", visibleList.length == 0 );
		if( this.getMethods( "onSearch" ) ) {
			return this.executeMethod( "onSearch", visibleList, event, value );
		}
	},
	isVisible: function( item ) {
		return !!( item.offsetWidth || item.offsetHeight || item.getClientRects().length );
	},
	isEmpty: function( obj ) {
		for( var key in obj ) {
			return false;
		}

		return true;
	},

	methods : {
		optionSelect : function( event, value, component, item ) {

			this.setData( 'ltPropDropdownSelected', value )
			// this.setData( 'selectValue', item.innerText )
			var dropButton = component.$node.querySelector('lyte-drop-button')
			dropButton.classList.remove('lyteComboboxFiltering')
			if( !this._searchEle ){
				if( this.getData( 'ltPropType' ) != 'boxSearch' ) {
					  this._searchEle = this.$node.querySelector( 'lyte-input' ); 
				} else {
					var dropBox = component.childComp

					 this._searchEle = dropBox.querySelector( 'lyte-input' ); 
				}
			}
			 
			if(  this._searchEle !==null ) {
				$L( this._searchEle )[0].setValue('');
			}
			if( this.getMethods( 'onOptionSelect' ) ) {
				this.executeMethod( 'onOptionSelect', event, value, component, item )
			}
		},
		dropBoxOpen : function( event, component ) {

			if( !this._searchEle ) {
				if( this.getData( 'ltPropType' ) != 'boxSearch' ) {
					 this._searchEle = this.$node.querySelector( 'lyte-input' ); 
				} else {
					var dropBox = component.childComp
					 this._searchEle = dropBox.querySelector( 'lyte-input' ); 
				}
			}
			 
			if( this._searchEle!==null && !this.getData('ltPropDropdown').animate) {
				 this._searchEle.focus();
				$L( this._searchEle)[0].setValue('');
			}
			if( this.getMethods( 'onShow' ) ) {
				this.executeMethod( 'onShow', event, component );
			}
			
		},
		onAnimateEnd : function(event,component){
			if( !this._searchEle ) {
				if( this.getData( 'ltPropType' ) != 'boxSearch' ) {
					 this._searchEle = this.$node.querySelector( 'lyte-input' ); 
				} else {
					var dropBox = component.childComp
					 this._searchEle = dropBox.querySelector( 'lyte-input' ); 
				}
			}
			 
			if( this._searchEle!==null  ) {
				 this._searchEle.focus();
				$L( this._searchEle)[0].setValue('');
			}
			if( this.getMethods( 'onAnimationEnd' ) ) {
				this.executeMethod( 'onAnimationEnd', event, component );
			}
		},
		searchList : function( object , input){
			var dropDown = this.$node.querySelector( 'lyte-dropdown' ),
				dropButton = dropDown.querySelector( 'lyte-drop-button' ),
				dropBox = dropDown.component.childComp || dropDown.querySelector( 'lyte-drop-box' )
			// if(object.newValue != ""){
			// 	dropButton.classList.add('lyteComboboxFiltering')
			// }
			// else{
			// 	dropButton.classList.remove('lyteComboboxFiltering')
			// }
			if(dropBox){
				var elems = dropBox.querySelectorAll( 'lyte-drop-item:not(.lyteSearchHidden):not(.lyteDropdownActive)' ),
				cur = dropBox.querySelector( '.lyteDropdownSelection' ),elem
				for(var i=0 ; i < elems.length; i++ ) {
					if( this.isVisible( elems[ i ] )
						&& elems[ i ].getAttribute( 'disabled' ) !== "true" 
					) {
						elem = elems[ i ];
						break;
					}
				}

				if( cur ) {
					cur.classList.remove( 'lyteDropdownSelection' );
				}

				if( elem ) {
					elem.classList.add( 'lyteDropdownSelection' );
					return ;
				}
			}
		},
		beforeDropboxShow:function( event, component ) {
			if( this.getMethods( 'onBeforeShow' ) ) {
				return this.executeMethod( 'onBeforeShow', event, component )
			};
		},
		hideDropbox:function( event, component ) {
			if( !this._searchEle ) {
				if( this.getData( 'ltPropType' ) != 'boxSearch' ) {
					 this._searchEle = this.$node.querySelector( 'lyte-input' ); 
				} else {
					var dropBox = component.childComp
					 this._searchEle = dropBox.querySelector( 'lyte-input' ); 
				}
			}
			 
			if( this._searchEle!==null ) {
				$L(this._searchEle)[0].setValue('');
			}
			if( this.getMethods( 'onHide' ) ) {
				return this.executeMethod( 'onHide', event, component );
			};

		},
		beforeHideDropbox:function( event, component ) {
			if( this.getMethods( 'onBeforeHide' ) ) {
				return	this.executeMethod( 'onBeforeHide', event, component )
			};
		},
		scrollDropBox : function( event, dropdownComp ) {
			if( this.getMethods( 'onUserScroll' ) ) { 
				this.executeMethod( 'onUserScroll', event, dropdownComp ); 
			}
		},
		onSearchClear : function( event, element ){
			
			if( element!==null ) {
				$L(element)[0].setValue('');
			}
			if( this.getMethods( 'onClear' ) ) {
				return this.executeMethod( 'onClear', event, component );
			};
		}
	},
	actions : {
		toolTipConfig: function( button ) {
			var width = button.offsetWidth,
			scrollWidth = button.scrollWidth,
			config = this.getData( 'ltPropTooltip' );

			this.setData( 'showToolTip', ( width < scrollWidth ) && !this.isEmpty( config ) );
		},
		oninput: function(self){
			var dropButton = this.$node.querySelector( 'lyte-drop-button' ),
			input = self.querySelector('input')
			if(input.value != ""){
				dropButton.classList.add('lyteComboboxFiltering')
			}
			else{
				dropButton.classList.remove('lyteComboboxFiltering')
			}
		}
	}
});

/**
 * Renders a counter
 * @component lyte-counter
 * @version  2.0.0
 * @methods onComplete,easingFunction
 */
Lyte.Component.register("lyte-counter", {
_template:"<template tag-name=\"lyte-counter\"> <div class=\"counterDiv {{ltPropClass}}\"> <span class=\"counterNegative\">{{negative}}</span> <span class=\"counterPrefix\">{{ltPropPrefix}}</span> <span class=\"counterValue\">{{result}}</span> <span class=\"counterSuffix\">{{ltPropSuffix}}</span> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"text","position":[1,3,0]},{"type":"text","position":[1,5,0]},{"type":"text","position":[1,7,0]}],
_observedAttributes :["ltPropStart","ltPropEnd","ltPropPrefix","ltPropSuffix","ltPropDecimals","ltPropDuration","ltPropUseEasing","ltPropUseGrouping","ltPropSeparator","ltPropDecimalSeparator","ltPropState","ltPropClass","negative","startValue","endValue","result"],
	data : function(){
		return {
			/** 
			 * @componentProperty {number} ltPropStart=0
			 * @version 2.0.0
			 */
			'ltPropStart' : Lyte.attr( 'number', {
				'default' : 0
			} ),
/** 
			 * @componentProperty {number} ltPropEnd=0
			 * @version 2.0.0
			 */
			'ltPropEnd' : Lyte.attr( 'number', {
				'default' : 0
			} ),
			/** 
			 * @componentProperty {string} ltPropPrefix=""
			 * @version 2.0.0
			 */
			'ltPropPrefix' : Lyte.attr( 'string', {
				'default' :  _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'prefix', "" )
			} ),
			/** 
			 * @componentProperty {string} ltPropSuffix=""
			 * @version 2.0.0
			 */
			'ltPropSuffix' : Lyte.attr( 'string', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'suffix', "" )
			} ),
			/** 
			 * @componentProperty {number} ltPropDecimals=0
			 * @version 2.0.0
			 */
			'ltPropDecimals' : Lyte.attr( 'number', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'decimals', 0 )
			} ),
			/** 
			 * @componentProperty {number} ltPropDuration=2
			 * @version 2.0.0
			 */
			'ltPropDuration' : Lyte.attr( 'number', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'duration', 2 )
			} ),
			/** 
			 * @componentProperty {boolean} ltPropUseEasing=true
			 * @version 2.0.0
			 */
			'ltPropUseEasing' : Lyte.attr( 'boolean', { 
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'useEasing', true )
			} ),
			/** 
			 * @componentProperty {boolean} ltPropUseGrouping=true
			 * @version 2.0.0
			 */
			'ltPropUseGrouping' : Lyte.attr( 'boolean', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'useGrouping', true )
			} ),
			/** 
			 * @componentProperty {string} ltPropSeparator=','
			 * @version 2.0.0
			 */
			'ltPropSeparator' : Lyte.attr( 'string', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'separator', ',')
			} ),
			/** 
			 * @componentProperty {string} ltPropDecimalSeparator='.'
			 * @version 3.0.0
			 */
			'ltPropDecimalSeparator' : Lyte.attr( 'string', {
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'decimalSeparator', "." )
			} ),
			/** 
			 * @componentProperty {string} ltPropState=''
			 * @version 2.0.0
			 */
			'ltPropState' : Lyte.attr( 'string', {
			 'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'state', '' )
			} ),
			/** 
			 * @componentProperty {string} ltPropClass=""
			 * @version 2.0.0
			 */
			'ltPropClass' : Lyte.attr( 'string', { 
				'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-counter', 'class', '' )
			} ),
			/**
            * @experimental negative
            */
			'negative' : Lyte.attr( 'string', {
				'default' : ''
			} ),
			/**
            * @experimental startValue
            */
			'startValue' : Lyte.attr( 'number', {
				'default' : 0
			} ),
			/**
            * @experimental endValue
            */
			'endValue' : Lyte.attr( 'number' ),
			/**
            * @experimental result
            */
			'result' : Lyte.attr( 'string' )
		}		
	},
	
	didConnect : function() {
		if( this._rAFId ){
			window.cancelAnimationFrame( this._rAFId )
		}
		this._initialized = false;
		if( this.getData( 'seperator' ) === '' ) {
			this.getData( 'ltPropUseGrouping', false )
		}
		if( this.getData( 'ltPropEnd' ) == null ) {
			throw new TypeError( '"endValue" is null or not defined' )
		}
		if( !this.checkForNumber( Number( this.getData( 'ltPropStart' ) ) ) ) {
			throw new TypeError( '"Start Value" is not a number' )
		}
		if( !this.checkForNumber( Number( this.getData( 'ltPropEnd' ) ) ) ) {
			throw new TypeError( '"End Value" is not a number' )
		}
		this._startVal = Number( this.getData( 'ltPropStart' ) )
		this._endVal = Number( this.getData( 'ltPropEnd' ) )
		delete this._startTime
		delete this._paused
		this.initialize()
		if( this.getData( 'ltPropState' ).toUpperCase() == 'START' ) {
			this.start();
		}
	},
	stateObs : function() {
		if( this.getData( 'ltPropState' ).toUpperCase() == 'START' ) {
			this.start();
		}
		else if( this.getData( 'ltPropState' ).toUpperCase() == 'RESET' ) {
			this.reset();
		}
		else if( this.getData( 'ltPropState' ).toUpperCase() == 'PAUSE' ) {
			if( this._initialized ){
				this._paused = true;
				cancelAnimationFrame( this._rAFId );
			}
		}
		else if( this.getData( 'ltPropState' ).toUpperCase() == 'RESUME' && this._paused ) {
			this.resume();
		}
	}.observes( 'ltPropState' ),
	updateObs : function() {
		this._endVal = Number( this.getData( 'ltPropEnd' ) );
		if( this.getData( 'ltPropState' ) == 'Running' ) {
			this.update( this.getData( 'ltPropEnd' ) );
		}
	}.observes( 'ltPropEnd' ),
	startObs : function() {
		if( this._rAFId ) {
			window.cancelAnimationFrame( this._rAFId )
		}
		this._initialized = false;
		this._startVal = Number( this.getData( 'ltPropStart' ) )
		this._endVal = Number( this.getData( 'ltPropEnd' ) )
		delete this._startTime
		delete this._paused
		this.initialize()
	}.observes( 'ltPropStart' ),
	start : function() {
		if( this._rAFId ) {
			window.cancelAnimationFrame( this._rAFId )
		}
		this._initialized = false;
		delete this._startTime;
		delete this._paused;
		this.initialize()
		this.setData( 'ltPropState', 'Running' )
		this._startVal = this.getData( 'ltPropStart' )
		this._rAFId = requestAnimationFrame( this.count.bind( this ) );
	},
	reset : function() {
		this._paused = false;
		delete this._startTime;
		this._initialized = false;
		this.setData( 'ltPropState', '' );
		if( this.initialize() ) {
			window.cancelAnimationFrame( this._rAFId );
			this.printValue( this.getData( 'ltPropStart' ) );
		}
	},
	update : function(endVal){
		if ( !this._initialized ) {
			 return;
		}
		if ( !this.checkForNumber( endVal ) ) {
			return;
		}
		if ( endVal === this._frameVal ) {
			 return;
		}
		window.cancelAnimationFrame( this._rAFId );
		this._paused = false;
		delete this._startTime;
		this._startVal = this._frameVal;
		this.setData( 'ltPropEnd', endVal );
		this._endVal = endVal;
		this._endValue = this._endVal;
		this._countDown = ( this._startVal > this._endVal );
		this._rAFId = window.requestAnimationFrame( this.count.bind( this ) );
	},
	resume : function() {
		if( this._initialized ) {
			this._paused = false;
			delete this._startTime;
			if( this._remaining ) {
				this._duration = this._remaining;
			}
			if( this._frameVal ) {
				this._startVal = this._frameVal;
			}
			this.setData( 'ltPropState', 'running' );
			requestAnimationFrame( this.count.bind( this ) );
		}
	},
	count : function() {
		var timestamp=new Date().getTime();
		if (!this._startTime) {
		 this._startTime = timestamp;
		}
		this._timestamp = timestamp;
		var progress = timestamp - this._startTime;
		this._remaining = this._duration - progress;
		if ( this.getData( 'ltPropUseEasing' ) ) {
			if ( this._countDown ) {
				this._frameVal = this._startVal - this.executeMethod( 'easingFunction', progress, 0, this._startVal - this._endVal, this._duration );
			} else {
				this._frameVal = this.executeMethod( 'easingFunction', progress, this._startVal, this._endVal - this._startVal, this._duration );
			}
		} else {
			if ( this._countDown ) {
				this._frameVal = this._startVal - ( ( this._startVal - this._endVal ) * ( progress / this._duration ) );
			} else {
				this._frameVal = this._startVal + ( this._endVal - this._startVal ) * ( progress / this._duration );
			}
		}
		if ( this._countDown ) {
			this._frameVal = ( this._frameVal < this._endVal ) ? this._endVal : this._frameVal;
		} else {
			this._frameVal = ( this._frameVal > this._endVal ) ? this._endVal : this._frameVal;
		}
		this._frameVal = Math.round( this._frameVal * this._dec )/this._dec;
		this.printValue( this._frameVal );
		if (progress <= this._duration ) {
			var func1 = this.count.bind( this );
			this._rAFId = window.requestAnimationFrame( func1 );

		}
		else {
			var self = this;
			setTimeout( function() {
				if( self.getMethods( 'onComplete' ) ) {
					self.executeMethod( 'onComplete' )
				}
			},100);
			this.setData( 'ltPropState', '' ); 
			this._initialized = false;
		}
	},
	initialize : function() {
		if ( this._initialized ) {
			 	return true;
		}
		if ( this.checkForNumber( this._startVal ) && this.checkForNumber( this._endVal ) ) {
				this._decimals = Math.max( 0, this.getData( 'ltPropDecimals' ) || 0 )
				this._dec = Math.pow(10, this._decimals)
				this._duration = Number( this.getData( 'ltPropDuration' ) ) * 1000 || 2000
				this._countDown = ( this._startVal > this._endVal )
				this._frameVal = this._startVal
				this._initialized = true
				this.printValue( this._startVal )
				return true
		}
			return false;
	},
	checkForNumber : function( n ) {
		var num = Number( n )
		return ( typeof num === 'number' && !isNaN( num ) );
	},
	printValue : function( value ){
		var result = this.formatNumber( value );
		this.setData( 'result', result );
	
	},
	formatNumber : function( num ) {
		var neg = ( num < 0 ),x, x1, x2, x3, i, len;
		num = Math.abs( num ).toFixed( this.getData( 'ltPropDecimals' ) );
		num += '';
		x = num.split( '.' );
		x1 = x[ 0 ];
		x2 = x.length > 1 ? this.getData( 'ltPropDecimalSeparator' ) + x[ 1 ] : '';
		if ( this.getData( 'ltPropUseGrouping' ) ) {
			x3 = '';
			for ( i = 0, len = x1.length; i < len; ++i ) {
				if (i !== 0 && ((i % 3) === 0)) {
					x3 = this.getData( 'ltPropSeparator' ) + x3;
				}
				x3 = x1[ len - i - 1 ] + x3;
			}
			x1 = x3;
		}
		this.setData( 'negative', ( neg ? '-' : '' ) );
		return x1 + x2 ;
	},
	methods : {
		easingFunction : function( t, b, c, d ) {
			return c * ( -Math.pow( 2, -10 * t / d ) + 1 ) * 1024 / 1023 + b;
		}
	}
});

/**
 * @syntax nonYielded 
 * <lyte-counter></lyte-counter> 
 */
/**
 * Renders a daterangepicker
 * @component lyte-daterangepicker
 * @version 1.0.0
 * @dependencies lyte-calendar,lyte-dropdown,lyte-moment
 * @methods onDateSelected,onNavigation
 * @utility revertToSelected,revertToToday
 */

Lyte.Component.register("lyte-daterangepicker", {
_template:"<template tag-name=\"lyte-daterangepicker\"> <template is=\"switch\" value=\"{{ltPropSelectionType}}\"><template case=\"continuous\"> <div class=\"lyteDateRangePickerRow\" onmousedown=\"{{action('mouseDown',event)}}\" onmouseover=\"{{action('mouseOver',event)}}\"> <div class=\"lyteDateRangePickerCol1\"> <lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"{{ltPropFillRows}}\" class=\"dRPCalendar1\" on-viewdate-change=\"{{method('viewDateChange','cal1')}}\"> <template is=\"registerYield\" yield-name=\"navigator\"> <div class=\"lyteDateRPLeftNav\"> <span case=\"true\" class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('previous','Y',event)}}\"></span> <span class=\"lyteCalNav lyteCaldLft\" onclick=\"{{action('previous','M',event)}}\"></span> </div> <div class=\"{{lyteUiDateRPHeaderClass(ltPropHeaderType)}}\"> <template is=\"if\" value=\"{{ifEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"monthDD\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal1','M')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{monthNames}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"yearDD\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal1','Y')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{years}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template><template case=\"false\"> <span>{{monthHeader1}}</span> </template></template> </div> </template> </lyte-calendar> </div> <div class=\"lyteDateRangePickerCol2\"> <lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"{{ltPropFillRows}}\" class=\"dRPCalendar2\" select-date=\"false\" on-viewdate-change=\"{{method('viewDateChange','cal2')}}\"> <template is=\"registerYield\" yield-name=\"navigator\"> <div class=\"{{lyteUiDateRPHeaderClass(ltPropHeaderType)}}\"> <template is=\"if\" value=\"{{ifEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"monthDD\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal2','M')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{monthNames}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"yearDD\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal2','Y')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{years}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template><template case=\"false\"> <span>{{monthHeader2}}</span> </template></template> </div> <div class=\"lyteDateRPRightNav\"> <span case=\"true\" class=\"lyteCalNav lyteCaldRgt\" onclick=\"{{action('next','M',event)}}\"></span> <span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('next','Y',event)}}\"></span> </div> </template> </lyte-calendar> </div> </div> </template><template case=\"separate\"> <div class=\"lyteDateRangePickerRow lyteSeperateDRP\" onmousedown=\"{{action('separateMouseDown',event)}}\"> <div class=\"lyteDateRangePickerCol1\"> <lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"{{ltPropFillRows}}\" class=\"dRPCalendar1\" on-viewdate-change=\"{{method('viewDateChange','cal1')}}\"> <template is=\"registerYield\" yield-name=\"navigator\"> <div class=\"lyteDateRPLeftNav\"> <span case=\"true\" class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('separatePrevious','Y','cal1',event)}}\"></span> <span class=\"lyteCalNav lyteCaldLft\" onclick=\"{{action('separatePrevious','M','cal1',event)}}\"></span> </div> <div class=\"{{lyteUiDateRPHeaderClass(ltPropHeaderType)}}\"> <template is=\"if\" value=\"{{ifEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"monthDD\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal1','M')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{monthNames1}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"yearDD\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal1','Y')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{years1}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template><template case=\"false\"> <span>{{monthHeader1}}</span> </template></template> </div> <div class=\"lyteDateRPRightNav\"> <span case=\"true\" class=\"lyteCalNav lyteCaldRgt\" onclick=\"{{action('separateNext','M','cal1',event)}}\"></span> <span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('separateNext','Y','cal1',event)}}\"></span> </div> </template> </lyte-calendar> </div> <div class=\"lyteDateRangePickerCol2\"> <lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"{{ltPropFillRows}}\" class=\"dRPCalendar2\" select-date=\"false\" on-viewdate-change=\"{{method('viewDateChange','cal2')}}\"> <template is=\"registerYield\" yield-name=\"navigator\"> <div class=\"lyteDateRPLeftNav\"> <span case=\"true\" class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('separatePrevious','Y','cal2',event)}}\"></span> <span class=\"lyteCalNav lyteCaldLft\" onclick=\"{{action('separatePrevious','M','cal2',event)}}\"></span> </div> <div class=\"{{lyteUiDateRPHeaderClass(ltPropHeaderType)}}\"> <template is=\"if\" value=\"{{ifEquals(ltPropHeaderType,&quot;dropdown&quot;)}}\"><template case=\"true\"> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"monthDD\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal2','M')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{monthNames2}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <lyte-dropdown on-before-show=\"{{method('addDropdownClass')}}\" on-show=\"{{method('editArrowPosition')}}\" lt-prop-callout=\"true\" class=\"yearDD\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal2','Y')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{years2}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item}}\">{{item}}</lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template><template case=\"false\"> <span>{{monthHeader2}}</span> </template></template> </div> <div class=\"lyteDateRPRightNav\"> <span case=\"true\" class=\"lyteCalNav lyteCaldRgt\" onclick=\"{{action('separateNext','M','cal2',event)}}\"></span> <span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('separateNext','Y','cal2',event)}}\"></span> </div> </template> </lyte-calendar> </div> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"continuous":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"registerYield","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,3,1]},{"type":"registerYield","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"attr","position":[3,3]}]},{"type":"componentDynamic","position":[1,3,1]}]},"separate":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"registerYield","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[5,1]},{"type":"attr","position":[5,3]}]},{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,3,1]},{"type":"registerYield","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[5,1]},{"type":"attr","position":[5,3]}]},{"type":"componentDynamic","position":[1,3,1]}]}},"default":{}}],
_observedAttributes :["monthHeader1","monthHeader2","ltPropCurrentDate","ltPropFormat","ltPropMonthHeaderFormat","shortMonthNames","longMonthNames","ltPropStartYear","ltPropEndYear","ltPropStartDate","ltPropEndDate","ltPropDisabledDates","ltPropMinDate","ltPropMaxDate","ltPropSelectionType","ltPropPosition","ltPropHeaderType","ltPropFillRows","years","dateSelected","selectedDate1","selectedDate2","calViewDate1","calViewDate2","tempDate","monthNames","dateNode1","dateNode2","clickCount","convertedDates","convert","internallyChanged","monthNames1","monthNames2","years1","years2","triggerInit","triggerDidconnect"],
	data: function () {
		return {
			"monthHeader1": Lyte.attr("string", { "default": "Initializing.." }),
			"monthHeader2": Lyte.attr("string", { "default": "Initializing.." }),

			/**
						 * @componentProperty {string} ltPropCurrentDate
						 * @version 1.0.0
						 */
			"ltPropCurrentDate": Lyte.attr("string", { "default": '' }),
			/** 
			 * @typedef {
			 * MM/DD/YYYY |
			 * YYYY/MM/DD |
			 * MMM/DD/YYYY |
			 * MMM/YYYY/DD |
			 * DD/MMM/YYYY |
			 * YYYY/MMM/DD |
			 * DD/YYYY/MMM |
			 * YYYY/DD/MMM |
			 * MMMM/DD/YYYY |
			 * MMMM/YYYY/DD |
			 * DD/YYYY/MMMM |
			 * YYYY/DD/MMMM |
			 * DD/MMMM/YYYY |
			 * YYYY/MMMM/DD
			 * } dateFormat
			*/
			/**
						 * @componentProperty {dateFormat} ltPropFormat
						 * @version 1.0.0
						 * @default MM/DD/YYYY
						 */
			"ltPropFormat": Lyte.attr("string", { "default": "MM/DD/YYYY" }),
			/**
			 * @typedef {
			 * 'MMMM YYYY' |
			 * 'MMM YYYY' 
			 * } MonthHeaderFormat
			 */
			/**
						 * @componentProperty {MonthHeaderFormat} ltPropMonthHeaderFormat
						 * @version 1.0.0
						 * @default MMM YYYY
						 * @options MMMM YYYY,MMM YYYY
						 */
			"ltPropMonthHeaderFormat": Lyte.attr("string", { "default": "MMM YYYY" }),
			"shortMonthNames": Lyte.attr("array", { "default": ['Jan', 'Feb', 'Mar', 'Apr', 'short.may', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }),
			'longMonthNames': Lyte.attr('array', {
				'default': [
					'January',
					'February',
					'March',
					'April',
					'May',
					'June',
					'July',
					'August',
					'September',
					'October',
					'November',
					'December'
				]
			}),

			/**
						 * @componentProperty {number} ltPropStartYear
						 * @version 1.0.0
						 * @default 1900
						 */
			"ltPropStartYear": Lyte.attr("number", { "default": 1900 }),

			/**
						 * @componentProperty {number} ltPropEndYear
						 * @version 1.0.0
						 * @default 2100
						 */
			"ltPropEndYear": Lyte.attr("number", { "default": 2100 }),

			/**
						 * @componentProperty {dateString} ltPropStartDate
						 * @version 1.0.0
						 */
			"ltPropStartDate": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {dateString} ltPropEndDate
						 * @version 1.0.0
						 */
			"ltPropEndDate": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {array} ltPropDisabledDates
						 * @version 1.0.0
						 * @default []
						 */
			"ltPropDisabledDates": Lyte.attr("array", { "default": [] }),

			/**
						 * @componentProperty {dateString} ltPropMinDate
						 * @version 1.0.0
						 */
			"ltPropMinDate": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {dateString} ltPropMaxDate
						 * @version 1.0.0
						 */
			"ltPropMaxDate": Lyte.attr("string", { "default": "" }),

			/**
						 * @componentProperty {continuous|separate} ltPropSelectionType
						 * @version 2.0.0
						 * @default continuous
						 */
			"ltPropSelectionType": Lyte.attr("string", { "default": "continuous" }),

			/**
						 * @componentProperty {left|right} ltPropPosition
						 * @version 2.2.6
						 * @default left
						 */
			"ltPropPosition": Lyte.attr("string", { "default": "left" }),

			/**
						 * @componentProperty {dropdown|default} ltPropHeaderType
						 * @version 2.2.16
						 * @default dropdown
						 */
			"ltPropHeaderType": Lyte.attr("string", { "default": "dropdown" }),

			/**
						 * @componentProperty {boolean} ltPropFillRows
						 * @version 2.2.16
						 * @default false
						 * 
						 */
			"ltPropFillRows": Lyte.attr("boolean", { "default": false }),

			// "ltPropPreventClick" : Lyte.attr("boolean",{"default":true}),

			//local variables
			"years": Lyte.attr("array", { "default": [] }),
			"dateSelected": Lyte.attr("boolean", { "default": false }),
			"selectedDate1": Lyte.attr("string"),
			"selectedDate2": Lyte.attr("string"),
			"calViewDate1": Lyte.attr("object"),
			"calViewDate2": Lyte.attr("object"),
			"tempDate": Lyte.attr("string"),
			"monthNames": Lyte.attr("array"),
			"dateNode1": Lyte.attr("object"),
			"dateNode2": Lyte.attr("object"),
			"clickCount": Lyte.attr("number", { "default": 0 }),
			"convertedDates": Lyte.attr("array", { "default": [] }),
			"convert": Lyte.attr("number", { "default": 0 }),
			"internallyChanged": Lyte.attr("boolean", { "default": false }),
			"monthNames1": Lyte.attr("array"),
			"monthNames2": Lyte.attr("array"),
			"years1": Lyte.attr("array", { "default": [] }),
			"years2": Lyte.attr("array", { "default": [] }),
			"triggerInit": Lyte.attr("number", { "default": 0 }),
			"triggerDidconnect": Lyte.attr("number", { "default": 0 })
		}
	},


	didConnect : function(){
		this.isTimezone = $L.moment && $L.moment().getCurrentTimeZone();
	},


	toDate : function(){
		if( this.isTimezone ){
			return new Date( $L.moment().format( 'MM/DD/YYYY' ) );
		}
		return new Date();
	},	

	moment : function( arg1, arg2 ){
		return $L.moment( arg1, arg2, { ignore_timezone : this.isTimezone } );
	},


	/**
	 * The method is going to initialize the values based on which the daterangepicker will be rendered
	 *
	 */
	initFunc : function(){
		var year = [],
			self = this;
		if (!(this.addedUtil)) {
			this.$node.revertToSelected = function () {
				self.revertToSelected();
			};
			this.$node.revertToToday = function () {
				self.revertToToday();
			};
			this.$node.reset = function () {
				self.resetDrp();
			};
			this.addedUtil = true;
		}
		for (var i = this.getData("ltPropStartYear"); i <= this.getData("ltPropEndYear"); i++) {
			year.push(i);
		}
		if (this.getData('ltPropSelectionType') == "continuous") {
			this.setData("years", year);
		}
		if (this.getData('ltPropSelectionType') == "separate") {
			this.setData("years1", year);
			this.setData("years2", year);
		}
		var monthNames = [];
		// localeMonthString = [];
		if (this.getData('ltPropMonthHeaderFormat') === 'MMMM YYYY') {
			for (var i = 0; i < 12; i++) {
				// localeMonthString.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
				monthNames.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
			}
		}
		else {
			for (var i = 0; i < 12; i++) {
				// localeMonthString.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
				monthNames.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
			}
		}
		this.setData('monthNames', monthNames);
		if (this.getData('ltPropSelectionType') == "separate") {
			this.setData('monthNames1', monthNames);
			this.setData('monthNames2', monthNames);
		}
	}.observes('ltPropStartYear','ltPropEndYear','triggerInit').on('init'),

	/**
	 * The method is going to reset the daterangepicker component
	 *
	 */
	resetDrp : function(){
		this.setData('dateNode1', null);
		this.setData('dateNode2', null);
		this.setData('selectedDate1', '');
		this.setData('selectedDate2', '');
		this.checkAndRemoveSelectedDateClass('start');
		this.checkAndRemoveSelectedDateClass('end');
		if (this.getData('ltPropSelectionType') == 'separate') {
			this.restrictCalendarDates("cal2", this.getData('ltPropMinDate'), "min");
			this.restrictCalendarDates("cal1", this.getData('ltPropMaxDate'), "max");
			this.validateNavigation();
			var selected = this.$node.querySelectorAll('.lyteCalSel');
			if (selected.length > 0) {
				var selectedDate = new Date(selected[0].dataset.date);
				if (selectedDate.toString() === "Invalid Date") {
					if (!($L.moment)) {
						console.error("INCLUDE LYTE-MOMENT PLUGIN");
						return;
					}
					selectedDate = this.moment(selected[0].dataset.date, this.getData('ltPropFormat').toUpperCase()).getDObj();
				}
				for (var i = 0; i < selected.length; i++) {
					selected[0].classList.remove('lyteCalSel');
				}
			}
		}
	},
	revertToSelected: function () {
		this.setData('triggerDidconnect', this.getData('triggerDidconnect') + 1);
		if (this.getData('ltPropSelectionType') == "separate") {
			if (this.getData('ltPropStartDate')) {
				// this.checkAndRemoveSelectedDateClass("start");
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar1'), this.getData('ltPropStartDate'), "start");
			}
			if (this.getData('ltPropEndDate')) {
				// this.checkAndRemoveSelectedDateClass("end");
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar2'), this.getData('ltPropEndDate'), "end");
			}
		}
	},
	revertToToday: function () {
		var cal1 = this.$node.querySelector('.dRPCalendar1');
		var cal2 = this.$node.querySelector('.dRPCalendar2');
		var today = this.toDate();
		var dd = today.getDate();
		var mm = today.getMonth(); //January is 0!
		var yy = today.getFullYear();
		// this.setMonthAndYear(cal1,{dd:dd,mm:mm,yy:yy},"cal1");
		if (this.getData('ltPropSelectionType') == "continuous") {
			if (this.getData('ltPropPosition') == "right") {
				mm -= 1;
				if (mm < 0) {
					mm = 11;
					yy -= 1;
				}
				cal1.setData('selectDate', false);
				this.setMonthAndYear(cal1, { dd: 1, mm: mm, yy: yy }, "cal1");
				cal1.setData('selectDate', true);
			}
			else {
				this.setMonthAndYear(cal1, { dd: dd, mm: mm, yy: yy }, "cal1");
			}
			if (mm < 11) {
				mm += 1
			}
			else {
				mm = 0;
				yy += 1;
			}
			if (this.getData('ltPropPosition') == "right") {
				cal2.setData('selectDate', true);
				this.setMonthAndYear(cal2, { dd: dd, mm: mm, yy: yy }, "cal2");
				cal2.setData('selectDate', false);
			} else {
				this.setMonthAndYear(cal2, { dd: 1, mm: mm, yy: yy }, "cal2");
			}
			var selected = this.$node.querySelector('.lyteCalSel');
			if (selected) {
				var selectedDate = new Date(selected.dataset.date);
				if (selectedDate.toString() === "Invalid Date") {
					if (!($L.moment)) {
						console.error("INCLUDE LYTE-MOMENT PLUGIN");
						return;
					}
					selectedDate = this.moment(selected.dataset.date, this.getData('ltPropFormat').toUpperCase()).getDObj();
				}
				if (selectedDate.getMonth() === today.getMonth() && selectedDate.getDate() === today.getDate() && selectedDate.getFullYear() === today.getFullYear()) {
					selected.classList.remove('lyteCalSel');
					selected.classList.add('lyteCalToday');
				}
			}
		}
		else if (this.getData('ltPropSelectionType') == "separate") {
			this.setMonthAndYear(cal1, { dd: dd, mm: mm, yy: yy }, "cal1");
			var startDate = this.getData('ltPropStartDate') ? Date.parse(this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'))) : null,
				endDate = this.getData('ltPropEndDate') ? Date.parse(this.stringToDate(this.getData('ltPropEndDate'), this.getData('ltPropFormat'))) : null,
				currentDate = Date.parse(today), dateObj;
			if (startDate && startDate > currentDate) {
				dateObj = this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'));
				var dd = dateObj.getDate();
				var mm = dateObj.getMonth(); //January is 0!
				var yy = dateObj.getFullYear();
				this.setMonthAndYear(cal2, { dd: dd, mm: mm, yy: yy }, "cal2");
				this.restrictCalendarDates("cal2", this.getData('ltPropStartDate'), "min");
			}
			else if (endDate && endDate < currentDate) {
				dateObj = this.stringToDate(this.getData('ltPropEndDate'), this.getData('ltPropFormat'));
				var dd = dateObj.getDate();
				var mm = dateObj.getMonth(); //January is 0!
				var yy = dateObj.getFullYear();
				this.setMonthAndYear(cal1, { dd: dd, mm: mm, yy: yy }, "cal1");
				this.restrictCalendarDates("cal1", this.getData('ltPropEndDate'), "max");
			}
			else {
				this.setMonthAndYear(cal2, { dd: dd, mm: mm, yy: yy }, "cal2");
			}
			var selected = this.$node.querySelectorAll('.lyteCalSel');
			if (selected.length > 0) {
				var selectedDate = new Date(selected[0].dataset.date);
				if (selectedDate.toString() === "Invalid Date") {
					if (!($L.moment)) {
						console.error("INCLUDE LYTE-MOMENT PLUGIN");
						return;
					}
					selectedDate = this.moment(selected[0].dataset.date, this.getData('ltPropFormat').toUpperCase()).getDObj();
				}
				for (var i = 0; i < selected.length; i++) {
					if (selectedDate.getMonth() === today.getMonth() && selectedDate.getDate() === today.getDate() && selectedDate.getFullYear() === today.getFullYear()) {
						selected[0].classList.remove('lyteCalSel');
						selected[0].classList.add('lyteCalToday');
					}
				}
			}
			if (this.getData('ltPropStartDate')) {
				this.setData('selectedDate1', this.getData('ltPropStartDate'));
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar1'), this.getData('ltPropStartDate'), "start");
			}
			if (this.getData('ltPropEndDate')) {
				this.setData('selectedDate2', this.getData('ltPropEndDate'));
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar2'), this.getData('ltPropEndDate'), "end");
			}
			this.validateNavigationAndDropdown();
		}


		if (this.getData('ltPropDisabledDates').length > 0) {
			this.setData('convert', this.getData('convert') + 1);
		}
		if (this.getData('ltPropSelectionType') == "continuous" && this.getData('ltPropStartDate') && this.getData('ltPropEndDate')) {
			this.setData('selectedDate1', this.getData('ltPropStartDate'));
			this.setData('selectedDate2', this.getData('ltPropEndDate'));
			this.checkForSelectedDates(this.getData('ltPropStartDate'), this.getData('ltPropEndDate'));
		}
		this.setTodayClass();
	},

	setTodayClass : function(){
		var currentDate = this.toDate();
		if(this.getData('calViewDate1').getMonth() == currentDate.getMonth() && this.getData('calViewDate1').getFullYear() == currentDate.getFullYear()){
			var nodes = this.$node.querySelector('.dRPCalendar1').querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
			for(var i = 0; i<nodes.length; i++){
				var date = this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat'));
				if(currentDate.getDate() == date.getDate() && !(nodes[i].classList.contains('lyteDateRPFirstDateSelected') || nodes[i].classList.contains('lyteDateRPTempSelected') || nodes[i].classList.contains('lyteDateRPLastDateSelected'))){
					nodes[i].classList.add('lyteCalToday');
				}
			}
		}
		if(this.getData('calViewDate2').getMonth() == currentDate.getMonth() && this.getData('calViewDate2').getFullYear() == currentDate.getFullYear()){
			var nodes = this.$node.querySelector('.dRPCalendar2').querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
			for(var i = 0; i<nodes.length; i++){
				var date = this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat'));
				if(currentDate.getDate() == date.getDate() && !(nodes[i].classList.contains('lyteDateRPFirstDateSelected') || nodes[i].classList.contains('lyteDateRPTempSelected') || nodes[i].classList.contains('lyteDateRPLastDateSelected'))){
					nodes[i].classList.add('lyteCalToday');
				}
			}
		}
	},

	toggleSelectionType : function(){
		this.setData('triggerInit',this.getData('triggerInit') + 1);
		this.setData('triggerDidconnect',this.getData('triggerDidconnect') + 1);
	}.observes('ltPropSelectionType'),
	convertDisabledDates: function () {
		// var disabledDates = this.getData('ltPropDisabledDates');
		// var convertedDates = [];
		// for(var i = 0; i<disabledDates.length; i++){
		// 	convertedDates.push(Date.parse(disabledDates[i]));
		// }
		// this.setData('convertedDates',convertedDates);
		if (this.getData('ltPropDisabledDates').length > 0) {
			this.checkAndMarkDisabledDates();
		}
	}.observes("ltPropDisabledDates.[]","convert"),

	/**
	 * The method is going to set the months that will be shown in the daterangepicker
	 *
	 */
	setMonths : function(){
		var monthNames = [];
		// localeMonthString = "";
		if (this.getData('ltPropMonthHeaderFormat') === 'MMMM YYYY') {
			for (var i = 0; i < 12; i++) {
				// localeMonthString += _lyteUiUtils.i18n(this.getData('longMonthNames')[i]);
				monthNames.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
			}
		}
		else {
			for (var i = 0; i < 12; i++) {
				// localeMonthString += _lyteUiUtils.i18n(this.getData('shortMonthNames')[i]);
				monthNames.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
			}
		}
		if (this.getData('ltPropSelectionType') == "continuous") {
			this.setData('monthNames', monthNames);
		}
		if (this.getData('ltPropSelectionType') == "separate") {
			this.setData('monthNames1', monthNames);
			this.setData('monthNames2', monthNames);
		}
	}.observes('ltPropMonthHeaderFormat'),
	setCalendarHeader: function (cal, comp, viewDate) {
		var dd = 1;
		var mm = viewDate.getMonth();
		var yy = viewDate.getFullYear();
		if (this.getData('ltPropSelectionType') == "continuous") {
			if (this.getData('ltPropHeaderType') == "dropdown") {
				comp.$node.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[mm]);
				comp.$node.querySelector('.yearDD').ltProp("selected", "" + yy);
			}
			else {
				if (cal == "cal1") {
					this.setData('monthHeader1', comp.getData('monthHeader'));
				}
				if (cal == "cal2") {
					this.setData('monthHeader2', comp.getData('monthHeader'))
				}
			}
		}
		if (this.getData('ltPropSelectionType') == "separate") {
			if (this.getData('ltPropHeaderType') == "dropdown") {
				if (cal == "cal1") {
					comp.$node.querySelector('.monthDD').ltProp("selected", this.getData("monthNames1")[mm]);
				}
				if (cal == "cal2") {
					comp.$node.querySelector('.monthDD').ltProp("selected", this.getData("monthNames2")[mm]);
				}
				comp.$node.querySelector('.yearDD').ltProp("selected", "" + yy);
			}
			else {
				if (cal == "cal1") {
					this.setData('monthHeader1', comp.getData('monthHeader'));
				}
				if (cal == "cal2") {
					this.setData('monthHeader2', comp.getData('monthHeader'))
				}
			}
		}
	},
	didConnectFunc: function () {
		var cal1 = this.$node.querySelector('.dRPCalendar1');
		var cal2 = this.$node.querySelector('.dRPCalendar2');
		var currentDate = this.toDate();
		var today = this.getData("ltPropCurrentDate") ? this.stringToDate(this.getData("ltPropCurrentDate"), this.getData('ltPropFormat')) : currentDate;
		if (this.getData('ltPropSelectionType') == "continuous" && this.getData('ltPropStartDate') && this.getData('ltPropEndDate')) {
			today = this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'));
		}
		if (this.getData('ltPropSelectionType') == "separate" && this.getData('ltPropStartDate')) {
			today = this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'));
			this.restrictCalendarDates("cal2", this.getData('ltPropStartDate'), "min");
		}
		var dd = today.getDate();
		var mm = today.getMonth(); //January is 0!
		var yy = today.getFullYear();
		// this.setMonthAndYear(cal1,{dd:dd,mm:mm,yy:yy},"cal1");
		if (this.getData('ltPropSelectionType') == "continuous") {
			if (this.getData('ltPropPosition') == "right") {
				mm -= 1;
				if (mm < 0) {
					mm = 11;
					yy -= 1;
				}
				cal1.setData('selectDate', false);
				this.setMonthAndYear(cal1, { dd: 1, mm: mm, yy: yy }, "cal1");
				cal1.setData('selectDate', true);
			}
			else {
				this.setMonthAndYear(cal1, { dd: dd, mm: mm, yy: yy }, "cal1");
			}
			if (mm < 11) {
				mm += 1
			}
			else {
				mm = 0;
				yy += 1;
			}
			if (this.getData('ltPropPosition') == "right") {
				cal2.setData('selectDate', true);
				this.setMonthAndYear(cal2, { dd: dd, mm: mm, yy: yy }, "cal2");
				cal2.setData('selectDate', false);
			} else {
				this.setMonthAndYear(cal2, { dd: 1, mm: mm, yy: yy }, "cal2");
			}
			// this.setMonthAndYear(cal2,{dd:1,mm:mm,yy:yy});
			var selected = this.$node.querySelector('.lyteCalSel');
			if (selected) {
				var selectedDate = new Date(selected.dataset.date);
				if (selectedDate.toString() === "Invalid Date") {
					if (!($L.moment)) {
						console.error("INCLUDE LYTE-MOMENT PLUGIN");
						return;
					}
					selectedDate = this.moment(selected.dataset.date, this.getData('ltPropFormat').toUpperCase()).getDObj();
				}
				if (selectedDate.getMonth() === currentDate.getMonth() && selectedDate.getDate() === currentDate.getDate() && selectedDate.getFullYear() === currentDate.getFullYear()) {
					selected.classList.remove('lyteCalSel');
					selected.classList.add('lyteCalToday');
				}
			}
		}
		else if (this.getData('ltPropSelectionType') == "separate") {
			this.setMonthAndYear(cal1, { dd: dd, mm: mm, yy: yy }, "cal1");
			if (this.getData('ltPropEndDate')) {
				today = this.stringToDate(this.getData('ltPropEndDate'), this.getData('ltPropFormat'));
				this.restrictCalendarDates("cal1", this.getData('ltPropEndDate'), "max");
				var dd = today.getDate();
				var mm = today.getMonth(); //January is 0!
				var yy = today.getFullYear();
			}
			this.setMonthAndYear(cal2, { dd: dd, mm: mm, yy: yy }, "cal2");
			var selected = this.$node.querySelectorAll('.lyteCalSel');
			if (selected.length > 0) {
				var selectedDate = new Date(selected[0].dataset.date);
				if (selectedDate.toString() === "Invalid Date") {
					if (!($L.moment)) {
						console.error("INCLUDE LYTE-MOMENT PLUGIN");
						return;
					}
					selectedDate = this.moment(selected[0].dataset.date, this.getData('ltPropFormat').toUpperCase()).getDObj();
				}
				for (var i = 0; i < selected.length; i++) {
					if (selectedDate.getMonth() === currentDate.getMonth() && selectedDate.getDate() === currentDate.getDate() && selectedDate.getFullYear() === currentDate.getFullYear()) {
						selected[0].classList.remove('lyteCalSel');
						selected[0].classList.add('lyteCalToday');
					}
				}
			}
			this.validateNavigationAndDropdown();
			this.setTodayClass();
		}


		if (this.getData('ltPropDisabledDates').length > 0) {
			this.setData('convert', this.getData('convert') + 1);
		}
		if (this.getData('ltPropSelectionType') == "continuous" && this.getData('ltPropStartDate') && this.getData('ltPropEndDate')) {
			this.setData('selectedDate1', this.getData('ltPropStartDate'));
			this.setData('selectedDate2', this.getData('ltPropEndDate'));
			this.checkForSelectedDates(this.getData('ltPropStartDate'), this.getData('ltPropEndDate'));
		}
	}.observes('ltPropCurrentDate', 'ltPropMinDate', 'ltPropMaxDate', 'triggerDidconnect').on('didConnect'),
	restrictCalendarDates: function (cal, date, cond) {
		var calendar;
		if (cal == "cal1") {
			calendar = this.$node.querySelector('.dRPCalendar1');
		}
		else if (cal == "cal2") {
			calendar = this.$node.querySelector('.dRPCalendar2');
		}
		if (cond === "min") {
			calendar.ltProp('minDate', date);
			var minDate = this.stringToDate(date, this.getData('ltPropFormat'));
			this.calculateYears(cal, typeof minDate == "object" ? minDate.getFullYear() : this.getData('ltPropStartYear'), this.getData('ltPropEndYear'));
		}
		else if(cond == "max"){
			calendar.ltProp('maxDate',date);
			var maxDate = this.stringToDate(date,this.getData('ltPropFormat'));
			this.calculateYears(cal,this.getData('ltPropStartYear'),typeof maxDate == "object" ? maxDate.getFullYear() : this.getData('ltPropEndYear'));
		}
	},
	calculateYears: function (cal, start, end) {
		var year = [];
		for (var i = start; i <= end; i++) {
			year.push(i);
		}
		if (cal == "cal1") {
			this.setData('years1', year);
		}
		if (cal == "cal2") {
			this.setData('years2', year);
		}
	},
	changeStartAndEndDate: function () {
		// console.log(this.getData('internallyChanged'));
		if (this.getData('ltPropSelectionType') == "separate") {
			if (this.getData('ltPropStartDate')) {
				this.restrictCalendarDates("cal2", this.getData('ltPropStartDate'), "min");
			}
			if (this.getData('ltPropEndDate')) {
				this.restrictCalendarDates("cal1", this.getData('ltPropEndDate'), "max");
			}
			if (this.getData('ltPropStartDate')) {
				this.checkAndRemoveSelectedDateClass("start");
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar1'), this.getData('ltPropStartDate'), "start");
			}
			if (this.getData('ltPropEndDate')) {
				this.checkAndRemoveSelectedDateClass("end");
				this.checkforStartDateAndEndDate(this.$node.querySelector('.dRPCalendar2'), this.getData('ltPropEndDate'), "end");
			}
		}
		else if (this.getData('ltPropSelectionType') == "continuous") {
			if (!this.getData('internallyChanged')) {
				if (this.getData('dateSelected')) {
					this.setData('dateSelected', false);
				}
				if (this.getData('tempDate')) {
					this.setData('tempDate', '');
				}
				// if(this.getData('ltPropStartDate') === "" || this.getData('ltPropEndDate') === ""){
				this.checkAndRemoveAllSelectedClasses();
				this.removeMonthEndAndStart();
				// }
				if (this.getData('ltPropStartDate') && this.getData('ltPropEndDate')) {
					this.setData('selectedDate1', this.getData('ltPropStartDate'));
					this.setData('selectedDate2', this.getData('ltPropEndDate'));
					this.checkForSelectedDates(this.getData('ltPropStartDate'), this.getData('ltPropEndDate'));
				}
			}
			else {
				this.setData('internallyChanged', false);
			}
		}
		if (!this.getData('ltPropStartDate') && !this.getData('ltPropEndDate')) {
			this.resetDrp();
		}
	}.observes('ltPropStartDate', 'ltPropEndDate'),
	checkforStartDateAndEndDate: function (cal, date, cond) {
		var nodes = cal.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
		for (var i = 0; i < nodes.length; i++) {
			if (nodes[i].dataset.date == date) {
				if (cond == "start") {
					nodes[i].classList.add('lyteDateRPFirstDateSelected');
					this.setData('dateNode1', nodes[i]);
				}
				if (cond == "end") {
					nodes[i].classList.add('lyteDateRPLastDateSelected');
					this.setData('dateNode2', nodes[i]);
				}
				return;
			}
		}
	},
	checkAndRemoveSelectedDateClass: function (cond) {
		if (cond == "start") {
			var calendar = this.$node.querySelector('.dRPCalendar1');
			var nodes = Array.from(calendar.querySelectorAll(".lyteDateRPFirstDateSelected"));
			Lyte.arrayUtils(nodes, "push", Array.from(this.$node.querySelectorAll(".lyteCalToday")));
			Lyte.arrayUtils(nodes, "push", Array.from(this.$node.querySelectorAll(".lyteCalSel")));
			if (nodes.length > 0) {
				for (var i = 0; i < nodes.length; i++) {
					nodes[i].classList.remove("lyteDateRPFirstDateSelected", "lyteCalToday", "lyteCalSel");
				}
			}
		}
		if (cond == "end") {
			var calendar = this.$node.querySelector('.dRPCalendar2');
			var nodes = Array.from(calendar.querySelectorAll(".lyteDateRPLastDateSelected"));
			Lyte.arrayUtils(nodes, "push", Array.from(this.$node.querySelectorAll(".lyteCalToday")));
			Lyte.arrayUtils(nodes, "push", Array.from(this.$node.querySelectorAll(".lyteCalSel")));
			if (nodes.length > 0) {
				for (var i = 0; i < nodes.length; i++) {
					nodes[i].classList.remove("lyteDateRPLastDateSelected", "lyteCalToday", "lyteCalSel");
				}
			}
		}
	},

	/**
	 * The method is going to validate and change the month shown in the daterangepicker
	 *
	 */
	validateNavigation : function(){
		if(this.getData('ltPropStartYear') || this.getData('ltPropEndYear')){
			if(this.getData('ltPropSelectionType') == 'continuous'){
				if(this.getData('ltPropStartYear')){
					var date = this.getData('calViewDate1');
					var node = this.$node.querySelector('.lyteDateRangePickerCol1 .lyteDateRPLeftNav');
					if (date.getMonth() == 0 && date.getFullYear() == this.getData('ltPropStartYear')) {
						node.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node.classList.remove('lyteDateRPNavDisabled');
					}
				}
				if (this.getData('ltPropEndYear')) {
					var date = this.getData('calViewDate2');
					var node = this.$node.querySelector('.lyteDateRangePickerCol2 .lyteDateRPRightNav');
					if (date.getMonth() == 11 && date.getFullYear() == this.getData('ltPropEndYear')) {
						node.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node.classList.remove('lyteDateRPNavDisabled');
					}
				}
			}
			if (this.getData('ltPropSelectionType') == 'separate') {
				var date1 = this.getData('calViewDate1');
				var date2 = this.getData('calViewDate2');
				if (this.getData('ltPropStartYear')) {
					var node1 = this.$node.querySelector('.lyteDateRangePickerCol1 .lyteDateRPLeftNav');
					var node2 = this.$node.querySelector('.lyteDateRangePickerCol2 .lyteDateRPLeftNav');
					if (date1.getMonth() == 0 && date1.getFullYear() == this.getData('ltPropStartYear')) {
						node1.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node1.classList.remove('lyteDateRPNavDisabled');
					}
					if (date2.getMonth() == 0 && date2.getFullYear() == this.getData('ltPropStartYear')) {
						node2.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node2.classList.remove('lyteDateRPNavDisabled');
					}
				}
				if (this.getData('ltPropEndYear')) {
					var node1 = this.$node.querySelector('.lyteDateRangePickerCol1 .lyteDateRPRightNav');
					var node2 = this.$node.querySelector('.lyteDateRangePickerCol2 .lyteDateRPRightNav');
					if (date1.getMonth() == 11 && date1.getFullYear() == this.getData('ltPropEndYear')) {
						node1.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node1.classList.remove('lyteDateRPNavDisabled');
					}
					if (date2.getMonth() == 11 && date2.getFullYear() == this.getData('ltPropEndYear')) {
						node2.classList.add('lyteDateRPNavDisabled');
					}
					else {
						node2.classList.remove('lyteDateRPNavDisabled');
					}
				}
			}
		}
	},

	/**
	 * The method is going to validate and change the month shown in the daterangepicker and also change the dropdown values
	 *
	 */
	validateNavigationAndDropdown : function(){
		this.validateNavigation();
		if (this.getData('ltPropStartDate')) {
			var date1 = this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'));
			var date2 = this.getData('calViewDate2');
			var node = this.$node.querySelector('.lyteDateRangePickerCol2 .lyteDateRPLeftNav');
			if (date1.getMonth() == date2.getMonth() && date1.getFullYear() == date2.getFullYear()) {
				node.classList.add('lyteDateRPNavDisabled');
			}
			else {
				node.classList.remove('lyteDateRPNavDisabled');
			}
			if (date1.getFullYear() === date2.getFullYear()) {
				var monthNames = this.getData('monthNames2');
				var index = monthNames.indexOf(this.getData('monthNames')[date1.getMonth()]);
				if (index == -1 || index != 0) {
					this.calculateMonths('cal2', date1.getMonth());
				}
			}
			else {
				if (this.getData('monthNames2').length < 12) {
					this.setData('monthNames2', this.getData('monthNames'));
				}
			}

		}
		if (this.getData('ltPropEndDate')) {
			var date1 = this.stringToDate(this.getData('ltPropEndDate'), this.getData('ltPropFormat'));
			var date2 = this.getData('calViewDate1');
			var node = this.$node.querySelector('.lyteDateRangePickerCol1 .lyteDateRPRightNav');
			if (date1.getMonth() == date2.getMonth() && date1.getFullYear() == date2.getFullYear()) {
				node.classList.add('lyteDateRPNavDisabled');
			}
			else {
				node.classList.remove('lyteDateRPNavDisabled');
			}
			if (date1.getFullYear() === date2.getFullYear()) {
				var monthNames = this.getData('monthNames1');
				var index = monthNames.indexOf(this.getData('monthNames')[date1.getMonth()]);
				if (index == -1 || index != monthNames.length - 1) {
					this.calculateMonths('cal1', date1.getMonth());
				}
			}
			else {
				if (this.getData('monthNames1').length < 12) {
					this.setData('monthNames1', this.getData('monthNames'));
				}
			}
		}
	},
	calculateMonths: function (cal, limit) {
		if (cal == "cal1") {
			var monthNames = this.getData('monthNames');
			this.setData('monthNames1', monthNames.slice(0, limit + 1));
		}
		if (cal == "cal2") {
			var monthNames = this.getData('monthNames');
			this.setData('monthNames2', monthNames.slice(limit));
		}
	},
	setMonthAndYear: function (cal, date, view) {
		cal.ltProp("currentDate", this.constructDateString(date.mm + 1, date.dd, date.yy));
		cal.setData('currentDatechanged', cal.getData('currentDatechanged') + 1);
		if (this.getData('ltPropSelectionType') == "separate") {
			if (view == "cal1" && this.getData('monthNames1').indexOf(this.getData("monthNames")[date.mm]) == -1) {
				this.setData("monthNames1", this.getData('monthNames'));
			}
			if (view == "cal2" && this.getData('monthNames2').indexOf(this.getData("monthNames")[date.mm]) == -1) {
				this.setData("monthNames2", this.getData('monthNames'));
			}
		}
		if (this.getData('ltPropHeaderType') == "dropdown") {
			cal.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[date.mm]);
			cal.querySelector('.yearDD').ltProp("selected", "" + date.yy);
		}
		else {
			if (cal.classList.contains('dRPCalendar1')) {
				this.setData('monthHeader1', cal.getData('monthHeader'));
			}
			if (cal.classList.contains('dRPCalendar2')) {
				this.setData('monthHeader2', cal.getData('monthHeader'));
			}
		}
		if (view == "cal1") {
			this.setData('calViewDate1', cal.getData('viewDate'));
		}
		else {
			this.setData('calViewDate2', cal.getData('viewDate'));
		}
	},
	selectDates: function (targetDate) {
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
		var initNode = this.getData('dateNode1');
		var target = this.getData('dateNode2');
		var date1 = Date.parse(this.stringToDate(this.getData('selectedDate1'), this.getData('ltPropFormat')) /*this.getData('selectedDate1')*/);
		var date2 = Date.parse(this.stringToDate(targetDate, this.getData('ltPropFormat')) /*targetDate*/);
		var node1 = this.$node.querySelector('.lyteDateRPTempFirstDateSelected');
		var node2 = this.$node.querySelector('.lyteDateRPTempLastDateSelected');
		if (node1) {
			node1.classList.remove('lyteDateRPTempFirstDateSelected');
		}
		if (node2) {
			node2.classList.remove('lyteDateRPTempLastDateSelected');
		}
		this.removeMonthEndAndStart();
		if (date1 < date2) {
			for (var i = 0; i < nodes.length; i++) {
				var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
				if (date >= date1 && date <= date2) {
					if (nodes[i].classList.contains("lyteCalDisabled")) {
						this.checkForBeforeAndAfter(nodes, i, date1, date2);
					}
					else {
						if (date == date1) {
							initNode.classList.add('lyteDateRPTempFirstDateSelected');
						}
						else if (date == date2) {
							target.classList.add('lyteDateRPTempLastDateSelected');
						}
						else {
							if (!nodes[i].classList.contains("lyteDateRPTempSelected")) {
								nodes[i].classList.add("lyteDateRPTempSelected");
							}
						}
						this.checkForMonthEndAndStart(nodes, i, this.getData('selectedDate1'), targetDate);
					}
				}
				else {
					if (nodes[i].classList.contains("lyteDateRPTempSelected") || nodes[i].classList.contains("lyteCalSel")) {
						nodes[i].classList.remove("lyteDateRPTempSelected", 'lyteCalSel');
					}
				}
			}
		}
		else if (date1 > date2) {
			for (var i = 0; i < nodes.length; i++) {
				var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
				if (date >= date2 && date <= date1) {
					if (nodes[i].classList.contains("lyteCalDisabled")) {
						this.checkForBeforeAndAfter(nodes, i, date2, date1);
					}
					else {
						if (date == date2) {
							target.classList.add('lyteDateRPTempFirstDateSelected');
						}
						else if (date == date1) {
							initNode.classList.add('lyteDateRPTempLastDateSelected');
						}
						else {
							if (!nodes[i].classList.contains("lyteDateRPTempSelected")) {
								nodes[i].classList.add("lyteDateRPTempSelected");
							}
						}
						this.checkForMonthEndAndStart(nodes, i, targetDate, this.getData('selectedDate1'));
					}
				}
				else {
					if (nodes[i].classList.contains("lyteDateRPTempSelected") || nodes[i].classList.contains("lyteCalSel")) {
						nodes[i].classList.remove("lyteDateRPTempSelected", "lyteCalSel");
					}
				}
			}
		}
		else {
			this.checkAndRemoveAllSelectedClasses();
			this.setData('selectedDate1', targetDate)
			target.classList.add('lyteDateRPTempFirstDateSelected', 'lyteDateRPTempLastDateSelected');
			this.checkForMonthEndAndStart(nodes, Array.from(nodes).indexOf(target), targetDate, this.getData('selectedDate1'));
		}
		this.setData("tempDate", targetDate);

	},
	checkAndMarkDisabledDates: function () {
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
		if (nodes.length == 0) {
			return
		}
		var date;
		for (var j = 0; j < nodes.length; j++) {
			date = nodes[j].dataset.date;
			if (this.checkForDisabledDates(date)) {
				nodes[j].classList.add("lyteCalDisabled");
			}
		}
	},
	checkForDisabledDates: function (date) {
		var disabledDates = this.getData('ltPropDisabledDates');
		for (var i = 0; i < disabledDates.length; i++) {
			if (new RegExp(disabledDates[i]).test(date)) {
				return true;
			}
		}
		return false;
	},
	checkForBeforeAndAfter: function (nodes, pos, startDate, endDate) {
		if (pos > 0 && pos < nodes.length - 1) {
			var date1 = Date.parse(this.stringToDate(nodes[pos - 1].dataset.date, this.getData('ltPropFormat')) /*nodes[pos-1].dataset.date*/);
			var date2 = Date.parse(this.stringToDate(nodes[pos + 1].dataset.date, this.getData('ltPropFormat')) /*nodes[pos+1].dataset.date*/);
			if (date1 >= startDate && date1 <= endDate) {
				nodes[pos - 1].classList.add('lyteDateRPInterimEndDate');
			}
			if (date2 >= startDate && date2 <= endDate) {
				nodes[pos + 1].classList.add('lyteDateRPInterimStartDate');
			}
		}
	},
	checkAndRemoveAllSelectedClasses: function () {
		var nodes = Array.from(this.$node.querySelectorAll(".lyteDateRPFirstDateSelected"));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteDateRPLastDateSelected"))));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteDateRPTempLastDateSelected"))));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteDateRPTempFirstDateSelected"))));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteDateRPTempSelected"))));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteCalSel"))));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteCalToday"))));
		for (var i = 0; i < nodes.length; i++) {
			nodes[i].classList.remove("lyteDateRPFirstDateSelected", "lyteDateRPTempSelected", "lyteDateRPLastDateSelected", "lyteDateRPTempFirstDateSelected", "lyteDateRPTempLastDateSelected", "lyteCalSel", "lyteCalToday");
		}
		this.setData("selectedDate1", "");
		this.setData("selectedDate2", "");
	},
	checkForMonthEndAndStart: function (nodes, pos, startDate, endDate) {
		var allNodes = this.$node.querySelectorAll('.lyteCalCdate');
		var lastNode = allNodes[allNodes.length - 1];
		if (/*nodes[pos].innerText === "1"*/ this.isFirstDayOfTheMonth(nodes[pos]) && Date.parse(this.stringToDate(nodes[pos].dataset.date, this.getData('ltPropFormat')) /*nodes[pos].dataset.date*/) >= Date.parse(this.stringToDate(startDate, this.getData('ltPropFormat')) /*startDate*/) && Date.parse(this.stringToDate(nodes[pos].dataset.date, this.getData('ltPropFormat')) /*nodes[pos].dataset.date*/) <= Date.parse(this.stringToDate(endDate, this.getData('ltPropFormat')) /*endDate*/)) {
			nodes[pos].classList.remove('lyteDateRPTempSelected');
			nodes[pos].classList.add('lyteDateRPMonthStartDate');
		}
		else if (/*(pos + 1 < nodes.length && nodes[pos + 1].innerText === "1" && Date.parse(this.stringToDate(nodes[pos + 1].dataset.date, this.getData('ltPropFormat'))) >= Date.parse(this.stringToDate(startDate, this.getData('ltPropFormat'))) &&  Date.parse(this.stringToDate(nodes[pos].dataset.date, this.getData('ltPropFormat'))) <= Date.parse(this.stringToDate(endDate, this.getData('ltPropFormat')))) || */
			(/*pos == nodes.length - 1 && nodes[pos].isEqualNode(lastNode)*/ this.isLastDayOfTheMonth(nodes[pos]) && Date.parse(this.stringToDate(nodes[pos].dataset.date, this.getData('ltPropFormat')) /*nodes[pos].dataset.date*/) >= Date.parse(this.stringToDate(startDate, this.getData('ltPropFormat')) /*startDate*/) && Date.parse(this.stringToDate(nodes[pos].dataset.date, this.getData('ltPropFormat')) /*nodes[pos].dataset.date*/) <= Date.parse(this.stringToDate(endDate, this.getData('ltPropFormat')) /*endDate*/))) {
			nodes[pos].classList.remove('lyteDateRPTempSelected');
			nodes[pos].classList.add('lyteDateRPMonthEndDate');
		}
	},
	isFirstDayOfTheMonth: function (node) {
		return node.innerText.trim() === "1";
	},
	isLastDayOfTheMonth: function (node) {
		var calendar = node.closest('lyte-calendar');
		var viewDate = calendar.getData('viewDate');
		var month_31 = [0, 2, 4, 6, 7, 9, 11];
		var month_30 = [3, 5, 8, 10];
		if (month_31.indexOf(viewDate.getMonth()) != -1) {
			return node.innerText.trim() === "31";
		}
		else if (month_30.indexOf(viewDate.getMonth()) != -1) {
			return node.innerText.trim() === "30";
		}
		else {
			var year = viewDate.getFullYear();
			if (this.isLeapYear(year)) {
				return node.innerText.trim() === "29";
			}
			else {
				return node.innerText.trim() === "28";
			}
		}
	},
	isLeapYear: function (year) {
		return year % 100 === 0 ? year % 400 === 0 : year % 4 === 0;
	},
	removeMonthEndAndStart: function () {
		var nodes = Array.from(this.$node.querySelectorAll('.lyteDateRPMonthStartDate'));
		Lyte.arrayUtils(nodes, "push", (Array.from(this.$node.querySelectorAll(".lyteDateRPMonthEndDate"))));
		for (var i = 0; i < nodes.length; i++) {
			nodes[i].classList.remove("lyteDateRPMonthStartDate", "lyteDateRPMonthEndDate");
		}
	},
	executeSelected: function (event) {
		if (this.getMethods('onDateSelected')) {
			var date1 = Date.parse(this.stringToDate(this.getData('selectedDate1'), this.getData('ltPropFormat')) /*this.getData('selectedDate1')*/);
			var date2 = Date.parse(this.stringToDate(this.getData('selectedDate2'), this.getData('ltPropFormat')) /*this.getData('selectedDate2')*/);
			if (date1 <= date2) {
				if (this.getData('ltPropSelectionType') == "continuous") {
					this.setData('internallyChanged', true);
					this.setData('ltPropStartDate', this.getData('selectedDate1'));
					this.setData('internallyChanged', true);
					this.setData('ltPropEndDate', this.getData('selectedDate2'));
				}
				this.executeMethod('onDateSelected', event, this.getData('selectedDate1'), this.getData('selectedDate2'), this);
			}
			else {
				if (this.getData('ltPropSelectionType') == "continuous") {
					this.setData('internallyChanged', true);
					this.setData('ltPropStartDate', this.getData('selectedDate2'));
					this.setData('internallyChanged', true);
					this.setData('ltPropEndDate', this.getData('selectedDate1'));
				}
				this.executeMethod('onDateSelected', event, this.getData('selectedDate2'), this.getData('selectedDate1'), this);
			}
		}
	},
	checkForSelectedDates: function (startDate, endDate) {
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
		if (startDate && endDate) {
			var date1 = Date.parse(this.stringToDate(startDate, this.getData('ltPropFormat')) /*startDate*/);
			var date2 = Date.parse(this.stringToDate(endDate, this.getData('ltPropFormat')) /*endDate*/);
			for (var i = 0; i < nodes.length; i++) {
				var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
				if (date >= date1 && date <= date2) {
					if (nodes[i].classList.contains('lyteCalDisabled')) {
						this.checkForBeforeAndAfter(nodes, i, date1, date2);
					}
					else {
						if (date == date1) {
							nodes[i].classList.add('lyteDateRPFirstDateSelected');
						}
						if (date == date2) {
							nodes[i].classList.add('lyteDateRPLastDateSelected');
						}
						if (date !== date1 && date !== date2) {
							nodes[i].classList.add('lyteDateRPTempSelected');
						}
						this.checkForMonthEndAndStart(nodes, i, startDate, endDate);
					}
				}
			}
		}
		else {
			if (this.getData('ltPropDisabledDates').length > 0) {
				this.checkAndMarkDisabledDates();
			}
			var date1 = this.getData("selectedDate1");
			var date2 = this.getData("selectedDate2");
			var date3 = this.getData("tempDate");
			if (date1 && date2) {
				// this.removeMonthEndAndStart();
				date1 = Date.parse(this.stringToDate(date1, this.getData('ltPropFormat')) /*date1*/);
				date2 = Date.parse(this.stringToDate(date2, this.getData('ltPropFormat')) /*date2*/);
				if (date1 < date2) {
					for (var i = 0; i < nodes.length; i++) {
						var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
						if (date >= date1 && date <= date2) {
							if (nodes[i].classList.contains('lyteCalDisabled')) {
								this.checkForBeforeAndAfter(nodes, i, date1, date2);
							}
							else {
								if (date == date1) {
									nodes[i].classList.add('lyteDateRPFirstDateSelected');
								}
								if (date == date2) {
									nodes[i].classList.add('lyteDateRPLastDateSelected');
								}
								if (date !== date1 && date !== date2) {
									nodes[i].classList.add('lyteDateRPTempSelected');
								}
								this.checkForMonthEndAndStart(nodes, i, this.getData("selectedDate1"), this.getData("selectedDate2"));
							}
						}
					}
				}
				else {
					for (var i = 0; i < nodes.length; i++) {
						var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
						if (date >= date2 && date <= date1) {
							if (nodes[i].classList.contains('lyteCalDisabled')) {
								this.checkForBeforeAndAfter(nodes, i, date2, date1);
							}
							else {
								if (date == date2) {
									nodes[i].classList.add('lyteDateRPFirstDateSelected');
								}
								if (date == date1) {
									nodes[i].classList.add('lyteDateRPLastDateSelected');
								}
								if (date !== date1 && date !== date2) {
									nodes[i].classList.add('lyteDateRPTempSelected');
								}
								this.checkForMonthEndAndStart(nodes, i, this.getData("selectedDate2"), this.getData("selectedDate1"));
							}
						}
					}
				}
			}
			else if (date1 && date3) {
				date1 = Date.parse(this.stringToDate(date1, this.getData('ltPropFormat')) /*date1*/);
				date3 = Date.parse(this.stringToDate(date3, this.getData('ltPropFormat')) /*date3*/);
				if (date1 < date3) {
					for (var i = 0; i < nodes.length; i++) {
						var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
						if (nodes[i].classList.contains('lyteCalDisabled')) {
							this.checkForBeforeAndAfter(nodes, i, date1, date3);
						}
						else {
							if (date1 <= date3 && date == date1) {
								nodes[i].classList.add('lyteDateRPTempFirstDateSelected');
							}
							else if (date == date3) {
								nodes[i].classList.add('lyteDateRPTempLastDateSelected');
							}
							else if (date > date1 && date < date3) {
								nodes[i].classList.add('lyteDateRPTempSelected');
							}
						}
					}
				}
				else {
					for (var i = 0; i < nodes.length; i++) {
						var date = Date.parse(this.stringToDate(nodes[i].dataset.date, this.getData('ltPropFormat')) /*nodes[i].dataset.date*/);
						if (nodes[i].classList.contains('lyteCalDisabled')) {
							this.checkForBeforeAndAfter(nodes, i, date3, date1);
						}
						else {
							if (date3 <= date1 && date == date1) {
								nodes[i].classList.add('lyteDateRPTempFirstDateSelected');
							}
							else if (date == date1) {
								nodes[i].classList.add('lyteDateRPTempLastDateSelected');
							}
							else if (date >= date2 && date < date1) {
								nodes[i].classList.add('lyteDateRPTempSelected');
							}
						}
					}
				}
			}
		}
	},
	callOnNavigate : function(event,fromMonths,toMonths,comp,cal){
		this.setTodayClass();
		if(this.getMethods('onNavigation')){
			this.executeMethod('onNavigation',event,fromMonths,toMonths,this,cal);
		}
	},

	/** 
	 * get proper month from user defined value
	 * @param {String} mon - The current month
	 *
	 */

	getProperMonth: function (val) {
		var sm = {
			'jan': 1,
			'feb': 2,
			'mar': 3,
			'apr': 4,
			'may': 5,
			'jun': 6,
			'jul': 7,
			'aug': 8,
			'sep': 9,
			'oct': 10,
			'nov': 11,
			'dec': 12
		}, lg = {
			'january': 1,
			'february': 2,
			'march': 3,
			'april': 4,
			'may': 5,
			'june': 6,
			'july': 7,
			'august': 8,
			'september': 9,
			'october': 10,
			'november': 11,
			'december': 12
		}, ret

		val = val.toLowerCase();
		ret = sm[val] || lg[val];

		if (!ret && ret !== 0) {
			return parseFloat(val) - 1;
		}

		return ret - 1;
	},

	/**
	 * Convert the string to date object based on the format
	 * @param {String} cur - The current date of the user passed
	 * @param {String} format - The format of the dates
	 *
	 */

	stringToDate: function (cur, format) {

		try {
			var vals = cur.match(/([\da-z]+)/ig),
				format = format.toUpperCase(),
				sep = format.match(/([a-z]+)/ig),
				date = this.toDate(), i = 0, order = ['Y', 'M', 'D'];
			date.setDate(1);  //initialize the day to be 1 to avoid error for eg: 30 Feb if passed will generate 1 Mar as result.

			if (vals.length !== 3) {
				return 'Invalid Date';
			}

			while (i < sep.length) {
				var ind = this.getOrderIndex(sep, order[i]);
				if (i == 0) {
					date.setFullYear(vals[ind]);
				}
				else if (i == 1) {
					date.setMonth(this.getProperMonth(vals[ind]));
				}
				else if (i == 2) {
					date.setDate(vals[ind]);
				}

				if (date.toString() === 'Invalid Date') {
					return date.toString();
				}
				i++;
			}

			return date;
		}
		catch (e) {
			return 'Invalid Date';
		}


	},

	getOrderIndex: function (objArr, match) {
		for (var i = 0; i < objArr.length; i++) {
			if (objArr[i].charAt(0) === match) {
				return i;
			}
		}
		return -1;
	},

	/**
	 * The method is going to return the date as string based on the format
	 * @param {number} mm - month value
	 * @param {number} dd - day value
	 * @param {number} yy - year value
	 *
	 */
	constructDateString : function (mm,dd,yy) {
		var format = this.getData('ltPropFormat'),
			formatArr,
			date = '',
			sep;
		if ($L.moment) {
			var dateObj = new Date(mm + "/" + dd + "/" + yy);
			date = this.moment(dateObj).format(format.toUpperCase());
			return date;
		}
		if (format.indexOf('/') == -1) {
			if (!($L.moment)) {
				console.error("INCLUDE LYTE-MOMENT PLUGIN");
				return;
			}
			var dateObj = new Date(mm + "/" + dd + "/" + yy);
			date = this.moment(dateObj).format(format.toUpperCase());
			return date;
		}
		else {
			formatArr = format.split("/");
			sep = '/';
		}
		// if(format.indexOf('/') != -1){
		// 	formatArr = format.split("/"); 
		// 	sep = '/';
		// }
		if (formatArr.length != 3) {
			return "Invalid Format";
		}
		for (var i = 0; i < 3; i++) {
			if (formatArr[i].toUpperCase().charAt(0) === "M") {
				date += mm;
				if (i != 2) {
					date += sep;
				}
			}
			else if (formatArr[i].toUpperCase().charAt(0) === "D") {
				date += dd;
				if (i != 2) {
					date += sep;
				}
			}
			else if (formatArr[i].toUpperCase().charAt(0) === "Y") {
				date += yy;
				if (i != 2) {
					date += sep;
				}
			}
		}
		return date;
	},

	actions: {
		previous: function (opt, event) {
			var calendar = this.$node.querySelector('.dRPCalendar1');
			var fromMonths = {
				"date1": this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
				"date2": this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()
			};
			calendar.setData('selectDate', false);
			var dd = 1;
			var mm;
			var yy;
			if (opt == 'M') {
				mm = calendar.getData('viewDate').getMonth() - 1;
			}
			else {
				mm = calendar.getData('viewDate').getMonth();
			}
			if (opt == 'Y') {
				yy = calendar.getData('viewDate').getFullYear() - 1;
			}
			else {
				yy = calendar.getData('viewDate').getFullYear();
			}
			if (mm == -1) {
				mm = 11;
				yy -= 1;
			}
			if (yy < this.getData("ltPropStartYear")) {
				return;
			}
			this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal1");
			if (mm < 11) {
				mm += 1;
			}
			else {
				mm = 0;
				yy += 1;
			}
			this.setMonthAndYear(this.$node.querySelector('.dRPCalendar2'), { dd: dd, mm: mm, yy: yy }, "cal2");
			this.checkForSelectedDates();
			var toMonths = {
				"date1": this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
				"date2": this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()
			};
			this.validateNavigation();
			this.callOnNavigate(event, fromMonths, toMonths, this);
		},
		next: function (opt, event) {
			var calendar = this.$node.querySelector('.dRPCalendar2');
			calendar.setData('selectDate', false);
			var fromMonths = {
				"date1": this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
				"date2": this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()
			};
			var dd = 1;
			var mm;
			var yy;
			if (opt == 'M') {
				mm = calendar.getData('viewDate').getMonth() + 1;
			}
			else {
				mm = calendar.getData('viewDate').getMonth();
			}
			if (opt == 'Y') {
				yy = calendar.getData('viewDate').getFullYear() + 1;
			}
			else {
				yy = calendar.getData('viewDate').getFullYear();
			}
			if (mm == 12) {
				mm = 0;
				yy += 1;
			}
			if (yy > this.getData('ltPropEndYear')) {
				return;
			}
			this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal2");
			if (mm > 0) {
				mm -= 1;
			}
			else {
				mm = 11;
				yy -= 1;
			}
			this.$node.querySelector('.dRPCalendar1').setData('selectDate', false);
			this.setMonthAndYear(this.$node.querySelector('.dRPCalendar1'), { dd: dd, mm: mm, yy: yy }, "cal1");
			this.checkForSelectedDates();
			var toMonths = {
				"date1": this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
				"date2": this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()
			};
			this.validateNavigation();
			this.callOnNavigate(event, fromMonths, toMonths, this);
		},
		mouseDown: function (event) {
			var target = event.target;
			while (target.parentElement) {
				if (target.classList.contains('lyteCalCdate')) {
					break;
				}
				target = target.parentElement;
			}
			if (target.tagName === "HTML") {
				return;
			}
			var clickCount = this.getData('clickCount');
		 	clickCount++;
		 	this.setData('clickCount',clickCount);
		 	var self = this;
		    if (clickCount === 1) {
		        this.singleClickTimer = setTimeout(function() {
		            clickCount = 0;
		            self.setData('clickCount',clickCount);
		            delete this.singleClickTimer;
		        }, 400);
		    } else if (clickCount === 2) {
		        clearTimeout(this.singleClickTimer);
		        if(this.singleClickTimer){
		        	delete this.singleClickTimer;
		        }
		        clickCount = 0;
		        this.setData('clickCount',clickCount);
		        // var target = event.target;
		        if(target.classList.contains("lyteCalCdate")){
					if(!target.classList.contains("lyteCalDiffMonth")){
						this.checkAndRemoveAllSelectedClasses();
						this.removeMonthEndAndStart();
						this.setData('dateNode1', target);
						this.setData('dateNode2', target);
						target.classList.add('lyteDateRPFirstDateSelected', 'lyteDateRPLastDateSelected');
						var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
						this.checkForMonthEndAndStart(nodes, Array.from(nodes).indexOf(target), target.dataset.date, target.dataset.date);
						this.setData('selectedDate1', target.dataset.date);
						this.setData('selectedDate2', target.dataset.date);
						this.setData('dateSelected', false);
						this.executeSelected(event);
					}
				}
				return;
			}

			if (target.classList.contains("lyteCalCdate")) {
				if (!target.classList.contains("lyteCalDiffMonth")) {
					if (!this.getData('dateSelected')) {
						// if(this.getMethods('firstSelection')){
						// 	this.executeMethod('firstSelection',event,this);
						// }
						this.checkAndRemoveAllSelectedClasses();
						this.removeMonthEndAndStart();
						this.setData('dateNode1', target);
						target.classList.add("lyteDateRPTempFirstDateSelected");
						target.classList.add("lyteDateRPTempLastDateSelected");
						var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalDiffMonth)');
						this.checkForMonthEndAndStart(nodes, Array.from(nodes).indexOf(target), target.dataset.date, target.dataset.date);
						this.setData('selectedDate1', target.dataset.date);
						this.setData('dateSelected', true);
					}
					else {
						// if(this.getMethods('secondSelection')){
						// 	this.executeMethod('secondSelection',event,this);
						// }
						if (target.classList.contains('lyteDateRPTempSelected')) {
							target.classList.remove('lyteDateRPTempSelected');
						}
						var date1 = Date.parse(this.stringToDate(this.getData('selectedDate1'), this.getData('ltPropFormat')) /*this.getData('selectedDate1')*/);
						var date2 = Date.parse(this.stringToDate(target.dataset.date, this.getData('ltPropFormat')) /*target.dataset.date*/);
						if (date1 <= date2) {
							this.getData('dateNode1').classList.remove('lyteDateRPTempFirstDateSelected');
							this.getData('dateNode1').classList.add('lyteDateRPFirstDateSelected');
							this.getData('dateNode2').classList.remove('lyteDateRPTempLastDateSelected');
							this.getData('dateNode2').classList.add('lyteDateRPLastDateSelected');
						}
						else {
							this.getData('dateNode1').classList.remove('lyteDateRPTempLastDateSelected');
							this.getData('dateNode1').classList.add('lyteDateRPLastDateSelected');
							this.getData('dateNode2').classList.remove('lyteDateRPTempFirstDateSelected');
							this.getData('dateNode2').classList.add('lyteDateRPFirstDateSelected');
						}
						this.setData('selectedDate2', target.dataset.date);
						this.setData('tempDate', "");
						this.setData('dateSelected', false);
						this.executeSelected(event);
					}
				}
			}
		},
		mouseOver: function (event) {
			if (this.getData("dateSelected")) {
				var target = event.target;
				while (target.parentElement) {
					if (target.classList.contains('lyteCalCdate')) {
						break;
					}
					target = target.parentElement;
				}
				if (target.tagName === "HTML") {
					return;
				}
				if (target.classList.contains("lyteCalCdate")) {
					if (!target.classList.contains("lyteCalDiffMonth")) {
						this.setData('dateNode2', target);
						this.selectDates(target.dataset.date);
					}
				}
			}
		},
		separateMouseDown: function (event) {
			var target = event.target;
			while (target.parentElement) {
				if (target.classList.contains('lyteCalCdate')) {
					break;
				}
				target = target.parentElement;
			}
			if (target.tagName === "HTML") {
				return;
			}
			if (target.classList.contains("lyteCalCdate")) {
				if (!target.classList.contains("lyteCalDiffMonth")) {
					var calendar = target.closest('lyte-calendar');
					if (calendar.classList.contains('dRPCalendar1')) {
						this.setData('selectedDate1', target.dataset.date);
						this.setData('ltPropStartDate', target.dataset.date);
						var date1 = this.getData('calViewDate1');
						var date2 = this.getData('calViewDate2');
						if ((date1.getMonth() > date2.getMonth() && date1.getFullYear() == date2.getFullYear()) || (date1.getFullYear() > date2.getFullYear())) {
							var cal2 = this.$node.querySelector('.dRPCalendar2');
							var mm = this.getData('calViewDate1').getMonth(); //January is 0!
							var yy = this.getData('calViewDate1').getFullYear();
							this.setMonthAndYear(cal2, { dd: 1, mm: mm, yy: yy }, "cal2");
							if (this.getData('ltPropEndDate')) {
								this.checkforStartDateAndEndDate(cal2, this.getData('ltPropEndDate'), "end");
							}
						}
					}
					else if (calendar.classList.contains('dRPCalendar2')) {
						this.setData('selectedDate2', target.dataset.date);
						this.setData('ltPropEndDate', target.dataset.date);
						var date1 = this.getData('calViewDate1');
						var date2 = this.getData('calViewDate2');
						if ((date2.getMonth() < date1.getMonth() && date2.getFullYear() == date1.getFullYear()) || (date2.getFullYear() < date1.getFullYear())) {
							var cal1 = this.$node.querySelector('.dRPCalendar1');
							var mm = this.getData('calViewDate2').getMonth(); //January is 0!
							var yy = this.getData('calViewDate2').getFullYear();
							this.setMonthAndYear(cal1, { dd: 1, mm: mm, yy: yy }, "cal1");
							if (this.getData('ltPropStartDate')) {
								this.checkforStartDateAndEndDate(cal1, this.getData('ltPropStartDate'), "start");
							}
						}
					}
					this.validateNavigationAndDropdown();
					if (this.getData('dateNode1') && this.getData('dateNode2')) {
						this.executeSelected(event);
					}
				}
			}
		},
		separatePrevious: function (opt, cal, event) {
			var calendar, fromMonths, toMonths;
			if (cal == 'cal1') {
				calendar = this.$node.querySelector('.dRPCalendar1');
				fromMonths = this.getData('monthNames1')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear();
			}
			else if (cal == 'cal2') {
				calendar = this.$node.querySelector('.dRPCalendar2');
				fromMonths = this.getData('monthNames2')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear();
			}
			if (calendar) {
				calendar.setData('selectDate', false);
				var dd = 1;
				var mm;
				var yy;
				if (opt == 'M') {
					mm = calendar.getData('viewDate').getMonth() - 1;
				}
				else {
					mm = calendar.getData('viewDate').getMonth();
				}
				if (opt == 'Y') {
					yy = calendar.getData('viewDate').getFullYear() - 1;
				}
				else {
					yy = calendar.getData('viewDate').getFullYear();
				}
				if (mm == -1) {
					mm = 11;
					yy -= 1;
				}
				if (yy < this.getData("ltPropStartYear")) {
					return;
				}
				this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, cal);
				if (cal == 'cal1') {
					if (this.getData('ltPropStartDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropStartDate'), "start");
					}
					toMonths = this.getData('monthNames1')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear();
				}
				else if (cal == 'cal2') {
					if (this.getData('ltPropEndDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropEndDate'), "end");
					}
					toMonths = this.getData('monthNames2')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear();
				}
				this.validateNavigationAndDropdown();
				this.callOnNavigate(event, fromMonths, toMonths, this, cal == "cal1" ? "from Calendar" : "to Calendar");
			}
		},
		separateNext: function (opt, cal, event) {
			var calendar, fromMonths, toMonths;
			if (cal == 'cal1') {
				calendar = this.$node.querySelector('.dRPCalendar1');
				fromMonths = this.getData('monthNames1')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear();
			}
			else if (cal == 'cal2') {
				calendar = this.$node.querySelector('.dRPCalendar2');
				fromMonths = this.getData('monthNames2')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear();
			}
			if (calendar) {
				calendar.setData('selectDate', false);
				var dd = 1;
				var mm;
				var yy;
				if (opt == 'M') {
					mm = calendar.getData('viewDate').getMonth() + 1;
				}
				else {
					mm = calendar.getData('viewDate').getMonth();
				}
				if (opt == 'Y') {
					yy = calendar.getData('viewDate').getFullYear() + 1;
				}
				else {
					yy = calendar.getData('viewDate').getFullYear();
				}
				if (mm == 12) {
					mm = 0;
					yy += 1;
				}
				if (yy > this.getData('ltPropEndYear')) {
					return;
				}
				this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, cal);
				if (cal == 'cal1') {
					if (this.getData('ltPropStartDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropStartDate'), "start");
					}
					toMonths = this.getData('monthNames1')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear();
				}
				else if (cal == 'cal2') {
					if (this.getData('ltPropEndDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropEndDate'), "end");
					}
					toMonths = this.getData('monthNames2')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear();
				}
				this.validateNavigationAndDropdown();
				this.callOnNavigate(event, fromMonths, toMonths, this, cal == "cal1" ? "from Calendar" : "to Calendar");
			}
		}
	},

	start_obs : function( arg ){	
		var cb = 'onStartDateChanged';

		if( this.getMethods( cb ) ){
		   /**
	        * @method onStartDateChanged
	        * @version 3.29.0
	        */
			this.executeMethod( cb, arg, this );
		}

	}.observes( 'selectedDate1' ),

	methods: {
		addDropdownClass: function (ev, comp) {
			var body = comp.childComp;
			body.classList.add('lyteCalendarDropdown');
		},
		editArrowPosition: function (ev, comp) {
			var arrow = comp.childComp.querySelector('.lyteArrow');
			if (_lyteUiUtils.getRTL()) {
				arrow.style.right = "20%";
				arrow.style.left = "auto";
			} else {
				arrow.style.left = "20%";
				arrow.style.right = "auto";
			}
		},
		optionSelected: function (cal, opt, event, selected, comp) {
			if (this.getData('ltPropSelectionType') == "separate") {
				if (cal == "cal1") {
					var calendar = this.$node.querySelector('.dRPCalendar1');
					calendar.setData('selectDate', false);
					var dd = 1;
					var mm;
					var yy;
					if (opt == 'M') {
						mm = this.getData('monthNames').indexOf(selected);
					}
					else {
						mm = calendar.getData('viewDate').getMonth();
					}
					if (opt == 'Y') {
						yy = parseInt(selected);
					}
					else {
						yy = calendar.getData('viewDate').getFullYear();
					}
					if (this.getData('ltPropEndDate')) {
						var date = this.stringToDate(this.getData('ltPropEndDate'), this.getData('ltPropFormat'));
						if (mm > date.getMonth() && yy >= date.getFullYear()) {
							if (opt == 'M') {
								calendar.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
							}
							if (opt == 'Y') {
								calendar.querySelector('.yearDD').ltProp("selected", "" + calendar.getData('viewDate').getFullYear());
							}
							return;
						}
					}
					this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal1");
					if (this.getData('ltPropStartDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropStartDate'), "start");
					}
				}
				else if (cal == "cal2") {
					var calendar = this.$node.querySelector('.dRPCalendar2');
					calendar.setData('selectDate', false);
					var dd = 1;
					var mm;
					var yy;
					if (opt == 'M') {
						mm = this.getData('monthNames').indexOf(selected);
					}
					else {
						mm = calendar.getData('viewDate').getMonth();
					}
					if (opt == 'Y') {
						yy = selected;
					}
					else {
						yy = calendar.getData('viewDate').getFullYear();
					}
					if (this.getData('ltPropStartDate')) {
						var date = this.stringToDate(this.getData('ltPropStartDate'), this.getData('ltPropFormat'));
						if (mm < date.getMonth() && yy <= date.getFullYear()) {
							if (opt == 'M') {
								calendar.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
							}
							if (opt == 'Y') {
								calendar.querySelector('.yearDD').ltProp("selected", "" + calendar.getData('viewDate').getFullYear());
							}
							return;
						}
					}
					this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal2");
					if (this.getData('ltPropEndDate')) {
						this.checkforStartDateAndEndDate(calendar, this.getData('ltPropEndDate'), "end");
					}
				}
				this.validateNavigationAndDropdown();
			}
			// if(this.getMethods('ddOptionSelected')){
			// 	this.executeMethod('ddOptionSelected',event,selected,comp,cal,opt,this);
			// }
			if (this.getData('ltPropSelectionType') == "continuous") {
				if (cal == "cal1") {
					var calendar = this.$node.querySelector('.dRPCalendar1');
					calendar.setData('selectDate', false);
					var dd = 1;
					var mm;
					var yy;
					if (opt == 'M') {
						mm = this.getData('monthNames').indexOf(selected);
					}
					else {
						mm = calendar.getData('viewDate').getMonth();
					}
					if (opt == 'Y') {
						yy = parseInt(selected);
					}
					else {
						yy = calendar.getData('viewDate').getFullYear();
					}
					if (mm > 10 && yy == this.getData('ltPropEndYear')) {
						if (selected == _lyteUiUtils.i18n('Dec') || selected == _lyteUiUtils.i18n('December')) {
							calendar.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
						}
						else {
							calendar.querySelector('.yearDD').ltProp("selected", "" + calendar.getData('viewDate').getFullYear());
						}
						// console.log("returning "+mm+" "+yy);
						return;
					}
					this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal1");
					if (mm < 11) {
						mm += 1;
					}
					else {
						mm = 0;
						yy += 1;
					}
					this.setMonthAndYear(this.$node.querySelector('.dRPCalendar2'), { dd: dd, mm: mm, yy: yy }, "cal2");
				}
				else if (cal == "cal2") {
					var calendar = this.$node.querySelector('.dRPCalendar2');
					calendar.setData('selectDate', false);
					var dd = 1;
					var mm;
					var yy;
					if (opt == 'M') {
						mm = this.getData('monthNames').indexOf(selected);
					}
					else {
						mm = calendar.getData('viewDate').getMonth();
					}
					if (opt == 'Y') {
						yy = selected;
					}
					else {
						yy = calendar.getData('viewDate').getFullYear();
					}
					if (mm < 1 && yy == this.getData('ltPropStartYear')) {
						if (selected == _lyteUiUtils.i18n('Jan') || selected == _lyteUiUtils.i18n('January')) {
							calendar.querySelector('.monthDD').ltProp("selected", this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
						}
						else {
							calendar.querySelector('.yearDD').ltProp("selected", "" + calendar.getData('viewDate').getFullYear());
						}
						// console.log("returning "+mm+" "+yy);
						return;
					}
					this.setMonthAndYear(calendar, { dd: dd, mm: mm, yy: yy }, "cal2");
					if (mm > 0) {
						mm -= 1;
					}
					else {
						mm = 11;
						yy -= 1;
					}
					this.$node.querySelector('.dRPCalendar1').setData('selectDate', false);
					this.setMonthAndYear(this.$node.querySelector('.dRPCalendar1'), { dd: dd, mm: mm, yy: yy }, "cal1");
				}
				this.checkForSelectedDates();
				this.validateNavigation();
			}
			this.setTodayClass();
		},
		viewDateChange : function(cal,comp,viewDate){
			this.setCalendarHeader(cal,comp,viewDate);
		}
	}
});

/**
 * @syntax nonYielded
 * <lyte-daterangepicker>
 * </lyte-daterangepicker>
 */

/**
 * This component is used to select a date or a range of date from the given options
 * @component lyte-dateselect
 * @version 1.0.5
 * @dependency lyte-dropdown
 *  /components/lyte-dropdown.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-dropdown.css
 * @dependency lyte-calendar
 *  /components/lyte-calendar.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-calendar.css
 * @dependency lyte-daterangepicker
 *  /components/lyte-daterangepicker.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-daterangepicker.css
 * @methods beforeRender,afterRender,onBeforeShow,onShow,onBeforeHide,onHide,onSelect
 * @import lyte-dropdown
 * @ignoreMethods
 * @ignoreProperties
 * @ignoreUtilities
 */

Lyte.Component.register("lyte-dateselect", {
_template:"<template tag-name=\"lyte-dateselect\"> <lyte-dropdown lt-prop=\"{{stringify(ltPropDropdown)}}\" on-before-show=\"{{method('bfSw')}}\" on-show=\"{{method('sw')}}\" on-before-hide=\"{{method('bfHde')}}\" on-hide=\"{{method('hde')}}\" on-option-selected=\"{{method('optSel')}}\" lt-prop-selected=\"{{lbind(ltPropSelected)}}\" on-position-changed=\"{{method('posChange')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button> <template is=\"if\" value=\"{{ltPropButtonYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"buttonYield\"></lyte-yield> </template><template case=\"false\"> <template is=\"if\" value=\"{{ltPropSelected}}\"><template case=\"true\"> {{ltPropDisplayValue}} </template><template case=\"false\"> <span class=\"lyteDropPlaceholderMultiple\">{{ltPropDropdown.placeholder}}</span> </template></template> <lyte-icon class=\"dropdown\"></lyte-icon> </template></template> </lyte-drop-button> <lyte-drop-box class=\"{{ltPropDropdownWrapperClass}}\" id=\"lyteDateSelect\"> <lyte-drop-body class=\"lyteList\"> <template is=\"forIn\" object=\"{{ltPropOptions}}\" value=\"value\" key=\"key\"> <lyte-drop-item data-value=\"{{key}}\" class=\"{{key}}\"> <template is=\"if\" value=\"{{ltPropItemYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"item\" item-value=\"{{ltPropOptions[key]}}\"></lyte-yield> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(value,'==',true)}}\"><template case=\"true\"> {{lyteUiI18n(key)}} </template><template case=\"false\"> {{value}} </template></template></template></template><template is=\"if\" value=\"{{expHandlers(expHandlers(key,'==','specificDate'),'||',expHandlers(key,'==','customRange'))}}\"><template case=\"true\"> <span class=\"{{if(ifEquals(pos,'left'),'dateArrow arrowLeft','dateArrow arrowRight')}}\"></span> </template></template> </lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> <div class=\"dateSelectcal lyteDropdownHidden {{ltPropCalendarWrapperClass}}\"> <template is=\"if\" value=\"{{opend}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropOptions.specificDate}}\"><template case=\"true\"> <div class=\"specificDate lyteDropdownHidden\"> <lyte-calendar lt-prop=\"{{stringify(ltPropCalendar)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" on-date-selected=\"{{method('dateselected1')}}\" on-navigate=\"{{method('rangenavigate')}}\"> <template is=\"if\" value=\"{{ltPropCalendarYield}}\"><template case=\"true\"> <template is=\"registerYield\" yield-name=\"footer\"> <lyte-yield yield-name=\"footer\"></lyte-yield> </template> </template></template> </lyte-calendar> <template is=\"if\" value=\"{{ltPropFooterYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"dateselect-footer\" selected=\"{{ltPropSelected}}\" current-date=\"{{ltPropCurrentDate}}\"></lyte-yield> </template></template> </div> </template></template> <template is=\"if\" value=\"{{ltPropOptions.customRange}}\"><template case=\"true\"> <div class=\"customRange lyteDropdownHidden\"> <lyte-daterangepicker lt-prop=\"{{stringify(ltPropDateRangePicker)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" short-month-names=\"{{shortMonthNames}}\" long-month-names=\"{{longMonthNames}}\" cal-view-date1=\"{{lbind(ltPropStartDateObject)}}\" cal-view-date2=\"{{lbind(ltPropEndDateObject)}}\" on-date-selected=\"{{method('dateselected')}}\" on-navigation=\"{{method('rangenavigate')}}\" on-start-date-changed=\"{{method('startChange')}}\"> </lyte-daterangepicker> <template is=\"if\" value=\"{{ltPropFooterYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"dateselect-footer\" selected=\"{{ltPropSelected}}\" start-date=\"{{ltPropStartDate}}\" end-date=\"{{ltPropEndDate}}\"></lyte-yield> </template></template> </div> </template></template></template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"componentDynamic","position":[3]}]}},"default":{}},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1,1]},{"type":"forIn","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,2]},{"type":"if","position":[1,2],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["shortMonthNames","longMonthNames","ltPropStartDateObject","ltPropEndDateObject","ltPropStartDate","ltPropEndDate","ltPropCurrentDate","ltPropCalendarYield","ltPropCalendar","ltPropDateRangePicker","ltPropItemYield","ltPropSelected","ltPropOptions","ltPropDropdownWrapperClass","ltPropDropdown","ltPropDisplayValue","ltPropButtonYield","ltPropCalendarWrapperClass","ltPropFooterYield","ltPropI18n","ltPropAnimation","pos","prevSel","opend"],
	init : function(){
		this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node )
		this.$node.toggle = function(){
			this._drop.toggle();
		}.bind( this )
	},
	data : function(){
		return {
			// data for date range picker and calendar
		   /**
			* @experimental shortMonthNames
			*/
			shortMonthNames : Lyte.attr( "array" , { "default" : [ 'Jan', 'Feb', 'Mar', 'Apr', 'short.may', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]}),
		   /**
			* @experimental longMonthNames
			*/
			longMonthNames : Lyte.attr( 'array', { 
				'default': [
				'January',
				'February',
				'March',
				'April',
				'May',
				'June',
				'July',
				'August',
				'September',
				'October',
				'November',
				'December' 
				]
			} ),
		   /**
			* @componentProperty {object} ltPropStartDateObject
			* @version 1.0.5
			*/			
			ltPropStartDateObject : Lyte.attr( "object" ),
		   /**
			* @componentProperty {object} ltPropEndDateObject
			* @version 1.0.5
			*/
			ltPropEndDateObject : Lyte.attr("object"),
		   /**
			* @componentProperty {dateString} ltPropStartDate=''
			* @version 1.0.5
			*/
			ltPropStartDate : Lyte.attr( "string", { "default" : "" } ),
		   /**
			* @componentProperty {dateString} ltPropEndDate=''
			* @version 1.0.5
			*/
			ltPropEndDate : Lyte.attr( "string", { "default" : "" } ),
		   /**
			* @componentProperty {dateString} ltPropCurrentDate=''
			* @version 1.0.5
			*/
			ltPropCurrentDate : Lyte.attr( "string", { "default" : "" } ),
		   /**
			* @componentProperty {boolean} ltPropCalendarYield=false
			* @version 1.0.5
			*/
			ltPropCalendarYield : Lyte.attr( 'boolean', { default : false } ),
		   /**
			* @componentProperty {object} ltPropCalendar={"headerType":"dropdown","fillRows":false}
			* @version 1.0.5
			* @component lyte-calendar
			*/
			ltPropCalendar : Lyte.attr( 'object', { default : { headerType : "dropdown", fillRows : false } } ),
		   /**
			* @componentProperty {object} ltPropDateRangePicker={"monthHeaderFormat":"MMMM YYYY"}
			* @version 1.0.5
			* @component lyte-daterangepicker
			*/
			ltPropDateRangePicker : Lyte.attr( 'object', { default : { monthHeaderFormat : "MMMM YYYY" } } ),
		   /**
			* @componentProperty {boolean} ltPropItemYield=false
			* @version 1.0.5
			*/
			ltPropItemYield : Lyte.attr( 'boolean', { default : false } ),

			// dateselect props
		   /**
			* @componentProperty {string} ltPropSelected=today
			* @version 1.0.5
			*/
			ltPropSelected : Lyte.attr('string', { default : 'today'}),
		   /**
		    * @typedef {object} dateSelectOptions
		    * @property {boolean} today=true
		    * @property {boolean} yesterday=true
		    * @property {boolean} last7days=true
		    * @property {boolean} last30days=true
		    * @property {boolean} thisWeek=true
		    * @property {boolean} thisMonth=true
		    * @property {boolean} specificDate=true
		    * @property {boolean} customRange=true
		    */
		   /**
			* @componentProperty {dateSelectOptions} ltPropOptions
			* @version 1.0.5
			*/
			ltPropOptions : Lyte.attr( 'object', { default : {
				today :  true,
				yesterday : true,
				last7days : true,
				last30days : true,
				thisWeek : true,
				thisMonth : true,
				specificDate : true,
				customRange : true
			}}),
		   /**
			* @componentProperty {string} ltPropDropdownWrapperClass=''
			* @version 1.0.5
			*/
			ltPropDropdownWrapperClass : Lyte.attr( 'string', { default : '' } ),
		   /**
			* @componentProperty {object} ltPropDropdown
			* @version 1.0.5
			* @default {}
			* @component lyte-dropdown
			*/
			ltPropDropdown : Lyte.attr( 'object', { default : {} } ),
		   /**
			* @componentProperty {string} ltPropDisplayValue=''
			* @version 1.0.5
			*/
			ltPropDisplayValue : Lyte.attr( 'string', { default : '' } ),
		   /**
			* @componentProperty {boolean} ltPropButtonYield=false
			* @version 1.0.5
			*/
			ltPropButtonYield : Lyte.attr( 'boolean', { default : false } ),
		   /**
			* @componentProperty {string} ltPropCalendarWrapperClass=''
			* @version 1.0.5
			*/
			ltPropCalendarWrapperClass : Lyte.attr( 'string', { default : '' } ),
		   /**
			* @componentProperty {boolean} ltPropFooterYield=false
			* @version 3.10.0
			*/			
			ltPropFooterYield : Lyte.attr( 'boolean', { default : false } ),
		   /**
			* @componentProperty {boolean} ltPropI18n=false
			* @version 3.10.0
			*/
			ltPropI18n : Lyte.attr( 'boolean', { default : false } ),
			/**
			* @componentProperty {boolean} ltPropI18n=false
			* @version 3.14.0
			*/
			ltPropAnimation : Lyte.attr( 'object', { default : {
				dropdown : "Fade", // Scale, Slide
				calendar : "Fade"
			} } ),

			// system data

		   /**
			* @experimental pos
			*/
			pos : Lyte.attr( 'string', { default : '' } ),
		   /**
			* @experimental prevSel
			*/
			prevSel : Lyte.attr( 'string', { default : '' } ),
		   /**
			* @experimental opend
			*/
			opend : Lyte.attr( 'boolean',  { default : false } )

		}		
	},

	selectValue : function( dat ){
		if( !this.data.ltPropButtonYield ){
			// var val = this.data.ltPropOptions[ dat ];
			// var oriDisp = val.constructor == Boolean ? _lyteUiUtils.i18n( dat ) : val;
			this.setData( 'ltPropDisplayValue', this.getVal( dat ) )
		}
	},

	didConnect : function(){
		this._drop = this.$node.querySelector( 'lyte-dropdown' );
		this._drop.parent = this.$node;
		var com = this._drop.component;
		this._cmp = com.childComp ? com.childComp : this._drop.querySelector( 'lyte-drop-box' )
		this._end = this.tranEnd.bind( this );
		this._indend = this.tranEnd1.bind( this );

		this._opentrans = this.opentrans.bind( this );

		this._caldiv = this.$node.querySelector( '.dateSelectcal' ) 
		_lyteUiUtils.appendChild( document.body, this._caldiv )
		if( !this.data.ltPropButtonYield ){
			this.setData( 'ltPropDisplayValue', this.getVal( this.data.ltPropSelected ) )
		}
		if( !document._dateselectResize ){
			document._dateselectResize = true;
			window.addEventListener( 'resize', dtslctscroll );
			window.addEventListener( 'scroll', dtslctscroll );
			window.addEventListener( 'orientationchange', dtslctscroll );
		}
		this.$node.toggle = function( ev, tp ){
			this._drop.toggle( ev, tp )
		}.bind( this )
		this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );
		$L.fastdom.measure( function(){
			this._dir = _lyteUiUtils.getRTL();
			if( this._dir ) {
				$L.fastdom.mutate( function(){
						this._caldiv.classList.add( 'lyteRTL' )
				}.bind( this ) )
			}
		}.bind( this ) )
	},

	didDestroy : function(){
		document.body.removeChild( this._caldiv );
		if( document._dateselectResize && document.querySelectorAll( 'lyte-dateselect' ).length == 0 ){
			delete document._dateselectResize;
			window.removeEventListener( 'resize', dtslctscroll );
			window.removeEventListener( 'scroll', dtslctscroll );
			window.removeEventListener( 'orientationchange', dtslctscroll );
		}
		delete this._caldiv; delete this._cmp; delete this._drop; delete this.$node.toggle;
	},

	getVal : function( sel ){
		if( !sel ){
			return "";
		}
		var val = this.data.ltPropOptions[ sel ], oridisp = val.constructor == Boolean ? _lyteUiUtils.i18n( sel ) :  val ;
 		if( [ 'specificDate', 'customRange' ].indexOf( sel ) == -1 ){
			return oridisp;
		} else if( sel == 'specificDate' ){
			return this.i18_date( this.data.ltPropCurrentDate, this.data.ltPropCalendar.format || "MM/DD/YYYY" ) || oridisp;
		} else if( sel == 'customRange' ) {
			var format = this.data.ltPropDateRangePicker.format || "MM/DD/YYYY",
			s = this.i18_date( this.data.ltPropStartDate, format ), e = this.i18_date( this.data.ltPropEndDate, format );
			return ( s && e ) ? ( s + ' - ' + e ): oridisp;
		} 
		// return _lyteUiUtils.i18n( s );
	},

	resolveConflicts: function( format ) {
		var match = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/.exec( format ),
		index = ( match || {} ).index,
		matchLength = ( match || [] )[ 0 ].length || 0;

		if( !isNaN( index ) ) {
			return format.substring( 0, index + matchLength ) + ( format.substring( index + matchLength ) || '' ).toUpperCase();
		}

		return format.toUpperCase();
	},

	isConflictingFormat: function( format ) {
		var rdate = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/ig,
		match = format.match( rdate ) || [];

		return match.length > 1;
	},

	getRelevantFormat: function( format ) {

		if( this.isConflictingFormat( format ) ) {
			return this.resolveConflicts( format );
		}

		return format.toUpperCase();
	},

	i18_date : function( date, format ){

		format = this.getRelevantFormat( format );

		if( date && $L.moment && this.data.ltPropI18n ){
			var cb = function( value, converted, format ){
				if( this.getMethods( 'onI18n' ) ){
					return this.executeMethod( 'onI18n', value, converted, format );
				}
				return converted;
			}.bind( this );
			return $L.moment( date, format ).i18N( format, cb );
		}
		return date;
	},

	selectedObs : function( arg ){
		if( arg.newValue && this._cmp && !this._cmp.classList.contains( 'lyteDropdownHidden' ) ) {
			 var oldAn = [ 'specificDate', 'customRange' ].indexOf( arg.oldValue ) != -1 ? this._caldiv.querySelector( '.' + arg.oldValue ) : null,
			 newAn = [ 'specificDate', 'customRange' ].indexOf( arg.newValue ) != -1 ? this._caldiv.querySelector( '.' + arg.newValue ) : null;
			 if( newAn ) {
			 	if( oldAn ) {
			 		var prm = new Promise( function( res, rej ){
			 			this._new = res;
			 			this.hideele( oldAn );
			 		}.bind( this ) );
			 		Promise.resolve( prm ).then( function(){
			 			$L.fastdom.mutate( this.openele.bind( this ) );
			 		}.bind( this ))
			 	} else{
			 		this.openele()
			 	}
			 	this.data.prevSel = this.data.prevSel || arg.oldValue
			 }
		} else if( arg.newValue && ( ( this._cmp && this._cmp.classList.contains( 'lyteDropdownHidden' ) ) || [ 'specificDate', 'customRange' ].indexOf( arg.newValue ) != -1 ) ){
			this.selectValue( arg.newValue );
		}
		// this.resetValue();
	}.observes( 'ltPropSelected' ), 

	opentrans : function( evt ){
		$L( this._cmp ).removeClass( 'lyteDateselectAnimationHappening' );
		this._cmp.removeEventListener( 'transitionend', this._opentrans, true );
		delete this._drop.component._preventSetcss;


		if( this.getMethods( 'onAnimationEnd' ) ){
			this.executeMethod( 'onAnimationEnd', this.$node );
		}

	},

	tranEnd : function( evt ){
		if( this._cmp ){
			this._cmp.removeEventListener( 'transitionend', this._end, true );
			$L( this._cmp ).removeClass( 'lyteDateselectAnimationHappening' ).css( this.getValue( 1, 'dropdown', this._cmp ) );
		}

		if( this._el ){
			this._el.classList.add( 'lyteDropdownHidden' );
			delete this._el;
		}
		if( this._res ){
			this._res( true );
			this._caldiv.classList.add( 'lyteDropdownHidden' );
			this.callRevert();
			delete this._res;
		}
		this.hidedropdown();
	},

	tranEnd1 : function( evt ){
		if( this._el ){
			this._el.removeEventListener( 'transitionend', this._indend, true );
			$L( this._el ).removeClass( 'lyteDateselectAnimationHappening' );
			this._el.classList.add( 'lyteDropdownHidden' );
			delete this._el;
		}
		if( this._new ){
			this._new( true );
			delete this._new;
		}

		this.hidedropdown();
	},

	hidedropdown : function(){
		var dropdown = Array.from( this._caldiv.querySelectorAll( 'lyte-dropdown' ) );

		dropdown.forEach( function( item ){
			item.close();
		});
	},

	hideele : function( elem ){
		elem.addEventListener( 'transitionend', this._indend, true );
		$L( elem ).addClass( 'lyteDateselectAnimationHappening' );

		this._el = elem;
		
		if( this.data.ltPropAnimation.dropdown ){
			$L( elem ).css( this.getValue( 0, 'calendar', elem ) );
		} else{
			this._indend();
		}
	},

	getValue : function( value, type, elem ){
		var animation = this.data.ltPropAnimation[ type ];

		if( animation == 'Fade' ){
			return {
				opacity : value
			}
		} else if( animation == 'Scale' ){
			return{
				transform : "scaleY(" + value + ')'
			}
		} else if(  animation == 'Slide' ){
			var obj = {
				height : value ? ( elem.__height ) : 0,
				transform : ""
			};

			if( $L( this._caldiv ).hasClass( 'lyteDateselectUp' ) ){
				// obj.transform = 'translateY(' + ( !value ? elem.__height : 0 ) + 'px)';

				obj.transform = value ? '' : ( 'translateY(' + elem.__height + 'px)' );
			}

			return obj;
		}
		return {};
	},

	openele : function(){
		var sel = this.data.ltPropSelected;
		if( [ 'specificDate', 'customRange' ].indexOf( sel ) != -1 ) {
			this._caldiv.classList.remove( 'lyteDropdownHidden' );
			var el = this._caldiv.querySelector( '.' + sel );
			el.classList.remove( 'lyteDropdownHidden' );
			if( this.data.ltPropAnimation.calendar == 'Slide' ){
				$L.fastdom.measure( function(){
					el.__height = this._caldiv.__height = el.children[ 0 ].getBoundingClientRect().height;
					$L.fastdom.mutate( function(){
						$L( el ).css( 'transitionDuration', '0s' ).css( this.getValue( 0, 'calendar', el ) );
						// $L.fastdom.measure( this.setCss.bind( this ) );
						setTimeout( function(){
							$L( el ).css( 'transitionDuration', '' );
							this.setCss();
						}.bind( this ), 20 );
					}.bind( this ) );
				}.bind( this ));
			} else {
				$L( el ).css( this.getValue( 0, 'calendar', el ) );
				$L.fastdom.measure( this.setCss.bind( this ) );
			}
		}
	},

	animation_obs : function(){
		var animation = this.data.ltPropAnimation;
		
		$L( this._caldiv )
		.removeClass( 'lyteDateselectAnimate' )
		.addClass( animation.calendar != 'Fade' ? 'lyteDateselectAnimate' : '' )
		.css( {
			transform : "",
			opacity : ""
		} );

		$L( this._cmp )
		.removeClass( 'lyteDateselectAnimate' )
		.addClass( animation.dropdown != 'Fade' ? 'lyteDateselectAnimate' : '' )
		.css( {
			transform : "",
			opacity : ""
		} );

	}.observes( 'ltPropAnimation.{}, ltPropAnimation' ).on( 'didConnect' ),

	methods : {

		rangenavigate : function(){
			if( this.data.ltPropAnimation.calendar == 'Slide' ){
				var datepicker = arguments[ 3 ].$node;
				$L.fastdom.measure( function(){
					var height = datepicker.getBoundingClientRect().height;
					$L.fastdom.mutate( function(){
						$L( datepicker.parentNode ).css( 'height', height );
					});
				});
			}
		},

		bfSw : function( arg1, arg2 ){
			var ret;
			if( this.getMethods( 'onBeforeShow' ) ){
				ret = this.executeMethod( 'onBeforeShow', arg1, arg2 )
			}
			if( !this.data.opend && ret != false ) {
				this.setData( 'opend', true );
				return new Promise( function( res ){
					window.requestAnimationFrame( res );
				})
			}
			return ret;
		},
		sw : function( arg1, arg2 ){

			this._drop.component._preventSetcss = !this._drop.ltProp( 'freeze' );

			this.getMethods( 'onShow' ) && this.executeMethod( 'onShow', arg1, arg2 );

			var body = arg2.childComp;
			
			$L( body ).addClass( 'lyteDateselectAnimationHappening' ).css( 'transitionDuration', '0s' ).css( this.getValue( 0, 'dropdown', body ) );
			
			setTimeout( function(){ // request animation frame causes issue in ff
				$L( body ).css( 'transitionDuration', '' );
				this.openele();

				body.addEventListener( 'transitionend', this._opentrans, true );

				$L.fastdom.mutate( function(){
					$L( body ).css( this.getValue( 1, 'dropdown', body ) );
				}.bind( this ) ); 
			}.bind( this ), 20 );
		},
	
		bfHde : function( arg1, arg2 ){
			if( this._prevent || this._caldiv.contains( ( arg1 || {} ).target ) ){
				delete this._prevent;
				return false;
			}
			var ret;
			if( this.getMethods( 'onBeforeHide' ) ){
				ret = this.executeMethod( 'onBeforeHide', arg1, arg2 )
			}
			if( ret != false ){
				return new Promise( function( res, rej ){
					this._res = res;
					var animation = this.data.ltPropAnimation || {},
					el = this._caldiv.querySelector('.specificDate:not(.lyteDropdownHidden),.customRange:not(.lyteDropdownHidden)');

					this._el = el;

					if( animation.dropdown ){
						arg2.childComp.addEventListener( 'transitionend', this._end, true );
						$L( arg2.childComp ).addClass( 'lyteDateselectAnimationHappening' );
						if( el ) {
							$L( el ).css( this.getValue( 0, 'calendar', el ) );
						}
						$L( arg2.childComp ).css( this.getValue( 0, 'dropdown', arg2.childComp ) );
					} else{
						this._end();
					}
				}.bind( this ) )
			}
			return ret;
		},
		
		hde : function( arg1, arg ){
			if( !this._rest && this.data.prevSel ){
				this.setData( 'ltPropSelected', this.data.prevSel );
				if( !this.data.ltPropButtonYield ){
					this.setData( 'ltPropDisplayValue', this.getVal( this.data.ltPropSelected ) );
				}
			}
			delete this._rest;
			this.data.prevSel = ''; 
			this.resetValue();
			if( this.data.ltPropAnimation.dropdown == 'Slide' ){
				$L( this._cmp ).css( 'height', '' );
			}
			if( this.getMethods( 'onHide' ) ){
				return this.executeMethod( 'onHide', arg1, arg )
			}
		},
		dateselected : function( event ){
			this.selected( event, true )
		},

		dateselected1 : function( event ){
			this.selected( event )
		},
		optSel : function( evt, dat, com, itm ){
			if( [ 'specificDate', 'customRange' ].indexOf( dat ) != -1 ){
				this._prevent = true;
				return
			}
			this.selectValue( dat );
			this.getMethods('onSelect') && this.executeMethod( 'onSelect', evt, this.$node, dat, itm );
			this._rest = true;
		},
		posChange : function( pos ){
			var addClass = 'removeClass'
			if( /up/i.test( pos ) ){
				addClass = 'addClass';
			}
			$L( this._cmp )[ addClass ]( 'lyteDateselectUp' );
			$L( this._caldiv )[ addClass ]( 'lyteDateselectUp' );
		},

		startChange : function( arg ){
			var cb = 'onStartDateChanged';

			if( this.getMethods( cb ) ){
				this.executeMethod( cb, arg );
			}
		}
	},

	resetValue : function(){
		if( this.data.ltPropSelected != 'specificDate' ) {
			this.setData( 'ltPropCurrentDate', '' );
		}
		if( this.data.ltPropSelected != 'customRange' ){
			this.setData( 'ltPropStartDate', '' );
			this.setData( 'ltPropEndDate', '' );
		}
	},

	callRevert : function(){
		var selected = this.data.ltPropSelected,
		calendar = this._caldiv.querySelector( '.specificDate lyte-calendar' ),
		daterange = this._caldiv.querySelector( '.customRange lyte-daterangepicker' );

		if( selected == 'customRange' ){
			daterange.revertToSelected();
			if( calendar ){
				calendar.revertToToday();
			}
		} else {
			if( selected == 'specificDate' ){
				calendar.revertToSelected();
			} else {
				if( calendar ){
					calendar.revertToToday();
				}
			}
			if( daterange ){
				daterange.revertToToday();
			}
		}
	},

	setCss : function( obj ) {
		function rtlfunc( lft, bcr, ww ){
			if( this._dir ) {
				if( bcr ) {
					if( lft == 'right' ) {
						return ww - bcr.left;
					}
					return ww - bcr.right;
				} else if( lft == 'left' ) {
					return 'right';
				} 
			}
			return bcr ? bcr[ lft ] : 'left';
		}
		var y = window.pageYOffset || document.documentElement.scrollTop,
		body = this._caldiv, par = this._cmp,
		bbcr = body.getBoundingClientRect(),
		bcr = { left : bbcr.left, right : bbcr.right, width : bbcr.width, height : body.__height || bbcr.height }, 
		__bcr = par.getBoundingClientRect(),
		parcr = { left : __bcr.left, right : __bcr.right, width : __bcr.width, height : par.__height, top : parseFloat( par.style.top ) - y, bottom : parseFloat( par.style.top ) - y + par.__height },
		wwidth = window.innerWidth,
		x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? - 1: 1 ),
		selEl = par.querySelector( 'lyte-drop-item[selected = "true"]' ),
		__selBcr = selEl.getBoundingClientRect(),
		selBcr = { bottom : __selBcr.bottom - ( __bcr.top - parcr.top ) },
		arrow = selEl.querySelector( '.dateArrow' ),
		arbcr = arrow ? arrow.getBoundingClientRect() : { width : 0 },

		newLeft = rtlfunc.call( this, 'left', parcr, wwidth ) + parcr.width + arbcr.width / 2 + x,
		rgtLft = rtlfunc.call( this, 'left', parcr, wwidth ) - arbcr.width / 2 - bcr.width + x,
		newTop = par.style.top,
		pos;

		if( parseFloat( newTop ) + bcr.height < selBcr.bottom + y ){
			newTop = ( y + selBcr.bottom - bcr.height ) + 'px';
		}
		if( newLeft + bcr.width < wwidth + x ) {
			pos = 'right';
		} else {
			if( rgtLft > x ){
				newLeft = rgtLft;
				pos = 'left';
			} else {
				if( wwidth - rtlfunc.call( this, 'right', parcr, wwidth ) > rtlfunc.call( this, 'left', parcr, wwidth ) ){
					pos = 'right'
				} else {
					newLeft = rgtLft;
					pos = 'left'
				}
			}
		}
		$L.fastdom.mutate( function(){
			body.style[ rtlfunc.call( this, 'left' ) ] = newLeft + 'px';
			body.style.top = newTop;
			var elem = this._caldiv.getElementsByClassName( this.data.ltPropSelected )[ 0 ];
			if( elem ){
				$L( elem ).css( this.getValue( 1, 'calendar', elem ) );
			}
			this.setData( 'pos', pos )
		}.bind( this ))
	},

	selected : function( evt, flag ){
		if( !this.data.ltPropButtonYield ){
			this.setData( 'ltPropDisplayValue', this.getVal( this.data.ltPropSelected ) );
		}
		if( this.getMethods('onSelect') ){
			if( flag ){
				this.executeMethod( 'onSelect', evt, this.$node, 'customRange', this.data.ltPropStartDate, this.data.ltPropEndDate )
			} else{
				this.executeMethod( 'onSelect', evt, this.$node, 'specificDate', this.data.ltPropCurrentDate )
			}
		}
		this._rest = true
		this._drop.toggle()
	}

});

function dtslctscroll( evt ){
	if( evt && evt.type == 'resize' && _lyteUiUtils.isMobile ) {
		return;
	}
	var drops = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' )
	for( var i = 0; i < drops.length; i++ ){
		var opendrop = drops[ i ];
		if( opendrop && opendrop.origindd && opendrop.origindd.parent ){
			var cmp = opendrop.origindd.parent.component;
			evt.type == "orientationchange" ?  setTimeout( cmp.setCss.bind( cmp ), 500 ) : cmp.setCss.call( cmp );
		}
	}
}

/**
 * @syntax nonYielded
 * <lyte-dateselect></lyte-dateselect>
 */

/**
 * @syntax 
 * @attribute ltPropButtonYield=true
 * <lyte-dateselect lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax 
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-item-yield = true>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax 
 * @attribute ltPropCalendarYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-item-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropButtonYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropButtonYield=true
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-item-yield = true lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */

Lyte.Component.register("lyte-dragdrop", {
_template:"<template tag-name=\"lyte-dragdrop\"> <div class=\"lyteDragDropFields\"> <div class=\"lyteDragDropColumns\"> <div class=\"lyteDragDropFL lytePosRel\"> <span class=\"lyteDragDropHeading\">{{ltPropAvailableLabel}}</span> <div class=\"lyteDragDropAvailable\"> <span class=\"lyteSelectedNone\" id=\"AvailableNone\">{{ltPropAvailablelistEmptyMessage}}</span> <template is=\"if\" value=\"{{ltPropEnableSearch}}\"> <template case=\"true\"> <div class=\"lytePosRel\"> <lyte-search style=\"display: block;\" lt-prop-style=\"{{ltPropSearchStyle}}\" lt-prop-query-selector=\"{{querySelector}}\" lt-prop-appearance=\"box\" lt-prop-error=\"{{ltPropErrorMessage}}\"></lyte-search> </div> <ul class=\"lyteAvailableUL\" id=\"sortableSec\"> <template is=\"for\" items=\"{{ltPropAvailablelist}}\" item=\"item\"> <li class=\"filterlabel sortableElem\" data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown',event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut',event)}}\"> <span class=\"item\">{{item.name}}</span> <template is=\"if\" value=\"{{ltPropDraggable}}\"> <template case=\"true\"> <template is=\"if\" value=\"{{ltPropEnableIcon}}\"> <template case=\"true\"><span class=\"lyteDragDropAdd\"></span></template> </template> </template> </template> </li> </template> </ul> </template> <template case=\"false\"> <ul class=\"lyteAvailableUL\" id=\"sortableSec\" style=\"height: 336px;\"> <template is=\"for\" items=\"{{ltPropAvailablelist}}\" item=\"item\"> <li class=\"filterlabel sortableElem\" data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown',event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut',event)}}\"> <span class=\"item\">{{item.name}}</span> <template is=\"if\" value=\"{{ltPropDraggable}}\"> <template case=\"true\"> <template is=\"if\" value=\"{{ltPropEnableIcon}}\"> <template case=\"true\"><span class=\"lyteDragDropAdd\"></span></template> </template> </template> </template> </li> </template> </ul> </template> </template> </div> </div> <template is=\"if\" value=\"{{ltPropDraggable}}\"> <template case=\"true\"> <div class=\"lyteDragDropFL lytePosRel\"> <span class=\"lyteDragDropHeading\">{{ltPropSelectedLabel}}</span> <div class=\"lyteDragDropSelected\"> <span class=\"lyteSelectedNone\" id=\"SelectedNone\">{{ltPropSelectedlistEmptyMessage}}</span> <ul class=\"lyteSelectedUL\" id=\"dropSec\"> <template is=\"for\" items=\"{{ltPropSelectedlist}}\" item=\"item\"> <li data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown',event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut',event)}}\"> <span>{{item.name}}</span> <template is=\"if\" value=\"{{ltPropEnableIcon}}\"> <template case=\"true\"><span class=\"lyteDragDropRemove\"></span></template> </template> </li> </template> </ul> </div> </div> </template> </template> </div> </div> </template>",
_dynamicNodes : [{"type":"text","position":[1,1,1,1,0]},{"type":"text","position":[1,1,1,3,1,0]},{"type":"attr","position":[1,1,1,3,3]},{"type":"if","position":[1,1,1,3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"text","position":[1,3,1,0]},{"type":"attr","position":[1,3,3,1]},{"type":"for","position":[1,3,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}]}},"default":{}}],
_observedAttributes :["ltPropAvailablelist","ltPropSelectedlist","ltPropMultiselect","ltPropEnableSearch","ltPropEnableIcon","ltPropDraggable","ltPropErrorMessage","ltPropAvailablelistEmptyMessage","ltPropSelectedlistEmptyMessage","ltPropSearchStyle","ltPropAvailableLabel","ltPropSelectedLabel","clickCount","component","placeholder","div","offset","isDown","isMoved","top","bottom","prevScrollTop","multiSelectedItems","keyPressed","keyValue","prevMode","checkSelection","querySelector","left","right","availableList","selectedList","checkOnDidconnect","draggedItems"],
	init : function(){
		if(!this.getData('ltPropErrorMessage')){
			this.setData('ltPropErrorMessage',_lyteUiUtils.i18n("no.results.found"));
		}
		this.setData('ltPropAvailableLabel',_lyteUiUtils.i18n("Available"));
		this.setData('ltPropSelectedLabel',_lyteUiUtils.i18n("Selected"));
	},
	didConnect : function() {

		var dragdrops = document.querySelectorAll('lyte-dragdrop');
		for(var v = 0 ; v < dragdrops.length; v++){
			if(dragdrops[v] == this.$node){
				// console.log(v);
				this.$node.querySelector('#sortableSec').classList.add('searchable'+v);
				this.setData('querySelector',{'scope':'.searchable'+v,'target':'.filterlabel','search':'.item'});
				// console.log(this.getData('querySelector'));
				break;
			}
		}
		this.setData('checkOnDidconnect',true);
	},
	data : function(){
        return {
			"ltPropAvailablelist" : Lyte.attr("array",{"default":[]}),
			"ltPropSelectedlist" : Lyte.attr("array",{"default":[]}),
			"ltPropMultiselect" : Lyte.attr("boolean",{"default":true}),
			"ltPropEnableSearch" : Lyte.attr("boolean",{"default":true}),
			"ltPropEnableIcon" : Lyte.attr("boolean",{"default":true}),
			"ltPropDraggable" : Lyte.attr("boolean",{"default":true}),
			"ltPropErrorMessage" : Lyte.attr("string",{"default":""}),
			"ltPropAvailablelistEmptyMessage" : Lyte.attr("string",{"default" : "Empty List"}),
			"ltPropSelectedlistEmptyMessage" : Lyte.attr("string",{"default" : "Drop Here"}),
			"ltPropSearchStyle" : Lyte.attr("string",{"default" : ""}),
			"ltPropAvailableLabel" : Lyte.attr("string"),
			"ltPropSelectedLabel" : Lyte.attr("string"),

			/*local variables of the component*/
			"clickCount" : Lyte.attr("number",{"default":0}),
			"component" : Lyte.attr("object",{"default":null}),
			"placeholder" : Lyte.attr("object",{"default":null}),
			"div" : Lyte.attr("object",{"default":null}),
			"offset" : Lyte.attr("array",{"default":[0,0]}),
			"isDown" : Lyte.attr("boolean",{"default":false}),
			"isMoved" : Lyte.attr("boolean",{"default":false}),
			"top" : Lyte.attr("number",{"default":0}),
			"bottom" : Lyte.attr("number",{"default":0}),
			"prevScrollTop" : Lyte.attr("number",{"default":0}),
			"multiSelectedItems" : Lyte.attr("array",{"default":[]}),
			"keyPressed" : Lyte.attr("boolean",{"default":false}),
			"keyValue" : Lyte.attr("number",{"default":0}),
			"prevMode" : Lyte.attr("string",{"default":""}),
			"checkSelection" : Lyte.attr("boolean",{"default":false}),
			"querySelector" : Lyte.attr("object",{"default":{'scope':'#sortableSec','target':'.filterlabel','search':'.item'}}),
			"left" : Lyte.attr("boolean",{"default":false}),
			"right" : Lyte.attr("boolean",{"default":false}),
			"availableList" : Lyte.attr("array",{"default" : []}),
			"selectedList" : Lyte.attr("array",{"default" : []}),
			"checkOnDidconnect" : Lyte.attr("boolean",{"default" : false}),
			"draggedItems" : Lyte.attr("array",{"default" : []})
		}
	},

	makeDroppable : function(current){
		var dropables1 = this.$node.querySelectorAll('#sortableSec>li');
		var dropables2 = this.$node.querySelectorAll('#dropSec>li');
		if(dropables1.length > 0){
			for(var i = 0; i<dropables1.length ; i++){
				if(dropables1[i] !== current){
					dropables1[i].classList.add('dropable');
				}
			}
		}
		if(dropables2.length > 0){
			for(var i = 0; i<dropables2.length ; i++){
				if(dropables2[i] !== current){
					dropables2[i].classList.add('dropable');
				}
			}
		}
	},

	showMsgForEmpty : function(){
		if(this.getData('ltPropAvailablelist').length > 0){
			this.$node.querySelector('#AvailableNone').style.visibility = "hidden";
		}
		if(this.getData('ltPropAvailablelist').length == 0){
			this.$node.querySelector('#AvailableNone').style.visibility = "visible";
		}
		if(this.getData('ltPropDraggable')){
			if(this.getData('ltPropSelectedlist').length == 0){
		    	this.$node.querySelector('#SelectedNone').style.visibility = "visible";
		    }
		    if(this.getData('ltPropSelectedlist').length > 0){
		    	this.$node.querySelector('#SelectedNone').style.visibility = "hidden";
		    }
		}
	}.observes('ltPropAvailablelist.[]','ltPropSelectedlist.[]','checkOnDidconnect'),

	removeDropable : function(current){
		var dropables1 = this.$node.querySelectorAll('#sortableSec>li');
		var dropables2 = this.$node.querySelectorAll('#dropSec>li');
		if(dropables1.length > 0){
			for(var i = 0; i<dropables1.length ; i++){
				if(dropables1[i] !== current){
					dropables1[i].classList.remove('dropable');
				}
			}
		}
		if(dropables2.length > 0){
			for(var i = 0; i<dropables2.length ; i++){
				if(dropables2[i] !== current){
					dropables2[i].classList.remove('dropable');
				}
			}
		}
	},


	generateArray : function(){
		// this.hideOrShowMessageOnEmpty("availableList","Empty Array");
		var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
		var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
		//console.log(array2);
		ltPropAvailablelist = [];
		ltPropSelectedlist = [];
		for(var i = 1 ; i<=array1.length ; i++){
			var obj = this.getElement(array1[i-1]);
			if(obj){
				obj.pos = i;
				ltPropAvailablelist.push(obj);
			}
		}
		for(var i = 1 ; i<=array2.length; i++){
			var obj = this.getElement(array2[i-1]);
			obj.pos = i;
			ltPropSelectedlist.push(obj);
		}
	    this.setData('availableList',ltPropAvailablelist);
	    this.setData('selectedList',ltPropSelectedlist);
	},

	removeClass : function(){
		var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
		var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
		for(var v = 0 ; v< array1.length ; v++){
			if(array1[v].classList.contains('lyteDraggableElem')){
				array1[v].classList.remove('lyteDraggableElem');
			}
		}
		for(var v = 0 ; v< array2.length ; v++){
			if(array2[v].classList.contains('lyteDraggableElem')){
				array2[v].classList.remove('lyteDraggableElem');
			}
		}
	},

	//Push the selected items in the array based on their position in DOM
	positionalPush : function(item,tempArray){
		var multiSelectedItems = this.getData('multiSelectedItems');
		var pos = 0;
		for(var v = 0 ; v < multiSelectedItems.length ; v++){
			if(multiSelectedItems[v].offsetTop > item.offsetTop){
				break;
			}
			else{
				++pos;
			}
		}
		multiSelectedItems.splice(pos,0,item);
		this.setData('multiSelectedItems',multiSelectedItems);
	},


	//Adds the selected items to an array for multiselected drag and drop
	addToArray : function(item,mode){
		if(mode === "single"){
			var multiSelectedItems = this.getData('multiSelectedItems');
			var emptyArray = [];
			if(multiSelectedItems.length > 0){
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var lastItem = multiSelectedItems[multiSelectedItems.length - 1];
				var indexOfLastItem = array1.indexOf(lastItem);
				if(indexOfLastItem == -1){
					indexOfLastItem = array2.indexOf(lastItem);
					var index = array2.indexOf(item);
					if(index == -1){
						this.setData('multiSelectedItems',emptyArray);
						this.removeClass();
						this.addToArray(item,mode);
					}
					else{
						this.positionalPush(item);
						if(!(item.classList.contains('lyteDraggableElem'))){
							item.classList.add('lyteDraggableElem');
						}
					}
				}
				else{
					var index = array1.indexOf(item);
					if(index == -1){
						this.setData('multiSelectedItems',emptyArray);
						this.removeClass();
						this.addToArray(item,mode);
					}
					else{
						this.positionalPush(item);
						if(!(item.classList.contains('lyteDraggableElem'))){
							item.classList.add('lyteDraggableElem');
						}
					}
				}
			}
			else{
				this.getData('multiSelectedItems').push(item);
				if(!(item.classList.contains('lyteDraggableElem'))){
					item.classList.add('lyteDraggableElem');
				}
			}
			this.setData('prevMode',mode);
		}
		if(mode == "multiple"){
			if(this.getData('prevMode') == "multiple" || this.getData('prevMode')== ""){
				this.removeClass();
				var newMultiSelectedItems = [];
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var index = array1.indexOf(item);
				if(index == -1){
					index = array2.indexOf(item);
					for(var v = 0;v <= index; v++){
						newMultiSelectedItems.push(array2[v]);
						array2[v].classList.add('lyteDraggableElem');
					}
				}
				else{
					for(var v = 0;v <= index; v++){
						newMultiSelectedItems.push(array1[v]);
						array1[v].classList.add('lyteDraggableElem');
					}
				}
				this.setData('multiSelectedItems',newMultiSelectedItems);
			}
			if(this.getData('prevMode') == "single"){
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var multiSelectedItems = this.getData('multiSelectedItems');
				if(multiSelectedItems.length > 0){
					var lastItem = multiSelectedItems[multiSelectedItems.length - 1];
					var indexOfLastItem = array1.indexOf(lastItem);
					if(indexOfLastItem == -1){
						indexOfLastItem = array2.indexOf(lastItem);
						var index = array2.indexOf(item);
						if(index == -1){
							this.setData('prevMode',mode);
							this.removeClass();
							this.addToArray(item,mode);
						}
						else{
							if(indexOfLastItem != -1){
								if(indexOfLastItem <= index){
									for(var v = indexOfLastItem; v <= index ; v++){
										if(multiSelectedItems.indexOf(array2[v]) == -1){
											array2[v].classList.add('lyteDraggableElem');
											this.positionalPush(array2[v]);
										}
									}
								}
								else{
									for(var v = index; v <= indexOfLastItem ; v++){
										if(multiSelectedItems.indexOf(array2[v]) == -1){
											array2[v].classList.add('lyteDraggableElem');
											this.positionalPush(array2[v]);
										}
									}
								}
							}
						}
					}
					else{
						var index = array1.indexOf(item);
						if(index === -1){
							this.setData('prevMode',mode);
							this.removeClass();
							this.addToArray(item,mode);
						}
						else{
							if(indexOfLastItem != -1){
								if(indexOfLastItem <= index){
									for(var v = indexOfLastItem; v <= index ; v++){
										if(multiSelectedItems.indexOf(array1[v]) == -1){
											array1[v].classList.add('lyteDraggableElem');
											this.positionalPush(array1[v]);
										}
									}
								}
								else{
									for(var v = index; v <= indexOfLastItem ; v++){
										if(multiSelectedItems.indexOf(array1[v]) == -1){
											array1[v].classList.add('lyteDraggableElem');
											this.positionalPush(array1[v]);
										}
									}
								}
							}
						}
					}
				}
				else{
					this.setData('prevMode',mode);
					this.removeClass();
					this.addToArray(item,mode);
				}
				
			}
			this.setData('prevMode',mode);
		}
	},

	//Removes some items from the array
	removeFromArray : function(item){
		if(this.getData('multiSelectedItems').length > 0){
			var index = this.getData('multiSelectedItems').indexOf(item);
			this.getData('multiSelectedItems').splice(index,1);
		}
	},
	
	//Gets the top and bottom for multiSelected items
	getTopNBottom : function(prop){
		if(prop === "top"){
			return this.getData('multiSelectedItems')[0].getBoundingClientRect().top;
		}
		if(prop == "bottom"){
			return this.getData('multiSelectedItems')[this.getData('multiSelectedItems').length - 1].getBoundingClientRect().bottom;
		}
	},

	//Adds class to the selected items to identify them as droppable
	makeDroppableMultiple : function(array){
		var dropables1 = Array.from(this.$node.querySelectorAll('#sortableSec>li'));
		var dropables2 = Array.from(this.$node.querySelectorAll('#dropSec>li'));
		if(dropables1.indexOf(array[0]) == -1){
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					dropables1[i].classList.add('dropable');
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables2[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables2[i].classList.add('dropable');
					}
				}
			}
		}
		else{
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables1[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables1[i].classList.add('dropable');
					}
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					dropables2[i].classList.add('dropable');
				}
			}
		}
	},

	//Removes class from the selected items after they are dropped
	removeDropableMultiple : function(array){
		var dropables1 = Array.from(this.$node.querySelectorAll('#sortableSec>li'));
		var dropables2 = Array.from(this.$node.querySelectorAll('#dropSec>li'));
		if(dropables1.indexOf(array[0]) == -1){
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					dropables1[i].classList.remove('dropable');
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables2[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables2[i].classList.remove('dropable');
					}
				}
			}
		}
		else{
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables1[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables1[i].classList.remove('dropable');
					}
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					dropables2[i].classList.remove('dropable');
				}
			}
		}
	},

	checkElement : function(ele){
		if((ele == this.$node.querySelector('#sortableSec')) || (ele == this.$node.querySelector('#dropSec'))){
			return true;
		}
		return false;
	},

	checkPossiblePosition : function(ele,prop){
		var array = Array.from(this.$node.querySelectorAll('#'+ele.id+' > li'));
		if(prop == "single"){
			if(array.length > 0){
				var lastChild = array[array.length - 1];
				if(this.getData('div').getBoundingClientRect().top > lastChild.getBoundingClientRect().bottom){
					return true
				}
			}
			else{
				return true;
			}
		}
		if(prop == "multiple"){
			if(array.length > 0){
				var lastChild = array[array.length - 1];
				var top = this.getTopNBottom("top");
				if(top > lastChild.getBoundingClientRect().bottom){
					return true;
				} 
			}
			else{
				return true;
			}
		}
		return false;
	},

	checkIfDroppable : function(elem,prop){
		if(prop === "multiple"){
			var multiSelectedItems = this.getData('multiSelectedItems');
			if((multiSelectedItems[0].parentElement.id === elem.id) && elem.id === "sortableSec" && (elem.querySelectorAll('li').length === multiSelectedItems.length) && multiSelectedItems[0].getBoundingClientRect().left < (elem.getBoundingClientRect().left + multiSelectedItems[0].getBoundingClientRect().width / 2)){
				return true;
			}
			if((multiSelectedItems[0].parentElement.id === elem.id) && elem.id === "dropSec" && (elem.querySelectorAll('li').length === multiSelectedItems.length) && multiSelectedItems[0].getBoundingClientRect().right > (elem.getBoundingClientRect().right - multiSelectedItems[0].getBoundingClientRect().width / 2)){
				return true;
			}
		}
		if(prop === "single"){
			var div = this.getData('div');
			if((div.parentElement.id === elem.id) && elem.id === "sortableSec" && (elem.querySelectorAll('li').length === 1) && div.getBoundingClientRect().left < (elem.getBoundingClientRect().left + div.getBoundingClientRect().width / 2)){
				return true;
			}
			if((div.parentElement.id === elem.id) && elem.id === "dropSec" && (elem.querySelectorAll('li').length === 1) && div.getBoundingClientRect().right > (elem.getBoundingClientRect().right - div.getBoundingClientRect().width / 2)){
				return true;
			}
		}
		return false;
	},

	//Moves the item from one div to another when the icon is clicked or double click happens on the item
	appendElement : function(event,prop){
		// console.log(event.target.parentElement);
		var elem = event.target;
		var element;
		if(prop == 'span'){
			if(elem.classList.contains('lyteDragDropAdd') && this.onClickFunction(event,this.getElement(elem.parentElement),"availableList")){
				// this.$node.querySelector('#dropSec').appendChild(elem.parentElement);
				element = this.getElement(elem.parentElement);
				Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'removeAt',this.getElementPosition(this.getData('ltPropAvailablelist'),element),1);
				Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'push',element);
				element = null;
				this.generateArray();
				this.onDropFunction(event);
			}
			if(elem.classList.contains('lyteDragDropRemove') && this.onClickFunction(event,this.getElement(elem.parentElement),"selectedList")){
				// this.$node.querySelector('#sortableSec').appendChild(elem.parentElement);
				element = this.getElement(elem.parentElement);
				Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'removeAt',this.getElementPosition(this.getData('ltPropSelectedlist'),element),1);
				Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'push',element);
				element = null;
				this.generateArray();
				this.onDropFunction(event);
			}
		}
		else{
			while(elem){
				if(elem.parentElement && elem.parentElement.id == 'sortableSec' && this.onClickFunction(event,this.getElement(elem),"availableList")){
					element = this.getElement(elem);
					Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'removeAt',this.getElementPosition(this.getData('ltPropAvailablelist'),element),1);
					Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'push',element);
					element = null;
					this.generateArray();
					this.onDropFunction(event);
					break;
				}
				if(elem.parentElement && elem.parentElement.id == 'dropSec' && this.onClickFunction(event,this.getElement(elem),"selectedList")){
					element = this.getElement(elem);
					Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'removeAt',this.getElementPosition(this.getData('ltPropSelectedlist'),element),1);
					Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'push',element);
					element = null;
					this.generateArray();
					this.onDropFunction(event);
					break;
				}
				elem = elem.parentElement;
			}
		}
		
	},

	removeStyle : function(obj){
		obj.style.left = "";
    	obj.style.top = "";
    	// obj.style.zIndex = "";
    	obj.style.boxSizing = "";
    	obj.style.width = "";
    	obj.style.height = "";
    	obj.style.position = "";
    	obj.style.visibility = "";
	},

	getElement : function(elem){
		if(elem.dataset.propvalue){
			return JSON.parse(elem.dataset.propvalue);
		}
		return null;
	},

	getElementPosition : function(arrayElm,elem){
		for(var i =0;i<arrayElm.length;i++){
			var flag = true;
			for (var key in arrayElm[i]){
				if(arrayElm[i][key] != elem[key]){
					flag = false;
					break;
				}
			}
			if(flag){
				return i;
			}
		}
		return -1;
	},

	hideOrShowMessageOnEmpty : function(prop,msg){
		if(prop == "availableList"){
			if(this.getData('ltPropAvailablelist').length > 0){
				this.$node.querySelector('#AvailableNone').style.visibility = "hidden";
			}
			else{
				if(msg){
					this.$node.querySelector('#AvailableNone').innerHTML = msg;
				}
				this.$node.querySelector('#AvailableNone').style.visibility = "visible";
			}
		}
		else if(prop == "selectedList"){
			if(this.getData('ltPropSelectedlist').length > 0){
				this.$node.querySelector('#SelectedNone').style.visibility = "hidden";
			}
			else{
				if(msg){
					this.$node.querySelector('#SelectedNone').innerHTML = msg;
				}
				this.$node.querySelector('#SelectedNone').style.visibility = "visible";
			}
		}
		
	},

	selectFunction : function(event,target){
		var fromList = target.parentElement.id == "sortableSec" ? "availableList" : "selectedList"; 
		var returnVal;
		if(this.getMethods("onSelect")){
			returnVal = this.executeMethod("onSelect",event,this.getElement(target),this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'),fromList);	
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	onDragFunction : function(event){
		var items;
		if(this.getData('ltPropMultiselect')){
			items = this.getData('multiSelectedItems');
		}
		else{
			items = this.getData('div');
		}
		if(this.getMethods("onDrag")){
			this.executeMethod("onDrag",event,items);	
		}
	},

	onBeforeDropFunction : function(event){
		var returnVal;
		var items = [];
		if(this.getData('ltPropMultiselect')){
			for(var i = 0; i<this.getData('multiSelectedItems').length ;i++){
				items.push(this.getElement(this.getData('multiSelectedItems')[i]));
			}
		}
		else{
			items.push(this.getElement(this.getData('div')));
		}
		this.setData("draggedItems",items);
		if(this.getMethods("onBeforeDrop")){
			returnVal = this.executeMethod("onBeforeDrop",event,items,this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'));	
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	onDropFunction : function(event){
		if(this.getMethods("onDrop")){
			this.executeMethod("onDrop",event,this.getData('draggedItems'),this.getData('availableList'),this.getData('selectedList'));	
		}
	},

	onClickFunction : function(event,element,fromList){
		var returnVal;
		var items = [];
		items.push(element);
		this.setData('draggedItems',items);
		if(this.getMethods("onClick")){
			returnVal = this.executeMethod("onClick",event,element,this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'),fromList);
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	 actions : {
	 	mouseDown : function(event){
	 		if(event.which == 3){
	 			return;
	 		}
	 		event.preventDefault();

	 		//Disable right click on the sortable elements to avoid unwanted behaviour
	 		if(event.which == 3){
	 			return;
	 		}
		 	var clickCount = this.getData('clickCount');
		 	clickCount++;
		 	this.setData('clickCount',clickCount);
		 	var self = this;
		    if (clickCount === 1) {
		        singleClickTimer = setTimeout(function() {
		            clickCount = 0;
		            self.setData('clickCount',clickCount);
		        }, 400);
		    } else if (clickCount === 2) {
		        clearTimeout(singleClickTimer);
		        clickCount = 0;
		        this.setData('clickCount',clickCount);
		        this.appendElement(event);
		        return;
		    }
	 		var target;
			var elem = event.target;
			// console.log(elem);
			if(elem.classList.contains('lyteDragDropAdd')){
				this.appendElement(event,'span');
			}
			else if(elem.classList.contains('lyteDragDropRemove')){
				this.appendElement(event,'span');
			}
			else{
				if(elem.tagName.toLowerCase() == 'span'){
					target = event.target.parentElement;
					// console.log(target);
				}
				else{
					target = event.target;
				}
			}
			
			if(target && this.selectFunction(event,target)){
				var targetOffset = target.getBoundingClientRect();
				var parentOffset = target.offsetParent.getBoundingClientRect();
				var height = target.clientHeight;
				var width = target.clientWidth;
				var multiSelectedItems = this.getData('multiSelectedItems');
				/*---- Multiple DragDrop ----*/
				if(this.getData('ltPropMultiselect')){
		 			if(multiSelectedItems.length > 0 && (multiSelectedItems.indexOf(target) != -1)){
						this.setData('offset',[
							event.clientX - targetOffset.left,
					        event.clientY - targetOffset.top
						]);
			 			this.setData('div',target);
						// console.log(this.getData('div'));
						var div = this.getData('div');
						var height = target.clientHeight;
						var width = target.clientWidth;
						// div.style.zIndex = 1001;
						div.style.left = (targetOffset.left - parentOffset.left) + 'px';
						div.style.top = (targetOffset.top - parentOffset.top) + 'px';
						// console.log('pointedItem left->',target.getBoundingClientRect().left)
						// console.log('pointedItem top->',target.getBoundingClientRect().top)
						div.style.boxSizing = "border-box";
						div.style.width = width +'px';
						div.style.height = height +'px';
						div.style.position = "absolute";
						div.classList.add('lyteDraggableElem');

						this.setData('placeholder',document.createElement('li'));
						var placeholder = this.getData('placeholder');
						placeholder.setAttribute("id","dummy");
						placeholder.style.width = width +'px';
						placeholder.style.height = height +'px';
						placeholder.style.boxSizing = "border-box";
						
						
						div.parentNode.insertBefore(placeholder, div);
						this.setData('checkSelection', true);
					}
					else{
						var keyValue = this.getData('keyValue');
			 			if(keyValue == 91 || keyValue == 93 || keyValue == 224){
			 				//console.log("here");
			 				//this.setData('keyValue',"");
		 					if(target.classList.contains('lyteDraggableElem')){
					    		target.classList.remove('lyteDraggableElem');
					    		this.removeFromArray(target);
					    	}
					    	else{
					    		target.classList.add('lyteDraggableElem');
					    		this.addToArray(target,'single');
					    	}

			 			}
			 			else if(keyValue == 16){
			 				//this.setData('keyValue',"");
		 					if(target.classList.contains('lyteDraggableElem')){
					    		target.classList.remove('lyteDraggableElem');
					    		this.addToArray(target,'multiple');
					    	}
					    	else{
					    		target.classList.add('lyteDraggableElem');
					    		this.addToArray(target,'multiple');
					    	}
			 			}
			 			else if(keyValue == 0){
		 					if(target.classList.contains('lyteDraggableElem')){
		 						if(this.getData('prevMode') == "multiple"){
		 							this.removeClass();
		 							this.setData('multiSelectedItems',[]);
						    		target.classList.add('lyteDraggableElem');
						    		this.getData('multiSelectedItems').push(target);
		 						}
		 						else{
		 							target.classList.remove('lyteDraggableElem');
					    			this.removeFromArray(target);
		 						}
		 						this.setData('prevMode','single');
					    	}
					    	else{
					    		this.removeClass();
					    		this.setData('multiSelectedItems',[]);
					    		target.classList.add('lyteDraggableElem');
					    		this.getData('multiSelectedItems').push(target);
					    		this.setData('prevMode','single');
					    	}
			 			}
			 			this.setData('offset',[
							event.clientX - targetOffset.left,
					        event.clientY - targetOffset.top
						]);
			 			this.setData('div',target);
						// console.log(this.getData('div'));
						var div = this.getData('div');
						var height = target.clientHeight;
						var width = target.clientWidth;
						// div.style.zIndex = 1001;
						div.style.left = (targetOffset.left - parentOffset.left) + 'px';
						div.style.top = (targetOffset.top - parentOffset.top) + 'px';
						// console.log('pointedItem left->',target.getBoundingClientRect().left)
						// console.log('pointedItem top->',target.getBoundingClientRect().top)
						div.style.boxSizing = "border-box";
						div.style.width = width +'px';
						div.style.height = height +'px';
						div.style.position = "absolute";
						div.classList.add('lyteDraggableElem');

						this.setData('placeholder',document.createElement('li'));
						var placeholder = this.getData('placeholder');
						placeholder.setAttribute("id","dummy");
						placeholder.style.width = width +'px';
						placeholder.style.height = height +'px';
						placeholder.style.boxSizing = "border-box";
						
						
						div.parentNode.insertBefore(placeholder, div);
			 		}
			 		this.setData('isDown',true);
				}
				 /*----Single drag and drop----*/
		 		 else{
		 			this.removeClass();
					//source = event.target;
					target.classList.add('lyteDraggableElem');
					this.setData('offset',[
						event.clientX - targetOffset.left,
				        event.clientY - targetOffset.top
					]);
					var isScrolled = false;
					
					this.setData('div',target);
					var div = this.getData('div');
					this.setData('isDown',true);//isDown = true;
					// div.style.zIndex = 1001;
					div.style.left = (targetOffset.left - parentOffset.left) + 'px';
					// var parentScrollTop = target.parentElement.scrollTop;
					// if(target.offsetTop > target.parentElement.offsetTop + target.parentElement.getBoundingClientRect().height){
					// 	div.style.top = (targetOffset.top - parentTop /*- parentScrollTop - height*/) + 'px';
					// 	// isScrolled = true;
					// }
					// else{
					div.style.top = (targetOffset.top - parentOffset.top) + 'px';
					// }
					// console.log('left->',target.getBoundingClientRect().left)
					// console.log('top->',target.getBoundingClientRect().top)
					div.style.boxSizing = "border-box";
					//debugger;
					div.style.width = width +'px';
					div.style.height = height +'px';
					div.style.position = "absolute";
					div.classList.add('lyteDraggableElem');

					this.setData('placeholder', document.createElement('li'));//placeholder = document.createElement('li');
					var placeholder = this.getData('placeholder');
					placeholder.setAttribute('id','dummy');
					
					placeholder.style.width = width +'px';
					placeholder.style.height = height +'px';
					placeholder.style.boxSizing = "border-box";
					
					
					div.parentNode.insertBefore(placeholder, div);
		 		}
		 		
				
		 		// this.selectFunction(event);
			}
			// console.log(this.getData('multiSelectedItems'));
		},

		mouseOver : function(event){
			// console.log(event.target);
			var target;
			var elem = event.target;
			if(elem.tagName.toLowerCase() == 'span'){
				target = event.target.parentElement;
				// console.log(target);
			}
			else{
				target = event.target;
			}
			if(target.classList.contains('lyteDraggableElem')){
				if(target.parentElement.id == "sortableSec"){
					if(target.querySelector('.lyteDragDropAdd')){
						target.querySelector('.lyteDragDropAdd').style.visibility = "hidden";
					}
				}
				if(target.parentElement.id == "dropSec"){
					if(target.querySelector('.lyteDragDropRemove')){
						target.querySelector('.lyteDragDropRemove').style.visibility = "hidden";
					}
				}
			}
			else{
				if(target.parentElement.id == "sortableSec"){
					if(target.querySelector('.lyteDragDropAdd')){
						target.querySelector('.lyteDragDropAdd').style.visibility = "visible";
					}
				}
				if(target.parentElement.id == "dropSec"){
					if(target.querySelector('.lyteDragDropRemove')){
						target.querySelector('.lyteDragDropRemove').style.visibility = "visible";
					}
				}
			}

		},

		mouseOut : function(event){
			var elem = event.target;
			if(elem.tagName.toLowerCase() == 'span'){
				target = event.target.parentElement;
				// console.log(target);
			}
			else{
				target = event.target;
			}
			if(target.parentElement.id == "sortableSec"){
				if(target.querySelector('.lyteDragDropAdd')){
					target.querySelector('.lyteDragDropAdd').style.visibility = "hidden";
				}
			}
			if(target.parentElement.id == "dropSec"){
				if(target.querySelector('.lyteDragDropRemove')){
					target.querySelector('.lyteDragDropRemove').style.visibility = "hidden";
				}
			}
		}	
	}


	
});

if (document.readyState === "complete" || document.readyState === "interactive"){
	addEvent();
}
else{
	document.addEventListener("DOMContentLoaded", function(event){
		addEvent(event);
	});
}

function addEvent(event){

var mousePosition;
var elemBelow;
var id;
var dropablePlace;
var prevTop = 0;
var component;
var side;
//console.log(component);
document.addEventListener('mouseup',function(event){
	var component;
	var target = event.target;
	while(target.parentElement){
		target = target.parentElement;
		if(target.tagName.toLowerCase() == 'lyte-dragdrop'){
			component=target.component;
			break;
		}
	}
	//component = component.component;
	if(component && component.getData('isDown')){
		component.setData('isDown',false);
		if(component.getData('isMoved')){
			component.setData('isMoved',false);
			var returnVal = component.onBeforeDropFunction(event);
			if(returnVal){
				if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1 ){
					var placeholder = component.getData('placeholder');
					// console.log(placeholder);
					// console.log(placeholder.getBoundingClientRect().left)
					// console.log(placeholder.getBoundingClientRect().top)
					//debugger
					var placeholderOffset = placeholder.getBoundingClientRect();
					var multiSelectedItems = component.getData('multiSelectedItems');
					for(var v =0; v<multiSelectedItems.length ;v++){
						multiSelectedItems[v].style.visibility = "hidden";
					}
					var elem = document.elementFromPoint(placeholderOffset.left,placeholderOffset.top - 4);
					for(var v =0; v<multiSelectedItems.length ;v++){
						multiSelectedItems[v].style.visibility = "visible";
					}
					// console.log(elem);
					var parentListOfObjects = multiSelectedItems[0].parentElement.id == "sortableSec" ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var parentListOfPlaceholder = placeholder.parentElement.id == "sortableSec" ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var objects = [];
					for(var v = 0; v <multiSelectedItems.length ; v++){
						objects.push(component.getElement(multiSelectedItems[v]));
					}
					for(var i = 0 ; i < objects.length ; i++){
						Lyte.arrayUtils(component.getData(parentListOfObjects),'removeAt',component.getElementPosition(component.getData(parentListOfObjects),objects[i]),1);
					}
					var prevEle = placeholder.previousElementSibling;
					while(prevEle && prevEle.tagName == "TEMPLATE"){
						prevEle = prevEle.previousElementSibling;
					}
					if(prevEle){
						Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(prevEle))+1,objects);
					}
					else{
						var nextEle = placeholder.nextElementSibling;
						while(nextEle && nextEle.tagName == "TEMPLATE"){
							nextEle = nextEle.nextElementSibling;
						}
						if(nextEle){
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(nextEle)),objects);
						}
						else{
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'push',objects);
						}
					}

					placeholder.parentElement.removeChild(placeholder);
					component.setData('multiSelectedItems',[]);
					component.setData('prevMode','');
					component.setData('keyPressed',false);
					component.setData('keyValue','');
					component.setData('placeholder','');
					component.generateArray();
					prevTop = 0;
				}
				else{
					var div = component.getData('div');
					var elemData = component.getElement(div);
					// component.getData('placeholder').parentElement.replaceChild(div,component.getData('placeholder'));
					var placeholder = component.getData('placeholder');
					var prevEle = placeholder.previousElementSibling;
					var parentListOfDiv = div.parentElement.id == 'sortableSec' ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var parentListOfPlaceholder = placeholder.parentElement.id == 'sortableSec' ? "ltPropAvailablelist" : "ltPropSelectedlist";
					while(prevEle && prevEle.tagName == "TEMPLATE"){
						prevEle = prevEle.previousElementSibling;
					}
					if(prevEle){
						Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
						Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(prevEle))+1,elemData);
					}
					else{
						var nextEle = placeholder.nextElementSibling;
						while(nextEle && (nextEle.tagName == "TEMPLATE" || nextEle.isEqualNode(div))){
							nextEle = nextEle.nextElementSibling;
						}
						if(nextEle){
							Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(nextEle)),elemData);
						}
						else{
							Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'push',elemData);
						}
					}
					if(component.$node.querySelector('#sortableSec').contains(component.$node.querySelector('#dummy'))){
			    		component.$node.querySelector('#sortableSec').removeChild(component.$node.querySelector('#dummy'));
			    	}
			    	if( component.getData('ltPropDraggable') && component.$node.querySelector('#dropSec').contains(component.$node.querySelector('#dummy'))){
			    		component.$node.querySelector('#dropSec').removeChild(component.$node.querySelector('#dummy'));
			    	}
			    	// component.removeStyle(div);
			    	// div.classList.remove('lyteDraggableElem');
					component.removeDropable(div);
				    component.generateArray();
				}
				component.onDropFunction(event);
			}
			else{
				if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1 ){
					var multiSelectedItems = component.getData('multiSelectedItems');
					for(var i = 0; i<multiSelectedItems.length;i++){
						component.removeStyle(multiSelectedItems[i]);
						multiSelectedItems[i].classList.remove('lyteDraggableElem');
					}
					component.removeDropableMultiple(multiSelectedItems);
					component.setData('multiSelectedItems',[]);
					component.setData('prevMode','');
					component.setData('keyPressed',false);
					component.setData('keyValue','');
					component.setData('placeholder','');
					prevTop = 0;
				}
				else{
					component.removeStyle(component.getData('div'));
			    	component.getData('div').classList.remove('lyteDraggableElem');
					component.removeDropable(component.getData('div'));
				}
				component.getData('placeholder').remove();
			}
		}
		else{
			var div = component.getData('div');
			component.getData('placeholder').parentElement.replaceChild(div,component.getData('placeholder'));
			if(component.$node.querySelector('#sortableSec').contains(component.$node.querySelector('#dummy'))){
	    		component.$node.querySelector('#sortableSec').removeChild(component.$node.querySelector('#dummy'));
	    	}
	    	if( component.getData('ltPropDraggable') && component.$node.querySelector('#dropSec').contains(component.$node.querySelector('#dummy'))){
	    		component.$node.querySelector('#dropSec').removeChild(component.$node.querySelector('#dummy'));
	    	}
			component.removeStyle(div);
			if(component.getData('checkSelection')){
				var keyValue = component.getData('keyValue');
				if(keyValue == 91 || keyValue == 93 || keyValue == 224){
					div.classList.remove('lyteDraggableElem');
					component.removeFromArray(div);
				}
				if(keyValue == 16){
					component.removeClass();
					component.setData('multiSelectedItems',[]);
					component.addToArray(div,"multiple");
					component.setData('prevMode','multiple');
				}
				if(keyValue == 0){
					component.removeClass();
					component.setData('multiSelectedItems',[]);
					component.getData('multiSelectedItems').push(div);
					// component.setData('multiSelectedItems',);
					div.classList.add('lyteDraggableElem');
					component.setData('prevMode','single');
				}
				component.setData('checkSelection',false);
			}
		}
	}
	else{
		var selectedElems = document.querySelectorAll('.lyteDraggableElem');
		if(selectedElems){
			for(var i = 0;i<selectedElems.length;i++){
				selectedElems[i].classList.remove('lyteDraggableElem');
			}
		}
	}
},false);

document.addEventListener('mousemove',function(event){
	//console.log("Here mouse move");
	var component;
	var target = event.target;
	while(target.parentElement){
		//console.log(target.parentElement);
		target = target.parentElement;
		if(target.tagName.toLowerCase() == 'lyte-dragdrop'){
			component=target.component;
			break;
		}
	}
	//component = component.component;
	if(component && component.getData('isDown')){
		component.setData('isMoved',true);
		// if(component.getData('ltPropDraggable')){
			var div = component.getData('div');
			var parentOffset = div.offsetParent.getBoundingClientRect();
			var divOffset = div.getBoundingClientRect();
			var width = divOffset.width;
			var height = divOffset.height;
			mousePosition = {
	            x : event.clientX,
	            y : event.clientY
	        };
	        div.style.left = (mousePosition.x - component.getData('offset')[0]) - parentOffset.left + 'px';
		    div.style.top  = (mousePosition.y - component.getData('offset')[1]) - parentOffset.top + 'px';
			if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1){
			
				var multiSelectedItems = component.getData('multiSelectedItems');
				var index = multiSelectedItems.indexOf(div);
				
		        for(var v = index-1 ; v >= 0 ; v--){
		        	multiSelectedItems[v].style.left = div.offsetLeft + 'px' ;
		        	multiSelectedItems[v].style.top = (multiSelectedItems[v+1].offsetTop - height) + 'px';
		        	// multiSelectedItems[v].style.zIndex = 1001;
		        	multiSelectedItems[v].style.boxSizing = "border-box";
		        	multiSelectedItems[v].style.width = width + 'px';
		        	multiSelectedItems[v].style.height = height + 'px';
		        	multiSelectedItems[v].style.position = "absolute";
		        	multiSelectedItems[v].classList.add('lyteDraggableElem');
		        }
		        for(var v = index+1 ; v < multiSelectedItems.length ; v++){
		        	multiSelectedItems[v].style.left = div.offsetLeft + 'px';
		        	multiSelectedItems[v].style.top = (multiSelectedItems[v-1].offsetTop + height) + 'px';
		        	// multiSelectedItems[v].style.zIndex = 1001;
		        	multiSelectedItems[v].style.boxSizing = "border-box";
		        	multiSelectedItems[v].style.width = width + 'px';
		        	multiSelectedItems[v].style.height = height + 'px';
		        	multiSelectedItems[v].style.position = "absolute";
		        	multiSelectedItems[v].classList.add('lyteDraggableElem');
		        }

		        var placeholder = component.getData('placeholder');
		        var totalHeight = multiSelectedItems.length * height;
		        if(totalHeight > placeholder.getBoundingClientRect().height){
		        	if(document.getElementById('sortableSec').contains(document.getElementById('dummy'))){
			    		document.getElementById('sortableSec').removeChild(document.getElementById('dummy'));
			    	}
			    	if(component.getData('ltPropDraggable') && document.getElementById('dropSec').contains(document.getElementById('dummy'))){
			    		document.getElementById('dropSec').removeChild(document.getElementById('dummy'));
			    	}
			    	placeholder.style.height = totalHeight + 'px';
			    	placeholder.classList.add('lyteDragDropDropable');
			    	component.setData('placeholder',placeholder);
			    	div.parentElement.insertBefore(component.getData('placeholder'),div);
		        }
		        var top = component.getTopNBottom('top');
		        var bottom = component.getTopNBottom('bottom');
		        var placeholderOffset = placeholder.getBoundingClientRect();
		        var placeholderParentOffset = placeholder.parentElement.getBoundingClientRect();
		        divOffset = div.getBoundingClientRect();
		        
		        //for scrolling top or bottom
		        if(top < placeholderParentOffset.top){
		        	// console.log("scrolling up");
		        	if((placeholder.parentElement.scrollTop > 0) && (placeholder.parentElement.scrollTop <= (placeholder.parentElement.scrollHeight - placeholderParentOffset.height)) ){
		        		placeholder.parentElement.scrollTop -= placeholderParentOffset.top - top;
		        	}
		        }
		        if(bottom > placeholderParentOffset.bottom){
		        	// console.log("scrolling down");
		        	if(placeholder.parentElement.scrollTop <= placeholder.parentElement.scrollHeight - placeholderParentOffset.height ){
		        		placeholder.parentElement.scrollTop += bottom - placeholderParentOffset.bottom;
		        	}
		        }

		        component.makeDroppableMultiple(multiSelectedItems);

		        elementAtLeft = document.elementFromPoint(divOffset.left - 1, event.clientY);
		        elementAtRight = document.elementFromPoint(divOffset.right + 1, event.clientY);

		        // console.log("leftEle" , elementAtLeft);
		        // console.log("rightEle" , elementAtRight);
		        
		        dropablePlaceLeft = elementAtLeft.closest('.dropable');
		        dropablePlaceRight = elementAtRight.closest('.dropable');

		        if(!component.getData('left') && dropablePlaceLeft && (divOffset.left < (dropablePlaceLeft.getBoundingClientRect().right - divOffset.width / 2))){
					// console.log("inside left");
					
					if(divOffset.bottom > dropablePlaceLeft.getBoundingClientRect().bottom){
						
						dropablePlaceLeft.after(placeholder);
					}
					else{
						
						dropablePlaceLeft.parentElement.insertBefore(placeholder,dropablePlaceLeft);
					}
					component.setData('left',true);
					component.setData('right',false);
					side = "left";
				}
				else if(!component.getData('right') && dropablePlaceRight && (divOffset.right > (dropablePlaceRight.getBoundingClientRect().left + divOffset.width / 2))){
					// console.log("inside right");
					if(divOffset.bottom > dropablePlaceRight.getBoundingClientRect().bottom){
						
						dropablePlaceRight.after(placeholder);
					}
					else{
						
						dropablePlaceRight.parentElement.insertBefore(placeholder,dropablePlaceRight);
					}
					component.setData('right',true);
					component.setData('left',false);
					side = "right";
					
				}
				else if(elementAtLeft && component.checkElement(elementAtLeft) && component.checkPossiblePosition(elementAtLeft,"multiple") && (divOffset.left < (elementAtLeft.getBoundingClientRect().right - divOffset.width / 2))){
					
					elementAtLeft.appendChild(placeholder);
					component.setData('left',false);
					component.setData('right',false);
				}
				else if(elementAtRight && component.checkElement(elementAtRight) && component.checkPossiblePosition(elementAtRight,"multiple") && (divOffset.right > (elementAtRight.getBoundingClientRect().left + divOffset.width / 2))){
					
					elementAtRight.appendChild(placeholder);
					component.setData('left',false);
					component.setData('right',false);
				}
				else{
					// console.log("inside else");
					if(top < prevTop){
						// if(side){
							if(side == "left"){
								elemBelow = document.elementFromPoint(divOffset.left,top-1);
							}
							else if(side == "right"){
								elemBelow = document.elementFromPoint(divOffset.right,top-1);	
							}
							else{
								elemBelow = document.elementFromPoint(event.clientX,top-1);
							}
						// }
		        		if(!elemBelow){
		        			return;
		        		}
		        		dropablePlace = elemBelow.closest('.dropable');
		        		// console.log(dropablePlace);
		        		if(dropablePlace && (divOffset.left > (dropablePlace.parentElement.getBoundingClientRect().right - divOffset.width / 2) ||
							divOffset.right <(dropablePlace.parentElement.getBoundingClientRect().left + divOffset.width / 2))){
							// console.log("getting return");
							return
						}
						// console.log("top",dropablePlace);
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(top < dropablePlace.getBoundingClientRect().bottom - 16){
		        				// console.log("going up");
		        	
						    	dropablePlace.parentElement.insertBefore(placeholder,dropablePlace);
		        			}
		        		}
		        		if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"multiple")){
		        			// console.log("top",elemBelow);
		        			elemBelow.appendChild(placeholder);
		        		}
			        }
		        	else{
		        		
							if(side == "left"){
								elemBelow = document.elementFromPoint(divOffset.left,bottom+1);
							}
							else if(side == "right"){
								elemBelow = document.elementFromPoint(divOffset.right,bottom+1);	
							}
							else{
								elemBelow = document.elementFromPoint(event.clientX,bottom+1);
							}
						
		        		if(!elemBelow){
		        			return;
		        		}
		        		
		        		dropablePlace = elemBelow.closest('.dropable');
		        		if(dropablePlace && (divOffset.left > (dropablePlace.parentElement.getBoundingClientRect().right - divOffset.width / 2) ||
							divOffset.right <(dropablePlace.parentElement.getBoundingClientRect().left + divOffset.width / 2))){
							// console.log("getting return");
							return
						}
						// console.log("down",dropablePlace);
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(bottom >= dropablePlace.getBoundingClientRect().top + 16){
		        				// console.log('going down');
		        	
						    	dropablePlace.after(placeholder);
		        			}
		        		}
		        		if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"multiple")){
		        			// console.log("down",elemBelow);
		        			elemBelow.appendChild(placeholder);
		        		}
		        	}
				}
				// console.log("left ====>" + component.getData('placeholder').getBoundingClientRect().left);
		  //       console.log("top ====>" + component.getData('placeholder').getBoundingClientRect().top);
		        prevTop = top;
			}
			

			/*---Single drag and drop----*/
			else{
				// var div = component.getData('div');
				// mousePosition = {
		  //           x : event.clientX,
		  //           y : event.clientY
		  //       };
		        // var parent = div.offsetParent;
		        // div.style.left = (mousePosition.x - component.getData('offset')[0]) - parentOffset.left + 'px';
		        // div.style.top  = (mousePosition.y - component.getData('offset')[1]) - parentOffset.top + 'px';
		        //div.parentNode.insertBefore(component.getData('placeholder'), div);
		        var placeholder = component.getData('placeholder');
		        var placeholderParentOffset = placeholder.parentElement.getBoundingClientRect();
		        divOffset = div.getBoundingClientRect();
		        if(divOffset.top < placeholderParentOffset.top){
		        	if((placeholder.parentElement.scrollTop > 0) && (placeholder.parentElement.scrollTop <= (placeholder.parentElement.scrollHeight - placeholderParentOffset.height)) ){
		        		placeholder.parentElement.scrollTop -= placeholderParentOffset.top - divOffset.top;
		        	}
		        }
		        if(divOffset.bottom > placeholderParentOffset.bottom){
		        	if(placeholder.parentElement.scrollTop <= placeholder.parentElement.scrollHeight - placeholderParentOffset.height ){
		        		placeholder.parentElement.scrollTop += divOffset.bottom - placeholderParentOffset.bottom;
		        	}
		        }

		        component.makeDroppable(div);

		        elementAtLeft = document.elementFromPoint(divOffset.left - 1, event.clientY);
		        elementAtRight = document.elementFromPoint(divOffset.right + 1, event.clientY);

		        // console.log("leftEle" , elementAtLeft);
		        // console.log("rightEle" , elementAtRight);
		        droppableLeft = elementAtLeft.closest('.dropable');
		        droppableRight = elementAtRight.closest('.dropable');


		        maxAllowableWidth = divOffset.width / 2;

		        if(droppableLeft && (divOffset.left < (droppableLeft.getBoundingClientRect().right - maxAllowableWidth))){
		        	// console.log("inside left");
		        	if(divOffset.bottom > droppableLeft.getBoundingClientRect().bottom){
		        		droppableLeft.after(placeholder);
		        	}
		        	else{
		        		droppableLeft.parentElement.insertBefore(placeholder,droppableLeft);
		        	}
		        }
		        else if(droppableRight && (divOffset.right > (droppableRight.getBoundingClientRect().left + maxAllowableWidth))){
		        	// console.log("inside right");
		        	if(divOffset.bottom > droppableRight.getBoundingClientRect().bottom){
		        		droppableRight.after(placeholder);
		        	}
		        	else{
		        		droppableRight.parentElement.insertBefore(placeholder,droppableRight);
		        	}
		        }
		        else if(elementAtLeft && component.checkElement(elementAtLeft) && component.checkPossiblePosition(elementAtLeft,"single") && (divOffset.left < (elementAtLeft.getBoundingClientRect().right - maxAllowableWidth))){
		        	// console.log("inside parent left");
		        	elementAtLeft.appendChild(placeholder);
		        }
		        else if(elementAtRight && component.checkElement(elementAtRight) && component.checkPossiblePosition(elementAtRight,"single") && (divOffset.right > (elementAtRight.getBoundingClientRect().left + maxAllowableWidth))){
		        	// console.log("inside parent right");
		        	elementAtRight.appendChild(placeholder);
		        }
		        else{
		        	// console.log("inside here");
		        	div.style.visibility = "hidden";
		        	elemBelow = document.elementFromPoint(event.clientX,event.clientY);
		        	div.style.visibility = "visible";

		        	if(!elemBelow){
		        		return;
		        	}

		        	dropablePlace = elemBelow.closest('.dropable');
		        	if(dropablePlace && (divOffset.left > (dropablePlace.getBoundingClientRect().right - maxAllowableWidth) || divOffset.right < (dropablePlace.getBoundingClientRect().left + maxAllowableWidth))){
		        		return;
		        	}
		        	else{
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(divOffset.top < dropablePlace.getBoundingClientRect().top){
		        				dropablePlace.parentElement.insertBefore(placeholder,dropablePlace);
		        			}
		        			if(divOffset.bottom > dropablePlace.getBoundingClientRect().bottom){
		        				dropablePlace.after(placeholder);
		        			}
		        		}
		        	}
		        	if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"single")){
	        			// console.log(elemBelow);
	        			elemBelow.appendChild(placeholder);
	        		}
		        }
				component.getData('placeholder').classList.add('lyteDragDropDropable');
			}
		component.onDragFunction(event);
	}


},false);

// document.addEventListener('dragstart',function(event){
// 	event.preventDefault();
// },false);


document.addEventListener('keydown',function(event){
	var component = document.querySelectorAll('lyte-dragdrop');
	for(var v = 0; v<component.length; v++){
		var elem = component[v].component;
		elem.setData('keyPressed',true);
		var keyValue = event.which;
		elem.setData('keyValue',keyValue);
		// console.log(keyValue);
	}
	
},false);

document.addEventListener('keyup',function(event){
	var component = document.querySelectorAll('lyte-dragdrop');
	for(var v = 0; v<component.length; v++){
		var elem = component[v].component;
		elem.setData('keyPressed',false);
		elem.setData('keyValue',0);
	}
	
},false);

};


/**
 * Renders a dropdown
 * @component lyte-dropdown
 * @version 1.0.0
 * @utility toggle,resetPosition,open,close
 * @methods onShow,onBeforeShow,onScroll,onPositionChanged,onChange,beforeSelect,onHide,onBeforeHide,onAdd,onBeforeAdd,onRemove,onBeforeRemove,onOptionSelected
 * @dependencies lyte-tooltip
 */

 // _preventSetCSS has external depedency - pk - dateselect

Lyte.Component.register( 'lyte-dropdown', {
_template:"<template tag-name=\"lyte-dropdown\"> <template is=\"if\" value=\"{{expHandlers(ltPropHover,'==',true)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(multiple,'==',true)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(search,'==',true)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\"> <lyte-drop-button aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\" aria-haspopup=\"listbox\"> <div class=\"lyteMultiselect\"> <ul class=\"lyteMultipleSelect\"> <template is=\"for\" items=\"{{ltPropSelectedList}}\" item=\"item\" index=\"indexVal\"> <li data-value=\"{{lyteUiReturnValueBy(item,sysValue)}}\"> <span class=\"lyteDropdownVisible\" onmouseenter=\"{{action('toolTipConfig',this,'selToolTip')}}\" lt-prop-title=\"{{if(selToolTip,lyteUiReturnValueBy(item,userValue),'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\">{{lyteUiReturnValueBy(item,userValue)}}</span> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </li> </template> <li class=\"lyteMultiselectInput\"> <input onkeydown=\"{{action('preventDefault',event)}}\" type=\"text\" placeholder=\"{{ltPropPlaceholder}}\" class=\"lyteDropdownTextField\" autocomplete=\"off\" tabindex=\"{{ltPropTabindex}}\" onclick=\"{{action('showHide',event)}}\"> </li> </ul> </div> <template is=\"if\" value=\"{{shouldDisplayIcon}}\"><template case=\"true\"> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </template></template> </lyte-drop-button> </template><template case=\"false\"> </template></template> </template><template case=\"false\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <div class=\"lyteDummyEventContainer\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\" onclick=\"{{action('showHide',event)}}\" onkeyup=\"{{action('checkKey',event)}}\" tabindex=\"{{ltPropTabindex}}\"> <lyte-drop-button> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropSelectedList.length,'==',0),'&amp;&amp;',expHandlers(ltPropForcePlaceholder,'!'))}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span> </template></template> <ul class=\"lyteMultipleSelect\"> <template is=\"for\" items=\"{{ltPropSelectedList}}\" item=\"item\" index=\"indexVal\"> <li data-value=\"{{lyteUiReturnValueBy(item,sysValue)}}\"> <span class=\"lyteDropdownVisible\" onmouseenter=\"{{action('toolTipConfig',this,'selToolTip')}}\" lt-prop-title=\"{{if(selToolTip,lyteUiReturnValueBy(item,userValue),'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\">{{lyteUiReturnValueBy(item,userValue)}}</span> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </li> </template> </ul> <template is=\"if\" value=\"{{ltPropForcePlaceholder}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span> </template></template> <template is=\"if\" value=\"{{shouldDisplayIcon}}\"><template case=\"true\"> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </template></template> </lyte-drop-button> </div> </template><template case=\"false\"> </template></template> </template></template> </template><template case=\"false\"> <div onmouseenter=\"{{action('showHide',event,'enter')}}\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\" onmouseleave=\"{{action('closeIt',event)}}\" class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabindex}}\" style=\"\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <lyte-drop-button> <template is=\"if\" value=\"{{ltPropDisplayValue}}\"><template case=\"true\"> <span class=\"lyteMarginRight lyteDropdownLabel\" onmouseenter=\"{{action('toolTipConfig',this,'showToolTip')}}\" lt-prop-title=\"{{if(showToolTip,ltPropDisplayValue,'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\">{{ltPropDisplayValue}}</span> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropSelected,'!'),'&amp;&amp;',expHandlers(ltPropDisplayValue,'!'))}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderNormal\">{{ltPropPlaceholder}}</span> </template></template></template></template> <template is=\"if\" value=\"{{expHandlers(ltPropSelected,'&amp;&amp;',ltPropShowRemoveIcon)}}\"><template case=\"true\"> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </template></template> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </lyte-drop-button> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;yield&quot;)}}\"><template case=\"true\"> </template></template></template></template> </div> </template></template> </template><template case=\"false\"> <template is=\"if\" value=\"{{expHandlers(multiple,'==',true)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(search,'==',true)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\"> <lyte-drop-button onclick=\"{{action('showHide',event)}}\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\"> <div class=\"lyteMultiselect\"> <ul class=\"lyteMultipleSelect\"> <template is=\"for\" items=\"{{ltPropSelectedList}}\" item=\"item\" index=\"indexVal\"> <li data-value=\"{{lyteUiReturnValueBy(item,sysValue)}}\"> <span class=\"lyteDropdownVisible\" onmouseenter=\"{{action('toolTipConfig',this,'selToolTip')}}\" lt-prop-title=\"{{if(selToolTip,lyteUiReturnValueBy(item,userValue),'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\">{{lyteUiReturnValueBy(item,userValue)}}</span> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </li> </template> <li class=\"lyteMultiselectInput\"> <input onkeydown=\"{{action('preventDefault',event)}}\" type=\"text\" placeholder=\"{{ltPropPlaceholder}}\" class=\"lyteDropdownTextField\" autocomplete=\"off\" tabindex=\"{{ltPropTabindex}}\"> </li> </ul> </div> <template is=\"if\" value=\"{{shouldDisplayIcon}}\"><template case=\"true\"> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </template></template> </lyte-drop-button> </template><template case=\"false\"> <div class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabindex}}\" style=\"\" onclick=\"{{action('showHide',event)}}\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\"> </div> </template></template> </template><template case=\"false\"> <div class=\"lyteDummyEventContainer\" onclick=\"{{action('showHide',event)}}\" tabindex=\"{{ltPropTabindex}}\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <lyte-drop-button> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropSelectedList.length,'==',0),'&amp;&amp;',expHandlers(ltPropForcePlaceholder,'!'))}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span> </template></template> <ul class=\"lyteMultipleSelect\"> <template is=\"for\" items=\"{{ltPropSelectedList}}\" item=\"item\" index=\"indexVal\"> <li data-value=\"{{lyteUiReturnValueBy(item,sysValue)}}\"> <span class=\"lyteDropdownVisible\" onmouseenter=\"{{action('toolTipConfig',this,'selToolTip')}}\" lt-prop-title=\"{{if(selToolTip,lyteUiReturnValueBy(item,userValue),'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\">{{lyteUiReturnValueBy(item,userValue)}}</span> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </li> </template> </ul> <template is=\"if\" value=\"{{ltPropForcePlaceholder}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span> </template></template> <template is=\"if\" value=\"{{shouldDisplayIcon}}\"><template case=\"true\"> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </template></template> </lyte-drop-button> </template><template case=\"false\"> </template></template> </div> </template></template> </template><template case=\"false\"> <div onclick=\"{{action('showHide',event)}}\" class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabindex}}\" style=\"\" aria-haspopup=\"listbox\" aria-expanded=\"{{if(ltPropIsOpen,'true','false')}}\"> <template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <lyte-drop-button> <template is=\"if\" value=\"{{ltPropDisplayValue}}\"><template case=\"true\"> <span onmouseenter=\"{{action('toolTipConfig',this,'showToolTip')}}\" lt-prop-tooltip-config=\"{{ltPropTooltip}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\" lt-prop-title=\"{{if(showToolTip,ltPropDisplayValue,'')}}\" class=\"lyteMarginRight lyteDropdownLabel\">{{ltPropDisplayValue}}</span> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropSelected,'!'),'&amp;&amp;',expHandlers(ltPropDisplayValue,'!'))}}\"><template case=\"true\"> <span class=\"lyteDropPlaceholderNormal\">{{ltPropPlaceholder}}</span> </template></template></template></template> <template is=\"if\" value=\"{{expHandlers(ltPropSelected,'&amp;&amp;',ltPropShowRemoveIcon)}}\"><template case=\"true\"> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </template></template> <lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon> </lyte-drop-button> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(drophead,'==',&quot;yield&quot;)}}\"><template case=\"true\"> </template></template></template></template> </div> </template></template> </template></template> <template is=\"if\" value=\"{{expHandlers(ltPropHover,'==',false)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(dropbody,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <lyte-drop-box class=\"lyteDropdownHidden\"> <lyte-drop-body> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\"> <lyte-drop-group> <lyte-drop-label>{{lyteUiReturnOnlyKey(item)}}</lyte-drop-label> <template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteUiReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\"> <template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{subitem[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem[ltPropSystemValue])}}\">{{subitem[ltPropUserValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{subitem}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem)}}\">{{subitem}}</lyte-drop-item> </template></template> </template> </lyte-drop-group> </template><template case=\"false\"> <template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{item[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item[ltPropSystemValue])}}\">{{item[ltPropUserValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{item}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item)}}\">{{item}}</lyte-drop-item> </template></template> </template></template> </template> </lyte-drop-body> </lyte-drop-box> </template><template case=\"false\"> </template></template> <div class=\"lyteLoadMsg\" style=\"display:none;\">Loading</div> </template><template case=\"false\"> <template is=\"if\" value=\"{{expHandlers(dropbody,'==',&quot;noyield&quot;)}}\"><template case=\"true\"> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\"> <lyte-drop-group> <lyte-drop-label>lyteUiReturnOnlyKey(item)</lyte-drop-label> <template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\"> <template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{subitem[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem[ltPropSystemValue])}}\">{{subitem[ltPropUserValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{subitem}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem)}}\">{{subitem}}</lyte-drop-item> </template></template> </template> </lyte-drop-group> </template><template case=\"false\"> <template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\"> <lyte-drop-item data-value=\"{{item[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item[ltPropSystemValue])}}\">{{item[ltPropUserValue]}}</lyte-drop-item> </template><template case=\"false\"> <lyte-drop-item data-value=\"{{item}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item)}}\">{{item}}</lyte-drop-item> </template></template> </template></template> </template> </lyte-drop-body> </lyte-drop-box> </template><template case=\"false\"> </template></template> <div class=\"lyteLoadMsg\" style=\"display:none;\">Loading</div> </template></template> <lyte-yield yield-name=\"yield\" style=\"display: none;\" lyte-options=\"{{ltPropOptions}}\"></lyte-yield> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"for","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"attr","position":[1,1,1,3,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,1,3,1]},{"type":"for","position":[1,1,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,1,7]},{"type":"if","position":[1,1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"componentDynamic","position":[1,5]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"for","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"attr","position":[1,1,1,3,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"for","position":[1,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[1,5]},{"type":"componentDynamic","position":[1,5]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}},{"type":"attr","position":[5]},{"type":"insertYield","position":[5]}],
_observedAttributes :["shouldDisplayIcon","changeItToInvoke","dummy1","dummy2","savedPositions","ltPropRemoveMultiple","ltPropYield","ltPropType","ltPropTabindex","ltPropShow","ltPropFreeze","ltPropOptions","ltPropUserValue","ltPropSystemValue","ltPropPosition","ltPropIconClass","ltPropSelected","ltPropCallout","ltPropPlaceholder","ltPropDisabled","ltPropHover","ltPropNoResult","ltPropMaxCount","ltPropInputClass","ltPropBoundary","pos","secondaryPosition","firePos","ltPropAjaxRequest","firstRequest","userValue","sysValue","ltPropDisplayValue","ltPropDisabledList","ltPropAnimate","ltPropSetPos","ltPropTooltip","ltPropBoxClass","ltPropIsOpen","ltPropFocus","ltPropFixPositionOnOpen","ltPropForcePlaceholder","ltPropShowEmptyMessage","ltPropBoxButtonWidth","ltPropPreventScroll","ltPropScope","ltPropAnimateBox","ltPropTooltipClass","ltPropDisplayList","ltPropSelectedList","searchMethod","ltPropFocusOnClose","ltPropButtonClass","ltPropDisableItemTooltip","ltPropPreventParentScroll","ltPropShowRemoveIcon"],
	init: function() {
		var type = this.getData( 'ltPropType' ),
		sel = this.getData( 'ltPropSelected' );
		this._close = this.closeDrop1.bind( this );

		this._transEnd = this.tranEnd.bind( this );
		// if( !Lyte.Component.registeredHelpers.lyteUiIsEmptyObject( this.getData( 'ltPropAjaxRequest' ) ) ) {
		// 	this.fetchData();
		// }

		if( this.getData( 'ltPropPreventParentScroll' ) ) {
			this.setData( 'ltPropFreeze', false );
		}

		if( !document.getElementById( 'lytedropdownfreezelayer' ) ) {
			var fzl ;
			fzl = document.createElement( 'div' );
			fzl.setAttribute( 'id', 'lytedropdownfreezelayer' );
			fzl.style.display = 'none';
			fzl.style.opacity = '0.01';
			fzl.style.background = '#fff';
			document.body.appendChild( fzl );
		}

		this.$node.resetPosition = function() {
			var comp = this.component,
			shouldUseSave = comp.getData( 'ltPropFixPositionOnOpen' );

			comp.setCss( false, shouldUseSave );
		}

		// Create toggle function
		this.$node.toggle = function( event, type ) {
			var val = event ? event : undefined;
			if( this.component.getData( 'ltPropDisabled' ) ) {
				return ;
			}

			this.constructor._actions.showHide.call(this.component, val, type, true);
		}

		this.$node.getDropBox = function() {
			var component = this.component;

			return component.getDropBox();
		}

		this.$node.open = function() {
			var component = this.component,
			isOpen = component.getData( 'ltPropIsOpen' );

			if( !isOpen ) {
				this.toggle();
			}
		}

		this.$node.close = function() {
			var component = this.component,
			isOpen = this.getData( 'ltPropIsOpen' );

			if( isOpen ) {
				this.toggle();
			}

		}

		this.$node.getInitialSelected = function( options ) {
			var component = this.component;

			component.setInitialSelected( options );

			return component.getData( 'ltPropSelected' );
		}

		this.$node.getDisplayValue = function() {
			var component = this.component,
			link = component.childComp,
			body = component.getDropBody( link ),
			sel = component.getData( 'ltPropSelected' ),
			node;

			if( sel ) {
				node = body.querySelector( '[data-value="' + window._lyteUiUtils.escape( sel ) + '"]' );

				if( node ) {
					return node.textContent.trim();
				}
			}

			return '';
		}

		this.$node.closeError = function() {
			var component = this.component, 
			link = component.childComp,
			drophead = component.getData( 'drophead' ),
			body = component.getDropBody( link ),
			nodes = body.querySelectorAll( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' );

			if( nodes.length !== 0 ) {
				component.closeError( link, drophead );
			}	
		}


		if( type.indexOf( 'multiple' ) !== -1 
			|| type.indexOf( 'multisearch' ) !== -1 
		) {
			this.setData( 'multiple', true );

			if( !sel ) {
				this.setData( 'ltPropSelected', '[]' );
			}

			if( type.indexOf('multisearch') !== -1 ) {
				this.setData( 'search', true );
			}

			this.setIterator();
		}
	},

	setIterator: function() {
		var userValue = this.getData( 'ltPropUserValue' ),
		sysValue = this.getData( 'ltPropSystemValue' );

		this.setData( 'userValue', userValue ? userValue : 'display' );
		this.setData( 'sysValue', sysValue ? sysValue : 'value' );
	},

	didDestroy: function() {
		var body = this.childComp,
		mut = this.$node.mutobserver,
		freeze = this.getData( 'ltPropFreeze' ),
		scrollsToPrevent = this.getData( 'ltPropPreventScroll' );

		if( body ) {

			// If a dropdown is getting destroyed when it is open, then we hide the freeze layer set because of it
			if( !body.classList.contains( 'lyteDropdownHidden' )
				&& freeze 
				&& scrollsToPrevent === 'all'
			 ) {
				document.getElementById( 'lytedropdownfreezelayer' ).style.display = 'none';
			}

			if( !body.classList.contains( 'lyteDropdownHidden' ) && document.body ) {
				document.body.classList.remove( 'lyteBodyWrapper' );
			}

			delete body.origindd;
			body.remove();
		}

		if( mut ) {
			mut.disconnect()
		}

		this.disableParentListeners();

		// Flush autoClosed when the autoClosed dropdown is getting destroyed
		if( _lyteDropdown.autoClosed === this.$node ) {
			_lyteDropdown.autoClosed = null;
		}

		if( _lyteDropdown.lastDropdownWithAPromise === this.$node ) {
			_lyteDropdown.lastDropdownWithAPromise = null;
		}

		if( this._inputElement ) {
			this._inputElement.removeEventListener( 'keyup', this._function );
			$L( this._inputElement ).removeSearch();			
			this._inputElement = null;
		}

		delete this.childComp;
		delete this.$node.toggle;
		delete this.$node.element;

		this.$node.mutobserver = null;
	},

	disableParentListeners: function() {
		var that = this;

		if( this.scrollableParents ) {
			this.scrollableParents.off( 'scroll', this.resetScroll );
		}

		this.scrollableParents = undefined;

		if( this.lyteScrollBarParents ) {

			this.lyteScrollBarParents.each( function( index, item ) {

				if( item ) {
					item.removeEventListener( 'touchmove', that.disableLyteScrollBar, true );
					item.removeEventListener( 'wheel', that.disableLyteScrollBar, true );
				}
				
			} );

			this.lyteScrollBarParents = undefined;
		}
		
	},

	prerequisites: function() {
		var ev, body = this.getDropBody( this.childComp );
		// Not putting inside fastdom because it causes a jitter 
		if( this.data.ltPropAnimate ) {
			this._hgtRemoval = true
			// body.style.height = '';
		}
		this.setCss( false, true );
		this.openSlideAnimate();

		if( this.getData( 'call' ) ) {
			this.childComp.removeAttribute( 'lyte-hidden' );
		}

		if( this.getData( 'call' ) && this.getMethods( 'onShow' ) ) {
			ev = this.getData( 'call' );
			ev = ev === true ? undefined : ev;
			this.executeMethod( 'onShow', ev, this );
		}

		this.setData( 'call', null );
	},

	// Do a dfs to find the types of dropdown
	getChildren: function( childs ) {
		var head = this.getData( 'drophead' ),
		body = this.getData( 'dropbody' ),
		tag, i = 0, drop = this.$node;

		if( head === 'yield' && body === 'yield' ) {
			return ;
		}

		for( ; i < childs.length; i++ ) {

			tag = childs[i].tagName;
			if( tag === 'LYTE-DROPDOWN' 
				|| tag === 'TEMPLATE'
			) {
				continue;
			}

			if( tag === 'LYTE-DROP-BOX' ) {
				this.setData( 'dropbody', 'yield' );
				drop.querySelector( 'lyte-drop-box' ).classList.add( 'lyteDropdownHidden' );
			}
			else if( tag === 'LYTE-DROP-BUTTON' ) {
				this.setData( 'drophead', 'yield' );
				_lyteUiUtils.appendChild( drop.querySelector( '.lyteDummyEventContainer' ), drop.querySelector( 'lyte-drop-button' ) )
				i--;
			}
			else {
				this.getChildren( childs[ i ].children );
			}
		}
	},

	setBoxClass: function( oldValue ) {
		var cls = this.getData( 'ltPropBoxClass' ),
		box = this.childComp || this.$node.querySelector( 'lyte-drop-box' ),
		body = this.getData( 'dropbody' );

		if( body === 'noyield' ) {
			if( oldValue ) {
				$L( box ).removeClass( oldValue );
			}
			
			if( cls ) {
				$L( box ).addClass( cls );
			}
		}
		
	},

	setButtonClass: function( oldValue ) {
		var cls = this.getData( 'ltPropButtonClass' ),
		button = this.$node.querySelector( 'lyte-drop-button' );

		if( oldValue ) {
			$L( button ).removeClass( oldValue );
		}
		
		if( cls ) {
			$L( button ).addClass( cls );
		}
	},

	iconClassChanged: function() {
		this.setIconClass();
	}.observes( 'ltPropIconClass' ),

	setIconClass: function() {
		var multiple = this.getData( 'multiple' ),
		dropButton = this.getDropButton(),
		drophead = this.getData( 'drophead' );

		if( !multiple ) {
			return ;
		}

		if( drophead === 'yield' ) {
			return ;
		}

		if( this.hasIconClassChanged() ) {
			dropButton.classList.add( 'lyteDropdownRemoveIcon' );
			this.setData( 'shouldDisplayIcon', true );
		}
		else {
			dropButton.classList.remove( 'lyteDropdownRemoveIcon' );
			this.setData( 'shouldDisplayIcon', false );
		}
	},

	getDropButton: function() {
		return this.$node.querySelector( 'lyte-drop-button' );
	},

	hasIconClassChanged: function() {
		var iconCls = this.getData( 'ltPropIconClass' );

		return iconCls && iconCls !== 'dropdown';
	},

	didConnect: function() {
		var drop = this.$node,
		link = this.childComp,
		nores = this.getData( 'ltPropNoResult' ),
		yd = drop.querySelector( 'lyte-yield' ),
		ph = this.getData( 'ltPropPlaceholder' ),
		hover = this.getData( 'ltPropHover' ),
		sel = this.getData( 'ltPropSelected' ),
		options = this.getData( 'ltPropOptions' ) || [],
		type = this.getData( 'ltPropType' ),
		disabled = this.getData( 'ltPropDisabled' ),
		index = this.getData( 'ltPropTabindex' ),
		show = this.getData( 'ltPropShow' ),
		list = this.getData( 'ltPropDisabledList' ),
		disp = this.getData( 'ltPropDisplayValue' ),
		selList = this.getData( 'ltPropSelectedList' ) || [],
		dummyContainer,
		button, box, config, div, span, node, tab, head, body, boxes, evbody;

		this.determine( yd );

		head = this.getData( 'drophead' );
		body = this.getData( 'dropbody' );
		if( head !== 'yield' ) {
			this.setData( 'drophead', head = 'noyield' );
		}

		if( body !== 'yield') {
			this.setData( 'dropbody', body = 'noyield' );
		}

		box = drop.querySelector( 'lyte-drop-box' )

		this.setBoxClass();
		this.setButtonClass();
		this.setIconClass();
		this.calculateSelected = selList.length > 0;

		// Mutation observer
		drop.mutobserver = new MutationObserver( function( mutations ) {

			if( this._preventMutObs || this._preventClass ) {
				this._preventClass = false;
				return
			} 
			if( this._hgtRemoval ) {
				delete this._hgtRemoval;
				return
			}

			var dropbox = this.childComp ? this.childComp : drop.querySelector( 'lyte-drop-box' ), i, ev,
			// Added so that users can now set the left and top in onBeforeShow callback without setCss interfering with it.
			manual = this.getData( 'ltPropSetPos' );

			if( manual 
				|| !dropbox || dropbox.classList.contains( 'lyteDropdownHidden' ) 
			) {
				return ;
			}

			if( this.getData( 'multiple' ) ) {
				var notselected = false;
				for( i = 0; i < mutations.length; i++ ) {

					if( mutations[ i ].type === 'attributes' && mutations[ i ].attributeName === 'lyte-hidden' ) {
						continue;
					}

					var allCases = mutations[i].type == 'childList' 
								   	|| mutations[i].attributeName == 'selected' 
								   	|| (
										mutations[i].attributeName == 'class' 
										// Prevent firing when setting class to lyteArrow span
										&& ( !mutations[ i ].target.classList.contains( 'lyteArrow' )

											// Prevent firing when setting the lyteDropdownSelection class for the lyte-drop-item
											// We want to fire in the other cases
											&& (
												mutations[ i ].target.tagName === 'LYTE-DROP-ITEM' ?
												!this.hasClassToggled( mutations[ i ], 'lyteDropdownSelection' ) && !this.hasClassToggled( mutations[ i ], 'lyteMenuSelected' )
												: true
											)
										)
									) 
									|| ( 
										mutations[i].attributeName == 'style' 
										&& mutations[i].target.tagName != 'LYTE-DROP-BOX' 
										&& !mutations[i].target.classList.contains( 'lyteArrow' )
									)
									|| (
										// If the dropbox's visibility did change we still call setcss
										mutations[ i ].attributeName === 'style'
										&& mutations[ i ].target.tagName === 'LYTE-DROP-BOX'
										&& this.isVisibilityModified( mutations[ i ].oldValue, mutations[ i ].target.getAttribute( 'style' )  )
									);

					if( allCases ) {
						notselected = true
						break;
					}
				}

				if( notselected ) {
					this.prerequisites();
		
					// Returning to prevent the onShow at the end from getting called
					return ;
				}
			}
			else {
				var notselected = false
				var stylemutations = false
				for( i = 0; i < mutations.length; i++ ) {
					if( mutations[i].attributeName == 'style' 
						&& mutations[i].target.tagName == 'LYTE-DROP-BOX'
						&& !this.isVisibilityModified( mutations[ i ].oldValue, mutations[ i ].target.getAttribute( 'style' ) )
					) {
						stylemutations = true
					}
				}

				for( i = 0; i < mutations.length; i++ ) {

					if( mutations[ i ].type === 'attributes' && mutations[ i ].attributeName === 'lyte-hidden' ) {
						continue;
					}

					var allCases = 
									// Fire when new children are added to the dropdown
									mutations[i].type == 'childList' 
									|| (
										mutations[i].attributeName == 'style' 

										// Prevent firing when setting styles to drop-box
										&& mutations[i].target.tagName != 'LYTE-DROP-BOX'

										// Prevent firing when setting styles to lyteArrow 
										&& !mutations[i].target.classList.contains('lyteArrow')
									) 
									|| (
										mutations[i].attributeName == 'class'
										&& mutations[ i ].type === 'attributes'

										// Prevent firing when setting class to lyteArrow span
										&& ( !mutations[i].target.classList.contains( 'lyteArrow' )
											// Prevent firing when setting the lyteDropdownSelection class for the lyte-drop-item
											// We want to fire in the other cases
											&& (
												mutations[ i ].target.tagName === 'LYTE-DROP-ITEM' ?
												!this.hasClassToggled( mutations[ i ], 'lyteDropdownSelection' ) && !this.hasClassToggled( mutations[ i ], 'lyteMenuSelected' )
												: true
											)
										)
									)
									|| (
										// If the dropbox's visibility did change we still call setcss
										mutations[ i ].attributeName === 'style'
										&& mutations[ i ].target.tagName === 'LYTE-DROP-BOX'
										&& this.isVisibilityModified( mutations[ i ].oldValue, mutations[ i ].target.getAttribute( 'style' )  )
									);	

					// If a class mutation happened,check if there is a style mutation in LYTE-DROP-BOX. If there is then do nothing
					if( allCases 
						&& mutations[ i ].attributeName == 'class' 
						&& mutations[ i ].target.tagName == 'LYTE-DROP-BOX' 
					) {
						if( !stylemutations ) {
							notselected = true;
							break;
						}
					}
					else if( allCases && !stylemutations ) {
						notselected = true
					}
				}

				if( notselected ) {
					this.prerequisites();

					// Returning to prevent the onShow at the end from getting called
					return ;
				}
			}

			if( this.getData( 'call' ) ) {
				this.childComp.removeAttribute( 'lyte-hidden' );
			}

			if( this.getData( 'call' ) && this.getMethods( 'onShow' ) ) {
				ev = this.getData( 'call' );
				ev = ev === true ? undefined : ev;
				this.executeMethod( 'onShow', ev, this );
			}

			this.setData( 'call', null );
		}.bind( this ) );

		config = { 
			attributes: true,
			childList : true,
			subtree: true,
			attributeOldValue: true 
		};

		drop.mutobserver.observe( box, config );
		// Mutation observer ends

		div = document.createElement( 'div' );
		div.setAttribute( 'class', 'lyteDropdownNoResult' );
		div.textContent = nores;
		div.style.display = 'none';

		box.addEventListener( 'click', function( event ) {
			this.actions.processElements.call( this, event );
		}.bind( this ) );

		if( hover ) {
			box.addEventListener( 'mouseout', function( event ) {
				this.actions.closeIt.call( this, event );
			}.bind( this ) );
		}

		span = document.createElement( 'span' );
		span.setAttribute( 'class', 'lyteArrow' );
		box.insertBefore( span, box.children[ 0 ] );

		//We need to set the first value in the dropdown as the selected one
		if( !ph && !sel && options.length > 0 ) {
			var firstElement = options[ 0 ],
			flag = false,
			value;

			if( firstElement.constructor == Object ) {
           		if( Object.keys( firstElement ).length == 1 ) {
	              	value = firstElement[ Object.keys( firstElement )[ 0 ] ];
	              	if( value.constructor == Array ) {
	                   	flag = true
	               	}
	            }   
           	}

           	this.setData( 'preventDisp', true );
           	if( flag ) {
           		if ( Object.prototype.toString.call( value[ 0 ] ) === '[object Object]' ) {
           			this.setData( 'ltPropSelected', value[ 0 ][ this.getData( 'ltPropSystemValue' ) ] );
           		}
           		else{
           			this.setData( 'ltPropSelected', value[ 0 ] );
           		}
           	}
           	else{
           		if ( Object.prototype.toString.call( firstElement ) === '[object Object]' ) {
           			this.setData( 'ltPropSelected', firstElement[ this.getData( 'ltPropSystemValue' ) ] );
           		}
           		else {
           			this.setData( 'ltPropSelected', firstElement );
           		}

           	}

           	this.setData( 'preventDisp', false );	
		}
		else if(
			!ph
			&& !this.getData( 'ltPropSelected' ) 
			&& body == 'yield' 
			&& type !== 'multiple' 
			&& type !== 'multisearch'
		) { 
			node = this.getFirstEnabledItem();

			if( node ) {
				this.setData( 'preventDisp', true );
				node.setAttribute( 'selected', true );
				this.setData( 'preventDisp', false );
			}
		}

		this.removeTabIndexForYieldedMultisearch();
		tab = this.getElementWithTabIndex();

		
		if( disabled ) {
			this.disableClickableItem( tab );
			tab.setAttribute( 'tabindex', -1 );
		}
		else {
			this.enableClickableItem( tab );
			tab.setAttribute( 'tabindex', index );
		}

		if( type === 'multisearch' ) {
			this._inputElement = tab;
			this._function = this.fireCheckKey.bind( this );
			tab.addEventListener( 'keyup', this._function );

		}

		this.toggleDropdownClass();
		// Bad way to trigger an observer
		this.setData( 'preventDisp', true );
		this.setData( 'changeItToInvoke', this.getData( 'changeItToInvoke' ) + 1 );
		this.setData( 'preventDisp', false );
		this.setSelectedFromList( true );

		if( show ) {
			this.setData( 'ltPropShow', false );
			drop.toggle();

			$L.fastdom.measure( function() {
				tab.focus();
				var pos = drop.getBoundingClientRect();

				// This doesn't work exactly it can be behind a overflow'd div and still not be visible.
				if( pos.left < 0 
					|| pos.top < 0 
				) { 
					drop.scrollIntoView();
				}
			} );
			
		}

		link = this.childComp;
		evbody = this.getDropBody( link );
		evbody.appendChild( div );
		this.showNoResultDiv();

		evbody.addEventListener( 'scroll', function( event ) {
			this.callOnScroll( event, this );
		}.bind( this ) );

		// Check if this causes detached dom!!!
		this.getDropBox().addEventListener( 'mousemove', function( event ) {
			var cur = event.target,
			curTar = event.currentTarget,
			prev = curTar.querySelector( '.lyteDropdownSelection' );

			cur = _lyteDropdown.traverse( cur, [ 'LYTE-DROP-ITEM' ] );

			if( this.hasMousePositionNotChanged( event ) || cur === prev ) {
				return ;
			}

			// This will make sure that it is removed for disabled items which have pointer-events:none
			if( prev ) {
				prev.classList.remove( 'lyteDropdownSelection' );
			}
			
			if( !cur || cur.tagName !== 'LYTE-DROP-ITEM' ) {
				return ;
			}

			if( cur.getAttribute( 'disabled' ) === 'true' ) {
				return ;
			}

			if( cur ) {
				cur.classList.add( 'lyteDropdownSelection' );
			}

		}.bind( this ) );

		if( 
			options.length > 0 
			&& ( list && list.length > 0 )
		) {
			this.addDisabledClass( drop.querySelectorAll( 'lyte-drop-item' ) );
		}
		
	},

	removeTabIndexForYieldedMultisearch: function() {
		var drophead = this.getData( 'drophead' ),
		type = this.getData( 'ltPropType' ),
		tabIndexElement = this.$node.querySelector( '.lyteDummyEventContainer' );

		if( tabIndexElement && drophead === 'yield' && type === 'multisearch' ) {
			tabIndexElement.removeAttribute( 'tabindex' );
		}
	},

	addTabIndexForYieldedMultisearch: function() {
		var type = this.getData( 'ltPropType' ),
		drophead = this.getData( 'drophead' ),
		tabIndexElement = this.$node.querySelector( 'input' ),
		index = this.getData( 'ltPropTabindex' ),
		isDisabled = this.getData( 'ltPropDisabled' );

		if( tabIndexElement && drophead === 'yield' && type === 'multisearch' && !isDisabled ) {
			tabIndexElement.setAttribute( 'tabindex', index );
		}
	},

	addTabIndex: function() {
		this.addTabIndexForYieldedMultisearch();
	}.observes( 'ltPropTabindex' ),

	getElementWithTabIndex: function() {
		return this.$node.querySelector( '[tabindex]' ) || this.$node.querySelector( 'input' );
	},

	getFirstEnabledItem: function() {
		var body = this.getDropBody( this.childComp ),
		items = body.querySelectorAll( 'lyte-drop-item' ),
		disabledList = this.getData( 'ltPropDisabledList' ) || [];

		for( var i = 0; i < items.length; i++ ) {
			if( !~disabledList.indexOf( items[ i ].getAttribute( 'data-value' ) ) ) {
				return items[ i ];
			}
		}
	},

	hasMousePositionNotChanged: function( event ) {
		var curClientX = event.clientX,
		curClientY = event.clientY,
		prevClientX = this.prevClientX,
		prevClientY = this.prevClientY;

		this.prevClientX = curClientX;
		this.prevClientY = curClientY;

		if( prevClientX === curClientX && prevClientY === curClientY ) {
			return true;
		}

		return false;
	},

	tranEnd : function( evt ){
		var box = this.childComp,
		isAnimate = this.getData( 'ltPropAnimate' ),
		body = this.data.ltPropAnimateBox ? box : this.getDropBody( box );

		if( isAnimate ) {
			body.style.height = 'auto';
		}

		box.classList.remove( 'lyteAnimate', 'lyteDropBoxAnimate' );
		box.removeEventListener( 'transitionend', this._transEnd )	
		delete this._prevent;
		delete this._preventSetcss;
		delete this._preventMutObs;

		if( this.getMethods( 'onAnimationEnd' ) ){
			this.executeMethod( 'onAnimationEnd', evt, this );
		}
	},

	openSlideAnimate : function() {
		if( this.getData( 'ltPropAnimate' ) ){
			if( this._preventSetcss ) {
				return
			}

			if( this._preventAnimate ) {
				return ;
			}

			this._preventAnimate = true;
			this._preventSetcss = true
			this._preventMutObs = true
			var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),
			isBoxAnimate = this.data.ltPropAnimateBox,
			elem = isBoxAnimate ? box : this.getDropBody( this.childComp );
			this._oriStyle = elem.style.height;
			// animation starts from zero
			elem.style.height = 0;
			// for invert animation
			if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
				box.style.top = parseInt( box.style.top ) + this._hgt + 'px';
			}

			box.classList.add( 'lyteAnimate' );
			if( isBoxAnimate ){
				box.classList.add( 'lyteDropBoxAnimate' );
			}
			// setTimeout( function(){
				// animation class added
				// box.classList.add( 'lyteAnimate' );
				setTimeout( function(){
					// invert anime starts
					if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
						box.style.top = parseInt( box.style.top ) - this._hgt  + 'px';
					}
					// height animate starts
					elem.style.height = this._hgt + 'px';
					setTimeout( function(){
						box.addEventListener( 'transitionend', this._transEnd )
						if( !this._hgt ){
							this.tranEnd.call( this, {} )
						}
					}.bind(this), 20)
				}.bind(this), 20)	
			// }.bind(this), 20)
		}
	},

	/**
	 * This is going to determine the structure of the dropdown whether it is a single or dropdown within dropdown
	 * @param {HTMLElement} yd - The yield of the dropdown
	 *
	 */

	determine: function( yd ) {
		var children = yd.children,
		head, box, drop = this.$node, dummy, other;

		other = drop.querySelector( 'lyte-dropdown' );
		if( other ) {
			this.getChildren( children );
		}
		else {
			box = yd.querySelector( 'lyte-drop-box' );
			head = yd.querySelector( 'lyte-drop-button' );

			if( head ) {
				dummy = drop.querySelector( '.lyteDummyEventContainer' );
				this.setData( 'drophead', 'yield' );
				_lyteUiUtils.appendChild( dummy, head );
			}

			if( box ) {
				this.setData( 'dropbody', 'yield' );
				box.classList.add( 'lyteDropdownHidden' )
			}
		}
	},

	/**
	 * This is going to add a class to the drop-box for multiselects
	 *
	 */

	addClass: function() {
		var link = this.childComp;

		link.classList.add( 'lyteMultiSelectDropdown' );
	},

	closeDrop : function( link, event, freeze, isScroll ){
		_lyteDropdown.autoClosed = null;
		this.setData( 'ltPropIsOpen', false );
		
		if( this._prevent ) {
			return
		}
		if( this.getData( 'ltPropAnimate' ) && !isScroll ) {
			var isBoxAnimate = this.data.ltPropAnimateBox;
			this._prevent = true;
			this._preventSetcss = true;
			this._arguments = arguments;
			this.childComp.classList.add( 'lyteAnimate' );
			if( isBoxAnimate ){
				this.childComp.classList.add( 'lyteDropBoxAnimate' );
			}
			setTimeout( function(){
				var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),
				elem = isBoxAnimate ? box : this.getDropBody( this.childComp );
				
				elem.style.height = this._hgt + 'px';

				setTimeout( function() {
					// var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),
					// elem = isBoxAnimate ? box : this.getDropBody( this.childComp );

					// height set to zero for hide animation
					elem.style.height = 0;
					// invert animation
					if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
						box.style.top = parseInt( box.style.top ) + this._hgt + 'px';
					}

					this._animationStarted = true;
					this._elem = elem;
					this._box = box;
					elem.addEventListener( 'transitionend', this._close );

					if( !this._hgt ){
						this.closeDrop1.call( this )
					}
				}.bind( this ), 20 );

			}.bind( this ), 20)
		} else {
			this.closeDrop1( link, event, freeze )
		}
	},

	closeDrop1 : function( link, event, freeze){
		var bt = this.$node.querySelector( 'lyte-drop-button' ),
		pos = this.getData( 'pos' ), cls, mul = this.getData( 'multiple' ), body,
		box = this.getDropBox(),
		scrollsToPrevent = this.getData( 'ltPropPreventScroll' ),
		preventParentScroll = this.getData( 'ltPropPreventParentScroll' );

		if( this._arguments ) {
			link = this._arguments[ 0 ], event = this._arguments[ 1 ], freeze = this._arguments[ 2 ]
			this._elem.style.height = this._oriStyle;
			//animate class removal
			this._box.classList.remove( 'lyteAnimate', 'lyteDropBoxAnimate' );
			this._elem.removeEventListener( 'transitionend', this._close )	
			delete this._hgt; delete this._oriStyle; delete this._arguments; delete this._elem; delete this._box;
		}

		if( mul ) {
			body = this.getDropBody( link );
			body.scrollTop = 0;
		}

		link.classList.add( 'lyteDropdownHidden' );
		var freezeLayer = document.querySelector( '#lytedropdownfreezelayer' )
		if( freezeLayer && scrollsToPrevent === 'all' ) {
			document.querySelector( '#lytedropdownfreezelayer' ).style.display = 'none'
		}

		link.style.left = '';
		link.style.top = '';

		if( freeze || preventParentScroll ) {
			document.body.classList.remove( 'lyteBodyWrapper' );
		}

		this.disableParentListeners();

		cls = this.removeClass( bt.classList, pos, 'lyteDropButton', true );

		if( cls ) {
			bt.classList.remove( cls );
		}

		if( this.getMethods( 'onHide' ) ) {
			this.executeMethod( 'onHide', event, this );
		}

		this.focusButton();

		// This if statement is a bad fix. Added so that the dropdown doesn't throw an error when it is destroyed in on-option-selected and box is empty
		if( box ) {
			var posClsToRemove = this.removeClass( box.classList, pos, 'lyteDropdown', true );
		}
		
		if( posClsToRemove ) {
			box.classList.remove( posClsToRemove );
		}
		
		this.setData( 'pos', '' );
		this.setData( 'secondaryPosition', '' );
		this.setData( 'savedPositions', {} );

		delete this._prevent; delete this._preventSetcss;
		delete this._preventAnimate;
		delete this._animationStarted;
	},

	focusButton: function() {
		var isSearch = this.getData( 'search' ),
		activeElement = document.activeElement,
		focusOnClose = this.getData( 'ltPropFocusOnClose' );

		/* Not sure about multisearchs */
		if( focusOnClose && !isSearch && !this.isFocusable( activeElement ) ) {
			this.setData( 'ltPropFocus', true );
		}
	},

	isFocusable: function( element ) {
		var tabIndex;

		element = $L( element );

		if ( !_lyteDropdown.isVisible( element.get( 0 ) ) || element.is( ":disabled" ) ) {
        	return false;
    	}

	    tabIndex = element.attr( "tabindex" );
	    tabIndex = isNaN( tabIndex ) ? -1 : tabIndex;
	    return element.is( "button, input, select, textarea, a[href], area[href], iframe" ) || tabIndex > -1;
	},

	callOnScroll: function( event ) {
		if( this.getMethods('onScroll') ) {
			this.executeMethod( 'onScroll', event, this );
		}
	},

	addDisabledClass: function( elements ) {
		var i = 0, e, ele;
		for( ; i < elements.length; i++ ) {
			ele = elements[ i ];
			if( ele.getAttribute( 'disabled' ) == 'true' ) {
				ele.classList.add( 'lyteDropdown-disabled' );
			}
			else if( ele.classList.contains( 'lyteDropdown-disabled' ) ) {
				ele.classList.remove( 'lyteDropdown-disabled' );
			}
		}
	},

	changeBoxClass: function( change ) {
		var oldValue = change.oldValue;

		this.setBoxClass( oldValue );

	}.observes( 'ltPropBoxClass' ),

	changeButtonClass: function( change ) {
		var oldValue = change.oldValue;

		this.setButtonClass( oldValue );

	}.observes( 'ltPropButtonClass' ),

	noResultChanged: function() {
		var link = this.childComp,
		type = this.getData( 'ltPropType' ),
		head = this.getData( 'drophead' ),
		body = this.getDropBody( link ),
		nores = body.querySelector( '.lyteDropdownNoResult' ),
		text = this.getData( 'ltPropNoResult' ),
		link = this.childComp;

		nores.textContent = text;

		if( !text ) {
			nores.style.display = 'none';
		}

		// Hide the no result div if text is empty
		if( link ) {
			this.showError( link, type, head );
		}
		
	}.observes( 'ltPropNoResult' ),

	showNoResultDiv: function() {
		var show = this.getData( 'ltPropShowEmptyMessage' ),
		link = this.childComp,
		body = this.getDropBody( link ),
		items = body.querySelectorAll( 'lyte-drop-item' ),
		nores = body.querySelector( '.lyteDropdownNoResult' ),
		multiple = this.getData( 'multiple' );

		if( !nores ) {
			return ;
		}

		if( show && !multiple ) {
			if( items.length === 0 ) {
				nores.style.display = 'block';
			}
			else {
				nores.style.display = 'none';
			}
			
		}
		else if( !show && !multiple ) {
			nores.style.display = 'none';
		}
	},

	// TODO: Fix this 
	onChangeInDisabledList: function() {
		var elements = this.childComp ? this.childComp.querySelectorAll('lyte-drop-item') : this.$node.querySelectorAll('lyte-drop-item'),
		isItemDisabled;
		
		for(var i = 0; i<elements.length; i++){
			isItemDisabled = Lyte.Component.registeredHelpers.lyteUiCheckDisabled(this.getData('ltPropDisabledList') || [],elements[i].dataset.value);
			
			if( isItemDisabled === 'true' ) {
				elements[ i ].classList.remove( 'lyteDropdownSelection' );
				elements[i].setAttribute('disabled', isItemDisabled );
			}

			if( isItemDisabled === 'false' && elements[ i ].hasAttribute( 'disabled' ) ) {
				elements[ i ].removeAttribute( 'disabled' );
			}
		}
		this.addDisabledClass(elements);

	}.observes( 'ltPropDisabledList.[]' ).on( 'didConnect' ),


	/**
	 * The method is going to specify the class that needs to be removed from the classList 
	 * ( Might be buggy when lt-prop-position is changed as it only removes opposites)
	 * @param {classList} arr - The classlist under question
	 * @param {string} pos - The current position of the dropdown
	 * @param {string} prefix - A prefix that is appended to the pos attribute to determine the class
	 * @param {boolean} ignore - Tells whether we must search for the opposites
	 * @param {string} suffix - A suffix added to the end of the class
	 *
	 */


	removeClass: function( arr, pos, prefix, ignore, suffix ) {
		if( !pos ) {
			return '';
		}

		suffix = suffix || '';

		var negate = {
			'up': 'Down',
			'down': 'Up',
			'left': 'Right',
			'right': 'Left'
		}, i = 0, len = arr.length,

		ngcls = prefix 
				+ ( ignore ? 
					 pos[ 0 ].toUpperCase() + pos.substring( 1 ) 
					: negate[ pos ] ) + suffix;

		for( ; i < len; i++ ) {
			if( arr[ i ] === ngcls ) {
				return ngcls;
			}
		}

		return '';
	},

	/**
	 * Fires the position callback and adds and removes classes for the drop-box according to the direction
	 *
	 */ 

	firePosCallBack: function() {
		var pos = this.getData( 'pos' ),
		needCv = this.getData( 'widthAdjusted' );

		if( pos !== '' ) {
			// Fast dom removed here because it is causing a bug in ie
			// $L.fastdom.mutate( function() {
				var body = this.childComp,
				bt = this.$node.querySelector( 'lyte-drop-button' ),
				ngcls = this.removeClass( body.classList, pos, 'lyteDropdown' );

				/* Removing and adding class of the lyte-drop-box */

				if( ngcls ) {
					this._preventClass = true;
					body.classList.remove( ngcls );
				}

				body.classList.add( 'lyteDropdown' + pos[ 0 ].toUpperCase() + pos.substring( 1 ) );

				/* End */

				/* Removing and adding class of lyte-drop-button */

				ngcls = this.removeClass( bt.classList, pos, 'lyteDropButton' );

				if( ngcls ) {
					this._preventClass = true;
					bt.classList.remove( ngcls );
				}

				bt.classList.add( 'lyteDropButton' + pos[ 0 ].toUpperCase() + pos.substring( 1 ) );

				/* End */ 

				if( needCv === 2 ) {
					body.classList.add( 'lyteDropdownCurve' );
				}

				if( this.getMethods( 'onPositionChanged' ) ) {
					this.executeMethod( 'onPositionChanged', pos, this);
				}
			// }, this );	

		}

	}.observes(
		'pos',
		'firePos'
	),

	secondaryPositionObserver: function() {
		var pos = this.getData( 'secondaryPosition' ) || '';

		if( pos !== '' ) {
			var box = this.childComp,
			classToRemove = this.removeClass( box.classList, pos, 'lyteDropbox', false, 'AlignToButton' );

			if( classToRemove ) {
				box.classList.remove( classToRemove );
			}

			this._preventClass = true;  // This preventClass will take care of the classToRemove mut observer fire
			box.classList.add( 'lyteDropbox' + pos[ 0 ].toUpperCase() + pos.substring( 1 ) + 'AlignToButton' );
		}
	}.observes( 'secondaryPosition' ),
	/*
		Calculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
	*/
	setLeftExceedForDown: function( element, container, bcr, width, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		total = scrolledLeft + elementLeft + elementWidth - width;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth
	*/
	setLeftNotExceedForDown: function( element, bcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		total = scrolledLeft + elementLeft;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come above the select element
	*/
	setTopAboveForDown: function( element, container, bcr, containerbcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		containerBCR = containerbcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop  - containerHeight;

		if( this._animationStarted ) {
			return scrolledHeight + elementTop;
		}

		return total
	},
	/*
		Calculate top of dropdown container when it has to come below the select element
	*/
	setTopBelowForDown: function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		total = scrolledHeight + elementTop + elementHeight;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come to right of the select element
	*/
	setLeftForRight:function( element, bcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		total = scrolledWidth + elementLeft + elementWidth;

		return total
	},
	/*
		Calculate right of dropdown container when it has to come to left of the select element of right dropdown
	*/
	setRightForRight: function( element, container, bcr, width, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		total = scrolledWidth + elementLeft - width;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is space below
	*/
	setTopForRight:function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		total = scrolledHeight + elementTop;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is no space below
	*/
	setTopForRightAbove:function( element, container, bcr, elembcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		containerBCR = elembcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop + elementHeight - containerHeight;

		if( this._animationStarted ) {
			return scrolledHeight + elementTop + elementHeight;
		}

		return total
	},
	/**
		Remove wrong arrow and append proper arrow
		@param string correct - the correct class
	*/
	setCorrectClass: function( cls ) {
		var arrow = this.childComp.querySelector( '.lyteArrow' ),
		list = arrow.classList, i = 0;
		for( ; i < list.length; i++ ) {
			if( list[ i ] == 'lyteArrow' || list[ i ] == cls ) {
				continue;
			}
			else { 
				arrow.classList.remove( list[ i ] );
				i--;
			}
		}

		arrow.classList.add( cls );
		arrow.classList.add( 'lyteArrowIcon' );
	},

	/**
	 * This going to check if a class has been toggled
	 * @param {MutationRecord} rec - The mutation record
	 * @param {String} cls - The class that needs to be checked
	 *
	 */
	hasClassToggled: function( rec, cls ) {
		var old = rec.oldValue ? rec.oldValue.trim().split( " " ) : [],
		node = rec.target,
		olen = old.length,
		nlen = node.classList.length;

		if( ( ( !!~old.indexOf( cls )
			&& !node.classList.contains( cls ) )
			|| ( !~old.indexOf( cls )
				&& node.classList.contains( cls ) 
			) )

			// Only 1 class changed
			&& Math.abs( olen - nlen ) === 1
		) {
			return true;
		}

		return false;
	},

	/**
	 * If you are going to reuse one of the two functions below
	 * make sure you pass an empty string instead of undefined
	 *
	 */

	wasVisibilityAddedOrRemoved: function( oldValue, newValue ) {
 		return ( !!~oldValue.indexOf( 'visibility' ) && !~newValue.indexOf( 'visibility' ) )
				|| ( !!~newValue.indexOf( 'visibility' ) && !~oldValue.indexOf( 'visibility' ) );
	},

	didValueChange: function( oldValue, newValue ) {
		return ( !!~oldValue.indexOf( 'visible' ) && !!~newValue.indexOf( 'hidden' ) )
			|| ( !!~oldValue.indexOf( 'hidden' ) && !!~newValue.indexOf( 'visible' ) );
	},

	isVisibilityModified: function( oldValue, newValue ) {
		oldValue = oldValue || '';
		newValue = newValue || '';

		if( this.wasVisibilityAddedOrRemoved( oldValue, newValue )
			|| this.didValueChange( oldValue, newValue )
		) {
			return true;
		}
	},

	/**
	 * The adjust width is going to adjust the width of the dropdown's body that is going to open
	 * @param {Element} body - The lyte-drop-box
	 * @param {Number} pwidth - The width of the parent Element
	 * @param {Number} bwidth - The width of the body Element
	 *
	 */

	adjustWidth: function( body, pwidth, bwidth ) {
		var boxButtonWidth = this.getData( 'ltPropBoxButtonWidth' ), newWidth;

		if( boxButtonWidth === 'min-button' ) {
			this.setData( 'widthAdjusted', 1 );

			if( bwidth > pwidth ) {
				this.setData( 'widthAdjusted', 2 );
			}

			body.style.minWidth = pwidth + 'px';
		}
		else if( boxButtonWidth === 'auto' ) {
			this.setData( 'widthAdjusted', 1 );
			body.style.width = 'auto';
			newWidth = body.getBoundingClientRect().width;

			if( newWidth > pwidth ) {
				this.setData( 'widthAdjusted', 2 );
			}
		}
		else {
			this.setData( 'widthAdjusted', 1 );
			body.style.width = pwidth + 'px';
			body.style.minWidth = pwidth + 'px';
		}

		return body.getBoundingClientRect().width;
		
	},

	/**
	 * This is going to return the proper drop-body tag of the dropdown - ( dropdown inside dropdown )
	 * @param {Element} box - The lyte-drop-box of the dropdown
	 *
	 */

	getDropBody: function( link ) {
		var all;

		if( link ) {
			all = link.querySelectorAll( 'lyte-drop-body' );
		}
		else {
			all = this.$node.querySelectorAll( 'lyte-drop-body' );
		}

		return all[ all.length - 1 ];
	},

	/**
	 * This is going to remove the previous highlighted element and set a new highlighted element
	 * @param {Element} node - The element to be toggled -> should not be undefined
	 * @param {Element} body - The lyte-drop-body
	 *
	 */

	toggleCurrent: function( node ) {
		var cls = 'lyteDropdownSelection',
		box = this.getDropBox(),
		prev = box.querySelector( '.' + cls );

		if( prev ) {
			prev.classList.remove( cls );
		}

		node.classList.add( cls );
	},

	/**
	 * This is going to scroll the drop-body to the element above the selected element
	 * This function is also going to highlight the selected value
	 * Note this doesn't work when they are making a request and trying to set the data
	 *
	 */

	scrollSel: function() {

		var sel = this.getData( 'ltPropSelected' ),
		link = this.childComp,
		body = this.getDropBody( link ),
		tmp, highlightedElement,
		node = tmp = body.querySelector( '[data-value="' + window._lyteUiUtils.escape( sel ) + '"]' );

		// Not for multiselects
		if( this.getData( 'multiple' ) ) {
			tmp = body.querySelector( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' );

			if( tmp && !tmp.classList.contains( 'lyteDropdown-disabled' ) ) {
				this.toggleCurrent( tmp );
			}

			return ; 
		}

		if( ( sel || '' ).length === 0 ) {
			body.scrollTop = 0;
		}

		while( node
			&& ( node = node.previousElementSibling ) 
		) {
			if( ( node.tagName === 'LYTE-DROP-ITEM'
				|| node.tagName === 'LYTE-DROP-LABEL' )
				&& _lyteDropdown.isVisible( node ) 
			) {
				break;
			}
		}

		// Scroll to original node if no visible node is found
		node = node ? node : tmp;

		// If we now have a node set the scrollTop
		if( node ) {
			body.scrollTop = node.offsetTop;
		}
		else {
			body.scrollTop = 0;
		}

		if( tmp && !tmp.classList.contains( 'lyteDropdown-disabled' ) ) {
			this.toggleCurrent( tmp );
		}
		else {
			highlightedElement = body.querySelector( '.lyteDropdownSelection' );

			if( highlightedElement ) {
				highlightedElement.classList.remove( 'lyteDropdownSelection' );
			}
		}
	},

	/**
	 * This is going to clone the object
	 * @param {Object} obj - the object to be clone
	 *
	 */

	clone: function( obj ) {
		var clone = {};

		for( var key in obj ) {
			clone[ key ] = obj[ key ];
		}

		return clone;
	},

	isFF: function() {
		var ua = navigator.userAgent;

		return !!~ua.indexOf( 'Firefox' );
	},

	isBodyScrollable: function() {
		var link = this.childComp,
		body = this.getDropBody( link );

		return body.scrollHeight > body.offsetHeight;
	},

	addProperScrollbar: function() {
		var link = this.childComp,
		body = this.getDropBody( link );

		if( !body.classList.contains( 'lyteDropdownFFScroll' ) ) {
			body.classList.add( 'lyteDropdownFFScroll' );
		}

		if( body.classList.contains( 'lyteDropdownFFZeroScroll' ) ) {
			body.classList.remove( 'lyteDropdownFFZeroScroll' );
		}
	},

	removeScrollbar: function() {
		var link = this.childComp,
		body = this.getDropBody( link );

		if( !body.classList.contains( 'lyteDropdownFFZeroScroll' ) ) {
			body.classList.add( 'lyteDropdownFFZeroScroll' );
		}

		if( body.classList.contains( 'lyteDropdownFFScroll' ) ) {
			body.classList.remove( 'lyteDropdownFFScroll' );
		}
	},

	/**
	 * Set the CSS for your dropdown
	 * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
	 * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
	 */ 
	setCss: function( onlyScroll, useSave ) {
		var link = this.childComp,

		// An indication that the dropdown has been opened recently and this setcss is called for the open
		isOpen = this.getData( 'call' );

		if( !useSave ) {
			this.setData( 'savedPositions', {} );
		}

		if( !link 
			|| link.classList.contains( 'lyteDropdownHidden' )
		) {
			return;
		}

		// Get properties
		var callout = this.getData( 'ltPropCallout' );


		// Get button
		var body = link,
		custom = this.$node.element,
		par = custom ? custom : this.$node.querySelector( 'lyte-drop-button' );

		// Get Geometric propotions
		var wwidth = window.innerWidth, 
		wheight = window.innerHeight,
		save = this.getData( 'savedPositions' ),
		drop = this.clone( body.getBoundingClientRect() ), 
		bodybcr = this.getDropBody( body ).getBoundingClientRect(),
		x = window.pageXOffset || document.documentElement.scrollLeft,
		y = window.pageYOffset || document.documentElement.scrollTop,
		height = body.offsetHeight,
		width = body.offsetWidth, 
		arrow = link.querySelector( '.lyteArrow' ),
		position = this.getData( 'ltPropPosition' ),
		offsets = par.getBoundingClientRect(),
		isFF = this.isFF(),
		scopeBoundary = this.getScopeBoundary();

		if( this.data.ltPropAnimate ) {
			this._hgt = this.data.ltPropAnimateBox ? drop.height : bodybcr.height;
			// this.getDropBody( body ).style.height = ( this._hgt ) + 'px';
		}


		// Adjusting width of the body is a one time thing. Atleast that is what we think.
		// Till the smoke clears around this issue we are going to hang on to onlyScroll
		// onlyScroll will probably be deprecated
		if( isOpen ) {

			// Hack to prevent the mutation observer from getting fired
			// MutationObserver fired when i added a class attribute to the drop-item.
			// We have cases where it should fire when we add a class to the drop-item
			this._preventClass = true;
			this.scrollSel();

			if( !onlyScroll ) {

				// Reset width for later usage
		 		width = this.adjustWidth( body, offsets.width, width );
		 		drop.width = width;
				
			 	// Set width of span.lyteArrow if there is no callout
				if( !callout ) {
					arrow.style.width = offsets.width + 'px';
				}	
			}
		}

		// Adding the not check here because it was causing the mutobserver to fire infinitely when resize occured.
		// When resized the dropdown would add the lyteDropBodyCallout again and this keeps happening over and over again.
		if( callout && !body.classList.contains( 'lyteDropBodyCallout' ) ) {
			body.classList.add( 'lyteDropBodyCallout' )
		}

		if( isFF && this.isBodyScrollable() ) {
			this.addProperScrollbar();
		}
		else if( isFF && !this.isBodyScrollable() ) {
			this.removeScrollbar();
		}		
		
		// Intialize flags
		var downPos, 
		rightPos, 
		topPos, 
		leftPos, 
		rtl = _lyteUiUtils.getRTL();


		// temp stores
		var tempStore,
		tempTop, 
		tempLeft, 
		tempMarginLeft, 
		tempMarginTop,
		tempNum, 
		tempDenom, 
		tempPer, 
		aHeight, 
		aWidth;

		if( position === 'down' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height; 
			if( tempTop + height > scopeBoundary.bottom 
				&& offsets.top > height 
			) {
				downPos = false;		
			}
			else {
				downPos = true;
			}

			rightPos = 0;

			// rightPos - 1 -> rtl or no space to the right -> align left
			// rightPos - 2 -> ltr or space available to the right -> align right
			// rightPos - 0/3 -> align to the right if ltr or to the left if rtl
			tempLeft = offsets.left;
			if( tempLeft + offsets.width - width > scopeBoundary.left ) {
				rightPos = 1;
			}

			if( offsets.left + width <= scopeBoundary.right ) {
				rightPos += 2;
			}

			if( rtl ) {
				rightPos = !!( !( rightPos & 1  || !rightPos ) );
			}
			else {
				rightPos = !!( rightPos & 2 || !rightPos );
			}

			if( useSave && !_lyteDropdown.isEmpty( save ) ) {
				rightPos = save.rightPos;
				downPos = save.downPos;
			}
			else if( useSave ) {
				save.rightPos = rightPos;
				save.downPos = downPos;

				this.setData( 'savedPositions', save );
			}

			if( downPos ) {
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					tempStore = this.setTopBelowForDown( par, offsets, y ) + parseFloat( aHeight ? aHeight : '0px' ) + 'px';
				}
				else { 
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';
				}

				
				
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - parseFloat( aHeight ? aHeight : '0px' ) + 'px';					
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}

				
			}

			if( rightPos ) {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempNum = offsets.width / 2 - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 	
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';	
			}
			else {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );	
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, width, x ) + 'px'
			}

			if( downPos ) {
				this.setData( 'pos', 'down' );
			}
			else {
				this.setData( 'pos', 'up' );
			}

			if( rightPos ) {
				this.setData( 'secondaryPosition', 'right' );
			}
			else {
				this.setData( 'secondaryPosition', 'left' );
			}

			
		}
		else if( position === 'right' ) {
			rightPos = 0;
			if( offsets.left - drop.width > scopeBoundary.left ) {   
				rightPos = 1;
				
			}
			if( offsets.left + offsets.width + drop.width < scopeBoundary.right ) {
				rightPos += 2;
			}

			if( rtl ) {
				rightPos = !!( !( rightPos & 1 || !rightPos ) );
			}
			else {
				rightPos = !!( rightPos & 2 || !rightPos );
			}

			downPos = true;
			if( offsets.top + drop.height > scopeBoundary.bottom ) {
				downPos = false
			}
			else {
				downPos = true
			}

			if( useSave && !_lyteDropdown.isEmpty( save ) ) {
				rightPos = save.rightPos;
				downPos = save.downPos;
			}
			else if( useSave ) {
				save.rightPos = rightPos;
				save.downPos = downPos;

				this.setData( 'savedPositions', save );
			}

			if( rightPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setLeftForRight( par, offsets, x ) + aWidth + 'px';
				}
				else {
					body.style.left= this.setLeftForRight( par, offsets, x ) + 'px'
				}
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setRightForRight( par, body, offsets, width, x ) - aWidth + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, width, x ) + 'px';
				}
			}

			if( downPos ) {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( ( offsets.height / 2 ) - aHeight  + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 removed cos its value is 0
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px' 
			}
			else {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) ); 
					tempNum = ( drop.height - offsets.height / 2 - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'
			}

			if( rightPos ) {
				this.setData( 'pos', 'right' );
			}
			else {
				this.setData( 'pos', 'left' );
			}

			if( downPos ) {
				this.setData( 'secondaryPosition', 'down' );
			}
			else {
				this.setData( 'secondaryPosition', 'up' );
			}
		}
		else if( position === 'up' ) {
			topPos = true
			if( offsets.top - drop.height < scopeBoundary.top 
				&& offsets.top + offsets.height + height < scopeBoundary.bottom 
			) {
				topPos = false
			}
			else {
				topPos = true
			}

			rightPos = 0
			if( offsets.left + offsets.width - width > scopeBoundary.left ) {
				rightPos = 1;
			}
			if( offsets.left + width <= scopeBoundary.right ) {
				rightPos += 2;
			}

			if( rtl ) {
				rightPos = !!( !( rightPos & 1 || !rightPos ) );
			}
			else {
				rightPos = !!( rightPos & 2 || !rightPos );
			}

			if( useSave && !_lyteDropdown.isEmpty( save ) ) {
				rightPos = save.rightPos;
				topPos = save.topPos;
			}
			else if( useSave ) {
				save.rightPos = rightPos;
				save.topPos = topPos;

				this.setData( 'savedPositions', save );
			}

			if( topPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - aHeight + 'px';	
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempStore = this.setTopBelowForDown( par, offsets, y ) + aHeight + 'px';
				}
				else {
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'
				}
			}
			if( rightPos ) {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempNum = offsets.width / 2 + tempMarginLeft - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%' 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';
			}
			else {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) + tempMarginLeft - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom; 
					arrow.style.left = tempPer +'%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, width, x ) + 'px';
			}

			if( topPos ) {
				this.setData( 'pos', 'up' );
			}
			else {
				this.setData( 'pos', 'down' );
			}

			if( rightPos ) {
				this.setData( 'secondaryPosition', 'right' );
			}
			else {
				this.setData( 'secondaryPosition', 'left' );
			}
		}
		else if( position === 'left' ) {
			leftPos = 0;
			
			if( offsets.left + offsets.width + width < scopeBoundary.right ) {
				leftPos = 1;
			}
			if( offsets.left - width > scopeBoundary.left ) {
				leftPos += 2;
			}

			if( rtl ) {
				leftPos = !!( !( leftPos & 1  || !leftPos ) );
			}
			else {
				leftPos = !!( leftPos & 2 || !leftPos );
			}

			downPos = true;
			if( offsets.top + drop.height > scopeBoundary.bottom ) {
				downPos = false;
			}
			else {
				downPos = true;
			}

			if( useSave && !_lyteDropdown.isEmpty( save ) ) {
				leftPos = save.leftPos;
				downPos = save.downPos;
			}
			else if( useSave ) {
				save.leftPos = leftPos;
				save.downPos = downPos;

				this.setData( 'savedPositions', save );
			}

			if( leftPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setRightForRight( par, body, offsets, width, x ) - aWidth + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, width, x ) + 'px';
				}	
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setLeftForRight( par, offsets, x ) + aWidth + 'px';
				}
				else {
					body.style.left = this.setLeftForRight( par, offsets, x ) + 'px';
				}
			}
			if( downPos ) {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( ( offsets.height / 2 ) - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px';
			}
			else{
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).getPropertyValue( 'border-left-width' );
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( drop.height - offsets.height / 2 - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%'; 
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';
			}

			if( leftPos ) {
				this.setData( 'pos', 'left' );
			}
			else {
				this.setData( 'pos', 'right' );
			}

			if( downPos ) {
				this.setData( 'secondaryPosition', 'down' );
			}
			else {
				this.setData( 'secondaryPosition', 'up' );
			}
		}

		body.__height = height;	
	},

	getScopeBoundary: function() {
		var scope = this.getData( 'ltPropScope' ),
		element,
		res = {
			left: 0,
			top: 0,
			right: window.innerWidth,
			bottom: window.innerHeight
		}, boundingRects;

		if( scope !== 'window' ) {
			element = $L( this.$node ).closest( scope ).get( 0 );

			if( element ) {
				boundingRects = element.getBoundingClientRect();

				return {
					left: Math.max( 0, boundingRects.left ),
					top: Math.max( 0, boundingRects.top ),
					right: Math.min( window.innerWidth, boundingRects.right ),
					bottom: Math.min( window.innerHeight, boundingRects.bottom )
				};
			}
		}

		return res;
	},

	setFreezeLayer: function() {
		var node = document.getElementById( 'lytedropdownfreezelayer' ),
		scrollsToPrevent = this.getData( 'ltPropPreventScroll' );

		if( scrollsToPrevent === 'all' ) {
			node.style.display = 'block';
			node.classList.add( 'lyteDropdownZIndex' );
		}

		document.body.classList.add( 'lyteBodyWrapper' );
	},

	isInView: function( element ) {
		var body = this.getDropBody( this.childComp ),
		containerScrollTop = body.scrollTop,
		containerHeight = body.offsetHeight,
		elementTop = element.offsetTop,
		elementHeight = element.offsetHeight;

		return elementTop >= containerScrollTop && elementTop + elementHeight <= containerScrollTop + containerHeight; 
	},

	moveIntoView: function( element ) {
		var body = this.getDropBody( this.childComp ),
		containerScrollTop = body.scrollTop,
		elementTop = element.offsetTop;

		if( elementTop <= containerScrollTop ) {
			this.moveDown( element );
		}
		else {
			this.moveUp( element );
		}
	},

	moveDown: function( element ) {
		var body = this.getDropBody( this.childComp );

		body.scrollTop = element.offsetTop;
	},

	moveUp: function( element ) {
		var body = this.getDropBody( this.childComp );

		body.scrollTop = element.offsetTop + element.offsetHeight - body.offsetHeight
	},

	scrollIntoView: function( element, move ) {
		var parent = this.getDropBody( this.childComp ),
		offsetTop = element.offsetTop,
		scrollT = parent.scrollTop,
		height = parent.getBoundingClientRect().height,
		elementHeight = element.getBoundingClientRect().height;

		if( !parent.contains( element ) ) {
			// There can be elements inside lyte-drop-footer. So we only scroll to elements inside the body
			return ;
		}

		if( !this.isInView( element ) ) {
			this.moveIntoView( element );
		}
	},

	open: function() {
		var that = this, link,
		type = this.getData( 'ltPropType' ),
		head = this.getData( 'drophead' ),
		mul = this.getData( 'multiple' ),
		freeze = this.getData( 'ltPropFreeze' ),
		hover = this.getData( 'ltPropHover' );
		
		link = this.childComp = this.$node.querySelector( 'lyte-drop-box' );

		this.closeError( link, head );
		this.hideNodes();

		if( 
			type === 'multisearch' 
			&& head !== 'yield' 
		) {
			$L( this.$node.querySelector( '.lyteDropdownTextField' ) ).search( {
				scope: link,
				trim: true,
				search: 'lyte-drop-item',
				related: 'lyte-drop-group',
				onSearch: function( res, event, value ) {
					var i = 0, lk = that.childComp,
					body = that.getDropBody( lk ),
					div = body.querySelector( '.lyteDropdownNoResult' ),
					text = that.getData( 'ltPropNoResult' ), ret;

					if( that.getMethods( 'onSearch' ) ) {
						ret = that.executeMethod( 'onSearch', res, event, value, that );
					}

					if( ret === false ) {
						return ret;
					}

					for( ; i < res.length; i++ ) {
						if( !res[ i ].classList.contains( 'lyteDropdownActive' ) ) {
							if( div ) {
								div.style.display = 'none';
							}

							// that.toggleCurrent( res[ i ], that.getDropBody( lk ) );

							return ;
						}
					}

					if( div.style.display !== 'none' ) {
						return ;
					}

					if( text ) {
						div.style.display = 'block';
					}
				}
			} );
		}

		_lyteUiUtils.appendChild( document.body, link );
		link.origindd = this.$node;
		link.classList.remove( 'lyteDropdownHidden' );

		this.preventParentScroll();

		if( freeze && !mul && !hover ) {
			this.setFreezeLayer()
		}

	},

	preventParentScroll: function() {

		if( !this.getData( 'ltPropPreventParentScroll' ) ) {
			return ;
		}

		var parents = $L( this.$node ).parents(), scrollableParents, lyteScrollBarParents, that = this;

		scrollableParents = parents.filter( this.isScrollable );
		lyteScrollBarParents = parents.filter( this.isLyteScrollBar );

		lyteScrollBarParents = lyteScrollBarParents.map( function( index, item ) {
			return item.parentNode;
		} );

		scrollableParents.each( function( index, item ) {
			$L( item ).data( 'lyte-scrollTop', item.scrollTop );
			$L( item ).data( 'lyte-scrollLeft', item.scrollLeft );
		} );

		this.scrollableParents = scrollableParents;
		this.lyteScrollBarParents = lyteScrollBarParents;

		this.scrollableParents.on( 'scroll', this.resetScroll );
		this.lyteScrollBarParents.each( function( index, item ) {
			if( item ) {
				item.addEventListener( 'touchmove', that.disableLyteScrollBar, true );
				item.addEventListener( 'wheel', that.disableLyteScrollBar, true );
			}
		} );

		document.body.classList.add( 'lyteBodyWrapper' );
	},

	disableLyteScrollBar: function( event ) {
		event.stopPropagation();
	},

	isScrollable: function( index, item ) {
		var overflowY = $L( item ).css( 'overflow-y' ),
		overflowX = $L( item ).css( 'overflow-x' );

		if( ( item.clientWidth < item.scrollWidth && ( overflowX === 'auto' || overflowX === 'scroll' ) ) || ( item.clientHeight < item.scrollHeight && ( overflowY === 'auto' || overflowY === 'scroll' ) ) ) {
			return true;
		}

		return false;
	},

	isLyteScrollBar: function( index, item ) {
		return item.classList.contains( 'lyteScrollBar' );
	},

	resetScroll: function() {
		var scrollTop = $L( this ).data( 'lyte-scrollTop' ),
		scrollLeft = $L( this ).data( 'lyte-scrollLeft' );

		this.scrollTop = scrollTop;
		this.scrollLeft = scrollLeft;
	},

	hideNodes: function() {
		var link = this.childComp, selected, i = 0, item,
		mul = this.getData( 'multiple' ),
		type = this.getData( 'ltPropType' ),
		head = this.getData( 'drophead' ),
		sel = this.getData( 'ltPropSelected' );

		// Hide the filtered items in the dropdown list
		if( mul && sel && sel.length > 2 ) {                    
			if( !link ) {
				return ;
			}

			try {
				selected = JSON.parse( this.getData( 'ltPropSelected' ) || '[]' );
			}
			catch( err ) {
				console.error( 'Unable to parse ltPropSelected', err );
				return ;
			}

			// Hide new selected values
			for( ; i < selected.length; i++ ) {
				item = link.querySelector('[data-value="'+ window._lyteUiUtils.escape( selected[ i ] ) +'"]');
				if( item ) {
					item.classList.add( 'lyteDropdownActive' );
					this.hideGroup( item );
					this.setData( 'preventSel', true );
					item.setAttribute( 'selected', true );
					this.setData( 'preventSel', false );
				}	
			}
		}

		this.showError( link, type, head );
	},

	showNodes: function( change ) {
		var i = 0, j, olen, elm, res, 
		link = this.childComp,
		body = this.getDropBody( link ),
		mul = this.getData( 'multiple' ),
		type = this.getData('ltPropType'),
		head = this.getData('drophead'),
		all = this.getData( 'ltPropSelectedList' ),
		sysValue = this.getData( 'sysValue' ),
		nv = change.newValue, 
		ov = change.oldValue;

		if( !mul ) {
			return ;
		}

		// if link doesn't make sense here: TODO
		if( link ) {
			res = body.querySelector( '.lyteDropdownNoResult' );
		}

		try {
			// Convert to string for obvious reasons
			nv = JSON.parse( nv || '[]' ).map( function( val ) {
				return '' + val;
			} );

			// Convert to string for obvious reasons
			ov = JSON.parse( ov || '[]' ).map( function( val ) {
				return '' + val;
			} );
		}
		catch( err ) {
			console.error( 'Unable to parse ltPropSelected', err );
			return ;
		}

		olen = ov.length;
		for( ; i < olen; i++ ) {
			if( nv.indexOf( ov[ i ] ) === -1 ) {
				if( link ) {
					elm = link.querySelector( '[data-value="' + window._lyteUiUtils.escape( ov[ i ] ) + '"]' );

					// show items in dropbox
					if( elm ) {
						elm.classList.remove( 'lyteDropdownActive' );
						this.showGroup( elm );
						this.setData( 'preventSel', true );
						elm.removeAttribute( 'selected' );
						this.setData( 'preventSel', false );

					}
				}
				

				// remove items from head
				this.setData( 'preventSelListObs', true );

				for( j = 0; j < all.length; j++ ) {
					if( ( '' + all[ j ][ sysValue ] ) === ov[ i ] ) {
						Lyte.arrayUtils( all, 'removeAt', j, 1 );
						break;
					}
				}

				this.setData( 'preventSelListObs', false );

				// May need to add a check to see if the dropdown is open
				if( res
					&& ( ( type === 'multisearch' && head !== 'yield' ) 
					|| type === 'multiple' )
				) {
					res.style.display = 'none';
				}
			}
		}
	},

	selObs: function( change ) {
		var old = change.oldValue;

		if( this.getData( 'prev' ) ) {
			return ;
		}

		// TODO:
		// When limit crosses we reset the ltPropSelected which causes the other lt-prop-selected to fire
		// That observer fires twice overall but doesn't change the state of the dropdown but we need to cutdown
		// the processing
		if( this.checkLimit( 0 ) ) {
			this.setData( 'prev', true );
			this.setData( 'ltPropSelected', old );
			this.setData( 'prev', false );

			return ;
		}

		this.hideNodes();
		this.showNodes( change );
	}.observes( 'ltPropSelected' ),

	toggleDropdownClass: function() {
		var node = this.$node,
		sel = this.getData( 'ltPropSelected' ) || '[]',
		isMultiple = this.getData( 'multiple' );

		if( !isMultiple ) {
			return ;
		}

		sel = JSON.parse( sel );

		if( sel.length > 0 ) {
			node.classList.remove( 'lyteDropNoOptSelected' )
		}
		else {
			node.classList.add( 'lyteDropNoOptSelected' );
		}
	},

	first: function() {
		var type = this.getData( 'ltPropType' );

		this.setData( 'ltPropShow', true );
		this.setData( 'ltPropIsOpen', true );
		this.open();

		if( type === 'multisearch' ) {
			this.focusInput();
		}
	},

	subsequent: function( link, freeze, mul, hover ) {
		var type = this.getData( 'ltPropType' ),
		head = this.getData( 'drophead' );

		this.setData( 'ltPropIsOpen', true );
		link.classList.remove( 'lyteDropdownHidden' );

		this.preventParentScroll();

		if( freeze && !mul && !hover ) {
			this.setFreezeLayer()
		}

		if( type === 'multisearch' ) {
			this.focusInput();
		}

		this.closeError( link, head );
		this.showError( link, type, head );
	},

	/**
	 * This invokes the beforeShow method but with a twist
	 * You can now return promises which open the dropdown only when they are resolved
	 * @param {Event} event - The event
	 * @param {boolean} fromTg - Whether it is from the toggle function
	 *
	 *
	 */

	beforeShow: function( event, fromTg, first ) {
		var res, that = this, link = this.getDropBox(),
		freeze = this.getData( 'ltPropFreeze' ),
		mul = this.getData( 'multiple' ),
		hover = this.getData( 'ltPropHover' );

		res = this.executeMethod( 'onBeforeShow', event, this );
		if( res && res.then ) {

			_lyteDropdown.lastDropdownWithAPromise = this.$node;
			this.setData( 'blockShowHide', true );

			res
			.then( function( arg ) {
				that.setData( 'blockShowHide', false );

				if( that.isNotLastDropdownWithPromise() ) {
					return ;
				}
				
				that.setData( 'call', fromTg ? true : event );

				if( first ) {
					that.first();
				}
				else {
					that.subsequent( link, freeze, mul, hover );
				}
			} )
			.catch( function( err ) {
				that.setData( 'blockShowHide', false );
				link.removeAttribute( 'lyte-hidden' );
				console.error( err );
			} );
		}
		else if( res !== false ) {
			that.setData( 'call', fromTg ? true : event );
			if( first ) {
				that.first();
			}
			else {
				that.subsequent( link, freeze, mul, hover );
			}
		}
		else if( res === false ) {
			link.removeAttribute( 'lyte-hidden' );
		}
	},

	// Don't change this fn name because thangagiri/anantha(in lyte-tags) is using it to get the dropbox in one of his components.
	getDropBox: function() {
		var box = this.childComp;

		if( !box ) {
			box = this.$node.querySelector( 'lyte-drop-box' );
		}

		return box;
	},

	isNotLastDropdownWithPromise: function() {
		var lastDropdown = _lyteDropdown.lastDropdownWithAPromise;

		return this.$node !== lastDropdown;
	},

	/**
	 * Show the error div when one of the elements get removed
	 * @param link - the drop box
	 * @param head -  the dropdown's head
	 *
	 */

	closeError: function( link, head ) {
		var body = this.getDropBody( link ), 
		result = body.querySelector( '.lyteDropdownNoResult' ),
		type = this.getData( 'ltPropType' );

		if(  
			result 
			&& ( ( head !== 'yield' && type === 'multisearch' )
				|| ( type === 'multiple' ) )
			
		) {
			result.style.display = 'none';
		}
	},

	/**
	 * Check if the number of selected items has crossed the limit
	 * @param {Number} extra - The extra items to be added to the selected list
	 * @returns {Boolean} - true if it does
	 *
	 */

	checkLimit: function( extra ) {
		var type = this.getData( 'ltPropType' ),
		max = this.getData( 'ltPropMaxCount' ),
		sel = this.getData( 'ltPropSelected' ),
		arr, count;

		if( type !== 'multiple'
			&& type !== 'multisearch' 
		) {
			return ;
		}

		arr = JSON.parse( sel || '[]' ),
		count = arr.length + extra;

		if( max > 0 && count > max ) {
			return true;
		}
	},

	/**
	 * Find the data-values of nodes that are going to be removed
	 * @param {sel} - The current selected
	 * @param {Array} nodes - An array of HTMLElements that are going to be removed
	 * @return {Object} - Object containing two keys => removed representing the nodes that are getting removed and selected which represents the current selected
	 *
	 */

	findMarked: function( sel, nodes ) {
		var i, ind, removed = [],
		len = nodes.length;

		try {
			sel = JSON.parse( sel || '[]' ).map( function( val ) {
				return '' + val; 
			} );
		}
		catch( er ) {
			console.error( 'Unable to parse ltPropSelected', er );
		}

		// Unfortunately sortable can change the order of selected values 
		for( i = 0; i < len; i++ ) {
			ind = sel.indexOf( nodes[ i ].getAttribute( 'data-value' ) );
			removed = removed.concat( sel.splice( ind, 1 ) );
		}

		return {
			removed: removed,
			selected: sel
		};
	},

	/**
	 * Remove the marked values
	 * @param sel - The current selected
	 * @param nodes - nodes that are going to be removed
	 * @param head - whether the content was yielded or not
	 *
	 */

	removeMarked: function( sel, nodes, head, link ) {
		var len = nodes.length, 
		i, j, all = this.getData( 'ltPropSelectedList' ),
		sysValue = this.getData( 'sysValue' ),
		body, node;

		this.setData( 'preventSelListObs', true );

		for( i = 0; i < len; i++ ) {
			for( j = 0; j < all.length; j++ ) {
				if( ( '' + all[ j ][ sysValue ] ) == nodes[ i ].getAttribute( 'data-value' ) ) {
					Lyte.arrayUtils( all, 'removeAt', j );
					break;
				}
			}
		}

		this.setData( 'preventSelListObs', false );

		body = this.getDropBody( link );

		for( i = 0; i < nodes.length; i++ ) {
			node = body.querySelector( '[data-value="'+ window._lyteUiUtils.escape( nodes[ i ].getAttribute( 'data-value' ) ) +'"]' );
			if( node ) {
				node.classList.remove( 'lyteDropdownActive' );
				node.classList.remove( 'lyteSearchHidden' );
				this.showGroup( node ); 
				node.removeAttribute( 'selected' );
			}
		}

		this.setData( 'prev', true );
		this.setData( 'ltPropSelected', JSON.stringify( sel ) );
		this.setData( 'prev', false );

	},

	removeAll: function( event ) {
		var drop = this.$node,
		link = this.childComp,
		head = this.getData( 'drophead' ),
		button = drop.querySelector( 'lyte-drop-button' ),
		nodes = button.querySelectorAll( '.lyteDropMark' ),
		oldSelected = this.getData( 'ltPropSelected' ),
		sel = this.getData( 'ltPropSelected' ),
		proper, changeObj, ret;

		changeObj = this.findMarked( sel, nodes );

		proper = this.getData( 'isKeyDown' ) ? 'keydown' : 'click';

		// Intentionally sending false because we are already passing in an array
		ret = this.beforeRemove( event, changeObj.removed, proper, nodes );

		if( ret ) {
			// Don't know why exactly this is here
			event.stopPropagation();
			return ;
		}

		this.removeMarked( changeObj.selected, nodes, head, link );

		this.closeError( link, head );

		if( this.getMethods( 'onRemove' ) ) {
			this.executeMethod( 'onRemove', event, changeObj.removed, this.getData( 'ltPropSelected' ), this, proper, nodes );
		}

		this.fireOnChange( oldSelected, event, nodes );

		// Don't know why exactly this is here
		event.stopPropagation();
	},


	/**
	 * Returns true when current clicked node and previous selected node( only 1 ) are same or one of the previous selected nodes is behind. Else returns false
	 * 
	 * @param cur - currently selected node
	 */

	relativePosition: function( cur, prev ) {
		var iterator = cur;

		// When the current selected element and the previous selected element is the same
		if( prev.length === 1 && prev[ 0 ] === cur ) {
			return true;
		}

		// Loop through previous elements to check if it is present
		while( ( iterator = iterator.previousElementSibling ) ) {
			if( iterator.getAttribute( 'lyte-last' ) ) {
				return true;
			}
		}

		return false;
	},

	shade: function( node ) {
		var front, iterator, 
		// There can be dropdowns within dropdown - this guarantees the first button is selected
		present = this.$node
							.querySelector( 'lyte-drop-button' )
							.querySelectorAll( '.lyteDropMark' );

		// Don't process when a there are more than 1 selected items and the user clicks on one of the selected items
		if( present.length > 1 && node.classList.contains( 'lyteDropMark' ) ) {
			return ;
		}

		iterator = ( present.length === 0 || this.relativePosition( node, present ) ) ? 'previousElementSibling' : 
																			'nextElementSibling';

		do {
			node.classList.add( 'lyteDropMark' );
		} while( ( node = node[ iterator ] ) 
				&& !node.getAttribute( 'lyte-last' ) );
	},

	fireCheckKey: function() {
		var node = this.$node;

		node.constructor._actions.checkKey.call( this, event );
	},

	fireOnChange: function( oldValue, event, item ) {
		var newValue = this.getData( 'ltPropSelected' );

		if( this.hasValueChanged( oldValue ) && this.getMethods( 'onChange' ) ) {
			this.executeMethod( 'onChange', event, newValue, this, item );
		}	
	},

	hasValueChanged: function( oldValue ) {
		var newValue = this.getData( 'ltPropSelected' ),
		isMultiSelects = this.getData( 'multiple' );

		if( isMultiSelects ) {
			oldValue = this.stringifyALS( oldValue );
			newValue = this.stringifyALS( newValue );

			// differently ordered selected values are considered different.
			return oldValue !== newValue;
		}
		else {
			return oldValue !== newValue;
		}
	},

	stringifyALS: function( arrayLikeString ) {
		arrayLikeString = arrayLikeString || '[]';
		
		arrayLikeString = JSON.parse( arrayLikeString ).map( function( item ) {
			return '' + item;
		} );

		return JSON.stringify( arrayLikeString );
	},

	mark: function( node, shift, single ) {

		

		// When shift is pressed
		if( shift ) {
			_lyteDropdown.unmark( this );
			this.shade( node );
		}
		// When command or control is pressed
		else if( single ) {
			_lyteDropdown.unmark( this );
			node.classList.add( 'lyteDropMark' );
		}
		// When none of the modifier keys are pressed
		else {
			_lyteDropdown.unmark();
			node.classList.add( 'lyteDropMark' );
		}

		this.setLast( node );	
	},

	beforeSelect: function( event, item ) {
		var selected = this.getData( 'ltPropSelected' ), ret = true,
		value = item.getAttribute( 'data-value' );

		if( this.getMethods( 'beforeSelect' ) ) {
			ret = this.executeMethod( 'beforeSelect', event, selected, this, item, value );
			ret = ret === false ? false : true;
		}

		return ret;
	},

	/**
	 * This function is going to focus the input in the dropdown when 
	 * an item is selected from the multiselect list
	 * an item is removed from the selected list
	 *
	 */

	focusInput: function() {
		var inp;

		// People have search inside the drop-box in multisearch
		if( !window._lyteUiUtils.isMobile ) {
			$L.fastdom.measure( function() {
				
				if( !this.$node ) {
					return ;
				}

				var inp = this.$node.querySelector( 'input' );

				if( inp ) {
					inp.focus();
				}
			}, this );	
		}
		else {
			inp = this.$node.querySelector( 'input' );

			if( inp ) {
				inp.focus();
			}
		}
	},

	/**
	 * This is going to show the no result div
	 * @param {Element} link - The drop-box element
	 * @param {String} type - The dropdown type
	 * @param {String} head - Whether the head is an yield or not
	 *
	 */

	showError: function( link, type, head ) {
		var body = this.getDropBody( link ),
		nodes = body.querySelectorAll( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' ),
		res, text = this.getData( 'ltPropNoResult' );

		if( 
			text
			&& nodes.length === 0
			&& ( res = body.querySelector( '.lyteDropdownNoResult' ) )
			&& ( ( type === 'multisearch' && head !== 'yield' ) || ( type === 'multiple' ) ) 
		) {
			res.style.display = 'block';
		}
	},

	/**
	 * This is going to decide whether to remove or to not remove the current item from the multiselect
	 * @param {Event} event - The event object
	 * @param {String/Array} src - An array or the single data-value getting removed
	 * @param {String} proper - The event which triggered the remove function
	 * @param {Element/Array} node - An array or the single item getting removed
	 * @returns {Boolean} - true to prevent it from getting removed
	 *
	 */

	beforeRemove: function( event, src, proper, node ) {
		var ret;

		if( this.getMethods( 'onBeforeRemove' ) ) {
			ret = this.executeMethod( 'onBeforeRemove', event, src, this.getData( 'ltPropSelected' ), this, proper, node );

			ret = ret != false ? false : true;
		}

		return ret;
	},

	/**
	 * This invokes a method which is going to decide whether to add the item into the multiselect or not
	 * @param {Event} event - The event object
	 * @param {Element} elm - The element that was selected
	 * @param {String} src - Its data-value
	 * @returns {Boolean} - returning prevents the element from being selected
	 *
	 */

	beforeAdd: function( event, elm, src ) {
		var ret;

		if( this.getMethods( 'onBeforeAdd' ) ) {
			ret = this.executeMethod( 'onBeforeAdd', event, src, this.getData( 'ltPropSelected' ), this, elm );

			ret = ret != false ? false : true;
		}

		return ret;	
	},

	/**
	 * This is going to invoke the beforeHide callback and tell us whether the dropbody should be hidden or not
	 * @param {Event} event - The invoked event object
	 *
	 *
	 */

	beforeHide: function( link, event, freeze ) {
		var res = false;

		if( this.getMethods( 'onBeforeHide' ) ) {
			res = this.executeMethod( 'onBeforeHide', event, this );
			if( res && res.then ) {
				res
				.then( function() {
					this.closeDrop( link, event, freeze);
				}.bind( this, link, event, freeze ) )
				.catch( function( err ) {
					console.error( err );
				} );

				return true;
			}
			res = res != false ? false : true;
		}

		return res;
	},

	beforeScrollClose: function( event ) {
		if( this.getMethods( 'onBeforeScrollClose' ) ) {
			this.executeMethod( 'onBeforeScrollClose', event );
		}
	},

	beforeScrollOpen: function( event ) {
		if( this.getMethods( 'onBeforeScrollOpen' ) ) {
			this.executeMethod( 'onBeforeScrollOpen', event );
		}
	},

	/**
	 * This is going to set the highlight element of the dropdown
	 * @param {NodeList} elems - All the lyte-drop-items to be traversed
	 * @param {Element} node - Current selected drop-item
	 *
	 */

	 setHighlight: function( elems, node ) {
	 	var i = 0, j, k;

	 	for( ; i < elems.length; i++ ) {
			if( elems[ i ].classList.contains( 'lyteDropdownSelection' ) ) {
				break;
			}
		}

		if( elems[ i ] && elems[ i ] === node ) {
			
			k = j = i;
			i = _lyteDropdown.find( elems, i + 1, true );

			

			if( i != elems.length ) {
				elems[ i ].classList.add( 'lyteDropdownSelection' );
			}
			else {
				j = _lyteDropdown.find( elems, j - 1, false );

				if( j != -1 ) {
					elems[ j ].classList.add( 'lyteDropdownSelection' );
				}
			}

			elems[ k ].classList.remove( 'lyteDropdownSelection' );
		}

	 },

	/** 
	 * Sets the current node as the last selected node 
	 * so that subsequent selections can proceed from this node ( Also removes the previous last)
	 * 
	 * @param node - the node which is going to be the last node that is getting set
	 */

	setLast: function( node ) {
		var prev = document.querySelector( '[lyte-last="true"]' );

		if( prev ) {
			prev.removeAttribute( 'lyte-last' );
		}

		node.setAttribute( 'lyte-last', true );
	},

	/**
	 * This is going to invoke the onOptionSelected callback
	 * @param {Event} event - The event object
	 * @param {string} sel - The current selected value
	 * @param {Element} elm - The lyte-drop-item that was selected
	 *
	 */

	optCall: function( event, sel, elm ) {
		if( this.getMethods( 'onOptionSelected' ) ) {
			this.executeMethod( 'onOptionSelected', event, sel, this, elm );
		}
	},

	/**
	 * Function to set the first value as lt-prop-selected
	 *
	 */

	setInitialSelected: function( options ) {
		var options = options || this.getData( 'ltPropOptions' ) || [],
		firstElement = options[ 0 ],
		flag = false,
		value;

		if( firstElement.constructor == Object ) {
           	if( Object.keys( firstElement ).length == 1 ) {
	            value = firstElement[ Object.keys( firstElement )[ 0 ] ];
	            if( value.constructor == Array ) {
	                flag = true
	            }
	        }   
        }

        if( flag ) {
           	if ( Object.prototype.toString.call( value[ 0 ] ) === '[object Object]' ) {
           		this.setData( 'ltPropSelected', value[ 0 ][ this.getData( 'ltPropSystemValue' ) ] );
           	}
           	else{
           		this.setData( 'ltPropSelected', value[ 0 ] );
           	}
        }
        else{
           	if ( Object.prototype.toString.call( firstElement ) === '[object Object]' ) {
           		this.setData( 'ltPropSelected', firstElement[ this.getData( 'ltPropSystemValue' ) ] );
           	}
           	else {
           		this.setData( 'ltPropSelected', firstElement );
           	}
        }
	},

	/**
	 * Function to set an initial value to the dropdown when lt-prop-options is pushed later
	 * into the dropdown. When lt-prop-options is empty and new items are pushed in 
	 * @param change - Old value and new values
	 *
	 */

	contentChange: function( change ) {
		var oldValue = change.oldValue,
		newValue = change.newValue,
		sel = this.getData( 'ltPropSelected' ),
		ph = this.getData( 'ltPropPlaceholder' ),
		disp = this.getData( 'ltPropDisplayValue' ),
		body = this.getData( 'dropbody' ) === 'yield',

		// Old value of lt-prop-options should be empty and the new value should be filled
		initial = ( 
					( oldValue && oldValue.length === 0 ) 
					|| !oldValue 
				) && newValue && newValue.length > 0;

		if( initial && !sel && !ph && !body ) {
			this.setInitialSelected();	
		}

		this.showNoResultDiv();
	}.observes( 'ltPropOptions' ),

	// This is going to only process the child nodes
	hideOptionsBasedOnSelected: function() {
		// This is for multiselect
		var link = this.childComp,
		head = this.getData( 'drophead' ),
		multiple = this.getData( 'multiple' ),
		type = this.getData( 'ltPropType' );

		if( link && multiple ) {
			this.hideNodes();
			
			// close error will always close the error
			this.closeError( link, head );

			// So there is no error div showing now and show error will decide to show it or not based on the displayed items
			this.showError( link, type, head );
		}
	}.observes( 'ltPropOptions' ),

	selChange: function() {
		var mul = this.getData( 'multiple' ),
		head = this.getData( 'drophead' ), 
		link = this.childComp,
		sel = this.getData( 'ltPropSelected' ),
		disp = this.getData( 'ltPropDisplayValue' ),
		preventDisp = this.getData( 'preventDisp' ),
		sels, parent = link ? link : this.$node.querySelector( 'lyte-drop-box' ), 
		body = this.getDropBody( parent ),
		node, i = 0;

		if( this.prevSelectedList ) {
			return ;
		}

		if( 
			mul 
		) {
			this.setSelectedList();	
		}
		else if( !mul ) {
			node = parent.querySelector( '[data-value="' + window._lyteUiUtils.escape( sel ) + '"]' );

			if( node ) {
				this.toggleCurrent( node );
			}

			// Don't remove previous selected=true attribute when it is a multiselect should only remove it when the element is removed from the selected list.
			sels = parent.querySelectorAll( '[selected]' );

			for( ; i < sels.length; i++ ) {
				if( sels[ i ].getAttribute( 'data-value' ) != sel ) {
					sels[ i ].removeAttribute( 'selected' );
				}
			}

			if( head !== 'yield' ) {
				if( node ) {
					var innerText = node.textContent;

					if( ( disp && !preventDisp ) || !disp ) {

						// don't really need the or over here but w.e
						this.setData( 'ltPropDisplayValue', ( innerText || '' ).trim() );
					}	
				}
				else if( !sel && !preventDisp ) {
					this.setData( 'ltPropDisplayValue', '' );
				}
			}

		}

		// To set selected to true to the ltPropSelected node
		if( node ) {
			node.setAttribute( 'selected', 'true' );
		}

		this.toggleDropdownClass();
	
	}.observes(
		'ltPropOptions',
		'ltPropSelected',
		'changeItToInvoke'
	),

	setSelectedList: function() {
		var sel = this.getData( 'ltPropSelected' ),
		selected, selectedList;

		if( !sel ) {
			return ;
		}

		try {
			selected = JSON.parse( sel || '[]' ).map( function( val ) {
				return '' + val;
			} );
		}
		catch( err ) {
			console.error( 'Could not parse ltPropSelected', err );
			return ;
		}

		this.buildList( selected );
	},

	buildList: function( selected ) {
		this.setData( 'preventSelListObs', true );

		for( var i = 0; i < selected.length; i++ ) {
			if( this.isPresentInList( selected[ i ] ) ) {
				continue;
			}

			if( this.isOptionsGiven() ) {
				this.buildWithOptions( selected[ i ] );
			}
			else {
				this.buildManually( selected[ i ] );
			}
		}

		this.setData( 'preventSelListObs', false );
	},

	isPresentInList: function( sel ) {
		var list = this.getData( 'ltPropSelectedList' ),
		sysValue = this.getData( 'sysValue' );

		for( var i = 0; i < list.length; i++ ) {
			if( ( '' + list[ i ][ sysValue ] ) === sel ) {
				return true;
			}
		}

		return false;
	},

	isOptionsGiven: function() {
		var userValue = this.getData( 'ltPropUserValue' ),
		sysValue = this.getData( 'ltPropSystemValue' )

		return userValue || sysValue;
	},

	buildWithOptions: function( selected ) {
		var options = this.getData( 'ltPropOptions' ) || [],
		sysValue = this.getData( 'sysValue' ), selectedObj, i = 0;

		while( i < options.length && !selectedObj ) {
			if( this.isOptGroup( options[ i ] ) ) {
				selectedObj = this.getSelectedFromGroup( options[ i ], selected );
			}
			else if( ( '' + options[ i ][ sysValue ] ) === selected ) {
				// TODO: Check if same object needs to be pushed or a cloned object needs to be pushed.
				selectedObj = options[ i ];
			}

			i++;
		}

		Lyte.arrayUtils( this.getData( 'ltPropSelectedList' ), 'push', selectedObj ); 
	},

	isOptGroup: function( option ) {
		var keys = Object.keys( option ),
		length = keys.length;

		return keys.length === 1 && Array.isArray( option[ keys[ 0 ] ] );
	},

	getSelectedFromGroup: function( group, selected ) {
		var key = Object.keys( group )[ 0 ],
		sysValue = this.getData( 'sysValue' );

		group = group[ key ] || [];

		for( var i = 0; i < group.length; i++ ) {
			if( ( '' + group[ i ][ sysValue ] ) === selected ) {
				return group[ i ];
			} 
		}
	},

	buildManually: function( selected ) {
		var link = this.childComp,
		parent = link ? link : this.$node.querySelector( 'lyte-drop-box' ),
		element = parent.querySelector( '[data-value="' + window._lyteUiUtils.escape( selected ) + '"]' ),
		obj = {
			value: selected,
			display: ( element || {} ).textContent
		};
		
		if( !obj.display ) {
			return ;
		}

		Lyte.arrayUtils( this.getData( 'ltPropSelectedList' ), 'push', obj ); 
	},

	tabIndexChange: function() {
		var disabled = this.getData( 'ltPropDisabled' ),
		tab = this.getElementWithTabIndex(),
		ind = this.getData( 'ltPropTabindex' );

		if( disabled ) {
			this.disableClickableItem( tab );
			tab.tabIndex = -1;
		}
		else{
			this.enableClickableItem( tab );
			tab.tabIndex = ind;
		}
	}.observes( 'ltPropDisabled' ),

	disableClickableItem: function( tab ) {
		var type = this.getData( 'ltPropType' );

		if( type === 'multisearch' ) {
			tab = this.getClickableItem( tab );
		}
		
		if( tab && tab.classList ) {
			tab.classList.add( 'lyteDropdown-disabled' );
		}

		this.$node.classList.add( 'lyteDropdownDisabled' );
	},

	enableClickableItem: function( tab ) {
		var type = this.getData( 'ltPropType' );

		if( type === 'multisearch' ) {
			tab = this.getClickableItem( tab );
		}
		
		if( tab && tab.classList ) {
			tab.classList.remove( 'lyteDropdown-disabled' );
		}	

		this.$node.classList.remove( 'lyteDropdownDisabled' );	
	},

	getClickableItem: function( tab ) {
		var head = this.getData( 'drophead' );

		if( head === 'noyield' ) {
			return _lyteDropdown.traverse( tab, [ 'HTML', 'LYTE-DROP-BUTTON' ] );
		}
		else {
			return this.$node.querySelector( '.lyteDummyEventContainer' );
		}

		
	},

	hideGroup: function( item ) {
		var group = $L( item ).parent(), visibleItems;

		if( !group.get( 0 ) || group.get( 0 ).tagName !== 'LYTE-DROP-GROUP' ) {
			return ;
		}

		visibleItems = this.getVisibleItems( group );

		if( visibleItems.length === 0 ) {
			group.addClass( 'lyteDropdownHideGroup' );
		}
	},

	showGroup: function( item ) {
		var group = $L( item ).parent(), visibleItems;

		if( !group.get( 0 ) || group.get( 0 ).tagName !== 'LYTE-DROP-GROUP' ) {
			return ;
		}

		visibleItems = this.getVisibleItems( group );

		if( visibleItems.length > 0 ) {
			group.removeClass( 'lyteDropdownHideGroup' );
		}
	},

	getVisibleItems: function( group ) {
		return group.find( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' );
	},

	setSelectedFromList: function( isDidConnect ) {
		var isMultiple = this.getData( 'multiple' ),
		list, selected, sysValue = this.getData( 'sysValue' ),
		selstr = this.getData( 'ltPropSelected' );

		if( !isMultiple ) {
			return ;
		}

		list = this.getData( 'ltPropSelectedList' );

		if( isDidConnect 
			&& !this.calculateSelected
		) {
			return ;
		}

		selected = [];

		for( var i = 0; i < list.length; i++ ) {
			selected.push( '' + list[ i ][ sysValue ] );
		}

		this.prevSelectedList = true;
		this.setData( 'ltPropSelected', JSON.stringify( selected ) );
		this.prevSelectedList = false;
		this.toggleDropdownClass();
	},

	focusDropdown: function() {
		var focusableElement = this.getElementWithTabIndex(),
		shouldFocus = this.getData( 'ltPropFocus' ),
		isSearch = this.getData( 'search' );

		if( shouldFocus ) {
			if( !isSearch && focusableElement ) {
				focusableElement.focus();
			}
			else if( isSearch ) {
				this.$node.open();
			}
		}

		this.data.ltPropFocus = false;
	}.observes( 'ltPropFocus' ).on( 'didConnect' ) ,

	showHideEmptyMessage: function() {
		this.showNoResultDiv();
	}.observes( 'ltPropShowEmptyMessage' ),

	setSelectedFromListObs: function() {
		if( this.getData( 'preventSelListObs' ) ) {
			return ;
		}

		this.setSelectedFromList();
	}.observes( 'ltPropSelectedList.[]' ),

	data: function() {
        return {
        	'shouldDisplayIcon': Lyte.attr( 'boolean', { 'default': false } ),
        	'changeItToInvoke':Lyte.attr("number",{"default":1}),
        	'dummy1':Lyte.attr("boolean",{"default":true}),
        	'dummy2':Lyte.attr("boolean",{"default":false}),
        	'savedPositions': Lyte.attr( 'object', { 'default': {} } ),

        	/**
        	 * @componentProperty {boolean} ltPropRemoveMultiple
        	 * @default false
        	 * @version 1.0.2
        	 * 
        	 */

        	'ltPropRemoveMultiple': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'removeMultiple', false ) } ),
        	'ltPropYield':Lyte.attr("boolean",{"default":false}),

        	/**
        	 * @componentProperty {default|multiple|multisearch} ltPropType
        	 * @default default
        	 */

        	'ltPropType':Lyte.attr( "string", { "default": 'default' } ),

        	/**
        	 * @componentProperty {number} ltPropTabindex
        	 * @default 0
        	 */

        	'ltPropTabindex':Lyte.attr("number",{"default":0}),

        	/**
        	 * @componentProperty {boolean} ltPropShow
        	 * @default false
        	 * 
        	 */

        	'ltPropShow':Lyte.attr("boolean",{"default":false}),

        	/**
        	 * @componentProperty {boolean} ltPropFreeze
        	 * @default true
        	 * 
        	 */

        	'ltPropFreeze':Lyte.attr( "boolean", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'freeze', true ) } ),

        	/**
        	 * @componentProperty {array} ltPropOptions
        	 * @default []
        	 */

        	'ltPropOptions':Lyte.attr("array",{"default":[]}),

        	/**
        	 * @componentProperty {string} ltPropUserValue
        	 */

        	'ltPropUserValue':Lyte.attr("string",{"default":undefined}),

        	/**
        	 * @componentProperty {string} ltPropSystemValue
        	 */

			'ltPropSystemValue':Lyte.attr("string",{"default":undefined}),

			/**
			 * @componentProperty {up|down|left|right} ltPropPosition
			 * @default down
			 */

			'ltPropPosition':Lyte.attr( "string", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'position', 'down' ) } ),

			/**
			 * @componentProperty {string} ltPropIconClass
			 * @default dropdown
			 */

			'ltPropIconClass':Lyte.attr( "string", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'iconClass', 'dropdown' ) } ),

			/**
			 * @componentProperty {string} ltPropSelected
			 * @default ''
			 */

			'ltPropSelected':Lyte.attr("string",{"default":''}),

			/**
			 * @componentProperty {boolean} ltPropCallout
			 * @default false
			 * 
			 */

			'ltPropCallout':Lyte.attr( "boolean", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'callout', false ) } ),

			/**
			 * @componentProperty {string} ltPropPlaceholder
			 * @version 1.0.4
			 */

			'ltPropPlaceholder': Lyte.attr( "string", { "default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'placeholder', '' ) } ),

			/**
			 * @componentProperty {boolean} ltPropDisabled
			 * @default false
			 * 
			 */

			'ltPropDisabled':Lyte.attr("boolean",{"default": false}),

			/**
			 * @componentProperty {boolean} ltPropHover
			 * @default false
			 * 
			 */

			'ltPropHover':Lyte.attr("boolean",{"default": false}),

			/**
			 * @componentProperty {string} ltPropNoResult
			 * @default No Results Found
			 * @version 2.0.0
			 */

			'ltPropNoResult':Lyte.attr("string",{"default": _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'noResult', _lyteUiUtils.i18n( 'no.results.found' ) ) } ),

			/**
			 * @componentProperty {number} ltPropMaxCount
			 * @default 0
			 * @version 2.1.0
			 */

			'ltPropMaxCount': Lyte.attr( 'number', { 'default': 0 } ),

   			'ltPropInputClass':Lyte.attr("string",{"default":'lyteSearch'}),

				/**
				 * @typedef {object} boundary
				 * @property {number} left
				 * @property {number} right
				 * @property {number} top
				 * @property {number} bottom
				 */
   			/**
   			 * @componentProperty {boundary} ltPropBoundary
   			 * @default {}
   			 */

   			'ltPropBoundary':Lyte.attr("object",{"default":{}}),
   			'pos':Lyte.attr("string",{"default":''}),
   			'secondaryPosition':Lyte.attr("string",{"default":''}),
   			'firePos':Lyte.attr("number",{"default":1}),
   			'ltPropAjaxRequest':Lyte.attr("object",{"default":{}}),
   			'firstRequest':Lyte.attr("boolean",{"default":true}),
   			'userValue': Lyte.attr( 'string' ),
   			'sysValue': Lyte.attr( 'string' ),

   			/**
   			 * @componentProperty {string} ltPropDisplayValue
   			 * @version 1.0.1
   			 */

   			'ltPropDisplayValue': Lyte.attr("string",{"default":"", hideAttr: true } ),

   			/**
   			 * @componentProperty {array} ltPropDisabledList
   			 * @version 1.0.3
   			 * @default []
   			 */

   			'ltPropDisabledList': Lyte.attr('array',{"default":[]}),

   			/**
   			 * @componentProperty {boolean} ltPropAnimate
   			 * @default false
   			 * 
   			 */

   			 ltPropAnimate : Lyte.attr( 'boolean', { default : _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'animate', false ) } ),
   			'ltPropSetPos': Lyte.attr( 'boolean', { 'default': false }),
				

   			/**
   			 * @componentProperty {tooltipConfig} ltPropTooltip
				 * @default { "position" : "bottom", "appearance" : "box","margin" : 5, "keeptooltip" : true}
   			 * @version 2.0.0
   			 * @component lyte-tooltip ltPropTooltipConfig
   			 */

   			'ltPropTooltip': Lyte.attr( 'object', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'tooltip', { 
	   				'position': 'bottom', 
	   				'appearance': 'box',
	   				'margin': 5,
	   				'keeptooltip': true 
   				} )
   				 
   			} ),
			// 'ltPropContainerClass':Lyte.attr("string",{"default":''}),
			// 'ltPropSlide':Lyte.attr("boolean",{"default": false}),

			/**
			 * @componentProperty {string} ltPropBoxClass
			 * @version 2.2.8
			 */

			'ltPropBoxClass': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'boxClass', '' ) } ),

			/**
			 * @componentProperty {boolean} ltPropIsOpen
			 * @default false
			 * 
			 * @version 2.2.8
			 */

			'ltPropIsOpen': Lyte.attr( 'boolean', { 'default': false } ),

			'ltPropFocus': Lyte.attr( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {boolean} ltPropFixPositionOnOpen
			 * @default false
			 * 
			 * @version 2.2.12
			 */

			'ltPropFixPositionOnOpen': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'fixPositionOnOpen', false ) } ),

			'ltPropForcePlaceholder': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'forcePlaceholder', false ) } ),

			'ltPropShowEmptyMessage': Lyte.attr( 'boolean', { 'default': false } ),

			'ltPropBoxButtonWidth': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'boxButtonWidth', 'min-button' ) } ),

			'ltPropPreventScroll': Lyte.attr( 'string', { 'default': 'all' } ),

			'ltPropScope': Lyte.attr( 'string', { 'default': 'window' } ),

			ltPropAnimateBox : Lyte.attr( 'boolean', { default : _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'animateBox', false ) } ),

			'ltPropTooltipClass': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'tooltipClass', '' ) } ),

			'ltPropDisplayList': Lyte.attr( 'array', { 'default': [] } ),

			'ltPropSelectedList': Lyte.attr( 'array', { 'default': [] } ),

			'searchMethod' : Lyte.attr( 'string', { 'default' : 'contains' } ),	//@options contains, startsWith

			'ltPropFocusOnClose': Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'focusOnClose', true ) } ),

			'ltPropButtonClass': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'buttonClass', '' ) } ),

			'ltPropDisableItemTooltip': Lyte.attr( 'boolean', { 'default': false } ),

			'ltPropPreventParentScroll': Lyte.attr( 'boolean', { 'default': false } ),

			'ltPropShowRemoveIcon': Lyte.attr( 'boolean', { 'default': false } )

		}
	},
	actions:{
		toolTipConfig: function( button, propName ) {
			var width = button.offsetWidth,
			scrollWidth = button.scrollWidth,
			config = this.getData( 'ltPropTooltip' );

			propName = propName || 'showToolTip';

			this.setData( propName, ( width < scrollWidth ) && !_lyteDropdown.isEmpty( config ) );
		},
		
		preventDefault: function( event ) {
			if( event.keyCode === 13 ) {
				event.preventDefault();
			}
		},

		closeIt: function( event ) {
			var mx = event.clientX, 
			my = event.clientY,
			dp = this.$node.querySelector('lyte-drop-button'),
			dpt = dp.getBoundingClientRect().top,
			dph = dp.getBoundingClientRect().height,
			dpl = dp.getBoundingClientRect().left,
			dpw = dp.getBoundingClientRect().width,
			dc = this.childComp,
			dct = dc.getBoundingClientRect().top,
			dch = dc.getBoundingClientRect().height,
			dcl = dc.getBoundingClientRect().left,
			dcw = dc.getBoundingClientRect().width;

			if(	( mx > Math.floor( dpl ) 
				&& mx < Math.floor( dpl + dpw ) 
				&& my > Math.floor( dpt ) 
				&& my < Math.floor( dpt + dph ) ) 
				|| ( mx > Math.floor( dcl )
					&& mx < Math.floor( dcl + dcw )
					&& my > Math.floor( dct )
					&& my < Math.floor( dct + dch )
				) 
			) {
				return ;
			}

			this.$node.toggle(event,"leave")
		},

		processElements: function( event ) {
			var link = this.childComp,
			elm =  event.target,
			mul = this.getData( 'multiple' ),
			head = this.getData('drophead'),
			freeze = this.getData( 'ltPropFreeze' ),
			type = this.getData('ltPropType'),
			body = this.getDropBody( link ),
			search = this.getData( 'search' ),
			oldSelected = this.getData( 'ltPropSelected' ),
			sel, res, elements, i = 0, j, src, button, cur, ret, input;

			if( search ) {
				input = this.$node.querySelector( 'lyte-search' ) || this.$node.querySelector( 'input' );
				this.focusInput();
			}

			elm = _lyteDropdown.traverse( elm, [ 'HTML', 'LYTE-DROP-ITEM' ] );

			if( !elm || elm.tagName === 'HTML' ) {               //Clicking on header should not trigger an event(CODE HELP)
				return ;
			}

			if( elm.getAttribute( 'disabled' ) === 'true' ) {
				return ;
			}

			if( !mul && head !== 'yield' ) {

				if( !this.beforeSelect( event, elm ) ) {
					return ;
				}

				elm.setAttribute( 'selected', 'true' );
				this.optCall( event, this.getData( 'ltPropSelected' ), elm );
				this.fireOnChange( oldSelected, event, elm );

				if( this.beforeHide.call( this, link, event, freeze ) ) {
					return ;
				}

				this.toggleCurrent( elm );
				this.closeDrop( link, event, freeze);
				
			}
			else if( mul ) {

				if( this.checkLimit( 1 ) ) {
					return ;
				}

				src = elm.getAttribute( 'data-value' );

				if( this.getMethods( 'onBeforeAdd' ) ) {
					ret = this.beforeAdd( event, elm, src );

					if( ret ) {
						return ;
					}
				}

				// Focus multisearch input on selecting an element
				if( search && input.setValue ) {
					input.setValue( '' );
				}

				elements = link.querySelectorAll( 'lyte-drop-item' );
				
				this.setHighlight( elements, elm );

				this.setData( 'prev', true );
				elm.setAttribute( 'selected', 'true' );
				this.setData( 'prev', false );

				elm.classList.add( 'lyteDropdownActive' );

				this.hideGroup( elm );

				// check this things position in code now.
				if( this.getMethods('onAdd') ) {
					this.executeMethod( 'onAdd', event, src, this.getData( 'ltPropSelected' ), this, elm );
				}

				this.showError( link, type, head );
				this.fireOnChange( oldSelected, event, elm );
			}
			else {	

				if( !this.beforeSelect( event, elm ) ) {
					return ;
				}

				// Maybe need to set selected to true	
				// Have to remove and add lyteDropdownSelection over here cause we have a check over in selChange which prevents it from doing it there
				// if( head !== 'yield' )
				// if( ( cur = link.querySelector( 'lyte-drop-item.lyteDropdownSelection' ) ) ) {
				// 	cur.classList.remove( 'lyteDropdownSelection' );
				// }

				// elm.classList.add( 'lyteDropdownSelection' );
				this.toggleCurrent( elm );
				this.setData( 'ltPropSelected', elm.getAttribute( 'data-value' ) );
				this.optCall( event, this.getData( 'ltPropSelected' ), elm );
				this.fireOnChange( oldSelected, event, elm );

				if( this.beforeHide.call( this, link, event, freeze ) ) {
					return ;
				}

				this.closeDrop( link, event, freeze );
			}
		}, 
		
		closeFun: function( event ) {
			var link = this.childComp,
			head = this.getData('drophead'), 
			rm = this.getData( 'ltPropRemoveMultiple' ),
			oldSelected = this.getData( 'ltPropSelected' ),
			node = event.target, src, sel = this.getData( 'ltPropSelected' ), i = 0,
			res = [], body, end, proper, hide, ret, changeObj;

			while( 
				!node.getAttribute( 'data-value' ) 
				&& node
			) {
				node = node.parentElement
			}

			if( !node ) {
				return ;
			}

			src = node.getAttribute( 'data-value' )

			proper = this.getData( 'isKeyDown' ) ? 'keydown' : 'click';

			ret = this.beforeRemove( event, rm ? [ src ] : src, proper, rm ? [ node ] : node );

			if( ret ) {
				// Don't know why this is here
				event.stopPropagation();
				return ;
			}

			// This is for inbuilt error display
			this.closeError( link, head );

			changeObj = this.findMarked( sel, [ node ] );

			this.removeMarked( changeObj.selected, [ node ], head, link );			
			
			if( this.getMethods( 'onRemove' ) ) {
				// Return an array of removed values in case of removeMultiple
				// else return a singular value
				this.executeMethod( 'onRemove', event, rm ? [ src ] : src  , this.getData('ltPropSelected'), this, proper, rm ? [ node ] : node );
			}

			this.fireOnChange( oldSelected, event, rm ? [ node ] : node );

			// Don't know why this is here
			event.stopPropagation();

		},

		checkKey: function( event ) {
			var type = this.getData('ltPropType');
			if( event.keyCode == 9 ) {
				this.$node.constructor._actions.showHide.call(this, event, event.type );
				
				if( type == 'multisearch' ) {
					this.focusInput();
				}
			}
		},

		showHide: function( event, eventtype, fromTg ) {
			var link = this.childComp,
			freeze = this.getData( 'ltPropFreeze' ),
			mul = this.getData( 'multiple' ),
			type = this.getData( 'ltPropType' ),
			hover = this.getData( 'ltPropHover' ),
			rm = this.getData( 'ltPropRemoveMultiple' ),
			show = this.getData( 'ltPropShow' ), res, cur,
			blockShowHide = this.getData( 'blockShowHide' );

			if( blockShowHide ) {
				return ;
			}

			/* Doesn't matter if the onBeforeOpen returns false
			 * trying to open another dropdown when autoClosed is set will flush it
			 * showHide is called from toggle as well
			 */

			_lyteDropdown.autoClosed = null;

			// Exists to remove multiple selected values from a multiselect using either the meta key or the control key
			if( rm && event && mul ) {
				cur = event.target;
				while( cur && cur.tagName !== 'LYTE-DROPDOWN' && !cur.getAttribute( 'data-value' ) ) {
					cur = cur.parentNode;
				}

				// Node with data-value is clicked so you need to process it
				if( cur && cur.getAttribute( 'data-value' ) ) {
					this.mark( cur, event.shiftKey, event.ctrlKey || event.metaKey );
					return ;
				}
				// The node with data-value is not clicked so this is going to unmark everything
				else {
					_lyteDropdown.unmark();
				}
			}
			// When you click another dropdown whose rm is false
			else {
				_lyteDropdown.unmark();
			}

			// For some unknow reason the dropdown closes when you hover over the select box to prevent this we are doing this and same for the opposite
			if( eventtype == 'enter' ) {
				if( 
					link
					&& !link.classList.contains( 'lyteDropdownHidden' ) 
				) {
					return ;
				}

				this.$node.querySelector( '[tabindex]' ).focus()
			}

			if( eventtype == 'leave' ) {
				if( 
					link 
					&& link.classList.contains( 'lyteDropdownHidden' ) 
				) {
					return ;
				}
			}

			this.showNoResultDiv();

			if( !show ) {
				if( !link ) {
					this.childComp = this.$node.querySelector( 'lyte-drop-box' );
				}

				if( this.childComp ) {
					this.childComp.setAttribute( 'lyte-hidden', '' );
				}

				if( this.getMethods( 'onBeforeShow' ) ) {
					this.beforeShow( event, fromTg, true );
				}
				else {
					this.setData( 'call', fromTg ? true : event );
					this.first();
				}

				if( mul ) {
					this.addClass();
				}
			}
			else if( link && link.classList.contains( 'lyteDropdownHidden' ) ) {
				link.setAttribute( 'lyte-hidden', '' );
				if( this.getMethods( 'onBeforeShow' ) ) {
					this.beforeShow( event, fromTg, false );
				}
				else {
					this.setData( 'call', fromTg ? true : event );
					this.subsequent( link, freeze, mul, hover );
				}
			}
			else if( link && ( fromTg || !mul ) ) {
				if( this.beforeHide.call( this, link, event, freeze ) ) {
					return ;
				}

				this.closeDrop( link, event, freeze);
			}
			else if( link && type === 'multisearch' ) {
				this.focusInput();
			}			
		}
	}
});

window.addEventListener( 'scroll', function( event ) {	
	$L.fastdom.measure( function() {
		var elm = _lyteDropdown.getVisibleDropbox(),
		tempele = elm,
		isAnimate,
		cur = event.target, shouldUseSave,
		drop, component, boundary, offsets, link, bounds;

		if( !elm ) {
			_lyteDropdown.openAutoClosedDropdown( cur, event );
			return ;
		}

		// if( cur.nodeName == "#document" ) {     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)
		// 	return ;
		// }

		while( cur != document && cur.tagName !== 'LYTE-DROP-BOX' && cur.tagName !== 'HTML' ) {
			cur = cur.parentElement;
		}

		if( cur.tagName === 'LYTE-DROP-BOX' ) {
			return ;
		}

		drop = elm.origindd;

		// People could just render the lyte-drop-box without any dropdown and that guy is scrolling
		if( !drop ) {
			_lyteDropdown.openAutoClosedDropdown( cur, event );
			return ;
		}

		component = drop.component;
		link = component.childComp;


		// Dropdowns crossing their boundaries are closed automatically
		bounds = _lyteDropdown.buildBounds( component );
		offsets = drop.getBoundingClientRect();

		if( ( offsets.top < bounds.top
				|| offsets.left < bounds.left
				|| offsets.right > bounds.right
				|| offsets.bottom > bounds.bottom )
		) {

			component.beforeScrollClose( event );
			if( component.beforeHide.call( component, link, event, component.getData( 'ltPropFreeze' ) ) ) {
				return ;
			}

			component.closeDrop.call( component, link, event, component.getData( 'ltPropFreeze' ), true );
			isAnimate = component.getData( 'ltPropAnimate' );

			/* While closeDrop does set autoClosed to null
			 * This sets it to its proper value thereby making the dropdown properly close/open when
			 * it either moves out or comes into bounds
			 */


			if( !isAnimate ) {
				_lyteDropdown.autoClosed = drop;
			}
			
		}
		
		// Set CSS of the dropdown on scrolling
		if( !drop.component._preventSetcss ) {
			shouldUseSave = drop.component.getData( 'ltPropFixPositionOnOpen' );

			drop.component.setCss( true, shouldUseSave );
		}
	} );
},true);

document.addEventListener( 'click', function( event ) {
	var ele = event.target,
	target = event.target,
	cur, all, i = 0, j = 0, type,
	open, temp, component, res, freeze, link, drp, item, active, container, head, input;

	// Performing an user action such as click whether it is on the same dropdown
	// or another dropdown or anywhere will flush autoClosed
	// Browser defined scrollbars don't trigger a click but lyte-scrollbar does
	if( !_lyteDropdown.isScrollBar( target ) ) {
		_lyteDropdown.autoClosed = null;
	}

	ele = _lyteDropdown.traverse( ele, [ 'LYTE-DROPDOWN', 'HTML', 'LYTE-DROP-BOX', 'LYTE-DROP-REMOVE' ] );

	if( _lyteDropdown.focusOut ) {

		// If container is html, then the click event in the dropdown will close it.
		_lyteDropdown.preventClose = ele && ele.tagName !== 'HTML' ? true : false;
	}

	// return when there is no element
	if( !ele ) {
		return ;
	}

	if( ele.tagName == 'HTML' ) {

		_lyteDropdown.unmark();
		open = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' );

		for( ; j < open.length; j++ ) {
			temp = open[ j ];
			if( temp ) {
				component = temp.origindd.component;

				if( component.beforeHide.call( component, temp, event, component.getData( 'ltPropFreeze' ) ) ) {
					continue;
				}

				freeze = document.getElementById( 'lytedropdownfreezelayer' );
				component.closeDrop.call( component, temp, event, freeze );
			}
		}

		active = document.activeElement;

		// Looks like activeElements can be undefined - LOL IE
		if( active && active.tagName === 'INPUT' && ( container = _lyteDropdown.traverse( active, [ 'LYTE-DROPDOWN' ] ) ) ) {
			active.blur();
		}
	}
	else if( ele.tagName === 'LYTE-DROPDOWN' ) {
		cur = ele;
		all = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' )
		for( ; i < all.length; i++ ) {
			if( all[ i ].origindd == cur ) {
				continue;
			}
			else {
				drp = all[ i ].origindd;
				component = drp.component;
				_lyteDropdown.unmark();

				if( component.beforeHide.call( component, component.childComp, event, component.getData('ltPropFreeze')) ) {
					continue ;
				}

				component.closeDrop.call( component, component.childComp, event, component.getData('ltPropFreeze'));
			}
		}
	}
	else if( ele.tagName === 'LYTE-DROP-REMOVE' ) {
		drp = ele;
		while( drp.tagName != 'LYTE-DROPDOWN' ) {
			if( drp.getAttribute( 'data-value' ) ) {
				item = drp;
			}
			drp = drp.parentElement;
		}

		type = drp.ltProp( 'type' );
		head = drp.component.getData( 'drophead' );

		if( type === 'default' ) {
			drp.ltProp( 'selected', '' );
		}
		else {
			if( type === 'multisearch' ) {
				drp.component.focusInput();
				input = drp.querySelector( 'lyte-search' ) || drp.querySelector( 'input' );

				if( input && input.setValue ) {
					input.setValue( '' );
				}
			}

			if( item.classList.contains( 'lyteDropMark' ) ) {
				drp.component.removeAll( event );
			}
			else {
				_lyteDropdown.unmark();
				drp.component.actions.closeFun.call( drp.component, event );	
			}
		}
		
	}
}, true );

if( window._lyteUiUtils.isIos ) {
	document.addEventListener( 'focusout', function( event ) {
		// need to check for multiple dropdown
		var target = event.target,
		open, drop, comp, freeze;

		// test for normal input in dom
		if( ( drop = _lyteDropdown.traverse( target, 'LYTE-DROPDOWN' ) )
			&& event.target.tagName === 'INPUT' 
		) {
			comp = drop.component;
			open = comp.childComp;
			freeze = comp.getData( 'ltPropFreeze' );

			_lyteDropdown.focusOut = true;

			setTimeout( function() {

				if( _lyteDropdown.preventClose ) {
					_lyteDropdown.preventClose = _lyteDropdown.focusOut = false;
					return ;
				}

				if( open 
					&& !open.classList.contains( 'lyteDropdownHidden' ) 
				) {
					if( comp.beforeHide( open, event, freeze ) ) {
						return ;
					}

					comp.closeDrop( open, event, freeze );
				}

				_lyteDropdown.focusOut = false;
			}, 0 );
		}
	}, true );
}

document.addEventListener( 'keydown', function( event ) {  //This is to take care of the tabbing problems in a dropdown and traversing(CODE HELP)
	var kc = event.keyCode, 
	active, acomp, abutton, anodes, activeDrop,
	open = document.querySelector( 'lyte-drop-box:not(.lyteDropdownHidden)' ),
	type, res, drp, component, src, last, l = 0, cur, elem, elems, i = 0, j, all, k, curActive;

	if( kc === 32 || kc === 40 ) {
		curActive = activeDrop = document.activeElement;
		activeDrop = _lyteDropdown.traverse( activeDrop, [ 'LYTE-DROPDOWN', 'HTML' ] );

		// active elements can be null - LOL IE
		if( activeDrop ) {
			if( activeDrop.tagName === 'LYTE-DROPDOWN' && curActive.tagName !== 'INPUT' ) {
				event.preventDefault();
			}

			if( activeDrop.tagName === 'LYTE-DROPDOWN' 
				&& ( !open 
					|| activeDrop !== open.origindd ) 
			) {
				activeDrop.constructor._actions.showHide.call(activeDrop.component, event, event.type );

				// End this here
				return ;
			}
		}
	}

	// UP, DOWN, ENTER
	if(
		( 
			kc == 38 
			|| kc == 40 
			|| kc == 13 
		) 
		&& open 
	) {

		if( kc == 38 
			|| kc == 40 
		) {
			event.preventDefault()
		}

		// Get the current highlighted element
		drp = open.origindd;
		component = drp.component;
		type = component.getData( 'ltPropType' );
		open = component.getDropBox();
		cur = open.querySelector( '.lyteDropdownSelection' );

		// No current Highlighted Element or the current highlighted element is hidden
		// It just sets the first visible element as highlighted and returns
		// Only for multiselects
		if( 
			!cur 
			|| ( cur && !_lyteDropdown.isVisible( cur ) )
		) {

			// This one is a yikes
			elems = open.querySelectorAll( 'lyte-drop-item:not(.lyteSearchHidden):not(.lyteDropdownActive)' ) //wrong

			for( ; i < elems.length; i++ ) {
				if( _lyteDropdown.isVisible( elems[ i ] )
					&& elems[ i ].getAttribute( 'disabled' ) !== "true" 
				) {
					elem = elems[ i ];
					break;
				}
			}

			if( cur ) {
				cur.classList.remove( 'lyteDropdownSelection' );
			}

			if( elem ) {
				elem.classList.add( 'lyteDropdownSelection' );
				return ;
			}
		}
			
		kc = event.keyCode;
		elems = open.querySelectorAll( 'lyte-drop-item' );
		for( i = 0; i < elems.length; i++ ) {
			if( elems[ i ].classList.contains( 'lyteDropdownSelection' ) ) {
				break;
			}
		}

		// A highlighted element was present and enter is pressed
		if( kc == 13 ) {
			if( component.getData( 'multiple' ) ) {
				if( !elems[ i ] ) { 
					return ;
				}

				elems[ i ].click();
			}
			else {

				// Just a safety check.
				// lyteDropdownSelection is most likely present
				if( elems[ i ] ) {
					elems[ i ].click();
				}
			}
		}
		// Key up was pressed
		else if(
			kc == 38 
			&& i != 0 
		) {
			j = i;
			i = _lyteDropdown.find( elems, i - 1, false );

			if( i != -1 ) {
				component.scrollIntoView( elems[ i ], 'up' );
				elems[ j ].classList.remove( 'lyteDropdownSelection' );
				elems[ i ].classList.add( 'lyteDropdownSelection' );
			}							
		}

		// Key down was pressed
		else if(
			kc == 40
			&& i != elems.length -1
		) {
			j = i;
			i = _lyteDropdown.find( elems, i + 1, true );

			if( i < elems.length ) {  // Added this because it was breaking in CRM		
				component.scrollIntoView( elems[ i ], 'down' );
				elems[ j ].classList.remove( 'lyteDropdownSelection' );
				elems[ i ].classList.add( 'lyteDropdownSelection' );
			}
		}
		
	}

	// Backspace was pressed
	else if( kc === 8 ) {
		active = _lyteDropdown.getActive();

		if( active ) {
			acomp = active.component;
			abutton = active.querySelector( 'lyte-drop-button' );
			anodes = abutton.querySelector( '.lyteDropMark' );
		}

		drp = _lyteDropdown.getDropdownWithFocusedInput();

		if( !drp ) {
			return ;
		}

		component = drp && drp.component;
		type = component && component.getData( 'ltPropType' );
		
		if( anodes ) {
			event.preventDefault();
			acomp.setData( 'isKeyDown', true );
			acomp.removeAll( event );
			acomp.setData( 'isKeyDown', false );
		}
		else if( drp && type === 'multisearch' && _lyteDropdown.isInput( event ) ) {
			last = drp.querySelectorAll( 'lyte-drop-remove' )
			if( last.length > 0 ) {
				drp.component.setData( 'isKeyDown', true );
				last[ last.length - 1 ].click();
				drp.component.setData( 'isKeyDown', false );
			}
		}
	}


	else if( 
		kc === 27
		|| kc === 9 
	) {
		// Escape
		// Close the current opened dropdown
		if( open ) {

		 	open = _lyteDropdown.traverse( open, [ 'LYTE-DROP-BOX' ] );

		 	if( !open ) {
		 		return ;
		 	}

		 	component = open.origindd.component;

		 	if( component.beforeHide.call( component, component.childComp, event, component.getData('ltPropFreeze')) ) {
		 		return ;
		 	}

			// open.classList.add('lyteDropdownHidden')
		 	component.closeDrop.call( component, component.childComp, event, component.getData('ltPropFreeze'));
		}
	}
} );
	
document.addEventListener( 'keypress', function( event ) { //It searches the dropdown items matching the pressed charactes when the dropdown is open
	var kc = event.which || event.keyCode, i = 0, children, pos,
	open = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' ), drp, searchMethod;

	var isMatchFound = function( itemValue, searchKey, method ) {
		if( method === 'contains' ) {
			if(itemValue.trim().toLowerCase().indexOf(searchKey.toLowerCase()) != -1){
				return true;
			}
		}
		else if( method === 'startsWith' ) {
			if(itemValue.trim().substring( 0, searchKey.length ).toLowerCase() === searchKey.toLowerCase()){
				return true;
			}
		}

		return false;
	};

	if( 
		open.length > 0
		&& ( ( kc >= 65 && kc <= 90 ) 
			|| ( kc >= 97 && kc <= 122 )
			|| ( kc >= 48 && kc <= 57 ) )
	) {
		_lyteDropdown.pressedCharacter = _lyteDropdown.pressedCharacter ? _lyteDropdown.pressedCharacter += String.fromCharCode(kc) : String.fromCharCode(kc);
		if( _lyteDropdown.checkDDtimeoutId ) {
			clearTimeout( _lyteDropdown.checkDDtimeoutId );
		}

		_lyteDropdown.checkDDtimeoutId = setTimeout( function() {
			_lyteDropdown.pressedCharacter = null;
		}, 500 );

		// activeElements can be null - LOL IE
		drp = ( document.activeElement || {} ).parentElement;
		drp = ( drp || {} ).tagName == "LYTE-DROPDOWN" ? drp : null;
		if( open.length > 0 && drp ) {
			for(var i =0 ; i < open.length ; i++ ) {
				// breaking change
				if( open[ i ].origindd == drp ) {
					break;
				}
			}

			open = open[ i ];
			drp = open.origindd;
			children = open.querySelectorAll('lyte-drop-item');
			searchMethod = drp.getData('searchMethod');

			if( 
				_lyteDropdown.cachePreviousVal.char 
				&& _lyteDropdown.cachePreviousVal.char == _lyteDropdown.pressedCharacter 
				&& ( _lyteDropdown.cachePreviousVal.pos + 1 ) < children.length 
				&& isMatchFound(children[ _lyteDropdown.cachePreviousVal.pos + 1 ].textContent, _lyteDropdown.pressedCharacter, searchMethod)/* children[ _lyteDropdown.cachePreviousVal.pos + 1 ].textContent.trim().substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase()*/ 
			) {
				pos = _lyteDropdown.cachePreviousVal.pos + 1;
			}
			else {
				for( i = 0; i < children.length; i++ ) {
					if(isMatchFound(children[ i ].textContent, _lyteDropdown.pressedCharacter, searchMethod) /*children[ i ].textContent.trim().substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase()*/ ) {
						pos = i;
						break;
					}
				}
			}
			
			if( pos != undefined ) {
				var selected = open.querySelectorAll( '.lyteDropdownSelection' );
				for(var j = 0; j< selected.length ; j++){
					selected[ j ].classList.remove( 'lyteDropdownSelection' );
				}
				children[ pos ].classList.add( 'lyteDropdownSelection' );
				var scrollDiv = open.querySelector( 'lyte-drop-body' );

				if( scrollDiv.contains( children[ pos ] ) ) {
					// footers can have lyte-drop-items. So no scrolling there.
					scrollDiv.scrollTop += parseInt( children[ pos ].getBoundingClientRect().top - scrollDiv.getBoundingClientRect().top );
				}
				
			}

			_lyteDropdown.cachePreviousVal.char = _lyteDropdown.pressedCharacter;
			_lyteDropdown.cachePreviousVal.pos = pos;
		}

	}

});

if( !window._lyteUiUtils.isMobile ) {
	window.addEventListener( 'resize', function( event ) {
		delete this._hgt;

		// Resizing is counted as an user action which flushes the autoClosed property
		_lyteDropdown.autoClosed = null;

		var open = document.querySelector( 'lyte-drop-box:not(.lyteDropdownHidden)' ),
		shouldUseSave;

		if( open && !open.origindd.component._preventSetcss ) {
			shouldUseSave = open.origindd.component.getData( 'ltPropFixPositionOnOpen' );

			open.origindd.component.setCss( true, shouldUseSave );
		}
	} );	
}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-drop-box' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-drop-box' ] = true;

	/**
 	 * @customElement lyte-drop-box
 	 */

 	Lyte.createCustomElement( "lyte-drop-box", {
		static : {
			"observedAttributes": {
				get : function() {
					return [];
				}
			}
		},
		"connectedCallback": function() {
			var cur = _lyteDropdown.traverse( this, [ 'LYTE-DROPDOWN', 'BODY' ] ), dropdown, component;

			if( cur.tagName === 'BODY' ) {
				cur = this.origindd;
			}

			if( !cur || cur.tagName !== 'LYTE-DROPDOWN' ) {
				return ;
			}

			dropdown = cur;
			component = dropdown.component;

			if( component.getData( 'ltPropType' ) === 'multisearch' || component.getData( 'ltPropType' ) === 'multiple' ) {
				this.setAttribute( 'aria-multiselectable', 'true' );
			}
			else {
				this.setAttribute( 'aria-multiselectable', 'false' );
			}

			this.setAttribute( 'role', 'listbox' );
		}
	} ); 



}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-drop-item' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-drop-item' ] = true;

/**
 * @customElement lyte-drop-item
 */

	Lyte.createCustomElement( 'lyte-drop-item', {
		static : {
			"observedAttributes" : {
				get : function() {
					return [ 'selected' ];
				}
			}
		},

		"connectedCallback": function() {
			this.setAttribute( 'option', 'role' );

			if( !this._eventRegistered ) {
				this._eventRegistered = true;


				this.addEventListener( 'mouseenter', function() {
					var title = this.getAttribute( 'data-title' ),
					width = this.offsetWidth,
					scrollWidth = this.scrollWidth,
					component = _lyteDropdown.getDropdownFromItem( this ), tooltipConfig, cls, showToolTip;

					if( !component ) {
						return ;
					}

					if( component.getData( 'ltPropDisableItemTooltip' ) ) {
						return ;
					}

					tooltipConfig = component.getData( 'ltPropTooltip' );
					cls = component.getData( 'ltPropTooltipClass' );

					title = title || this.textContent.trim();

					showToolTip = ( width < scrollWidth && !_lyteDropdown.isEmpty( tooltipConfig ) );
					this.setAttribute( 'lt-prop-title', showToolTip ? title : '' );

					if( showToolTip ) {
						this.setAttribute( 'lt-prop-tooltip-config', JSON.stringify( tooltipConfig ) );
						this.setAttribute( 'lt-prop-tooltip-class', cls );
					}
					
				} );
			}
		},

		"attributeChangedCallback": function(attr, oldValue, newValue, namespace) {
			var cur = this, drp, component, type, sel, res,
			src = this.getAttribute( 'data-value' );
			if( attr == 'selected' ) {
	        	if( this.hasAttribute( 'selected' ) ) {

	        		this.setAttribute( 'aria-selected', 'true' );

	          		cur = _lyteDropdown.traverse( cur, [ 'LYTE-DROP-BOX', 'BODY' ] );

	          		if ( !cur || cur.tagName == 'BODY' ) {
	            		return;
	          		}

	          		drp = cur.origindd;
	          		if ( !drp ) {
	          			cur = _lyteDropdown.traverse( cur, [ 'LYTE-DROPDOWN', 'BODY' ] );
	            		drp = cur;
	          		}

	          		component = drp.component;

	          		if( !component ) {
	          			return ;
	          		}

	          		if( component.getData( 'preventSel' ) ) {
	          			return ;
	          		}

	          		type = component.getData( 'ltPropType' );

	          		if ( type == 'multiple' 
	          			|| type == 'multisearch'
	          		) {
	            		sel = component.getData( 'ltPropSelected' );
	            		if ( ( sel && sel.length == 2 ) || !sel ) {
	              			sel = JSON.stringify( [ src ] );
	              			// not setting prev to true here
	              			component.setData( 'ltPropSelected', sel );
	            		} 
	            		else {
	              			res = JSON.parse( sel );
	              			res.push( src );
	              			// not setting prev to true here
	              			component.setData( 'ltPropSelected', JSON.stringify( res ) );
	            		}
	          		} 
	          		else {
	            		component.setData( 'ltPropSelected', src );
	          		}
	        	}
	        	else {
	        		this.setAttribute( 'aria-selected', 'false' );
	        	}
	      	}
		}
	} );
}



var _lyteDropdown = {
	// When multiple dropdowns have multiple callbacks returning a promise, store the last dropdown
	lastDropdownWithAPromise: null,

	// Whether the dropdown should not be closed when the input is focused out
	preventClose: false,

	// Current dropdown that was autoClosed
	autoClosed: null,

	// Whether a focus happened
	focusOut: false,

	getDropdownFromItem: function( cur ) {
		cur = _lyteDropdown.traverse( cur, [ 'LYTE-DROP-BOX', 'BODY' ] );

  		if ( !cur || cur.tagName == 'BODY' ) {
    		return;
  		}

  		var drp = cur.origindd;
  		
  		if ( !drp ) {
  			cur = _lyteDropdown.traverse( cur, [ 'LYTE-DROPDOWN', 'BODY' ] );
    		drp = cur;
  		}

  		var component = drp.component;

  		return component;
	},

	getDropdownWithFocusedInput: function() {
		var activeElement = document.activeElement, dropdown;

		if( activeElement 
			&& activeElement.nodeName.toLowerCase() === 'input' 
		) {
			dropdown = _lyteDropdown.traverse( activeElement, [ 'HTML', 'LYTE-DROPDOWN' ] );
		}

		if( dropdown && dropdown.nodeName.toLowerCase() === 'lyte-dropdown' ) {
			return dropdown;
		}
		
	},

	/**
	 * Gets the current visible dropbox from the body
	 * This was added to fix a performance problem in CRM - kural's subform feature
	 *
	 *
	 */

	getVisibleDropbox: function() {
		var childs = ( document.body || {} ).children || [], 
		i = 0;

		for( ; i < childs.length; i++ ) {
			if( 
				childs[ i ].tagName === 'LYTE-DROP-BOX' 
				&& _lyteDropdown.isVisible( childs[ i ] ) 
			) {
				return childs[ i ];
			}
		}
	},

	/**
	 * Check if the element is a scrollbar
	 * @param {HTMLElement} element - the clicked element
	 *
	 */

	isScrollBar: function( element ) {
		return element 
				&& ( element.classList.contains( 'lyteScrollContainer' ) || element.classList.contains( 'lyteScrollDiv' ) );
	},

	/**
	 * Checks if the dropdown is within the visible bounds
	 * @param {Object} visibleBound - The visible bound of the scrollable element
	 * @param {Object} dropBound - The dropdown's boundaries
	 *
	 */

	isInBounds: function( visibleBound, dropBound ) {
		return visibleBound.top < dropBound.top 
		&& visibleBound.bottom > dropBound.bottom
		&& visibleBound.left < dropBound.left
		&& visibleBound.right > dropBound.right;
	},

	/**
	 * This is going to construct the visible bound of the scrolling container
	 * @param {object} - getBoundingClientRect of the element
	 * @param {boolean} - If it is a boolean or not
	 * @param {HTMLElement} - The current scrollable div
	 *
	 */

	buildVisibleBounds: function( rect, isDoc, cur ) {
		var top = isDoc ? 0 : Math.max( rect.top, 0 ),
		left = isDoc ? 0 : Math.max( rect.left, 0 ),
		right = isDoc ? window.innerWidth : Math.min( window.innerWidth, rect.left + cur.offsetWidth ),
		bottom = isDoc ? window.innerHeight : Math.min( window.innerHeight, rect.top + cur.offsetHeight );

		return {
			top: top,
			left: left,
			right: right,
			bottom: bottom
		};
	},

	/**
	 * This is used to find the current auto closed dropdown
	 * @param {HTMLElement} cur - The cur scrolled element
	 *
	 */

	openAutoClosedDropdown: function( cur, event ) {
		var isDocument =  cur === document,
		scrollRect, visibleBound,
		drop = _lyteDropdown.autoClosed, comp, link;

		if( !drop ) {
			return ;
		}

		scrollRect = isDocument ? {} : cur.getBoundingClientRect();
		visibleBound = _lyteDropdown.buildVisibleBounds( scrollRect, isDocument, cur )

		comp = drop.component,
		link = comp.childComp;

		if( drop
			&& cur.contains( drop )
			&& _lyteDropdown.isInBounds( visibleBound, drop.getBoundingClientRect() )

			// safety
			&& link.classList.contains( 'lyteDropdownHidden' )
		) {
			comp.beforeScrollOpen( event );
			drop.toggle();
			_lyteDropdown.autoClosed = null; 
		}		
	},

	/**
	 * This is used to determine whether an object is empty or not
	 * @param {Object} obj - The object to be checked
	 * 
	 */

	isEmpty: function( obj ) {
		for( var key in obj ) {
			return false;
		}

		return true;
	},

	/**
	 * This is going to build the boundary parameter for a particular dropdown instance
	 * @param {Component} comp - The lyte-dropdown component object
	 *
	 */

	buildBounds: function( comp ) {
		var bound = comp.getData( 'ltPropBoundary' ),
		scope = comp.getData( 'ltPropScope' ), parent, boundingRects;

		if( scope !== 'window' ) {
			parent = $L( comp.$node ).closest( scope ).get( 0 );

			if( parent ) {
				boundingRects = parent.getBoundingClientRect();

				return {
					left: Math.max( 0, boundingRects.left ),
					top: Math.max( 0, boundingRects.top ),
					right: Math.min( window.innerWidth, boundingRects.right ),
					bottom: Math.min( window.innerHeight, boundingRects.bottom )
				};
			}
		}
		
		return {
			left: bound.left || 0,
			right: bound.right || window.innerWidth,
			top: bound.top || 0,
			bottom: bound.bottom || window.innerHeight
		}
	},

	/**
	 * This is going to traverse up the dom to check if the required tagNames are present
	 * @param {Element} node - The element whose parents need to be traversed
	 * @param {Array} arr - The set of tag names to check against
	 *
	 */

	traverse: function( node, arr ) {
		while( node && !~arr.indexOf( node.tagName ) ) {
			node = node.parentNode;
		}

		return node;
	},

	/**
	 * Find the next/previous element which is visible
	 * @param {NodeList} elems - The set of all elements to test against
	 * @param {integer} i - index from which we need to search
	 * @param {boolean} forward - whether to move forward or backward
	 *
	 *
	 */

	 find: function( elems, i, forward ) {
	 	var inc = forward ? 1 : -1,
	 	len = elems.length;

	 	for( 
	 		; 
	 		forward ? 
	 			i < len 
	 			: i > -1; 

	 		i = i + inc 
	 	) {
	 		if( _lyteDropdown.isVisible( elems[ i ] ) 
	 			&& elems[ i ].getAttribute( 'disabled' ) !== "true"
	 		) {
	 			return i;
	 		}
	 	}

	 	return forward ? len : -1;
	 },

	/**
	 * This is going to check if the element is visible or not
	 * @param {Element} item - The item to check against
	 *
	 */

	isVisible: function( item ) {
		return !!( item.offsetWidth || item.offsetHeight || item.getClientRects().length );
	},

	/** 
	 * Checks if the current target is an input within the dropdown and with no value
	 * @param event - the keydown event
	 *
	 */

	// Initialize variables
	pressedCharacter : null,

	checkDDtimeoutId : null,

	cachePreviousVal : {},

	isInput: function( event ) {
		// There maybe a case when a dropdown might be opened on pressing on an input with toggle. When backspace is pressed
		// on that input the global event handler for keydown might misbehave by trying to remove the last item
		// Fix is to check if the input is present inside the open dropdown
		var open = event.target;

		open = _lyteDropdown.traverse( open, [ 'LYTE-DROPDOWN' ] );

		if( open 
			&& event.target.tagName === 'INPUT' 
			&& event.target.type === 'text'
			&& !event.target.value 
		) {
		  	return true;
		}

		return false;
	},

	/**
	 * Unmark all nodes except the current components nodes
	 *
	 */

	unmark: function( comp ) {
		var nodes = document.querySelectorAll( '.lyteDropMark' ), 
		i = 0, len = nodes.length, par;

		for( ; i < len; i++ ) {
			// This is stupid. Change it later.
			//nodes[ i ].classList.remove( 'lyteDropMark' );
			par = comp ? _lyteDropdown.findParent( nodes[ i ] ) : undefined;
			par && par == comp.$node ? undefined : nodes[ i ].classList.remove( 'lyteDropMark' );
		}
	},

	findParent: function( node ) {
		node = _lyteDropdown.traverse( node, [ 'LYTE-DROPDOWN' ] )

		return node;
	},

	getActive: function() {
		var node = document.querySelector( '.lyteDropMark' );
		
		return _lyteDropdown.findParent( node );
	}
}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-drop-group' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-drop-group' ] = true;

/**
 * @customElement lyte-drop-group
 */

	Lyte.createCustomElement( "lyte-drop-group", {
		static : {
			"observedAttributes": {
				get : function() {
					return [ 'label' ];
				}
			}
		},
		"attributeChangedCallback": function( attr, oldValue, newValue, namespace ) {
			var node, value;

			if ( attr == 'label' ) {
	            node = this.querySelector('lyte-drop-label');
	            value = this.getAttribute('label');
	            if ( node ) {
	                node.textContent = value;
	            } 
	            else {
	                node = document.createElement('lyte-drop-label');
	                node.textContent = value;
	                this.insertBefore( node, this.children[ 0 ] );
	            }
	        }
		}
	} ); 
}

/**
 * @syntax nonYielded
 * <lyte-dropdown lt-prop-options='[{"name": "Option 1", "value": "1"}, {"name": "Option 2", "value": "2"}]' lt-prop-user-value="name" lt-prop-system-value="value"></lyte-dropdown>
 */

/**
 * @syntax yielded
 * <lyte-dropdown>
 *     <template is="registerYield" yield-name="yield">
 *         <lyte-drop-button>
 *             Option 1
 *         </lyte-drop-button>
 *         <lyte-drop-box>
 *             <lyte-drop-body>
 *                 <lyte-drop-item data-value="1">Option 1</lyte-drop-item>
 *                 <lyte-drop-item data-value="2">Option 2</lyte-drop-item>
 *             </lyte-drop-body>
 *         </lyte-drop-box>
 *      </template>
 * </lyte-dropdown>
 */

/**
 * @syntax 
 * @attribute ltPropType=multiple
 * <lyte-dropdown lt-prop-selected='["1"]' lt-prop-type="multiple">
 *     <template is="registerYield" yield-name="yield">
 *         <lyte-drop-box>
 *             <lyte-drop-body>
 *                 <lyte-drop-item data-value="1">Option 1</lyte-drop-item>
 *                 <lyte-drop-item data-value="2">Option 2</lyte-drop-item>
 *             </lyte-drop-body>
 *         </lyte-drop-box>
 *      </template>
 * </lyte-dropdown>
 */

/**
 * @syntax
 * @attribute ltPropType=multisearch
 * <lyte-dropdown lt-prop-selected='["1"]' lt-prop-type="multisearch">
 *     <template is="registerYield" yield-name="yield">
 *         <lyte-drop-box class="bodyContainer">
 *             <lyte-drop-body>
 *                 <lyte-drop-item data-value="1">Option 1</lyte-drop-item>
 *                 <lyte-drop-item data-value="2">Option 2</lyte-drop-item>
 *             </lyte-drop-body>
 *         </lyte-drop-box>
 *      </template>
 * </lyte-dropdown>
 */





/**
 * Renders a table
 * @component lyte-expresstable
 * @version  3.1.0
 * @methods beforeSetFixTableRowHeight,afterSetFixTableRowHeight,beforeSetFixTableColumnWidth,afterSetFixTableColumnWidth,onBeforeSelect,onSelect,onBeforeMove,onMove,onBeforeInterChange,onInterChange,onBeforeDrop,onDrop,onRelease
 * @utility fixRowHeight,scrollTo,setHeaderWidth,fixColumn,setColumnWidth,setVisibleFixedHeader,reset
 */
Lyte.Component.register("lyte-expresstable", {
_template:"<template tag-name=\"lyte-expresstable\"> <div class=\"lyteExpTableWrapper\"> <template is=\"if\" value=\"{{expHandlers(ltPropStickyTable,'!')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(ltPropHeaderLabelKey,'&amp;&amp;',tableHeader.length)}}\"><template case=\"true\"> <div class=\"lyteExpTableFakeHeaderWrapper\"> <div class=\"lyteExpTableFixedColHeader\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-exptable-thead class=\"fixedColumnTableHeader lyteExpTableHeaderGroup\"> <lyte-exptable-tr class=\"fixedColumnTableRow lyteExpTableRow\"> <template is=\"for\" items=\"{{fixedTableHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-th class=\"fixedColumn lyteExpTableHead {{list.class}}\" id=\"{{list.id}}\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\"> {{list[ltPropHeaderLabelKey]}} </lyte-exptable-th> </template> </lyte-exptable-tr> </lyte-exptable-thead> </template><template case=\"false\"> <lyte-yield class=\"lyteExpTableFakeHeaderGroup lyteExpTableHeaderGroup\" yield-name=\"headerYield\" lt-prop-table-header=\"{{fixedTableHeader}}\"></lyte-yield> </template></template> </div> <div class=\"lyteExpTableFakeColHeaderWrapper\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-exptable-thead class=\"lyteExpTableFakeColHeader lyteExpTableHeaderGroup\"> <lyte-exptable-tr class=\"originalColumnTableRow lyteExpTableRow\"> <template is=\"for\" items=\"{{tableHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-th id=\"{{list.id}}\" class=\"originalColumn lyteExpTableHead list.class\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\"> {{list[ltPropHeaderLabelKey]}} </lyte-exptable-th> </template> </lyte-exptable-tr> </lyte-exptable-thead> </template><template case=\"false\"> <lyte-yield class=\"lyteExpTableFakeColHeader lyteExpTableHeaderGroup\" yield-name=\"headerYield\" lt-prop-table-header=\"{{tableHeader}}\"></lyte-yield> </template></template> </div> </div> </template></template> </template></template> <div class=\"lyteExpTableOrigTableWrapper \"> <template is=\"if\" value=\"{{expHandlers(ltPropStickyTable,'!')}}\"><template case=\"true\"> <div class=\"lyteExpTableFixedColWrapper\" onscroll=\"{{action('fixedColScroll',event)}}\"> <lyte-exptable class=\"lyteExpTableFixedColTable\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-exptable-thead class=\"fixedColumn lyteExpTableHeaderGroup\"> <lyte-exptable-tr class=\"fixedColumn lyteExpTableRow\"> <template is=\"for\" items=\"{{fixedTableHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-th id=\"{{list.id}}\" class=\"fixedColumn lyteExpTableHead list.class\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\"> {{unescape(list[ltPropHeaderLabelKey])}} </lyte-exptable-th> </template> </lyte-exptable-tr> </lyte-exptable-thead> <lyte-exptable-tbody class=\"fixedColumn lyteExpTableRowGroup\"> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-tr id=\"{{list.id}}\" class=\"fixedColumn lyteExpTableRow {{list.class}}\"> <template is=\"for\" items=\"{{fixedTableHeader}}\" item=\"header\"> <lyte-exptable-td class=\"fixedColumn lyteExpTableCell\">{{unescape(lyteUiGetValue(list,header[ltPropBodyLabelKey]))}}</lyte-exptable-td> </template> </lyte-exptable-tr> </template> </lyte-exptable-tbody> </template><template case=\"false\"> <lyte-yield class=\"lyteExpTableHeaderGroup\" yield-name=\"headerYield\" lt-prop-table-header=\"{{fixedTableHeader}}\"></lyte-yield> <lyte-yield class=\"lyteExpTableRowGroup\" yield-name=\"contentYield\" lt-prop-table-header=\"{{fixedTableHeader}}\"> </lyte-yield> </template></template> </lyte-exptable> </div> </template></template> <template is=\"if\" value=\"{{expHandlers(ltPropHeaderLabelKey,'&amp;&amp;',tableHeader.length)}}\"><template case=\"true\"> <div class=\"lyteExpTableOrigTableInnerWrap\" tabindex=\"0\" onscroll=\"{{action('scroll',event)}}\"> <lyte-exptable class=\"lyteExpOriginalTable\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-exptable-thead class=\"originalColumn lyteExpTableHeaderGroup\"> <lyte-exptable-tr class=\"originalColumn lyteExpTableRow\"> <template is=\"for\" items=\"{{tableHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-th id=\"{{list.id}}\" class=\"originalColumn lyteExpTableHead list.class\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\"> {{list[ltPropHeaderLabelKey]}} </lyte-exptable-th> </template> </lyte-exptable-tr> </lyte-exptable-thead> <lyte-exptable-tbody class=\"originalColumn lyteExpTableRowGroup\"> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"> <lyte-exptable-tr id=\"{{list.id}}\" class=\"originalColumn lyteExpTableRow {{list.class}}\"> <template is=\"for\" items=\"{{tableHeader}}\" item=\"header\"> <lyte-exptable-td class=\"originalColumn lyteExpTableCell\">{{unescape(lyteUiGetValue(list,header[ltPropBodyLabelKey]))}}</lyte-exptable-td> </template> </lyte-exptable-tr> </template> </lyte-exptable-tbody> </template><template case=\"false\"> <lyte-yield class=\"lyteExpTableHeaderGroup\" yield-name=\"headerYield\" lt-prop-table-header=\"{{tableHeader}}\"></lyte-yield> <lyte-yield class=\"lyteExpTableRowGroup\" yield-name=\"contentYield\" lt-prop-table-header=\"{{tableHeader}}\"></lyte-yield> </template></template> </lyte-exptable> </div> </template></template> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]},{"type":"attr","position":[3]},{"type":"insertYield","position":[3]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]}},"default":{}},{"type":"attr","position":[1,3,3]},{"type":"if","position":[1,3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]},{"type":"attr","position":[3]},{"type":"insertYield","position":[3]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]}},"default":{}}],
_observedAttributes :["ltPropHeader","ltPropContent","ltPropHeaderLabelKey","ltPropBodyLabelKey","ltPropYield","ltPropInfiniteScroll","ltPropYield","ltPropMinWidth","ltPropMaxWidth","ltPropFixedTableScroll","ltPropHeight","ltPropPreventWidth","ltPropColumnSortable","ltPropScrollStep","ltPropHeaderOnly","ltPropPreventTableModify","ltPropSortDummyColumClass","ltPropPreventContentObserver","ltPropStickyTable","fixedTableHeader","fixedTableContent","tableHeader","tableContent","columns","minWidth1","minWidth2"],
    data : function(){
        return {
            /** 
             * @componentProperty {array} ltPropHeader=[]
             * @version 3.1.0
             */
            ltPropHeader : Lyte.attr("array",{"default":[]}),
            /** 
             * @componentProperty {array} ltPropContent=[]
             * @version 3.1.0
             */
            ltPropContent : Lyte.attr("array",{"default":[]}),
            /** 
             * @componentProperty {string} ltPropHeaderLabelKey=''
             * @version 3.1.0
             */
            ltPropHeaderLabelKey : Lyte.attr("string",{"default":''}),
           /** 
             * @componentProperty {string} ltPropBodyLabelKey=''
             * @version 3.1.0
             */
            ltPropBodyLabelKey : Lyte.attr("string",{"default":''}),
            /** 
             * @componentProperty {boolean} ltPropYield=false
             * @version 3.1.0
             */
            ltPropYield : Lyte.attr('boolean', {'default' : false}),
            /** 
             * @componentProperty {boolean} ltPropInfiniteScroll=false
             * @version 3.1.0
             */
            ltPropInfiniteScroll : Lyte.attr('boolean',{'default':false}),
           /** 
             * @componentProperty {boolean} ltPropYield=false
             * @version 3.1.0
             */
            ltPropYield : Lyte.attr('boolean', {'default' : false}),
            /** 
             * @componentProperty {string} ltPropMinWidth='50px'
             * @version 3.1.0
             */
            ltPropMinWidth : Lyte.attr('string',{'default':'50px'}),
            /** 
             * @componentProperty {string} ltPropMaxWidth='1000px'
             * @version 3.1.0
             */
            ltPropMaxWidth : Lyte.attr('string',{'default':'1000px'}),
           /** 
             * @componentProperty {boolean} ltPropFixedTableScroll=false
             * @version 3.1.0
             */
            ltPropFixedTableScroll : Lyte.attr('boolean',{'default':false}),
            /** 
             * @componentProperty {string} ltPropHeight='auto'
             * @version 3.1.0
             */
            ltPropHeight : Lyte.attr('string',{'default':'auto'}),
            /** 
             * @componentProperty {boolean} ltPropPreventWidth=false
             * @version 3.1.0
             */
            ltPropPreventWidth : Lyte.attr('boolean',{'default':false}),
            // column sortable
            /** 
             * @componentProperty {boolean} ltPropColumnSortable=false
             * @version 3.1.0
             */
            ltPropColumnSortable : Lyte.attr( 'boolean', { default : false } ),
            /** 
             * @componentProperty {number} ltPropScrollStep=10
             * @version 3.1.0
             */
            ltPropScrollStep : Lyte.attr( 'number', { default : 10 } ),
            /** 
             * @componentProperty {boolean} ltPropHeaderOnly=false
             * @version 3.1.0
             */
            ltPropHeaderOnly : Lyte.attr( 'boolean', { default : false } ),
            /** 
             * @componentProperty {boolean} ltPropPreventTableModify=false
             * @version 3.1.0
             */
            ltPropPreventTableModify : Lyte.attr( 'boolean', { default : false } ),
            /** 
             * @componentProperty {string} ltPropSortDummyColumClass=""
             * @version 3.1.0
             */
            ltPropSortDummyColumClass : Lyte.attr( 'string', { default : "" } ),
            /** 
             * @componentProperty {boolean} ltPropPreventContentObserver=false
             * @version 3.1.0
             */
            ltPropPreventContentObserver : Lyte.attr( 'boolean', { default : false } ),
            /** 
             * @componentProperty {boolean} ltPropStickyTable
             * @version 3.1.0
             */
            ltPropStickyTable : Lyte.attr('boolean'),
            fixedTableHeader : Lyte.attr("array",{"default":[]}),
            fixedTableContent : Lyte.attr("array",{"default":[]}),
            tableHeader : Lyte.attr("array",{"default":[]}),
            tableContent : Lyte.attr("array",{"default":[]}),
            columns : Lyte.attr("array",{"default":[]}),
            minWidth1 : Lyte.attr('string',{'default' : ''}),
            minWidth2 : Lyte.attr('string',{'default' : ''})
        }       
    },

    didDestroy: function() {
        this.$node.fixRowHeight = null;
        this.$node.scrollTo = null;
        this.$node.setColumnWidth = null;
        clearTimeout(this._scrollTimeOut)
        this._initProcessFrame != undefined && window.cancelAnimationFrame( this._initProcessFrame );
        this._setmeasure && $L.fastdom.clear( this._setmeasure );
        this._intersectionObs && this._intersectionObs.disconnect();
        this._intersections = [];
        delete this._intersectionObs; delete this._vertdiv; delete this._measure;
        delete this.scrollDiv; delete this.resizeComponent; delete this.targetElem;
    },

   init : function(){
        var uA = navigator.userAgent;
        this._dir = _lyteUiUtils.getRTL();

        this.isIE11Lyte = /rv:11/ig.test( uA );
        this.isEdgeLyte = /Edge/ig.test( uA );
        this._scrollWidth = _lyteUiUtils.getScrollBarWidth();
        this._verticalScrollWidth = this._scrollWidth;
        this._isSafari = /safari/ig.test( uA );
        // this._browser = this.isIE11Lyte || this.isEdgeLyte || uA.match('Safari');
        this._isIE = this.isIE11Lyte || this.isEdgeLyte;
        this._FF = /firefox/ig.test( navigator.userAgent );
        this._fixHeaderCount=0
        this._tmpScrollTop=0
        this._chrome = /Chrome/i.test(navigator.userAgent) && /Google Inc/i.test(navigator.vendor);
        this._isNegative = _lyteUiUtils.isNegativeScroll()

        if( !this._FF && this.getData('ltPropStickyTable') == undefined ){
            var span = document.createElement( 'th' ),
            isIntersection = "IntersectionObserver" in window;
            span.style.position = "sticky";
            if( span.style.position == "sticky" && isIntersection ){
               this.setData('ltPropStickyTable',true)
            } 
            else {
                span.style.position = "-webkit-sticky";
                if( span.style.position == "-webkit-sticky" && isIntersection ){
                   this.setData('ltPropStickyTable',true)
                }
                else{
                    this.setData('ltPropStickyTable',false)
                }
            }
        }


        if(this.getMethods('beforeRender'))
        {
            this.executeMethod('beforeRender', this.$node);
        }
        this.setTableHeader();
        this.setData('tableContent',this.getData('ltPropContent'))

        var tableHeader=this.getData('tableHeader'),
        fixedTableHeader=this.getData('fixedTableHeader');

        // for(var i=0;i<tableHeader.length;++i){
        //     if(tableHeader[i].fixed&&tableHeader[i].fixed=="enable"){
        //         Lyte.arrayUtils(fixedTableHeader,'push',tableHeader[i])
        //     }
        // }
       
   },
   didConnect : function(){

        this.$node.contentObserver = this.callContentObs.bind( this );

        this.$node.fixRowHeight = function( row ) {
            if( !this.getData('ltPropStickyTable') ){
                this.setFixTableRowHeight( row );
            }else {
                this.setLeftForInterSection(true);
            }
        }.bind( this );
        this.$node.fixColumn = function( col ) {
            if( !this.getData('ltPropStickyTable') ){
                this.setFixTableColumnWidth( col );
            }else {
                this.setLeftForInterSection(true);
            }
        }.bind( this );
        this.$node.setColumnWidth = function(col){
            if( !this.getData('ltPropStickyTable') ){
                this.setFixTableColumnWidth( col );
            }else {
                this.setLeftForInterSection(true);
            }
        }.bind( this );
        this.$node.setVisibleFixedHeader = function(){
            if( !this.getData('ltPropStickyTable') ){
                this.setVisibleFixHeader()
            } else {
                this.setLeftForInterSection(true);
            }
        }.bind( this );
        this.$node.setHeaderWidth = function(){
            if( !this.getData('ltPropStickyTable') ){
                this.fixHeaderHeight();
            }else {
                this.setLeftForInterSection(true);
            }
        }.bind( this );
        this.$node.reset = function(){
            this.setLeftForInterSection(true);
        }.bind(this)
        this._scrollDiv=this.$node.getElementsByClassName('lyteExpTableOrigTableInnerWrap')[ 0 ]
        if( this.getData('ltPropHeader').length >=1 ){
            if( !this.getData( 'ltPropStickyTable' ) ){
                 this.initProcess()
             }
             else{
               
                        this.$node.getElementsByClassName('lyteExpTableWrapper')[ 0 ].classList.add( 'lyteExpStickyTable' );
                        var scrollDiv = this.$node.getElementsByClassName('lyteExpTableOrigTableInnerWrap')[0];

                        this.registerInterSection( scrollDiv );
                        // scrollDiv.addEventListener( 'scroll', this.stickyScroll.bind( this ), true );
                        this.setLeftForInterSection( true );
                        var  height = this.getData( 'ltPropHeight' );
                        if( height != 'auto' ){
                            this.$node.style.height = this.getData( 'ltPropHeight' );
                        }
                        // this.detectBrowsers();
                
                  this._originalDiv = this.$node.getElementsByClassName( 'lyteExpTableOrigTableInnerWrap' )[ 0 ]
                  this._originalTable = this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ]
                   this.setWidth()
             }
            if( this.getMethods('afterRender') ) {
                
                this.executeMethod('afterRender', this.$node);
            }
        }

        this.$node.scrollTo = function( arg1, arg2 ,event){
            this._scrolled = true;
            if( arg1 != undefined ){
                this._originalDiv.scrollLeft = arg1;
            }
            if( arg2 != undefined ){
                this._originalDiv.scrollTop = arg2;
            }
           if( this._scrolled ){
                clearTimeout( this._scrollTimeOut ) 
                this._scrollTimeOut = setTimeout(function(){
                this.actions.scroll.call( this,event,arg1,arg2, true );
              }.bind(this),20)
            }
           delete this._scrolled;
            
        }.bind( this );
        // this.$node.setHeaderWidth = function(){
        //     this.fixHeaderHeight();
        // }.bind( this );
   },
   initProcess : function(){
        var originalDiv = this.$node.getElementsByClassName( 'lyteExpTableOrigTableInnerWrap' )[ 0 ],
        isFF = this._FF;
        this._originalDiv = originalDiv
        this._oHeader = this.$node.getElementsByClassName( 'lyteExpTableFakeColHeader' )[ 0 ]
        this._headerDiv = this.$node.getElementsByClassName( 'lyteExpTableFakeHeaderWrapper' )[ 0 ];
        this._originalTable = this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
        this._fakeOriginalHeader=this.$node.getElementsByClassName('lyteExpTableFakeColHeaderWrapper')[ 0 ]
        var div = this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],
        height = this.getData( 'ltPropHeight' ),scrollWidth;
        var scrollWidth = this._scrollWidth

        if( height != 'auto' ){
            this.$node.style.height = this.getData( 'ltPropHeight' );
        } 
        
        
        $L.fastdom.measure( function(){
            var lt = this._dir ? "left" : "right";
            this._startScrollLeft = isFF ? 0 : originalDiv.scrollLeft;
            this.setScrollWidth(true);
            var tbHeight = this._originalDiv.getBoundingClientRect().height;
                 this._resizeScrollLeft = originalDiv.scrollLeft;
                    $L.fastdom.mutate( function(){
                        
                        this._headerDiv.style[ lt ] = this._verticalScrollWidth +"px";
                        if( originalDiv.offsetWidth!= originalDiv.scrollWidth){
                            div.style.height = 'calc(100% - '+this._scrollWidth+'px)' 
                        }

                    }.bind( this ) );
                }.bind( this ) );
        
        // var ;

        // if(height!="auto"){
        //     this.$node.style.height=this.getData('ltPropHeight')
        // }
        // else{
            // this.$node.style.height = this._originalDiv.getBoundingClientRect().height + 'px';
        // }
        this.setFixTableColumnWidth();
        
        this.setWidth();
       
        // var scrollWidth=originalDiv.offsetWidth-originalDiv.clientWidth
        // var lt=this._dir? "left":"right"
        // this._startScrollLeft=originalDiv.scrollLeft;
        // this._headerDiv.style[lt]=scrollWidth +"px";
        // this._scrollWidth=scrollWidth;
        // div=this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ];
        
        // div.style.height=parseInt(height)-scrollWidth +"px"
        this._prevScollLeft = 0;
        // this._headerList=this._oHeader.querySelectorAll('lyte-exptable-th');
        // var strList=originalDiv.querySelectorAll('lyte-exptable-tr');
        this._initProcessFrame != undefined && window.cancelAnimationFrame( this._initProcessFrame );
        this._initProcessFrame = window.requestAnimationFrame( function() {
            this.setVisibleFixHeader();
            delete this._initProcessFrame;
            // this.setFixTableRowHeight();
        }.bind(this))
    },
    setFixedTable : function(){
        var originalTable = this._originalTable  || this.$node.getElementsByClassName('lyteExpOriginalTable')[0],
        originalTableHeader = originalTable.getElementsByTagName('lyte-exptable-th'),
        tableHeader = this.getData('ltPropHeader'), fixedTableHeader=[]
        for(var i = 0 ; i < tableHeader.length ; i++ ) {
            if( tableHeader[i].fixed && tableHeader[i].fixed == "enable" && originalTableHeader[i].offsetWidth != 0 ) {
                 Lyte.arrayUtils(fixedTableHeader,'push',tableHeader[i])
            }
        }
        this.setData('fixedTableHeader',fixedTableHeader)
        this.setData('fixedTableContent',this.setData('ltPropContent'))
    },
    // setting value for tableHeader
   setTableHeader : function(){ // for setting tableHeader 
            var tableHeader=[],ltPropHeader=this.getData('ltPropHeader'), fixedTableHeader=[]
            for(var i=0;i<ltPropHeader.length;++i){
                tableHeader[i]=ltPropHeader[i];
                if( !this.getData('ltPropStickyTable') && tableHeader[i].fixed && tableHeader[i].fixed == "enable"  ) {
                 Lyte.arrayUtils(fixedTableHeader,'push',tableHeader[i])
            }
            }
            this.setData('tableHeader',tableHeader)
            if( !this.getData('ltPropStickyTable') ){
                this.setData('fixedTableHeader',fixedTableHeader)
            }
     },
    setWidth : function(){
        var sthList=this._originalDiv.getElementsByTagName('lyte-exptable-th');
        var widthList=[],width=0, rpx = /(\d*)px/i;
         $L.fastdom.measure(function(){
            for(var i=0;i<sthList.length;++i){

                var off=sthList[i].getBoundingClientRect().width
                widthList[i]={}
                width+=off
                widthList[i].width= off;
            }
           
         }.bind( this ))
        this._widthList=widthList
    },
    setScrollWidth : function(flag){
            this._oriwrap = this._oriwrap || this.$node.getElementsByClassName( 'lyteExpTableOrigTableInnerWrap' ) [ 0 ];
             if(this._oriwrap){
                var scrollWidth = this._scrollWidth,heightScrollWidth = this._scrollWidth

                if(this._oriwrap.scrollHeight<=this._oriwrap.offsetHeight){
                        this._verticalScrollWidth = 0;
                       scrollWidth=0
                }
                else {
                     this._verticalScrollWidth = this._scrollWidth ;
                    scrollWidth = this._scrollWidth
                }
                if(!flag){

                        
                    $L.fastdom.measure( function(){
                        var lt = this._dir ? "left" : "right";
                        $L.fastdom.mutate( function(){

                                 this._headerDiv.style[ lt ] = scrollWidth +"px";
                                                    }.bind( this ) );
                    }.bind( this ) );
                 }

            }
    },
    fixHeaderHeight : function(){ // setting min-width value for fixedTable and both fakeHeader 
        var tableHeader=this.getData('tableHeader'),fixedTableHeader=this.getData('fixedTableHeader');
        var sHeader=this._oHeader,thList=sHeader.getElementsByTagName( 'lyte-exptable-th' );
        var sthList=this._originalDiv.getElementsByTagName( 'lyte-exptable-th' );

        var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],
        offset=[],minWidth=[],width=[],sum=0,fixedSum=0, rpx = /(\d*)px/i;
        var originalTable =this._originalTable || this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
        if( originalTable.style.width!="" && this.getData('ltPropPreventWidth')){
            this.setFixedTableWidth()
        }else {
           $L.fastdom.measure(function(){
                for(var i=0;i<thList.length;++i){ // setting minWidth value for fakeOriginalHEader
                    width[i] = this.getData('ltPropPreventWidth') ? ( sthList[i].style.width ? parseInt(sthList[i].style.width) : sthList[i].getBoundingClientRect().width) : sthList[i].getBoundingClientRect().width;
                }  

                $L.fastdom.mutate(function(){
                    var tableHeader=this.getData('tableHeader'),fixedTableHeader=this.getData('fixedTableHeader');
                    var sHeader=this._oHeader,thList=sHeader.getElementsByTagName( 'lyte-exptable-th' );
                    var sthList=this._originalDiv.getElementsByTagName( 'lyte-exptable-th' );

                    var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
                    this._fixedDivWrap = this._fixedDivWrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];

                    var ftrList=fDiv.getElementsByTagName( 'lyte-exptable-tr' ),fixedColumn=[],
                    fHeader=this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' )[ 0 ],_thList=fHeader.getElementsByTagName( 'lyte-exptable-th' );
                    var fthList=fDiv.getElementsByTagName( 'lyte-exptable-th' );
                    
                    for(var i=0;i<thList.length;++i){ // setting minWidth value for fakeOriginalHEader
                        if(!this.getData('ltPropPreventWidth')){
                            thList[i].style.width=width[i]+"px";
                            sthList[i].style.width=width[i]+"px";
                        }
                        
                        sum+=width[i];
                        if(sthList[ i ].classList.contains('lyteFixedColumn') ){
                            fixedSum+=width[i]
                        }
                    }
                    this._fixedSum=fixedSum;
                    var originalTable =this._originalTable || this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
                        originalTable.style.width=sum+"px";
                        this._fakeOriginalHeader.style.width=sum+"px"  

                    if( sthList ) {
                            for( var n = 0; n < sthList.length; n++ ){
                                if(sthList[ n ].classList.contains('lyteFixedColumn') ){
                                    fixedColumn.push( sthList[ n ] );
                                } 
                            }
                        }
                        sum=0;
                    for(var i=0;i<this._fixHeaderCount;++i){ // setting minWidth value for fixed Header and fake FixedHEader
                            var index=this.getIndex(fixedColumn[i])
                            sum+=width[index]
                            if(!this.getData('ltPropPreventWidth')){
                                _thList[i].style.width=width[index] +"px";
                                fthList[i].style.width=width[index] +"px";
                            }
                            
                    }
                    fDiv.style.width=sum+"px";
                    this._fixedDivWrap.style.width=fDiv.style.width

                    this._fHeader=fHeader;
                    this._fthList=fDiv.getElementsByClassName( 'lyteExpTableHeaderGroup' )[ 0 ];
                    this._setHeight=true
                    

                    if(this._fixHeaderCount==0){
                        fDiv.style.width = 0 + 'px';
                        delete this._setHeight
                        delete this._fHeader
                        delete this._fthList
                    }
                    
                }.bind( this ))
            }.bind( this ))
       }
    },
    // For Fixed Table
    setFixedTableWidth : function(){
                var tableHeader=this.getData('tableHeader'),fixedTableHeader=this.getData('fixedTableHeader');
                var sHeader=this._oHeader,thList=sHeader.getElementsByTagName( 'lyte-exptable-th' );
                var sthList=this._originalDiv.getElementsByTagName( 'lyte-exptable-th' );

                var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
                this._fixedDivWrap = this._fixedDivWrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];

                var ftrList=fDiv.getElementsByTagName( 'lyte-exptable-tr' ),fixedColumn=[],
                fHeader=this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' )[ 0 ],_thList=fHeader.getElementsByTagName( 'lyte-exptable-th' );
                var fthList=fDiv.getElementsByTagName( 'lyte-exptable-th' );
                if( sthList ) {
                        for( var n = 0; n < sthList.length; n++ ){
                            if(sthList[ n ].classList.contains('lyteFixedColumn') ){
                                fixedColumn.push( sthList[ n ] );
                            } 
                        }
                }
                var sum=0;
                for(var i=0;i<this._fixHeaderCount;++i){ // setting minWidth value for fixed Header and fake FixedHEader
                    var index=this.getIndex(fixedColumn[i])
                    sum += sthList[index].style.width ? parseInt(sthList[index].style.width) : sthList[index].getBoundingClientRect().width
                }
                    fDiv.style.width=sum+"px";
                    this._fixedDivWrap.style.width=fDiv.style.width

                    this._fHeader=fHeader;
                    this._fthList=fDiv.getElementsByClassName( 'lyteExpTableHeaderGroup' )[ 0 ];
                    this._setHeight=true
                

                if(this._fixHeaderCount==0){
                    fDiv.style.width = 0 + 'px';
                    delete this._setHeight
                    delete this._fHeader
                    delete this._fthList
                }
    },
    // fixHeaderHeightP : function(){
    //     var tableHeader=this.getData('tableHeader'),fixedTableHeader=this.getData('fixedTableHeader');
    //     var sHeader=this._oHeader,thList=sHeader.getElementsByTagName( 'lyte-exptable-th' );
    //     var sthList=this._originalDiv.getElementsByTagName( 'lyte-exptable-th' );
    //     var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],
    //     offset=[],minWidth=[],width=[],sum=0,fixedSum=0, rpx = /(\d*)px/i;
    //     var originalTable =this._originalTable || this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
    //     if( originalTable.style.width!="" && that.getData('ltPropPreventWidth')){
    //         this.setFixedTableWidth()
    //     }else {
    //         $L.fastdom.measure(function(){
    //             for(var i=0;i<thList.length;++i){ // setting minWidth value for fakeOriginalHEader
    //                 width[i] = sthList[i].style.width ? parseInt(sthList[i].style.width) : sthList[i].getBoundingClientRect().width;
    //             } 
    //          $L.fastdom.mutate(function(){
    //                 var tableHeader=this.getData('tableHeader'),fixedTableHeader=this.getData('fixedTableHeader');
    //                 var sHeader=this._oHeader,thList=sHeader.getElementsByTagName( 'lyte-exptable-th' );
    //                 var sthList=this._originalDiv.getElementsByTagName( 'lyte-exptable-th' );

    //                 var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
    //                 this._fixedDivWrap = this._fixedDivWrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];

    //                 var ftrList=fDiv.getElementsByTagName( 'lyte-exptable-tr' ),fixedColumn=[],
    //                 fHeader=this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' )[ 0 ],_thList=fHeader.getElementsByTagName( 'lyte-exptable-th' );
    //                 var fthList=fDiv.getElementsByTagName( 'lyte-exptable-th' );
                    
    //                 for(var i=0;i<thList.length;++i){ // setting minWidth value for fakeOriginalHEader
    //                     sum+=width[i];
    //                     if(sthList[ i ].classList.contains('lyteFixedColumn') ){
    //                         fixedSum+=width[i]
    //                     }
    //                 }
    //                 this._fixedSum=fixedSum;
    //                     originalTable.style.width=sum+"px";
    //                     this._fakeOriginalHeader.style.width=sum+"px"  

    //                 if( sthList ) {
    //                         for( var n = 0; n < sthList.length; n++ ){
    //                             if(sthList[ n ].classList.contains('lyteFixedColumn') ){
    //                                 fixedColumn.push( sthList[ n ] );
    //                             } 
    //                         }
    //                     }
    //                     sum=0;
    //                     for(var i=0;i<this._fixHeaderCount;++i){ // setting minWidth value for fixed Header and fake FixedHEader
    //                             var index=this.getIndex(fixedColumn[i])
    //                             sum+=width[index]
    //                     }
    //                     fDiv.style.width=sum+"px";
    //                     this._fixedDivWrap.style.width=fDiv.style.width

    //                     this._fHeader=fHeader;
    //                     this._fthList=fDiv.getElementsByClassName( 'lyteExpTableHeaderGroup' )[ 0 ];
    //                     this._setHeight=true
                    

    //                 if(this._fixHeaderCount==0){
    //                     fDiv.style.width = 0 + 'px';
    //                     delete this._setHeight
    //                     delete this._fHeader
    //                     delete this._fthList
    //                 }
                    
    //             }.bind( this ))
    //         }.bind( this ))
    //     }
    // },
    setFixTableRowHeight : function( row ) { //Fixing Row Height 
            var fDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
            var ftrList=fDiv.getElementsByTagName( 'lyte-exptable-tr' )
            var strList=this._originalDiv.getElementsByTagName('lyte-exptable-tr'),
            offsetsArray = [], that = this, rowIndex;
            var fHeader=this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' )[ 0 ]

            var fHeaderTr=fHeader.getElementsByTagName( 'lyte-exptable-tr' )[ 0 ]

            if( row && ( row.nodeType === 1 || !isNaN( row ) ) ) {
                if( row.nodeType === 1 ) {
                    rowIndex = Array.from( strList ).indexOf( row );
                }
                else {
                    rowIndex = row;
                }
                if(that.getMethods('beforeSetFixTableRowHeight'))
                    {
                        that.executeMethod('beforeSetFixTableRowHeight', that.$node);
                    }
                $L.fastdom.measure( function() {
                    if( !that.$node ) {
                        return ;
                    }

                    offsetsArray = strList[ rowIndex ].getBoundingClientRect().height + 'px';
                    strList[ rowIndex ]._relatedRow = ftrList[ rowIndex ];
                    ftrList[ rowIndex ]._relatedRow = strList[ rowIndex ];
                } );

                $L.fastdom.mutate( function() {
                    if( !that.$node ) {
                        return ;
                    }

                    ftrList[ rowIndex ].style.height = offsetsArray;
                } );
            }
            else {
                $L.fastdom.measure( function() {
                    if( !that.$node ) {
                        return ;
                    }

                    for( var i = 0; i < strList.length; i++ ) {
                        offsetsArray.push( strList[i].getBoundingClientRect().height + 'px' );
                        strList[ i ]._relatedRow = ftrList[ i ];
                        ftrList[ i ]._relatedRow = strList[ i ];
                    }  
                } );

                $L.fastdom.mutate( function() {
                    if( !that.$node ) {
                        return ;
                    }

                    for(var i = 0; i < strList.length; i++ ) {
                        ftrList[ i ].style.height = offsetsArray[ i ];
                    }
                    if(strList.length>0&& fHeaderTr){
                        fHeaderTr.style.height = offsetsArray[ 0 ]
                    }
                    if(that.getMethods('afterSetFixTableRowHeight'))
                    {
                        that.executeMethod('afterSetFixTableRowHeight', that.$node);
                    }
                } );   
            }
               
    },
    setFixTableColumnWidth : function( col ) { //Fixing Row Height 
            var fDiv= this._oHeader || this.$node.getElementsByClassName( 'lyteExpTableFakeColHeader' )[ 0 ]
            var fthList=fDiv.getElementsByTagName( 'lyte-exptable-th' )
            var sthList=this._originalDiv.getElementsByTagName('lyte-exptable-th'),
            offsetsArray = [], that = this, colIndex,width=0,sum=0,widthList;
            if(this._originalTable){
                this._originalTable = this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
            }
            this._originalTable.style.removeProperty('width');
            this._fakeOriginalHeader.style.removeProperty('width')
            if( col!=undefined && ( col.nodeType === 1 || !isNaN( col ) ) ) {
                if( col.nodeType === 1 ) {
                    colIndex = this.getIndex(col);
                }
                else {
                    colIndex = col;
                }
                $L.fastdom.mutate( function() {
                    if( !that.$node ) {
                        return ;
                    }
                    if(that._widthList){
                        sthList[colIndex].style.width=that._widthList[colIndex].width +"px";
                        fthList[colIndex].style.width=that._widthList[colIndex].width +"px";

                    }
                    if($L(sthList[colIndex]).hasClass('lyteFixedColumn')){
                        ofthList=that._originalDiv.getElementsByClassName('lyteFixedColumn')
                        fColIndex = Array.from( ofthList ).indexOf( sthList[colIndex] );
                        if(that._fixHeaderCount>=0){
                           var _colwrap = that._colwrap || that.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' ) [ 0 ];

                            fixothList = _colwrap.getElementsByTagName('lyte-exptable-th') ;
                            var w=fixothList[fColIndex].style.width  
                           fixothList[fColIndex].style.width = that._widthList[colIndex].width +"px";
                           _fcolwrap = that.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];
                           ffixothList = _fcolwrap.getElementsByTagName('lyte-exptable-th') ; 
                           ffixothList[fColIndex].style.width = that._widthList[colIndex].width +"px";
                           var width=parseInt(_colwrap.style.width) - (parseInt(w)-that._widthList[colIndex].width);
                            _colwrap.style.width = width+"px";
                            _fcolwrap.style.width = width+"px";
                        }
                    }
                    var width=that._originalTable.getBoundingClientRect().width
                    that._originalTable.style.width = width+"px";
                    that._fakeOriginalHeader.style.width = width+"px";
                } );
            }
            else{
                if( !that.$node ) {
                            return ;
                }
                // that.$node.classList.remove('tableLayoutFixed')
                if(that.getMethods('beforeSetFixTableColumnWidth'))
                {
                    that.executeMethod('beforeSetFixTableColumnWidth', that.$node);
                 }
                    // $L.fastdom.mutate( function() {
                        // if(that._widthList){
                        //     // widthList = that._widthList;
                        
                        //     // for(var i = 0; i < strList.length; i++ ) {
                        //     //     strList[ i ].style.width = widthList[i].width +"px";
                        //     // }
                        // }
                        if(!col){
                            that.fixHeaderHeight();
                            
                                $L.fastdom.measure( function() {
                                    $L.fastdom.mutate( function() {
                                        if(that.getMethods('afterSetFixTableColumnWidth'))
                                            {
                                                that.executeMethod('afterSetFixTableColumnWidth', that.$node);
                                            }
                                     });
                                });
                            }
                    // });
                }
                // $L.fastdom.mutate( function() {
                //     if( !that.$node ) {
                //         return ;
                //     }

                //     for(var i = 0; i < strList.length; i++ ) {
                //         strList[ i ].style.width = offsetsArray[ i ];
                //     }
                //     if(that._originalTable){
                //         that._originalTable.style.width=width+"px";
                //     }
                //     that.$node.classList.add('tableLayoutFixed')
                // } );   
            
               
    },
    setVisibleFixHeader : function(){ // To fix and unfix Columns
         var _fHeader=this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' )[ 0 ].getElementsByTagName( 'lyte-exptable-th' ),count=this._fixHeaderCount,
            originalHeader = this.$node.getElementsByClassName('lyteExpTableFakeColHeaderWrapper')[ 0 ].getElementsByClassName( 'lyteFixedColumn' ),
            fixedColDiv = this.$node;
            
            for(var i=0;i<_fHeader.length;i++){
                if(i+1<=count){
                    _fHeader[i].classList.remove('lyteFixHeaderDisplayNone')
                    _fHeader[ i ].style.width = originalHeader[ i ].style.width;
                }
                else{
                    _fHeader[i].classList.add('lyteFixHeaderDisplayNone')

                }
            }
            count=this._fixHeaderCount
            var trList=this.$node.getElementsByClassName( 'lyteExpTableFixedColTable' )[ 0 ].getElementsByTagName( 'lyte-exptable-tr' );
            // for(var i=0;i<trList.length;++i){
                for( var i = trList.length - 1; i >= 0; i-- ){
                var tdList=trList[i].getElementsByTagName( ( i == 0 ? 'lyte-exptable-th' : 'lyte-exptable-td' ) )
                for(var j=0;j<tdList.length;++j){
                    if(j+1<=count){
                        tdList[j].classList.remove('lyteFixHeaderDisplayNone')
                        // tdList[ j ].style.width = originalHeader[ j ].style.minWidth;
                    }
                    else if( j != 0 ){
                        tdList[j].classList.add('lyteFixHeaderDisplayNone')
                    }
                }
            }
            !this._elem && this.setFixTableRowHeight();

            if( count == 0 ){
                !fixedColDiv.classList.contains( 'lyteExpTableNoShadow' ) && fixedColDiv.classList.add( 'lyteExpTableNoShadow' );
            } else {
                fixedColDiv.classList.contains( 'lyteExpTableNoShadow' ) && fixedColDiv.classList.remove( 'lyteExpTableNoShadow' );
            }
        
    },

    callHeaderObs : function(){
        if(!this.getData('ltPropStickyTable')){
            this.setTableHeader();
            this._fixHeaderCount=0;
            this.setData('columns',[]);
            if(this.getData('ltPropHeader').length>=1){
                this.initProcess();
            }
            delete this._widthList;
            this._oHeader.parentNode.style.transform="translateX(0)"
        }else{
            this.setTableHeader()
            this.setLeftForInterSection(true)
        }
    },

    callContentObs : function(){
        if(!this.getData('ltPropStickyTable')){
            var preventCalculate = this.getData( 'ltPropPreventContentObserver' );

            delete this._widthList;

            if( !preventCalculate ) {
                this.setFixTableColumnWidth();
            }
            
            this.setFixTableRowHeight();

            if( !preventCalculate ) {
                this.setWidth();
            }
        }else{
            this.setWidth();
            this.setLeftForInterSection(true)
        }
        
    },


    /* Observes for Header,content,fixedTableScroll*/
    headerObs : function(){
        
         if( this._prevent ){
            return;     
            }
            this.callHeaderObs();
        

    }.observes('ltPropHeader.[]'),
    contentObs : function(){
        if(!this.getData('ltPropStickyTable')){
            if( this.data.ltPropPreventContentObserver ){
                return;
            }

            this.callContentObs();
        }

    }.observes('ltPropContent.[]'),
    HeightObs : function(){
        
            var height = this.getData('ltPropHeight') , scrollWidth = this._scrollWidth
            this.$node.style.height=this.getData('ltPropHeight')
            var div = this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]

            if(!this.getData('ltPropStickyTable')){
                this.setScrollWidth();
                $L.fastdom.measure( function() {
                    var scrollDiv=this._originalDiv,scrollTop= this._elem ? this.prevScollTop : ( scrollTop || scrollDiv.scrollTop ),scrollLeft = this._elem ? this._originalDiv._sL : (scrollLeft || scrollDiv.scrollLeft ),
                        scrollWidth = this._elem ? this._sw : scrollDiv.scrollWidth, offsetWidth = this._elem ? this._thisBccr.width : scrollDiv.offsetWidth,value
                    if( scrollWidth != undefined && scrollLeft != undefined && offsetWidth != undefined ){
                      value = this.returntrans( scrollLeft, offsetWidth, scrollWidth );
                    }
                    $L.fastdom.mutate( function() {
                        if( this._oHeader ){
                            this._oHeader.parentNode.style.transform="translateX("+ value +"px)";
                        }
                        
                       if( div && scrollDiv.offsetWidth != scrollDiv.scrollWidth ) {
                            div.style.height = 'calc(100% - '+this._scrollWidth+'px)'
                        }
                    }.bind(this))
                }.bind(this))
            }
    }.observes('ltPropHeight'),
    fixedTableScrollObs : function(){
        if(!this.getData('ltPropStickyTable')){
         var div=this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
        if(this.getData('ltPropFixedTableScroll')){
            // this._fixedScroll=this.fixedScroll.bind(this)
            // this._fixedWheel=this.fixedWheel.bind(this)
            // div.addEventListener('scroll',this._fixedScroll, true)
            // div.addEventListener('wheel',this._fixedWheel)
            div.style.overflow = '';
        }
        else{
            div.style.overflow = "hidden";
            // if(this._fixedScroll){
            //     div.removeEventListener('scroll',this._fixedScroll,true)
            // }
            // if(this._fixedWheel){
            //     div.removeEventListener('wheel',this._fixedWheel)
            // }
        }
    }
    }.observes('ltPropFixedTableScroll').on('didConnect'),

    /*Common Function*/
    // columnWidth : function(fixedColumn, i, j){
    //     var width = 0;
    //     if(!j)
    //         {
    //             j = 0
    //         }
    //     for(; j < i; j++)
    //         {
    //             width += fixedColumn[j].getBoundingClientRect().width;
    //         }
    //     return width;   
    // },
    getIndex : function(data){
        return Array.from( this._originalDiv.getElementsByTagName( 'lyte-exptable-th' ) ).indexOf( data );
    },
    getIndexFromFake : function(data){
        if(this._oHeader){
            return Array.from( this._oHeader.getElementsByTagName( 'lyte-exptable-th' ) ).indexOf( data );
        }
    },
    // transform : function( flag, elem, value ){

    //     var transform = ( elem.style.transform || 'translateX(0px) translateY(0px)' ),
    //     transX = parseFloat( /translateX\((.+)/.exec( transform )[ 1 ] ),
    //     transY = parseFloat( /translateY\((.+)/.exec( transform )[ 1 ] );
    //     if( value != undefined ){
    //         // if( flag ){
    //         //     elem.style.transform = "translateY(" + transY + 'px) ' + 'translateX(' + value + 'px)';
    //         // } else {
    //         //     elem.style.transform = "translateY(" + transY + 'px) ' + 'translateX(' + value + 'px)';
    //         // }
    //     } else {
    //         return parseFloat( flag ? transY : transX );
    //     }
    // },
   
    composePath : function(event){
        var arr = [], node = event.target.correspondingElement || event.target;
        while( node && node.tagName != 'HTML')
            {
                arr.push(node);
                node = node.parentNode;
            }
        return arr; 
    },
    rtlfunc : function( lft, bcr, ww ) {
        if( this._dir && lft != 'top' && lft != 'clientY' ) {
            if( bcr ) {
                if( lft == 'right' ) {
                    return ww - bcr.left;
                } else if( lft == 'clientX' ) {
                    return ww - bcr.clientX;
                }
                return ww - bcr.right;
            } else if( lft == 'left' ) {
                return 'right';
            } else if( lft == "right" ) {
                return "left";
            } 
        }
        return bcr ? bcr[ lft ] : lft;
    },
    getPreviousOffset : function(element) {
        while( element.previousElementSibling ) {
            var tmp = element.previousElementSibling
            var offset = tmp.getBoundingClientRect();
            if( tmp.width == 0 ){
                element = element.previousElementSibling;
            }
            else{
                return offset
            }
        }
        return 
    }, 
    
    scrollCheck : function(scrollTop,scrollLeft, ignore ){
        this._colwrap = this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' ) [ 0 ];
        this._oriwrap = this._oriwrap || this.$node.getElementsByClassName( 'lyteExpTableOrigTableInnerWrap' ) [ 0 ];
        this._tableWrp = this._tableWrp || this.$node.getElementsByClassName( 'lyteExpTableOrigTableWrapper' ) [ 0 ];
        this._fixedDivWrap = this._fixedDivWrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];

        var wrapfixed = this._colwrap.getElementsByClassName( 'lyteFixedColumn' ),
        originalFixed = this._oriwrap.getElementsByClassName( 'lyteFixedColumn' ) || [],
        wrapBcr = this._tableWrp.getBoundingClientRect(),
        wWidth = window.innerWidth

        if( scrollLeft != this._prevScrollLeft || ignore ) {
            var columns = this.getData( 'columns' ),
            tableHeader = this.getData( 'tableHeader' ),
            headRows = [],
            ltPropFixedColumnClass = this.data.ltPropFixedColumnClass || '',
            curWidth = 0;

            for( var i = 0; i < wrapfixed.length; i++ ){
                wrapfixed[ i ]._off = wrapfixed[ i ].getBoundingClientRect();
                originalFixed[ i ]._off = originalFixed[ i ].getBoundingClientRect();
            }

            for( var j = 0; j < columns.length; j++ ){
                curWidth += columns[ j ]._off.width;
            }

            var count = this._fixHeaderCount, now = [];

            var fDiv = this._colwrap;
            if( !this._fthList ){
                this._fthList= fDiv.getElementsByClassName( 'lyteExpTableHeaderGroup' ) [ 0 ];   
            }
            if( this._fthList ) {
                fDiv.scrollTop = scrollTop;
            }

            for( var i = columns.length; i < wrapfixed.length; i++ ){
                var current = originalFixed[ i ];

                if( this._elem ){
                    if( Array.apply( Array, current.parentNode.children ).indexOf( current ) == this._index ){
                        continue;
                    }
                }

                  if(current._off.width == 0 && i+1 < originalFixed.length && Math.round(this.rtlfunc( 'left', originalFixed[ i+1 ]._off, wWidth ) - this.rtlfunc( 'left', wrapBcr, wWidth )) < curWidth){
                    columns.push( wrapfixed[ i ] );
                    fDiv.style.width = ( parseFloat( fDiv.style.width )+ originalFixed[ i ]._off.width ) + 'px';
                    curWidth += originalFixed[ i ]._off.width;
                    this._fixHeaderCount++;
                    this.setVisibleFixHeader()
                    now.push( i );
                }
                else if( current._off.width != 0 && Math.round(this.rtlfunc( 'left', current._off, wWidth ) - this.rtlfunc( 'left', wrapBcr, wWidth )) < curWidth ){
                    columns.push( wrapfixed[ i ] );
                    fDiv.style.width = ( parseFloat( fDiv.style.width )+ originalFixed[ i ]._off.width ) + 'px';
                    curWidth += originalFixed[ i ]._off.width;
                    this._fixHeaderCount++;
                    this.setVisibleFixHeader()
                    now.push( i );

                } else{
                    break;
                } 

            }
            
            for( var n = columns.length - 1; n >= 0; n-- ){
                if( now.indexOf( n ) != -1 ){
                    continue;
                }
                if( columns[ n ]._off.width == 0 && n-1 >= 0 && this.rtlfunc( 'right', columns[ n-1 ]._off, wWidth ) <= this.rtlfunc( 'right', originalFixed[ n-1 ]._off, wWidth ) + ( this._isIE ? 2 : 0 ) ){
                    fDiv.style.width = ( parseFloat( fDiv.style.width ) - originalFixed[ n ]._off.width ) + 'px';
                    this._fixHeaderCount--;
                    this.setVisibleFixHeader()
                    Lyte.arrayUtils( columns, 'removeAt', n );
                }
                else if( columns[ n ]._off.width != 0 && this.rtlfunc( 'right', columns[ n ]._off, wWidth ) <= this.rtlfunc( 'right', originalFixed[ n ]._off, wWidth ) + ( this._isIE ? 2 : 0 ) ){

                
                    //     this.setForIEEdge( scrollLeft )
                    // } else {            
                        // this._oHeader.style.transform="translateX(" + ( this._isIE ? scrollLeft * ( this._dir ? 1 : -1 ) : ( this._dir ? this._startScrollLeft - scrollLeft : - scrollLeft ) ) + "px)";
                    // }
                    for( var k = columns.length - 1; k >= n; k-- ){
                         fDiv.style.width = ( parseFloat( fDiv.style.width ) - originalFixed[ k ]._off.width ) + 'px';
                        this._fixedDivWrap.style.width = fDiv.style.width
                        this._fixHeaderCount--;
                    
                        Lyte.arrayUtils( columns, 'removeAt', k );
                    }

                    this.setVisibleFixHeader()
                }
            }
        }
       this.prevScollTop=scrollTop;
       this._prevScrollLeft = scrollLeft;
       
    },
    hideTempHeader : function(flag){
        $L.fastdom.measure( function() {
            var div= this._colwrap || this.$node.getElementsByClassName('lyteExpTableFixedColWrapper')[0],
            scrollTop1 = div.scrollTop,
            scrollTop=this._originalDiv.scrollTop

            $L.fastdom.mutate( function() {
                 if(this.getData('ltPropFixedTableScroll')){
                   if(flag){
                        div.scrollTop = scrollTop
                    }
                    else{
                        this._originalDiv.scrollTop = scrollTop1
                    }
                }
            }.bind( this ) );
        }.bind( this ) );
        
       
        // $L.fastdom.mutate(function(){
            // if(this._fthList){
           
            //  this._fthList.style.transform="translateY("+(scrollTop)+"px)"
            // }
            // this._othead.style.transform="translateY("+(scrollTop)+"px)"
        // }.bind(this))   
        clearTimeout(this._scrollY)
        delete this._scrollY
    },
    scrollF : function(scrollTop,scrollLeft, ignore){
        this.scrollCheck(scrollTop,scrollLeft, ignore );
        // this.fixHeaderHeight();
    },
    verticalScroll : function(scrollLeft,flag){
           
            // if(this.getData('ltPropFixedTableScroll')){
            //     if(flag){
            //         var div=this.$node.querySelector('.lyteExpTableFixedColWrapper')
            //         div.scrollTop=this._originalDiv.scrollTop
            //     }
            //     else{
            //         var div=this.$node.querySelector('.lyteExpTableFixedColWrapper')
            //         this._originalDiv.scrollTop=div.scrollTop
            //     }
            // }
            // else{
            //     $L.fastdom.mutate(function(){
            //         var div=this.$node.querySelector('.lyteExpTableFixedColTable'),scrollTop=this._originalDiv.scrollTop
            //         div.style.transform="translateY(-"+scrollTop+"px)"
            //     }.bind(this))

            // }
            // if(!this._scrollY){
            //     $L.fastdom.mutate( function(){
            //         // if(this._fthList){
            //         //     this._fthList.style.transform="translateY("+(0)+"px)"
            //         // }
            //         // this._othead.style.transform="translateY("+(0)+"px)"
            //         this._oHeader.style.transform="translateX("+scrollLeft+"px)"
            //     }.bind(this))
                
            // }
            clearTimeout(this._scrollY)
            // this.hideTempHeader=this.hideTempHeader.bind(this,flag)
            // this._scrollY = setTimeout(this.hideTempHeader,200 )
            this._scrollY = setTimeout( this.hideTempHeader.bind( this, flag ), 200 )
           
    },
    
    /*Fixed Scroll*/
    fixedScroll : function(event){
        if(this.getData('ltPropStickyTable')){
            return
        }
            if(this._parentScroll){
                delete this._parentScroll
                return
            }

            var scrollDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],scrollTop=scrollDiv.scrollTop,scrollLeft=this._originalDiv.scrollLeft

            if((scrollTop!=this.prevScollTop)){
                if(this.getData('ltPropFixedTableScroll')){
                     var div=this._originalDiv
                    div.scrollTop=scrollTop
                    // this._fthList.style.transform="translateY("+(0)+"px)"
                    // this._othead.style.transform="translateY("+(0)+"px)"

                }
                scrollLeft=this._dir?this._startScrollLeft-scrollLeft: -scrollLeft
                // this.verticalScroll(event,scrollLeft)
                this.prevScollTop=scrollTop
                clearTimeout(this._fixedscrollY)
                this.setTranslate=this.setTranslate.bind(this)
                this._fixedscrollY = setTimeout(this.setTranslate,200 )
            }

            
    },
    setTranslate : function(){
        var scrollTop=this._originalDiv.scrollTop
        // $L.fastdom.mutate(function(){
            // if(this._fthList){
           
            //  this._fthList.style.transform = "translateY("+(scrollTop)+"px)"
            // }
            // this._othead.style.transform="translateY("+(scrollTop)+"px)"
        // }.bind(this))   
        clearTimeout(this._fixedscrollY)
        delete this._fixedscrollY
    },
    // fixedWheel : function(event){
           
    //        var scrollDiv= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],scrollLeft=scrollDiv.scrollLeft,scrollTop=scrollDiv.scrollTop,
    //        ret = this.getWheel( event );
    //        if( Math.abs( ret[ 0 ] ) > Math.abs( ret[ 1 ] ) ){
    //               this._originalDiv.scrollLeft += ret[ 0 ];
    //               event.preventDefault();  
    //        }
           
    // },
    minWidth : function(resizeComponent, arg){
        // for find original min width of a cell its width is set to its minumum width and width calculated 
        var minWidth = window.getComputedStyle(resizeComponent, null).getPropertyValue('min-width'),
        width  = resizeComponent.style.width
        resizeComponent.style.width = minWidth == '0px' ? '50px' : minWidth;
        minWidth = resizeComponent.offsetWidth + 'px'
        resizeComponent.style.width = width
        this.setData(arg, minWidth)     
    },
    arrayFrom : function(nodeList){
        var arrayList = [];
        for(var i = 0; i < nodeList.length; i++)
            {
                arrayList.push(nodeList[i]);
            }
        return arrayList.slice();   
     },

    closestFind : function(path, query){
            var elements = this.arrayFrom.call(this, document.querySelectorAll(query));
            for(var i = 0; i < path.length; i++)
                {
                    if( Array.prototype.indexOf.call( elements, path[ i ] ) != -1 ) {
                        return path[ i ];
                    }
                }
            return null;    
        },
     elementsFromPointCal : function(x, y){
        var arr = [], element = document.elementFromPoint(x, y);
        while(element != document && element != document.documentElement && element != document.body && element != this.$node)
            {
                element.style.pointerEvents = 'none';
                arr.push(element);
                element = document.elementFromPoint(x, y);
            }
        for(var i = 0; i < arr.length; i++)
            {
                arr[i].style.pointerEvents = 'initial';
            }
        return arr;     
    },
    setLeftDuringResize : function(offset,resizeComponent){
        var trList = this._originalTable.getElementsByTagName('lyte-exptable-tr');
        index = this.getIndex(resizeComponent)

        if( resizeComponent.classList.contains('lyteFixedColumn') ){
            for( var i = 0 ; i < trList.length; i++ ) {
                if( i == 0 ){
                    var thList = trList[ i ].getElementsByTagName('lyte-exptable-th') 
                    for( var j=index+1 ; j<thList.length ;j++){
                        if( thList[ j ].classList.contains( 'lyteFixedColumn' ) ){
                            thList[ j ].style.left = parseInt( thList[ j ].style.left ) + offset +"px"
                        }
                    }
                }
                else{
                    var tdList = trList[ i ].getElementsByTagName('lyte-exptable-td')
                     for( var j=index+1 ; j<tdList.length;j++){
                        if( tdList[j].classList.contains('lyteFixedColumn') ){
                            tdList[j].style.left = parseInt(tdList[j].style.left) + offset +"px"
                        }
                    }
                }
               
            }
        }
    },
 
    resizeFunc : function ( event ){
        var isTch = event.type == 'touchmove',
        evt = event;

        if( isTch && event.touches.length != 1 ){
            return;
        } else if( isTch ){
            evt = evt.touches[ 0 ];
        }

        var _this = document.Component,
        ww = window.innerWidth,
        resize = _this.resizeComponent,
        cx = _this.rtlfunc( 'clientX', evt, ww ),
        offset = cx - resize.offLeft,
        width = parseFloat( resize.style.width ),
        oriResize = _this._originalResizeHead,
        scrollLeft = _this._originalDiv.scrollLeft,
        tableWidth = _this.$node.getBoundingClientRect().width,
        j = 0, fakeIndex = -1,
        fixHeader, fakeFixHeader;

        if( !_this._isResizeMoved ){
            _this.hideRows( _this._thisBccr );
            _this._isResizeMoved = true;
        }
        if( !_this.data.ltPropStickyTable ){
            if( $L( oriResize ).hasClass( 'lyteFixedColumn' ) ){
                var index = _this.getIndex( oriResize ),
                sthList = _this._originalDiv.getElementsByTagName( 'lyte-exptable-th' ),
                fDiv = _this._colwrap || _this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ],
                fthList = fDiv.getElementsByTagName( 'lyte-exptable-th' ),
                len = sthList.length;

                _this._fixedDivWrap = _this._fixedDivWrap || _this.$node.getElementsByClassName( 'lyteExpTableFixedColHeader' ) [ 0 ];

                for( var i = 0 ; i < len ; i++ ){ // setting minWidth value for fakeOriginalHEader /* written by vidhya */

                    var current = sthList[ i ],
                    jobj = $L( current );

                    if( jobj.hasClass( 'lyteFixedColumn' ) ){
                        if( current == oriResize ){
                            fakeIndex = j;
                            fixHeader = fthList[ j ];
                            fakeFixHeader = _this._fixedDivWrap.getElementsByClassName( 'lyteFixedColumn' )[ j ];
                        } else {
                            j++;
                        }
                    }
                }
            }
        }

        if( resize.tagName == 'LYTE-EXPTABLE-TH' && offset ){
            var finalWidth = offset + width,
            // tableWidth = _this.data.tableWidth,
            currTableWidth,
            jobj = $L( resize ),
            fixed = !fixHeader || $L( fixHeader ).hasClass( 'lyteFixHeaderDisplayNone' ),
            isFixed = jobj.hasClass( 'lyteFixedColumn' ),
            minWidth1 = Math.ceil( parseFloat( _this.getData( 'minWidth1' ) ) ),
            minWidth2 = Math.ceil( parseFloat( _this.getData( 'minWidth2' ) ) );

            if( _this._originalTable ){
                currTableWidth = ( _this._originalTable.style.width ? parseFloat( _this._originalTable.style.width ) : _this._originalTable.getBoundingClientRect().width ) + offset;
            }
            if( (!_this._dir && offset<0 && event.clientX-resize.getBoundingClientRect().left < minWidth1 )||(_this._dir && resize.getBoundingClientRect().right-event.clientX <minWidth1)){
                return;
            }
            if( fixed && ( ( ( isFixed && ( _this._fixedSum + offset < tableWidth - 100 ) ) || !isFixed ) && finalWidth >= minWidth1 ) ){
                if( _this.oriTab ){
                    _this.oriTab.style.width = ( parseFloat( _this.oriTab.style.width ) + offset ) + 'px';
                }

                jobj.css( 'width', finalWidth + 'px' );

                if( _this.data.ltPropStickyTable ){
                    _this.setLeftDuringResize( offset, resize );
                }

                if( isFixed ){
                    _this._fixedSum += offset;
                }

                if( _this._dir ){
                    var ua = navigator.userAgent.toLowerCase(),
                    isChromium = !!window.chrome,
                    vendor = navigator.vendor,
                    isOpera = !!window.opr,
                    isIEedge = /edge/i.test( ua );

                    // if( /chrome/i.test( ua ) && isChromium && vendor == 'Google Inc.' && isOpera == false && isIEedge == false ){
                    //     _this._startScrollLeft += offset;

                    //     if( offset < 0 && ( _this._startScrollLeft - scrollLeft + _this._scrollWidth ) > _this._resizeScrollLeft ){
                    //         _this._oHeader.parentNode.style.transform = "translateX("+ ( _this._isIE ? scrollLeft * ( _this._dir ? 1 : -1 ) : ( _this._startScrollLeft - scrollLeft + _this._scrollWidth ) ) +"px)";
                    //     }
                    // }
                }

                $L( _this._originalTable ).css( 'width', currTableWidth );

                if( _this._fakeOriginalHeader ){
                    $L( _this._fakeOriginalHeader ).css( 'width', ( parseFloat( _this._fakeOriginalHeader.style.width || _this._originalTable.getBoundingClientRect().width ) + offset ) + 'px' );
                }

                $L( oriResize ).css( 'width', finalWidth );

                // if( fakeIndex != -1 ){
                //     $L( fixHeader ).css( 'width', finalWidth )
                // }

                if( fakeIndex != -1 ){
                    if( fixHeader ){
                        $L( fixHeader ).css( 'width', finalWidth );
                    }
                    if( fakeFixHeader ){
                        $L( fakeFixHeader ).css( 'width', finalWidth );
                    }
                }
            }
            if( cx > Math.max( _this.rtlfunc('left',_this._thisBccr, ww ), 0 )  && cx <  Math.min( _this.rtlfunc('right',_this._thisBccr, ww ), ww ) ){
                window.cancelAnimationFrame( _this._reqId );
                delete _this._reqId;
            }
            resize.offLeft = cx;
            if( oriResize ){
                oriResize.offLeft = cx;
            }
        }
        _this.horiScrollResize( evt, ww );
            
        event.preventDefault(); 
        event.stopPropagation();
    },
    mouseup : function(event){
        var isTch = event.type == 'touchend',component = document.Component, resizeComponent = component.resizeComponent,
        isMoved = false;
        delete document.Component; delete component.oriTab;

         if( component._resizeMeasure ){
            $L.fastdom.clear( component._resizeMeasure );
            delete component._resizeMeasure;
        }

        document.removeEventListener( isTch ? 'touchend' : 'mouseup' , component.mouseup);
        document.removeEventListener( isTch ? 'touchmove' : 'mousemove' , component.resizeFunc);
        // $L.fastdom.mutate( function(){
            resizeComponent.classList.remove( 'resizeSelect' )
            component.$node.classList.remove( 'lyteExpTableResizing' )
            // document.removeEventListener( isTch ? 'touchend' : 'mouseup' , component.mouseup)
            // document.removeEventListener( isTch ? 'touchmove' : 'mousemove' , component.resizeFunc)

            if( component._isResizeMoved ){
                $L( '.lyteExpTableHide', component.$node ).removeClass( 'lyteExpTableHide' );
                $L( 'lyte-exptable-tr.notModified', component.$node ).css( 'transform', '' ).removeClass( 'notModified' );
                delete component._isResizeMoved;
                if( !component.getData('ltPropStickyTable') ){
                    component.setFixTableRowHeight()
                }
                component._originalDiv.scrollTop = component._scrolltoMaintain;
                if(component._scrollLeftToSet){
                    component._originalDiv.scrollLeft = component._scrollLeftToSet;
                }
                isMoved = true;
            }
            if( component._tlayout != undefined ){
                var innTab = component.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ];
                innTab.style.tableLayout = component._tlayout;
                innTab.style.maxWidth = '';
                innTab.style.maxHeight = '';
                delete component._tlayout;
            }

            delete component._scrolltoMaintain; delete component._cellshidden; delete component._preventscroll;
            delete component._scrollLeftToSet;
            // $L.fastdom.mutate( function(){
                // component._originalDiv.scrollTop = component._scrolltoMaintain;

                // delete component._scrolltoMaintain; delete component._cellshidden;
                // component.fixHeaderHeight()
                if( component.getData( 'ltPropStickyTable' ) ){
                    component.setLeftForInterSection()
                }
                delete document.Component; delete component.oriTab; delete component._thisBccr;delete component._originalResizeHead;
                if( component.getMethods( 'onResizeEnd' ) ) {
                    // $L.fastdom.mutate( function(){
                        component.executeMethod( 'onResizeEnd', resizeComponent, component.$node )
                    // } )
                }
            // })
        window.cancelAnimationFrame( component._reqId );
        delete component._reqId;
        event.stopPropagation()
    },
    horiScrollResize : function( dummyDiv, ww ){
        var lt = this.rtlfunc.call( this, 'left' ), IE = this.isIE11Lyte || this.isEdgeLyte,
        isEvt, check1, check2;
        if( /mousemove|touchmove/i.test( dummyDiv.type ) ){
            isEvt = true;
        }
        if( isEvt ){
            if( this._reqId ){
                return;
            }
            check1 = this.rtlfunc.call( this, 'clientX', dummyDiv, ww ) > Math.min( this.rtlfunc.call( this, 'right', this._thisBccr, ww ), ww - 2 );
            check2 = this.rtlfunc.call( this, 'clientX', dummyDiv, ww ) <= Math.max( 0, this.rtlfunc( 'left', this._thisBccr, innerWidth ) );
        } else {
            check1 = ( parseFloat( dummyDiv.style[ lt ] ) - this._xxoff + parseFloat( dummyDiv.style.width ) ) >= this.rtlfunc( 'right', this._thisBccr, ww ) - 1;
            check2 = ( parseFloat( dummyDiv.style[ lt ] ) - this._xxoff + parseFloat( dummyDiv.style.width ) ) >= this.rtlfunc( 'right', this._thisBccr, ww ) - 1;
        }

        if( check1 /*&& ( !this.getData('ltPropStickyTable') || ( this.getData('ltPropStickyTable') && !this.resizeComponent.classList.contains('lyteTableFixed') ) )*/)  {
            this._originalDiv.scrollLeft += 2 * ( this._dir ? ( -1 * ( IE ? -1 : 1 ) ) : 1 )
            if( isEvt ){
                this.resizeComponent.offLeft -= 2;
                if(this._originalResizeHead){
                    this._originalResizeHead.offLeft -= 2;
                }
            }
            this._reqId = window.requestAnimationFrame( function(){
                delete this._reqId;
                delete this._scrollLeftToSet
                this.horiScrollResize( dummyDiv, ww )

                if( this._cellshidden ){
                    delete this._cellshidden;
                    window.requestAnimationFrame( function(){
                        this.$node && $L( 'lyte-exptable-tr.notModified .lyteExpTableHide', this.$node ).removeClass( 'lyteExpTableHide' );
                    }.bind( this ) )
                }

            }.bind( this ) )
        } else if( check2/* ( !this.getData('ltPropStickyTable') || ( this.getData('ltPropStickyTable') && !this.resizeComponent.classList.contains('lyteTableFixed') ) )*/ ) {
            if( isEvt ){
                this.resizeComponent.offLeft += 2;
                if(this._originalResizeHead){
                    this._originalResizeHead.offLeft += 2;
                }

            }
            this._originalDiv.scrollLeft -= 2 * ( this._dir ? ( -1 * ( IE ? -1 : 1 ) ) : 1 )
            this._reqId = window.requestAnimationFrame( function(){
                delete this._reqId;
                delete this._scrollLeftToSet
                this.horiScrollResize( dummyDiv, ww );
            }.bind( this ) )
        } else {
            window.cancelAnimationFrame( this._reqId );
            delete this._prevent;
        }
    },

    setWidthForOriginalHeader : function(){
            this._originalTable = this._originalTable || this.$node.getElementsByClassName('lyteExpOriginalTable')[ 0 ]
            var thList = Array.from( this._originalTable.getElementsByTagName('lyte-exptable-th') ),
            arr = [];

            thList.forEach( function( item ){
                arr.push( item.getBoundingClientRect().width + 'px' );
            } )

            thList.forEach( function( item, index ){
                item.style.width = arr[ index ];
            } )

            // for( var i = 0 ; i < thList.length ; i++ ){
            //     thList[i].style.width = thList[i].getBoundingClientRect().width + 'px'
            // }
        },
    actions :{
        scroll : function(event,scrollLeft,scrollTop, ignore ){
            if(this.getData('ltPropStickyTable')){
                // if( this._FF ){
                //     clearTimeout( this._scrollpointer );
                //     this.$node.classList.add( 'lyteExpScrollPointer' );
                //     this._scrollpointer = setTimeout( function(){
                //         this.$node.classList.remove( 'lyteExpScrollPointer' );
                //     }.bind( this ), 150 ); 
                // }
                this.stickyScroll(event)
                return
            }
         
            if( ( this._elem && event && event.type == 'scroll' ) || this._preventscroll ){
                return;
            }
            delete this._scrolled; 

            // if(this._scrolltriggered){
            //     delete this._scrolltriggered
            //     return;
            // }
            // $L.fastdom.measure( function(){
               var scrollDiv=this._originalDiv,scrollTop= this._elem ? this.prevScollTop : ( scrollTop || scrollDiv.scrollTop ),scrollLeft = this._elem ? this._originalDiv._sL : (scrollLeft || scrollDiv.scrollLeft ),
               scrollWidth = this._elem ? this._sw : scrollDiv.scrollWidth, offsetWidth = this._elem ? this._thisBccr.width : scrollDiv.offsetWidth;
               
                if((scrollTop!=this.prevScollTop) || ( ignore && !this._elem ) ){
                    $L.fastdom.mutate(function(){
                        if(this.getData('ltPropFixedTableScroll')){
                            var div= this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ]
                            div.scrollTop=scrollTop
                        }
                     }.bind(this))
                    // scrollLeft=this._dir?this._startScrollLeft-scrollLeft: -scrollLeft
                    this.verticalScroll(scrollLeft,true)
                    this.prevScollTop=scrollTop
                    this._parentScroll=true;
                }
                 if( scrollLeft!=this._prevScollLeft || ignore ){
                    this.scrollF(scrollTop,scrollLeft, ignore );
                    this._prevScollLeft=scrollLeft;
                    var value = this.returntrans( scrollLeft, offsetWidth, scrollWidth );
                    
                    if( this._elem ){
                        if(!this.getData('ltPropPreventWidth')){
                            this._FF && this.fixHeaderHeight();
                        }
                        else{
                            this.setFixedTableWidth()
                        }
                    } else {
                        if(!this.getData('ltPropPreventWidth')){
                            this.fixHeaderHeight();
                        }
                        else{
                            this.setFixedTableWidth()
                        }
                    
                    }
                    $L.fastdom.mutate(function(){
                       this._oHeader.parentNode.style.transform="translateX("+ value +"px)";
                    }.bind(this))
                    // event.preventDefault();
                }
            // }.bind( this ) )
            
        },
        
        tableResize : function( event ){
                var isTch = event.type == 'touchstart',
                evt = event;

                if( this._resizeMeasure ){  
                    return; 
                }

                if( isTch ){
                    if( evt.touches.length > 1 ) {
                        return;
                    }
                    evt = evt.touches[ 0 ];
                }

                var cell = evt.target.parentNode,
                // prevSibling = cell.previousElementSibling,
                // next = cell.nextElementSibling,
                wwidth = window.innerWidth
                // bcr = resizeComponent.getBoundingClientRect(),
                // nbcr = next ? next.getBoundingClientRect() : {},
                if( !this.getData('ltPropStickyTable') ){
                    fakeOriginalHeader = this._oHeader.getElementsByTagName( 'lyte-exptable-th' );
                    index = this.getIndexFromFake( cell )
                    nextIndex = this.getIndexFromFake( cell.nextElementSibling )
                }
                else{
                    index = this.getIndex( cell )
                    nextIndex = this.getIndex( cell.nextElementSibling )
                }
                var originalheaderList = this._originalDiv.getElementsByTagName( 'lyte-exptable-th' ),
                fakeOriginalHeader,
                arr = [],
                tabWid,
                dummyWid,
                innTab = this.$node.getElementsByClassName( 'lyteExpOriginalTable' )[ 0 ],
                index,nextIndex,
                maxWidth = innTab.style.maxWidth,
                maxHeight = innTab.style.maxHeight,
                resizeComponent = originalheaderList[ index ],
                next = originalheaderList[ nextIndex ],
                bcr = cell.getBoundingClientRect(),
                nextBcr = next ? next.getBoundingClientRect() : {},
                table = $L( resizeComponent ).closest( 'lyte-exptable' ).get( 0 ),
                isFixed = window.getComputedStyle( table ).tableLayout == 'fixed',
                style1 = window.getComputedStyle( resizeComponent ),
                style2 = next ? window.getComputedStyle( next ) : {},
                sL = this._originalDiv.scrollLeft,
                innTableWidth = this.getData('ltPropStickyTable') && innTab.style.width == "" ? innTab.getBoundingClientRect().width : void 0;
                
                if( index >= 0 ){
                    this._originalResizeHead = originalheaderList[ index ];
                }
                if( nextIndex >= 0 ){
                    this._originalNextResize = originalheaderList[ nextIndex ];
                }

                document.Component = this;
                this.resizeComponent = cell;
                this.targetElem = evt.target;

                this._preventscroll = true;

                this._thisBccr = this.$node.getBoundingClientRect();

                if( this.getMethods( 'onResizeSelect' ) ){
                    this.executeMethod( 'onResizeSelect', cell, event, this.$node );
                }

                if( this.getData('ltPropStickyTable') && resizeComponent.style.width =="" ){
                    this.setWidthForOriginalHeader()
                }
                if( innTableWidth ){
                    innTab.style.width = innTableWidth + "px";
                }

                var /*visible = this.hideRows( this._thisBccr ),*/
                layout = innTab.style.tableLayout;

                cell.offLeft = bcr.width + this.rtlfunc.call( this, 'left', bcr, wwidth )
                cell.offTop = evt.clientY;

                this._tlayout = layout;

                innTab.style.tableLayout = 'auto'
                innTab.style.maxWidth = 0;
                innTab.style.maxHeight = 0;

                this._resizeMeasure = $L.fastdom.measure( function(){
                    var minWidth1 = resizeComponent.getBoundingClientRect(),
                    minWidth2 = next ? next.getBoundingClientRect() : { width : Infinity };
                    // cellsToHide = this.cellsToHide( visible, this._thisBccr, minWidth1.width, bcr.width, wwidth );
                    delete this._resizeMeasure;

                    $L.fastdom.mutate( function(){
                        cell.classList.add( 'resizeSelect' );
                        this.$node.classList.add( 'lyteExpTableResizing' );
                        this.data.minWidth1 = Math.min( minWidth1.width, bcr.width );
                        this.data.minWidth2 = Math.min( minWidth2.width, nextBcr.width || 0 );

                        if( isFixed ){
                            var min1 = ( style1.minWidth || '' ).indexOf( 'px' ) != -1 ? parseFloat( style1.minWidth ) : NaN,
                            min2 = ( style2.minWidth || '' ).indexOf( 'px' ) != -1 ? parseFloat( style2.minWidth ) : NaN;

                            if( !isNaN( min1 ) ){
                                if( isFixed ){
                                    this.data.minWidth1 = min1;
                                } else {
                                    this.data.minWidth1 = Math.max( this.data.minWidth1, min1 );
                                }
                            }

                            if( !isNaN( min2 ) ){
                                if( isFixed ){
                                    this.data.minWidth2 = min2;
                                } else {
                                    this.data.minWidth2 = Math.max( this.data.minWidth2, min2 );
                                }
                            }
                        }

                        innTab.style.maxWidth = maxWidth;
                        innTab.style.maxHeight = maxHeight;

                        // cellsToHide.forEach(function(item){
                        //     item.classList.add('lyteExpTableHide');
                        // })

                        // this._cellshidden = true;

                        innTab.style.tableLayout = layout;
                        document.addEventListener( isTch ? 'touchmove' : 'mousemove' ,this.resizeFunc )

                        delete this._preventscroll; delete this._tlayout;

                        this._originalDiv.scrollLeft = sL;

                    }, this)

                }, this )

                document.addEventListener( isTch ? 'touchend' : 'mouseup' ,this.mouseup );

                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
        },

        fixedColScroll : function( evt ){
            this.fixedScroll( evt );
            return false;
        },

        fixedColWheel : function( evt ){
            var isTch = evt.type == 'touchmove';
            if( isTch && evt.touches.length > 1 ){
                return;
            }
            var value = isTch ? this.getTouch( evt.touches[ 0 ] ) : this.getWheel( evt );
            if( value ){
                var div = this._originalDiv,
                scrollLeft = div.scrollLeft,
                scrollWidth = div.scrollWidth,
                offsetWidth = div.clientWidth;

                value = this.toPrevent( scrollLeft, scrollWidth, offsetWidth, value );

                if( value ){
                    div.scrollLeft = scrollLeft + value;
                    evt.preventDefault();
                }
            }
            return false;
        }
    },

    toPrevent : function( scrollLeft, scrollWidth, offsetWidth, value ){
        var max = scrollWidth - offsetWidth,
        min = 0,
        newValue = scrollLeft + value;
        if( this._dir ){
            if( this._FF || ( this._isSafari && !this._chrome ) ){
                max = 0;
                min = offsetWidth - scrollWidth;
            }
        } 

        value = Math.max( Math.min( max, newValue ), min ) - scrollLeft;
        return value;
    },

    getTouch : function( evt ){
        if( !this._touchend ){
            this._touchend = this.touchend.bind( this );
            document.addEventListener( 'touchend', this._touchend, true );
        }

        var clientX = evt.clientX, 
        clientY = evt.clientY,
        prevX = this._prevTouchX == undefined ? clientX : this._prevTouchX,
        prevY = this._prevTouchY == undefined ? clientY : this._prevTouchY,
        x = prevX - clientX,
        y = prevY - clientY;

        this._prevTouchX = clientX;
        this._prevTouchY = clientY;

        if( Math.abs( x ) >= Math.abs( y ) ){
            return x;
        }
    },

    touchend : function(){
        document.removeEventListener( 'touchend', this._touchend, true );
        delete this._touchend;
        delete this._prevTouchX;
        delete this._prevTouchY;
    },

    getWheel : function( evt ){
        var delta = evt.deltaMode && evt.deltaMode == 1,
        x = 0,
        fact = 1;

        if( Math.abs( evt.deltaX || 0 ) >= Math.abs( evt.deltaY || 0 ) ) {
           x = delta ? ( evt.deltaX * 6 ) :  evt.deltaX
           if( /edge|trident|msie/i.test(  navigator.userAgent ) && this._dir ){
              fact = -1;
           }
           return x * fact;
        }
   },

    // getCellBcrs : function( visible ){
    //     var arr = [];
    //     visible.forEach( function( row ){
    //         var cells = Array.from( row.children );
    //         cells.forEach( function( td ){
    //             var bcr = td.getBoundingClientRect()
    //             arr.push( { cell : td, bcr : bcr } );
    //         })
    //     } )
    //     return arr;
    // },

    // cellsToHide : function( visible, bcr, minwidth, currentWidth, wwidth ){
    //     var width = Math.min( this.rtlfunc( 'right', bcr, wwidth ), wwidth ) + currentWidth - minwidth + 20,
    //     arr = [];

    //     visible.forEach( function( item ){
    //         var _bcr = item.bcr, 
    //         cell = item.cell;
            
    //         if( this.rtlfunc( 'left', _bcr, wwidth ) > width ){
    //             arr.push( cell );
    //         }
    //     }.bind( this ) )

    //     return arr;
    // },
    hideRows : function( bcr ){
        // return;
        var fakeRows,
        originalRows = Array.from( this._originalDiv.getElementsByTagName( 'lyte-exptable-tr' ) ),
        topRows = [],
        scrolltoMaintain = this._originalDiv.scrollTop,
        scrollToSet = 0,
        tValue = Math.max( bcr.top + originalRows[ 0 ].getBoundingClientRect().height , -10 ),
        bValue = Math.min( window.innerHeight + 10, bcr.bottom ),
        visible = [],
        remain,
        toReturn,
        isSticky = this.getData( 'ltPropStickyTable' );

        this._scrollLeftToSet = this._originalDiv.scrollLeft;

        if( !isSticky ){
             fakerows = Array.from( ( this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ] ).getElementsByTagName( 'lyte-exptable-tr' ) )
        }
        for( var i = 1; i < originalRows.length; i++ ){
            var row = originalRows[ i ],
            _bcr = row.getBoundingClientRect();
            if( _bcr.bottom < tValue ){
                topRows.push( row );
                if( !isSticky ){
                    topRows.push( fakerows[ i ] );
                }
                scrollToSet += _bcr.height;
                // lastBcr = _bcr;
            } else if( _bcr.top > bValue ){
                Lyte.arrayUtils( visible, 'push', originalRows.slice( i, i + 10 ) );
                Lyte.arrayUtils( topRows, 'push', originalRows.splice( i + 10 ) );
                if( !isSticky ){
                    Lyte.arrayUtils( visible, 'push', fakerows.slice( i, i + 10 ) );
                    Lyte.arrayUtils( topRows, 'push', fakerows.splice( i + 10 ) );
                }
                break;
            } else {
                visible.push( row );
                if( !isSticky ){
                    visible.push( fakerows[ i ] );
                }
            }
        }

        
        toReturn = /*this.getCellBcrs( visible ) ||*/ [] ;
        remain = scrolltoMaintain - scrollToSet;

        this._originalDiv.scrollTop = 0;

        topRows.forEach( function( item ){
           item.classList.add( 'lyteExpTableHide' );
        } );

        visible.forEach( function( item ){
            item.classList.add( 'notModified' );
            item.style.transform = 'translateY(-' + remain + 'px)';
        })

        this._scrolltoMaintain = scrolltoMaintain;

        return toReturn;
    },

    returntrans : function( scrollLeft, offsetWidth, scrollWidth ){
        var value;
        if( this._isIE ){
            value = scrollLeft * ( this._dir ? 1 : -1 );
        } else {
            if( this._dir ){
                if( this._chrome && !this._isNegative ){
                    value = scrollWidth - offsetWidth - scrollLeft +this._verticalScrollWidth;
                } else {
                    value = this._startScrollLeft - scrollLeft
                }
            } else {
                value = -scrollLeft;
            }
        }
        return value;
    },


    bindingEvts : function( arg ){
        var sortable = this.data.ltPropColumnSortable;

        if( !sortable && !arg ){
            return;
        }

        var is_sticky = this.data.ltPropStickyTable,
        header = this._headerDiv || this.$node.getElementsByClassName( is_sticky ? 'lyteExpTableHeaderGroup' : 'lyteExpTableFakeHeaderWrapper' )[ 0 ],
        add = "add",
        listener = "EventListener";

        if( header ){
            if( this._sortmousedown ){
                add = "remove";
            } else{
                if( sortable ){
                    this._sortmousedown = this.sortablemousedown.bind( this );
                } else{
                    return;
                }
            }

           [ 'mousedown', 'touchstart' ].forEach( function( item ){
                header[ add + listener ]( item, this._sortmousedown, true );
           }.bind( this ));

           $L( this.$node )[ add + 'Class' ]( 'lyteExpTableColumnSortable' );

           if( add == "remove" ){
                delete this._sortmousedown;
           }
        }
    }.observes( 'ltPropColumnSortable' ).on( 'didConnect' ),

    sortablemousedown : function( ev ){
        var evt = ev,
        isTch;

        if( /lyte-exptablehead-resize/i.test( ev.target.tagName ) || ev.button != 0 ){
            return
        }

        if( /touch/i.test( ev.type ) ){
            if( ev.touches.length > 1 ){
                return;
            }
            isTch = true;
            evt = ev.touches[ 0 ];
        }
        var target = evt.target,
        td = $L( target ).closest( 'lyte-exptable-th' ).get( 0 ),
        index = Array.apply( Array, td.parentNode.children ).indexOf( td ),
        is_sticky = this.data.ltPropStickyTable,
        getBoundingClientRect = "getBoundingClientRect";

        if( this._fixHeaderCount > index ){
            return;
        }

        if( is_sticky && $L( td ).hasClass( 'lyteTableFixed' ) ){
            return;
        }

        if( this.getMethods( 'onBeforeSelect' ) && this.executeMethod( 'onBeforeSelect', ev, td, index, this.$node ) == false ){
            return;
        }

        this._ww = window.innerWidth;
        var clientX = this.rtlfunc( 'clientX', evt, this._ww ),
        bcr = td[ getBoundingClientRect ](),
        offleft = 0,
        tbody = this._originalTable.getElementsByClassName( 'lyteExpTableRowGroup' )[ 0 ],
        cells = [],
        rows = tbody.children,
        originalCell = tbody.previousElementSibling.children[ 0 ].children[ index ];
        this._xoff = clientX - this.rtlfunc( 'right', bcr, this._ww );

        this._colwrap = this._colwrap || this.$node.getElementsByClassName( 'lyteExpTableFixedColWrapper' )[ 0 ];

        this._elem = td;
        this._index = index;
        this._sortmousemove = this.sortmousemove.bind( this );
        this._sortmouseup = this.sortmouseup.bind( this );
        this._currentIndex = index;
        this._tbody = tbody;
        this._cells = cells;
        this._affectedIndex = [];
        this._thisBccr = this._originalDiv[ getBoundingClientRect ]();
        this._sw = this._originalDiv.scrollWidth;

        this._prevx = clientX;

        this._originalDiv._sL = this._originalDiv.scrollLeft;

        if( is_sticky ){
            var obj = {
                width : this._fixedWidth
            },
            __left = this.rtlfunc( 'left' ),
            __right = this.rtlfunc( 'right' );

            obj[ __left ] = this._thisBccr[ __left ];

            if( __left == "left" ){
                obj.right = obj.width + obj.left;
            } else{
                obj.left = obj.right - obj.width;
            }

            this._colwrapbcr = obj;
        } else{
            this._colwrapbcr = this._colwrap[ getBoundingClientRect ]();
        }

        var parentChild = td.parentNode.children,
        firstbcr = parentChild[ 0 ][ getBoundingClientRect ]();

        for( var i = 0; i < parentChild.length; i++ ){
            var cur = parentChild[ i ],
            prev = ( parentChild[ i - 1 ] || {} )._bcr; 
            if( i == 0 ){
                cur._bcr = { left : firstbcr.left, right : firstbcr.right, width : firstbcr.width };
            } else if( this.data.ltPropStickyTable ){
                var __bcr = cur.getBoundingClientRect();
                cur._bcr = { left : __bcr.left, right : __bcr.right, width : __bcr.width };
            } else {
                var wid = parseFloat( cur.style.width );

                if( isNaN( wid ) ){
                    wid = cur[ getBoundingClientRect ]().width;
                }

                if( this._dir ){
                    cur._bcr = { left : prev.left - wid, right : prev.left, width : wid };
                } else {
                    cur._bcr = { left : prev.right, right : prev.right + wid, width : wid };
                }
            }
        }
        if( !this.data.ltPropPreventTableModify ){
            if( !this.data.ltPropHeaderOnly ){
                var height = 0;
                for( var i = 0; i < rows.length; i++ ){
                    var __current = rows[ i ].children[ index ];
                    __current._translate = 0;
                    cells.push( __current );
                    __current._transformedindex = index;
                    var rowbcr = __current[ getBoundingClientRect ]().height;
                    __current.classList.add( 'lyteExpSortSelected' );
                    height += rowbcr;
                    if( height >= this._thisBccr.height ){
                        break;
                    }
                }
            }
            cells.push( originalCell )
            originalCell._translate = 0;
            originalCell._transformedindex = index;
            if( !is_sticky ){
                td._translate = offleft;
                cells.push( td );
                td._transformedindex = index;
            }
        } else {
            td._transformedindex = index;
        }

        document.addEventListener( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );
        document.addEventListener( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );
        this.$node.classList.add( 'lyteTableSortSelected' );
        td.classList.add( 'lyteExpSortSelected' );
        ev.preventDefault();

        this.getMethods( 'onSelect' ) && this.executeMethod( 'onSelect', ev, td, index, this.$node );
    },

    getTd : function( td, inc, pos ){
        var children = td.parentNode.children,
        newtd, transindex = td._transformedindex;

        if( inc > 0 || ( inc == 0 && pos ) ){
            if( this._index <= transindex ){
                newtd = children[ transindex + 1 ];
            } else{
                newtd = children[ transindex ];
            }
        } else if( inc < 0 || ( inc == 0 && pos == false ) ) {
            if( this._index < transindex ){
                newtd = children[ transindex ];
            } else {
                newtd = children[ transindex - 1 ];
            }
        }

        return newtd;

    },

    findFormClosest : function( evt ){
        var closest=$L(evt.target).closest('.lyteExpTableFakeColHeader lyte-exptable-th,.lyteExpOriginalTable lyte-exptable-td').get(0);
        if( closest && /lyte-exptable-td/i.test( closest.tagName ) ){
            var index = Array.apply( Array, closest.parentNode.children ).indexOf( closest );
            closest = this._elem.parentNode.children[ index ];
        }
        return closest;
    },

    sortmousemove : function( ev, allow, pos ){
        if( this._preventmove || !this._elem || this._movemutate || this._movemeasure ){
            return;
        }
        var evt = ev,
        clientX = this.rtlfunc( 'clientX', evt, this._ww ),
        td = this._elem,
        tbody = this._tbody,
        cells = this._cells,
        xoff = this._xoff,
        prevtable = this.data.ltPropPreventTableModify;

        if( /touch/i.test( ev.type ) ){
            if( ev.touches.length > 1 ){
                return;
            }
            evt = ev.touches[ 0 ];
        }

        if( prevtable && !this._moved ){
            var div = document.createElement( 'div' ),
            bcr = td.getBoundingClientRect(),
            xscroll = document.documentElement.scrollLeft,
            yscroll = document.documentElement.scrollTop;
            div.innerHTML = td.innerHTML;
            $L( div ).attr( 'style', $L( td ).attr( 'style' ) ).addClass( this.data.ltPropSortDummyColumClass, 'lyteExpTableDummyColumn' );
            $L( td ).data( 'sortElement', div );
            $L( div ).data( 'relatedElement', td );
            div.style.height = bcr.height + 'px';
            div.style.width = bcr.width + 'px';
            div.style.left = ( xscroll * ( this._dir ? -1 : 1 ) ) + 'px';
            div.style.top = yscroll + 'px';
            div._bcr = { left : bcr.left, right : bcr.right, width : bcr.width };
            div._translate = div._bcr.left;
            div._translateY = bcr.top;
            div.style.transform = 'translate(' + div._translate + 'px,' + div._translateY + 'px)';
            document.body.appendChild( div );
            this._moved = true;
            return;
        }

        if( this._prevx == evt.clientX && !allow ){
            return;
        }

        if( this.getMethods( 'onBeforeMove' ) && this.executeMethod( 'onBeforeMove',  ev, td, this._index, td._transformedindex, this.$node ) == false ){
            return;
        }
        this._prevx = evt.clientX;

        var div = $L( td ).data( 'sortElement' ) || {},
        bcr = div._bcr || td._bcr || td.getBoundingClientRect(),
        inc = ( clientX - this.rtlfunc( 'right', bcr, this._ww ) - xoff ),
        closestTd = prevtable ? this.findFormClosest( evt ) : this.getTd( td, inc, pos ),
        closestbcr = closestTd ? ( closestTd._bcr || closestTd.getBoundingClientRect() ) : {},
        newone,
        index,
        sL = this._originalDiv._sL,
        fact = this._dir ? -1 : 1,
        interchangeprevent,
        offLeft = 0;

        if( sL == void 0 ){
            sL = this._originalDiv.scrollLeft;
        }

        if( td == closestTd && !div ){
            closestTd = undefined;
        }

        if( this.data.ltPropStickyTable && closestTd && $L( closestTd ).hasClass( 'lyteTableFixed' ) ){
            closestTd = void 0;
        }

        if( closestTd && this._moved ){
            index = Array.apply( Array, closestTd.parentNode.children ).indexOf( closestTd );
            if( index != this._index || prevtable ){
                var allow,
                transindex = closestTd._transformedindex == undefined ? index : closestTd._transformedindex;
                if( div && td == closestTd ){
                    transindex = index;
                }
                if( inc > 0 || ( inc == 0 && pos ) ){
                    if( this.rtlfunc( 'right', bcr, this._ww ) + inc > this.rtlfunc( 'left', closestbcr, this._ww ) + closestbcr.width * 0.5 ){
                        allow = transindex > td._transformedindex;
                    }
                } else if( inc < 0 || ( inc == 0 && pos == false ) ) {
                    if( this.rtlfunc( 'left', bcr, this._ww ) + inc <  this.rtlfunc( 'left', closestbcr, this._ww ) + closestbcr.width * 0.5 ){
                        allow = transindex < td._transformedindex;
                    }
                }

                if( allow ){
                    if( !prevtable ){
                        newone = this._affectedIndex.indexOf( index ) == -1;
                        if( newone ){
                            offLeft = this._isIE ? closestTd.offsetLeft : 0;
                            this._affectedIndex.push( index );
                        }
                    }
                } else {
                    closestTd = undefined;
                }
            }
        } else {
            closestTd = undefined;
        }

        if( closestTd && this.getMethods( 'onBeforeInterChange' ) ){
            interchangeprevent = this.executeMethod( 'onBeforeInterChange', ev, td, closestTd, this.$node ) == false;
            if( interchangeprevent && newone ){
                Lyte.arrayUtils( this._affectedIndex, 'removeAt', this._affectedIndex.indexOf( index ) );
            }
        }
        if( prevtable ){
            div._translate += ( inc * fact );
            div.style.transform = 'translate( ' + div._translate + 'px,' + div._translateY + 'px)';
            if( closestTd && !interchangeprevent ){
                if( closestTd != td ){
                   if( inc < 0 || ( inc == 0 && pos == false ) ){
                     td._transformedindex--;
                   } else {
                     td._transformedindex++;
                   } 
                }
            }
        } else {
            for( var i = 0; i < cells.length; i++ ){
                var current = cells[ i ];
                current._translate += ( inc * fact );
                current.style.transform = "translateX(" +  current._translate + "px)";
                if( !this._moved ){
                    current.classList.add( 'lyteExpTablePe' );
                }
                if( closestTd && !interchangeprevent ){
                    var newcell = cells[ i ].parentNode.children[ index ];
                    if( newone ){
                        newcell.classList.add( 'lyteExpTableAnimate' );
                        newcell._translate = 0;
                    }
                    newcell._translate += ( bcr.width * ( ( inc > 0 || ( inc == 0 && pos ) ) ? -1 : 1 ) * fact );
                    newcell.style.transform = "translateX(" +  newcell._translate + "px)";

                    if( newcell._transformedindex == undefined ){
                        newcell._transformedindex = index;
                    }
                    if( inc < 0 || ( inc == 0 && pos == false ) ){
                        newcell._transformedindex++;
                        current._transformedindex--;
                    } else if( inc > 0 || ( inc == 0 && pos ) ) {
                        newcell._transformedindex--;
                        current._transformedindex++;
                    }
                }
            }
        }

        if( div._bcr ){
            div._bcr.left += ( inc * fact );
            div._bcr.right += ( inc * fact );
        } else {
            td._bcr.left += ( inc * fact );
            td._bcr.right += ( inc * fact );
            if( closestTd && !interchangeprevent ){
                closestTd._bcr.left += ( bcr.width * ( ( inc > 0 || ( inc == 0 && pos ) ) ? -1 : 1 ) * fact );
                closestTd._bcr.right += ( bcr.width * ( ( inc > 0 || ( inc == 0 && pos ) ) ? -1 : 1 ) * fact );
            }
        }
        
        $L.fastdom.clear( this._reqId );
        $L.fastdom.clear( this._measure );
        delete this._measure;
        delete this._reqId;

        this.sorthorizontalscroll( { left : bcr.left/* + inc * fact*/, width : bcr.width, right :  bcr.right/* + bcr.left + inc * fact*/ }, sL );

        closestTd && this.getMethods( 'onInterChange' ) && this.executeMethod( 'onInterChange', ev, td, closestTd, this.$node );

        this.getMethods( 'onMove' ) && this.executeMethod( 'onMove', ev, td, this._index, td._transformedindex, this.$node );

        this._moved = true;
    },

    sorthorizontalscroll : function( bcr, sL ){
         var lt = this.rtlfunc.call( this, 'left' ), IE = this.isIE11Lyte || this.isEdgeLyte, check1, check2,
         td = this._elem;


         check1 = this.rtlfunc( 'left', bcr, this._ww ) < Math.max( this.rtlfunc( 'right', this._colwrapbcr, this._ww ), 0 );
         check2 = ( this.rtlfunc( 'left', bcr, this._ww ) + bcr.width ) > Math.min( this.rtlfunc( 'right', this._thisBccr, this._ww ), this._ww );

         if( ( this._FF || this._isIE ) && check2 ){
            if( td._transformedindex == td.parentNode.children.length - 1 ) {
                if( this._dir && !this._isIE ){
                    if( this._sw + sL + this._verticalScrollWidth <= this._thisBccr.width ){
                        return;
                    }
                } else if( sL + this._thisBccr.width >= this._sw ){
                    return;
                }
            }
         }

         var value;

         if( check1 ){
            value = sL - this.data.ltPropScrollStep * ( this._dir ? ( -1 * ( IE ? -1 : 1 ) ) : 1 );
            if( this._dir ){
                if( this._chrome ){
                    value = Math.min( value, this._sw - this._thisBccr.width );
                } else if( this._FF || this._isSafari ){
                    value = Math.min( value, 0 );
                }
            } else {
                value = Math.max( value, 0 );
            }
         } else if( check2 ){
            value = sL + this.data.ltPropScrollStep * ( this._dir ? ( -1 * ( IE ? -1 : 1 ) ) : 1 );
            if( this._dir ){
                if( this._chrome ){
                    value = Math.max( value, 0 );
                } else if( this._FF || this._isSafari ){
                    value = Math.max( value, this._thisBccr.width - this._sw );
                } else {
                    value = Math.min( value, this._sw - this._thisBccr.width ); 
                }
            } else {
                value = Math.min( value, this._sw - this._thisBccr.width );
            }
         } else {
            $L.fastdom.clear( this._reqId );
            $L.fastdom.clear( this._measure );
            delete this._measure;
            delete this._reqId;
         }

         if( check1 || check2 ){
            this._originalDiv.scrollLeft = value;
            this._originalDiv._sL += ( value - sL );
            var parentChild = this._elem.parentNode.children,
            is_sticky = this.data.ltPropStickyTable;

            for( var i = 0; i < parentChild.length; i++ ){
                var cur = parentChild[ i ];

                if( is_sticky && $L( cur ).hasClass( 'lyteTableFixed' ) ){
                    continue;
                } 

                cur._bcr.left -= ( value - sL );
                cur._bcr.right -= ( value - sL );
            }

            this._measure = $L.fastdom.measure( function(){
                delete this._measure;
                this.actions.scroll.call( this );
                this._reqId = $L.fastdom.mutate( function(){
                    delete this._reqId;
                    this.sortmousemove( { clientX : this._prevx }, true, !!check2 );
                }.bind( this ) )
            }.bind( this ) )
         }

    },

    sortmouseup : function( evt ){
        var index = this._index,
        td = this._elem,
        newindex = td._transformedindex,
        isTch = /touch/i.test( evt.type );

        if( this._moved ){
            var failed;
            if( this.getMethods( 'onBeforeDrop' ) && this.executeMethod( 'onBeforeDrop', evt, td, index, newindex, this.$node ) == false ){
                failed = true;
            }
            this.resetcells();
            if( !failed ){
                if( index != newindex ){
                    this._prevent = true;
                    var header = this.data.ltPropHeader,
                    current = Lyte.arrayUtils( header, 'removeAt', index );
                    delete this._prevent;
                    Lyte.arrayUtils( header, 'insertAt', newindex, current );
                }
                this.getMethods( 'onDrop' ) && this.executeMethod( 'onDrop', evt, td, index, newindex, this.$node );
            }
        } else {
            this.resetcells();
            this.getMethods( 'onRelease' ) && this.executeMethod( 'onRelease', evt, td, this.$node );
        }

        document.removeEventListener( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );
        document.removeEventListener( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );

        $L.fastdom.clear( this._reqId );
        $L.fastdom.clear( this._measure );
        delete this._measure;
        delete this._reqId;

        delete this._sortmouseup; delete this._sortmousemove; delete this._elem; delete this._xoff; 
        delete this._index; delete this._moved; delete this._affectedIndex; delete this._tbody;
        delete this._cells; delete this._prevx; delete this._thisBccr; delete this._ww; delete this._sw;
        delete this._colwrapbcr;

        this.$node.classList.remove( 'lyteTableSortSelected' );

        this.$node.scrollTo();
    },

    fixcolobs : function(){
        if( this._elem ){
            this._preventmove = true;
            $L.fastdom.measure( function(){
                this._colwrapbcr = this._colwrap.getBoundingClientRect();
                $L.fastdom.mutate( function(){
                    delete this._preventmove;
                }.bind( this ) )
            }.bind( this ) );
        }
    }.observes( 'columns.[]' ),

    resetcells : function( cells ){
        var affected = this._affectedIndex,
        cells = this._cells;
        $L( this._fakeOriginalHeader ).css( 'height', '' );
        if( this.data.ltPropPreventTableModify ){
            this._elem._transformedindex;
            this._elem._translate;
            var div = $L( this._elem ).data( 'sortElement' );
            div && div.remove();
            $L( this._elem ).data( 'sortElement', undefined );
        } else {
            for( var i = 0; i < cells.length; i++ ){
                var current = cells[ i ],
                children = current.parentNode.children;
                
                current.style.transform = "";
                current.classList.remove( 'lyteExpSortSelected', 'lyteExpTablePe' );
                delete current._transformedindex;
                delete current._translate;
                for( var j = 0; j < affected.length; j++ ){
                    var newcell = children[ affected[ j ] ];
                    newcell.classList.remove( 'lyteExpTableAnimate', 'lyteExpTablePe' );
                    newcell.style.transform = "";
                    delete newcell._transformedindex;
                    delete newcell._translate;
                }
            }
        }
    },
    setLeftForInterSection : function( reset ){
        $L.fastdom.clear( this._setmeasure );

        this._setmeasure = $L.fastdom.measure( function()  {
            var headerCells = Array.from( this.getHeaderCells() );
            if( headerCells.length ){

                var width = this.getHeaderWidths( headerCells ),
                sum=0;
                
                $L.fastdom.mutate( function()  {

                    var accumulatedWidth = 0,
                    accumulatedLeft = 0,
                    tbody = this.getTbody(),
                    rows = Array.from( tbody.children ),
                    intersectionDivs = [],
                    left = this.rtlfunc( 'left' );

                    headerCells.forEach( function( cell, index )  {
                        var intersection = cell._horizontalIntersectionDiv;
                        if( intersection ){
                            intersectionDivs.push( intersection );
                            intersection.style[ left ] = accumulatedLeft + 'px';
                            cell.style[ left ] = accumulatedWidth + 'px';
                            sum += width[ index ]
                            this.makeFixedColumn( rows, index, left, accumulatedWidth );

                            accumulatedWidth += width[ index ];

                            this.observe( intersection );

                            if( intersection._sticked && reset ){
                                this.addFixedClass( cell );
                            }
                        } else {
                            accumulatedLeft +=  width[ index ];
                        }
                    }.bind(this) );

                    this._intersections = intersectionDivs;
                    this._fixedSum = sum
                }.bind(this) );
            }
        }.bind(this) );
    },
    getHeaderCells : function(){
        return this.$node.getElementsByClassName('lyteExpOriginalTable')[0].getElementsByTagName( 'lyte-exptable-th' );
    },
    getHeaderWidths : function( headerCells ){
        var width =[]
        headerCells.forEach(function(cells,index){
            width[index]=cells.getBoundingClientRect().width
        })
        return width
    },
    getTbody : function(){
        return this._tbody || this.$node.getElementsByClassName( 'lyteExpTableRowGroup' )[ 0 ];
    },
    makeFixedColumn : function( rows, index, left, value ){

        rows.forEach( function(row) {
            var _$L = $L( row );
            if( !_$L.hasClass( 'dummy' ) ) {
                _$L.children().eq( index ).css( left, value ).addClass( 'lyteFixedColumn' );
            }
        } )
    },
    observe : function( intersection ){
        if( !intersection._observed ){
            this._intersectionObs.observe( intersection );
            intersection._observed = true;
        }
    },
    addFixedClass : function( cell ){
        this.stickyFunction( cell, false, 'addClass', 'lyteTableFixed' );
    },
    stickyScroll : function( evt ){
        if( evt && evt.target == this._scrollDiv ){
            if( this._intersections.length  ){
                $L.fastdom.measure( function()  {
                    var scrollTop = evt.target.scrollTop;
                    $L.fastdom.mutate( function(){
                        this._intersections.forEach( function( item ){
                            item.style.top = scrollTop + 'px';
                        })
                    }.bind(this))
                }.bind(this))
            }
        }
    },
    registerInterSection : function( scrollDiv ){
         this._intersectionObs = new IntersectionObserver( this.intersection.bind( this ), { threshold : [ 1 ], root : scrollDiv } )
    },
    intersection: function( intersections ){
        
        intersections.forEach( function(intersection) {
            this.singleIntersection( intersection );
        }.bind(this) )
    },

    singleIntersection : function( intersection ){
        this._fixedWidth = this._fixedWidth || 0;
        var cell = intersection.target._cell;

        if( cell && intersection.intersectionRatio ){
            this.processUnfix( cell, intersection );
        } else if(cell){
            this.processFix( cell, intersection );
        }
    },

    processUnfix : function( cell, intersection ){
        this.removeFixedClass( cell );
        delete cell._horizontalIntersectionDiv._sticked;
        this.callUnfix( cell );

        $L.fastdom.measure( function() {
            var bcr = cell._bcr || cell.getBoundingClientRect();
            this._fixedWidth = Math.max( this._fixedWidth - bcr.width, 0 );
            this.adjust_wrap_width();
        }.bind(this) )
    },

    adjust_wrap_width : function(){
        var obj = this._colwrapbcr;

        if( obj && this.data.ltPropStickyTable ){
            var left = this.rtlfunc( 'left' ),
            width = this._fixedWidth;
            if( left == "left" ){
                obj.right = obj.left + width;
            } else{
                obj.left = obj.right - width;
            }
        }
    },

    processFix : function( cell, intersection ){
        this.addFixedClass( cell );
        cell._horizontalIntersectionDiv._sticked = true;
        this.callFix( cell );

        $L.fastdom.measure( function(){
            var bcr = cell._bcr || cell.getBoundingClientRect();
            this._fixedWidth = this._fixedWidth + bcr.width;
            this.adjust_wrap_width();
        }.bind(this) )
    },

    callUnfix : function( cell ){
        if( this.getMethods( 'onUnFix' ) ){
            this.executeMethod( 'onUnFix', cell, this.$node );
        }
    },

    callFix : function( cell ){
        if( this.getMethods( 'onFix' ) ){
            this.executeMethod( 'onFix', cell, this.$node );
        }
    },

    callDrop :function( selectedCell, next, startIndex, endIndex, header, evt ){
        if( this.getMethods( 'onDrop' ) ){
            this.executeMethod( 'onDrop', selectedCell, next, startIndex, endIndex, header, evt, this.$node );
        }
    }, 

    callRelease : function( evt, selectedCell ){
        if( this.getMethods( 'onRelease' ) ){
            this.executeMethod( 'onRelease', evt, selectedCell, this.$node );
        }
    },

    callOnBeforeSelect : function( selectedCell, ev, index ){
        if( this.getMethods( 'onBeforeSelect' ) ) {
            return this.executeMethod( 'onBeforeSelect', selectedCell, ev, this.$node, index ) === false;
        }
    },

    callOnSelect : function( selectedCell, ev, index ){
        if( this.getMethods( 'onSelect' ) ) {
            return this.executeMethod( 'onSelect', selectedCell, ev, this.$node, index ) === false;
        }
    },
    stickyFunction : function( cell, isCss, property, value ){
        var index = this.getIndexForSticky( cell ),
        tbody = this.getTbody(),
        rows = Array.from( tbody.children ),
        fnName = isCss ? 'css' : property,
        fnValue = isCss ? ( this._dir ? { right : value } : { left : value } ) : value;

        if( !isCss ){
            $L( cell )[ property ]( value );
        }

        rows.forEach( function(row) {
            $L( row ).children().eq( index )[ fnName ]( fnValue );
        } )
    },
    getIndexForSticky : function( cell ){
        return Array.from( cell.parentNode.children ).indexOf( cell );
    },
    removeFixedClass : function( cell ){
        this.stickyFunction( cell, false, 'removeClass', 'lyteTableFixed' );
    },
    removeSticky : function( cell ){
        this.stickyFunction( cell, true, this.rtlfunc( 'left' ), '' );
    }


});

window.addEventListener( 'resize', function() {

    window.clearTimeout( _lyteUiUtils._expressDebounce );

    _lyteUiUtils._expressDebounce = setTimeout( function() {
        var tables = document.getElementsByTagName( 'lyte-expresstable' ),
        i = 0;
       
            for( ; i < tables.length; i++ ) {
                if( tables[ i ] && !tables[ i].getData('ltPropStickyTable')){
                    tables[ i ].component.setFixTableRowHeight();
                    tables[ i ].component.fixHeaderHeight();
                }
            
        }   
    }, 250 );
    
}, true );

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-exptable-th' ] ) {
    _lyteUiUtils.registeredCustomElements[ 'lyte-exptable-th' ] = true; 
    
    Lyte.createCustomElement("lyte-exptable-th", {
        static : {
             "observedAttributes" : {
                get : function() {
                    return ['fixed', 'resize', 'icon'];
                }
            }
        },
        "attributeChangedCallback" : function(attr, oldVal, newVal) {
            if (attr == 'fixed') {
            var scrollingDiv = this;
             while(scrollingDiv.tagName != 'DIV')
                {
                    scrollingDiv = scrollingDiv.parentElement;
                }  
            if (newVal == 'enable') {
              this.classList.add('lyteFixedColumn');
            } else {
              this.classList.remove('lyteFixedColumn');
            }
            this.checkIntersection( newVal == "enable" );
          } else if (attr == 'resize') {
            if (newVal == 'enable') {
              var tabHead = document.createElement('lyte-exptablehead-resize');
              tabHead.addEventListener('mousedown', this.resize);
              tabHead.addEventListener('touchstart', this.resize);
              this.appendChild(tabHead);
            } else {
              var tabHead = this.getElementsByTagName('lyte-exptablehead-resize')[ 0 ];
              if (tabHead) {
                this.removeChild(tabHead);
              }
            }
          }
        },
        checkIntersection : function( arg ){
                var table = $L( this ).closest( 'lyte-expresstable' ).get( 0 );
                if( table.getData('ltPropStickyTable') ){
                    if( arg && !this._horizontalIntersectionDiv ){
                        this.createIntersection( table );
                    } else if( !arg && this._horizontalIntersectionDiv ){
                        var intersection = this._horizontalIntersectionDiv;
                        this.removeIntersection( intersection, table );
                        table.component.removeSticky( this );
                        table.component.removeFixedClass( this );
                    }
                }
        },
        createIntersection : function( table ){
                var div = $L( document.createElement( 'div' ) ).addClass( 'lyteExpStickyInterSection' ).get( 0 );
                table.getElementsByTagName( 'lyte-exptable' )[ 0 ].appendChild( div );
                this._horizontalIntersectionDiv = div;
                div._cell = this;
                table.component.setLeftForInterSection();
        },
        removeIntersection : function( intersection, table ){
                if( table ){
                    table.component._intersectionObs.unobserve( intersection );
                }
                intersection.remove();
                delete intersection._cell;
                delete this._horizontalIntersectionDiv;
            },
        disconnectedCallback : function(){
            if(Lyte.Component.shouldIgnoreDisconnect()){
                return
            }
            var intersection = this._horizontalIntersectionDiv;
            if( intersection ){
                var table = $L( this ).closest( 'lyte-expresstable' ).get( 0 );
                this.removeIntersection( intersection, table );
            }
        },

            
        resize : function(event){
              var table = $L( event.target ).closest( 'lyte-expresstable' )[ 0 ];  
              table.component.actions.tableResize.call(table.component, event);
        }        
    });
}
/**
 * @syntax nonYielded 
 * <lyte-expresstable lt-prop-header = {{headerJSON}} lt-prop-content = {{contentJSON}} lt-prop-header-label-key = "name" lt-prop-body-label-key = "body" style="height: 150px"></lyte-expresstable> 
 */


 /**
 * 
 * @syntax yielded 
 *  <lyte-expresstable > 
 *      <template is = 'registerYield' yield-name = 'headerYield'> 
 *           <lyte-exptable-tr> 
 *              <lyte-exptable-th > 
 *                   From
 *               </lyte-exptable-th>
 *               <lyte-exptable-th > 
 *                   Name
 *               </lyte-exptable-th>
 *          </lyte-exptable-tr> 
 *      </template> 
 *       <template is = 'registerYield' yield-name = 'contentYield'> 
 *           <lyte-exptable-tr > 
 *               <lyte-exptable-td > 
 *                   Agra
 *               </lyte-exptable-td> 
 *               <lyte-exptable-td > 
 *                   Jaipur
 *               </lyte-exptable-td> 
 *           </lyte-exptable-tr>
 *            <lyte-exptable-tr > 
 *               <lyte-exptable-td > 
 *                   Mysore
 *               </lyte-exptable-td> 
 *               <lyte-exptable-td > 
 *                   Delhi
 *               </lyte-exptable-td> 
 *           </lyte-exptable-tr>
 *       </template> 
 *   </lyte-expresstable>  
 */
/**
 * Renders a fileupload
 * @component lyte-fileupload
 * @dependency lyte-text, lyte-tooltip
 * @version 2.2.9
 * @utility upload,removeUpload
 * @methods beforeRender,afterRender,onBeforeAdd,onAdd,onBeforeRemove,onRemove,onBeforeSend,onSend,onFileSuccess,onFileRemove,onRequestSuccess,onRequestFailure,onSuccess,onFailure,
 * onProgress,onRetry,onReject,onChunkSuccess,onChunkError,onBeforeOpen,onDragEnter,onDragOver,onDragLeave,onBeforeDrop,onDrop,onBeforePaste,onPaste
 */
Lyte.Component.register("lyte-fileupload", {
_template:"<template tag-name=\"lyte-fileupload\"> <input class=\"fileuploadInput {{ltPropClass}}\" id=\"{{ltPropId}}\" type=\"file\" name=\"{{ltPropName}}\" onchange=\"{{action('change',event,this)}}\" multiple=\"{{ltPropMultiple}}\" accept=\"{{ltPropAccept}}\"> <div tabindex=\"{{ltPropTabindex}}\" class=\"fileUploadWrapper {{fileClass}} {{if(ltPropMultiple,'multiFileupload','singleFileUpload')}} lyteFileUpd{{ltPropAppearance}}Type {{if(ltPropDisabled,'lyteFileUpdDisabled')}} {{maxFileClass}}\" ondragenter=\"{{action('drag',event)}}\" ondragleave=\"{{action('drag',event)}}\" ondragover=\"{{action('drag',event)}}\" ondrop=\"{{action('drop',event)}}\" onclick=\"{{action('click',event)}}\" style=\"outline: none;\" onpaste=\"{{action('paste',event)}}\" onkeydown=\"{{action('keydown',event)}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"file\" queue-list=\"{{queueList}}\" predefined-list=\"{{predefinedList}}\"></lyte-yield> </template><template case=\"false\"> <template is=\"if\" value=\"{{ltPropMultiple}}\"><template case=\"true\"> <lyte-file-select-area> <lyte-file-message class=\"lyteFileUpdMsgWrap\"> <span class=\"lyteFileUpdMsg\">{{lyteUiI18n(ltPropMessage,\"fileupload\")}}</span> </lyte-file-message> </lyte-file-select-area> <div class=\"lyteFileUpdList\"> <template is=\"for\" items=\"{{predefinedList}}\" item=\"item\" index=\"index\"> <div class=\"lyteFileUpdListFile\"> <div class=\"lyteFileUpdTypePreview\"> <template is=\"if\" value=\"{{lyteUiImageFile(item)}}\"><template case=\"true\"> <img class=\"lyteFileUpdThumb\" src=\"{{item.src}}\"> </template><template case=\"false\"> <span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span> </template></template> </div> <lyte-text class=\"lyteFileUpdFileName\" lt-prop-value=\"{{item.name}}\"></lyte-text> <span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size,ltPropFileUnit,ltPropDigits)}} )</span> <lyte-file-close data-value=\"{{item.id}}\" class=\"{{item.status}}\"></lyte-file-close> </div> </template> <template is=\"for\" items=\"{{queueList}}\" item=\"item\" index=\"index\"> <div class=\"lyteFileUpdListFile {{item.status}}\"> <div class=\"lyteFileUpdTypePreview\"> <template is=\"if\" value=\"{{lyteUiImageFile(item)}}\"><template case=\"true\"> <img class=\"lyteFileUpdThumb\" src=\"{{item.src}}\"> </template><template case=\"false\"> <span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span> </template></template> </div> <lyte-text class=\"lyteFileUpdFileName\" lt-prop-value=\"{{item.name}}\"></lyte-text> <span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size,ltPropFileUnit,ltPropDigits)}} )</span> <template is=\"if\" value=\"{{expHandlers(item.percentage,'!=',undefined)}}\"><template case=\"true\"> <div class=\"lyteFileUpdFileStatus\" data-completed=\"{{item.percentage}}\"> <div class=\"lyteFileUpdProgressBar {{item.status}}\"> <div class=\"lyteFileUpdProgressFill\" style=\"width: {{item.percentage}}%\"></div> </div> </div> </template></template><template is=\"if\" value=\"{{expHandlers(item.status,'==',&quot;error&quot;)}}\"><template case=\"true\"> <lyte-file-retry data-value=\"{{item.id}}\"> <span class=\"lyteFileUpdFailMsg\">{{lyteUiI18n(ltPropFailureMessage,\"fileupload\")}}</span> <template is=\"if\" value=\"{{expHandlers(ltPropUploadMultiple,'!')}}\"><template case=\"true\"> <span class=\"lyteFileUpdRetryMsg\">{{lyteUiI18n(ltPropRetryText,\"fileupload\")}}</span> </template></template> </lyte-file-retry> </template></template> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropUploadMultiple,'!'),'||',expHandlers(expHandlers(expHandlers(item.status,'!'),'||',expHandlers(item.status,'==',&quot;error&quot;)),'||',expHandlers(item.status,'==',&quot;success&quot;)))}}\"><template case=\"true\"> <lyte-file-close data-value=\"{{item.id}}\" class=\"{{item.status}}\"></lyte-file-close> </template></template> </div> </template> </div> </template><template case=\"false\"> <lyte-file-select-area> <lyte-file-message class=\"lyteFileUpdMsgWrap {{if(expHandlers(queueList.length,'||',predefinedList.length),'lyteHide','')}}\"> <span class=\"lyteFileUpdMsg\"> {{lyteUiI18n(ltPropMessage,\"fileupload\")}} </span> </lyte-file-message> <div class=\"lyteFileUpdList\"> <template is=\"for\" items=\"{{predefinedList}}\" item=\"item\" index=\"index\"> <div class=\"lyteFileUpdListFile\"> <div class=\"lyteFileUpdTypePreview\"> <template is=\"if\" value=\"{{lyteUiImageFile(item)}}\"><template case=\"true\"> <img class=\"lyteFileUpdThumb\" src=\"{{item.src}}\"> </template><template case=\"false\"> <span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span> </template></template> </div> <lyte-text class=\"lyteFileUpdFileName\" lt-prop-value=\"{{item.name}}\"></lyte-text> <span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size,ltPropFileUnit,ltPropDigits)}} )</span> <lyte-file-close data-value=\"{{item.id}}\" class=\"{{item.status}}\"></lyte-file-close> </div> </template> <template is=\"for\" items=\"{{queueList}}\" item=\"item\" index=\"index\"> <div class=\"lyteFileUpdListFile {{item.status}}\"> <div class=\"lyteFileUpdTypePreview\"> <template is=\"if\" value=\"{{lyteUiImageFile(item)}}\"><template case=\"true\"> <img class=\"lyteFileUpdThumb\" src=\"{{item.src}}\"> </template><template case=\"false\"> <span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span> </template></template> </div> <lyte-text class=\"lyteFileUpdFileName\" lt-prop-value=\"{{item.name}}\"></lyte-text> <span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size,ltPropFileUnit,ltPropDigits)}} )</span> <template is=\"if\" value=\"{{expHandlers(item.percentage,'!=',undefined)}}\"><template case=\"true\"> <div class=\"lyteFileUpdFileStatus\" data-completed=\"{{item.percentage}}\"> <div class=\"lyteFileUpdProgressBar {{item.status}}\"> <div class=\"lyteFileUpdProgressFill\" style=\"width: {{item.percentage}}%\"></div> </div> </div> </template></template><template is=\"if\" value=\"{{expHandlers(item.status,'==',&quot;error&quot;)}}\"><template case=\"true\"> <lyte-file-retry data-value=\"{{item.id}}\"> <span class=\"lyteFileUpdFailMsg\">{{lyteUiI18n(ltPropFailureMessage,\"fileupload\")}}</span> <span class=\"lyteFileUpdRetryMsg\">{{lyteUiI18n(ltPropRetryText,\"fileupload\")}}</span> </lyte-file-retry> </template></template> <lyte-file-close data-value=\"{{item.id}}\" class=\"{{item.status}}\"></lyte-file-close> </div> </template> </div> </lyte-file-select-area> </template></template> </template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"text","position":[1,5,1]},{"type":"attr","position":[1,7]},{"type":"componentDynamic","position":[1,7]}]},{"type":"attr","position":[3,3]},{"type":"for","position":[3,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"text","position":[1,5,1]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width: '","item.percentage","'%'"]}}}}]}},"default":{}},{"type":"attr","position":[1,8]},{"type":"if","position":[1,8],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[1,10]},{"type":"if","position":[1,10],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"for","position":[1,3,1],"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"text","position":[1,5,1]},{"type":"attr","position":[1,7]},{"type":"componentDynamic","position":[1,7]}]},{"type":"attr","position":[1,3,3]},{"type":"for","position":[1,3,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"text","position":[1,5,1]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width: '","item.percentage","'%'"]}}}}]}},"default":{}},{"type":"attr","position":[1,8]},{"type":"if","position":[1,8],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[1,10]},{"type":"componentDynamic","position":[1,10]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropName","ltPropMultiple","ltPropAccept","ltPropId","ltPropClass","ltPropAppearance","ltPropDisabled","ltPropYield","ltPropFileLimit","ltPropMinimumFileSize","ltPropTotalFilesSize","ltPropParallel","ltPropAutoUpload","ltPropTriggerUpload","ltPropParamName","ltPropThumb","ltPropTabindex","ltPropRetry","ltPropFileUnit","ltPropDigits","ltPropMessage","ltPropFailureMessage","ltPropRetryText","ltPropFiles","ltPropFolder","ltPropChunk","ltPropChunkSize","ltPropParallelChunkUpload","ltPropParallelChunkCount","ltPropChunkRetry","ltPropUploadMultiple","ltPropUploadMultipleCount","ltPropAjax","ltPropAllowReplace","ltPropFilesCount","queueList","predefinedList","currentUpload","chunkUpload","fileClass","chunkCount","abort","lxhrs","uploadedFiles","manualUpdFiles","uploadMultipleRetry","retryFiles","retry","manualUpload","totalFilesSize","curTotFilesSize"],
	init : function(){
		this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node )
	},

	didConnect : function(){
		this._file = this.$node.querySelector( 'input.fileuploadInput' );
		this.$node.upload = this.processqueue.bind( this );
		this.$node.removeUpload = function( id ){
			if( id ) {
				this.removeFrmUpload( id, 'queueList' );
			} else {
				this.removeFrmUpload( this.data.queueList, 'queueList', true );
			}
			this._file.value = "";
		}.bind( this )
		this.$node.predefined = function (files){
			if(!Array.isArray(files)){
				files = [files]
			}
			for(var index=0;index<files.length;index++){
				Lyte.arrayUtils(this.data.predefinedList,"push",files[index]);
			}
		}.bind(this);
		/**
		* @utility addFiles
		* @version 2.2.15
		*/ 
		this.$node.addFiles = function(files){
			if(!Array.isArray(files)){
				files = [files]
			}
			this.validate(files);
		}.bind(this);
		this.folderUpload();
		this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );
	},

	didDestroy : function(){
		this.$node.removeUpload();
		delete this._file;
		delete this.$node.upload; 
		delete this.$node.removeUpload;
		delete this.$node.predefined;
		delete this.$node.addFiles;
	},

	data : function(){
		return {
			// file input property
			/** 
			 * @componentProperty {string} ltPropName=file
			 */
			ltPropName : Lyte.attr( 'string', { "default" : "file" } ),
			/** 
			 * @componentProperty {boolean} ltPropMultiple=true
			 */
			ltPropMultiple : Lyte.attr( 'boolean', { "default" : true } ),
			/** 
			 * @componentProperty {string} ltPropAccept
			 */
			ltPropAccept : Lyte.attr( 'string', { "default" : ''} ),
			/** 
			 * @componentProperty {string} ltPropId
			*/
			ltPropId : Lyte.attr( 'string', { "default" : ''} ),
			/**
			 * @componentProperty {string} ltPropClass
			 */
			ltPropClass : Lyte.attr( 'string', { "default" : ''} ),
			/**
			 * @componentProperty {Box | Btn | Input} ltPropAppearance=Box 
			 */
			ltPropAppearance : Lyte.attr( 'string', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'appearance', "Box" )
			} ),
			/** 
			 * @componentProperty {boolean} ltPropDisabled=false
			 */
			ltPropDisabled : Lyte.attr('boolean',{"default":false}),
			// file uploader data
			/** 
			 * @componentProperty {boolean} ltPropYield=false
			 */
			ltPropYield : Lyte.attr( 'boolean', { "default" : false } ),
			// ltPropMultipleUpload : Lyte.attr( 'boolean', { default : true } ),
			/** 
			 * @componentProperty {number} ltPropFileLimit
			*/
			ltPropFileLimit : Lyte.attr( 'number', { "default" : undefined } ),
			/** 
			 * @componentProperty {number} ltPropMinimumFileSize=0
			 * @version 2.2.11
			*/
			ltPropMinimumFileSize : Lyte.attr( 'number',{"default": 0 } ),
			/** 
			 * @componentProperty {number} ltPropTotalFilesSize
			 * @version 3.2.1
			*/
			ltPropTotalFilesSize : Lyte.attr('string'),
			/** 
			 * @componentProperty {number} ltPropParallel=2
			*/
			ltPropParallel : Lyte.attr( 'number', { "default" : 2 } ),
			/** 
			 * @componentProperty {boolean} ltPropAutoUpload=true
			*/
			ltPropAutoUpload : Lyte.attr( 'boolean', { "default" : true } ),
			/** 
			 * @componentProperty {boolean} ltPropTriggerUpload=false
			*/
			ltPropTriggerUpload : Lyte.attr( 'boolean', { "default" : false } ),
			/** 
			 * @componentProperty {string} ltPropParamName=file
			 */
			ltPropParamName : Lyte.attr( 'string', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'paramName', 'file' ) 
			} ),
			/** 
			 * @componentProperty {boolean} ltPropThumb=false
			 */
			ltPropThumb : Lyte.attr( 'boolean', { "default" : false } ),
			/** 
			 * @componentProperty {number} ltPropTabindex=1
			 */
			ltPropTabindex : Lyte.attr( 'number', { "default" : 1 } ),
			/** 
			 * @componentProperty {number} ltPropRetry=2
			 */
			ltPropRetry : Lyte.attr( 'number', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'retry', 2 )
			} ),
			/** 
			 * @componentProperty {Bytes | KB | MB | GB | TB | PB | EB | ZB | YB} ltPropFileUnit
			 */
			ltPropFileUnit : Lyte.attr( 'string', { "default" : '' } ),
			/**
			 * @componentProperty {number} ltPropDigits=1
			 */
			ltPropDigits : Lyte.attr( 'number', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'digits', 1 ) 
			} ),
			/**
			 * @componentProperty {string} ltPropMessage
			 * @default Drag file here or browse to upload
			 */
			ltPropMessage : Lyte.attr( 'string', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'message', "Drag file here or browse to upload" )  
			} ),
			/**
			 * @componentProperty {string} ltPropFailureMessage
			 * @default Attachment failed
			 */
			ltPropFailureMessage : Lyte.attr( 'string', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'failureMessage', "Attachment failed" ) 
			} ),
			/**
			 * @componentProperty {string} ltPropRetryText=Retry
			 */
			ltPropRetryText : Lyte.attr( 'string', { 
				"default" : _lyteUiUtils.resolveDefaultValue( 'lyte-fileupload', 'retryText', "Retry" )  
			} ),
			ltPropFiles : Lyte.attr("array",{ "default" :[]}),
			/**
			 * @componentProperty {boolean} ltPropChunk=false
			 */
			ltPropFolder : Lyte.attr("boolean",{"default" : false}),
			// chunking
			/**
			 * @componentProperty {boolean} ltPropChunk=false
			 */
			ltPropChunk : Lyte.attr( 'boolean', { "default" : false }),
			/**
			 * @componentProperty {number} ltPropChunkSize=2000000
			 */
			ltPropChunkSize : Lyte.attr( 'number', { "default" : 2000000 } ),
			/**
			 * @componentProperty {boolean} ltPropParallelChunkUpload=false
			 */
			ltPropParallelChunkUpload : Lyte.attr('boolean' , { "default" : false }),
			/**
			 * @componentProperty {number} ltPropParallelChunkCount=Infinity
			 */
			ltPropParallelChunkCount : Lyte.attr( 'number', { "default" :  Infinity } ),
			/**
			 * @componentProperty {number} ltPropChunkRetry=2
			 */
			ltPropChunkRetry : Lyte.attr( 'number', { "default" : 2 } ),

			// preventing multiple upload
			/**
			 * @componentProperty {boolean} ltPropUploadMultiple=false
			 */
			ltPropUploadMultiple : Lyte.attr( 'boolean', { "default" : false } ),
			/**
			 * @componentProperty {number} ltPropUploadMultipleCount=Infinity
			 */
			ltPropUploadMultipleCount : Lyte.attr('number', { "default" : Infinity}),
			/**
 			 * @typedef {Object} ajaxConfig
			 * @property {string} url=''
			 */
			/**
			 * @componentProperty {ajaxConfig} ltPropAjax
			 */
			ltPropAjax : Lyte.attr( 'object', { "default" : { url : '' } } ),
			/**
			 * @componentProperty {boolean} ltPropAllowReplace=false
			 */
			ltPropAllowReplace : Lyte.attr("boolean",{"default":false}),
			/**
			 * @componentProperty {number} ltPropFilesCount=Infinity
			 */
			ltPropFilesCount : Lyte.attr("number",{"default" : Infinity}),

			// system data
			queueList : Lyte.attr( 'array', { "default" : [] } ),
			predefinedList : Lyte.attr('array',{ "default" : []}),
			currentUpload : Lyte.attr( 'array', { "default" : [] } ),
			chunkUpload : Lyte.attr('array',{ "default" : []}),
			fileClass : Lyte.attr( 'string', { "default" : '' } ),
			chunkCount : Lyte.attr('number', { "default" : 0}),
			abort : Lyte.attr("boolean",{ "default" : false}),
			lxhrs : Lyte.attr("array",{"default" : []}),
			uploadedFiles : Lyte.attr("array",{"default" :[]}),
			manualUpdFiles : Lyte.attr("array",{"default" :[]}),
			uploadMultipleRetry : Lyte.attr('number',{"default":0}),
			retryFiles : Lyte.attr('array',{"default" : []}),
			retry : Lyte.attr('boolean',{"default" : false}),
			manualUpload : Lyte.attr('boolean',{"default" : false}),
			totalFilesSize : Lyte.attr('number'),
			curTotFilesSize : Lyte.attr('number',{"default":0})
		}		
	},
	exceedTotalCount : function(){
		var fileCount =  this.data.ltPropFilesCount;
		if(fileCount !== Infinity)  {
			var predefinedList = this.data.predefinedList || [];
			var queueList =  this.data.queueList || [];
			var noOfFiles = predefinedList.length + queueList.length;
			if(noOfFiles < fileCount) {
				return false;
			}
			return true;
 		}
		return false;
	},
	folderUpload : function(){
		var folder =  this.data.ltPropFolder
		if(folder){
			this._file.setAttribute("webkitdirectory",true);
		}
		else{
			this._file.removeAttribute("webkitdirectory");
		}
	},
	validateAndGetType : function(fileName, fileType, reason){
		var acceptRegex = new RegExp( this.data.ltPropAccept.replace(/\s+/g,"").split(",").join("|"));
		var extension="", type;
		if(fileName){
			extension=fileName.substring(fileName.lastIndexOf('.')+1, fileName.length);
		}
		if(acceptRegex.test(fileType)){
			type = fileType.match(/(video|image|pdf|zip)/ig);
			type = type && type[0]?type[0]:extension;
		}
		else if(acceptRegex.test(extension)){
			type = extension;
		}
		else{
			reason.type = "Invalid_Type";
		}
		return type;
	},
	validateSize : function(file, reason) {
		if(file.size < this.data.ltPropMinimumFileSize){
			reason.size = "Lower_Size";
		}  
		else if(file.size > this.data.ltPropFileLimit){
			reason.size = "Higher_Size";
		}
		else if(this.checkTotalFilessize(file.size)){
			reason.totalSize = "Exceeds";
		}
	},
	folderUploadObserver : function(){
		this.folderUpload();
	}.observes('ltPropFolder'),
	trigUpl : function( arg ){
		if( arg.newValue ) {
			this.processqueue();
			this.setData( 'ltPropTriggerUpload', false );
		}
	}.observes( 'ltPropTriggerUpload' ),
	validate : function( files ){ 
		var promises = [],clearflag=false;
		for( var j = 0; j < files.length; j++ ) {
			var reason = {}, isChunk=this.data.ltPropChunk,
			fileName=files[ j ].name,fileType=files[ j ].type,
			type = this.validateAndGetType(fileName, fileType, reason);
			this.validateSize(files[ j ], reason);
			if(this.exceedTotalCount())  {
				reason.fileCount = "Exceeds"; 
			}
			if ( Object.keys(reason).length > 0 ){ 
				clearflag = true;
				this.getMethods( 'onReject' ) && this.executeMethod( 'onReject', files[ j ], reason, this.$node )
			} else {
				var ret;
				if( this.getMethods( 'onBeforeAdd' ) ) {
					ret = this.executeMethod( 'onBeforeAdd', files[ j ], this.$node );
				}
				if( ret == false ){
					clearflag = true;
					continue;
				} else if( ret && ret.then ) {
					promises.push( ret );
					var cur = files[ j ];
					Promise.resolve( ret ).then( this.add.bind( this, cur, isChunk,type) )
				} else {
					this.add( files[ j ], isChunk,type);
				}
				if( !this.data.ltPropMultiple ){
					break;
				}
			}
		}
		if(clearflag){
			this._file.value = "";
		}
		if( this.data.ltPropAutoUpload ){
			promises.length ? Lyte.resolvePromises( promises ).then( this.processqueue.bind( this ) ) : this.processqueue();
		} 
 	},

 	add : function( files, isChunk, fileType ){
 		var ret = { id : 'lyte' + new Date().getTime() + parseInt( Math.random() * 10E10 ), file : files, size : files.size, name : files.name, isChunk: isChunk, retry : 0, fileType : ( fileType? fileType:'document') };
 		if( this.data.ltPropThumb && /image/i.test( files.type ) ) {
 			Lyte.Component.set( ret, 'src', URL.createObjectURL( files ) );
		}
		this.addToTotalFilesSize(files.size);
		Lyte.arrayUtils( this.data.uploadedFiles, 'push', ret );
		Lyte.arrayUtils( this.data.queueList, 'push', ret );
		Lyte.arrayUtils( this.data.ltPropFiles, 'push' , files);
		this.getMethods( 'onAdd' ) && this.executeMethod( 'onAdd', files, this.$node );
 	},

 	chkId : function( id, obj ) {
 		 return obj.id == id;
 	},
	SendingFile : function(){
		var data = this.data, 
		manualUpdFiles = data.manualUpdFiles;
		for(var index =0 ; index < manualUpdFiles.length ;){
			var current = manualUpdFiles[index];
			if(!current.status || (current.isChunk && current.status == "uploading")){
				if(current.isChunk){
					if(!current.status){
						this.setData("manualUpload",true);
						this.uploadFile(current);
						break;
					}
					else if(current.finished + current.currentUploadingChunks < current.chunks.length){
						this.setData("manualUpload",true);
						this.uploadFile(current);
						break;
					}
					else{
						index++;
					}
				}
				else{
					if(data.currentUpload.length < data.ltPropParallel){
						this.setData("manualUpload",true);
						Lyte.arrayUtils( data.currentUpload, 'push', current );
						this.uploadFile( current );
						index++;
					}
					else{
						break;
					}
				}
			}
			else{
				index++;
			}
		}
		if(index === manualUpdFiles.length){
			this.finishcallback(manualUpdFiles);
		}
	},
 	processqueue : function( id  , check , frmRetry ){
 		var data = this.data, idx = 0,
		 multiple = [];
		 if(id && !frmRetry){
			if( id.constructor != Array ) {
				id = [ id ];
			}
			for( var i = 0; i < id.length; i++ ) {
				var fileId =  id[ i ].id || id[ i ];
				var file = data.queueList[ this.findIndex( data.queueList, this.chkId.bind( this, fileId ) ) ];
				if(file){
					Lyte.arrayUtils( this.data.manualUpdFiles, 'push', file );
				}
			}
			if(this.data.manualUpdFiles.length){
				this.SendingFile();
				return;
			}
		}
		 if(data.manualUpload){
			this.SendingFile();
			return;
		 }
 		while( ( ( data.currentUpload.length < data.ltPropParallel ) || ( data.ltPropUploadMultiple && data.currentUpload.length < data.ltPropUploadMultipleCount) /*|| ( !data.ltPropMultipleUpload && !data.currentUpload.length ) */) || frmRetry && data.queueList.length  ) {
 			var current = data.queueList[ idx ];
 			if( id ) {
 				id = id.constructor == Object ? id.id : id;
				current = data.queueList[ this.findIndex( data.queueList, this.chkId.bind( this, id ) ) ]
				if(frmRetry && current){
					Lyte.arrayUtils( this.data.retryFiles, 'push', current );
					Lyte.Component.set( current, 'status', 'reloading' );
					if(data.uploadedFiles.indexOf(current) < 0){
						Lyte.arrayUtils( this.data.uploadedFiles, 'push', current );
						this.retrySendingFile();
					}
					return;
				}
 			}
 			if( current ) {
 				if( /uploading|success/.test( current.status ) ) {
 					if( id ) {
 						break;
					 }
					if( /uploading/.test( current.status ) && current.isChunk && current.finished + current.currentUploadingChunks < current.chunks.length){
						this.processChunkQueue(current.chunks);
						break;
					}
					else{
						idx++;
 						continue;
					}
 				} else if( current.status == 'error'&& (this.data.ltPropUploadMultiple || ( current.retry >= ( data.ltPropRetry - 1 ) || current.isChunk )) && !id ) {
 					idx++;
 					continue;
 				} else if( current.status == 'reloading' ) {
					idx++;
					continue;
				}
 				if( !current.isChunk ){
		 			Lyte.arrayUtils( data.currentUpload, 'push', current );
				}
 				if( !this.data.ltPropUploadMultiple ){
					 this.uploadFile( current )
		 			if( id || current.isChunk ) {
		 				break;
		 			}
		 		} else{
		 			multiple.push( current );
		 		}
	 			idx++;
	 		} else {
				this.data.retryFiles.length && this.retrySendingFile();
				if(check){
					this.finishcallback();
				}
	 			break;
	 		}
 		} 

 		if( this.data.ltPropUploadMultiple && multiple.length ){
 			this.uploadFile( multiple );
 		}

 	},
	 retrySendingFile : function(){
		var data = this.data, 
		retryFiles = data.retryFiles;
		for(var index =0 ; index < retryFiles.length ;){
			var current = retryFiles[index];
			if(current.status == "reloading"|| current.status == "uploading"){
				if(current.isChunk){
					if(current.finished + current.currentUploadingChunks < current.chunks.length){
						this.setData("retry",true);
						this.processChunkQueue(current.chunks);
						break;
					}
					else{
						index++;
					}
				}
				else{
					if(data.currentUpload.length < data.ltPropParallel){
						this.setData("retry",true);
						Lyte.arrayUtils(retryFiles,"removeAt",index);
						Lyte.arrayUtils( data.currentUpload, 'push', current );
						this.uploadFile( current );
					}
					else{
						break;
					}
				}
			}
			else{
				Lyte.arrayUtils(retryFiles,"removeAt",index);
			}
		}
		if(!retryFiles.length){
			this.setData("retry",false);
			this.processqueue(undefined,true);
		}
	 },
 	findIndex : function ( array, condition ) {
	    if( condition.constructor == Function ) {
	        for( var i = 0; i < array.length; i++ ) {
	            var ret = condition.call( array[ i ], array[ i ] );
	            if( ret ) {
	                return i;
	            }
	        }
	    } else {
	       return array.indexOf( condition );
	    }    
	},
	abortChunksFrmUpload : function(id){
		var data = this.data,chunkUpload = data.chunkUpload;
		for(var index = 0;index <chunkUpload.length;){
			var chunk = chunkUpload[index];
			if(chunk.chunkProp.origin.id === id && chunk.xhr){
				this.setData("abort",true);
				chunk.xhr.ret.abort();
			}
			else {
				index++;
			}
		}
	},
 	removeFrmUpload : function( idd, arrnme, prevent ,check ) {//need to be checked
 		if( idd.constructor != Array ) {
 			idd = [ idd ];
 		}
 		for( var i = 0; i < idd.length; i++ ) {
	 		var id = idd[ i ].id || idd[ i ];
			 var arr = this.data[ arrnme ], crct = this.findIndex( arr,  this.chkId.bind( this, id ) ) , flag ,cur ;
			 if(crct === undefined || crct < 0){
				arr = this.data.predefinedList,crct = this.findIndex( arr,  this.chkId.bind( this, id ) ) ;
				if(crct > -1){
				   arrnme = "predefinedList";
				}
			 }
	 		if( crct >= 0 ) {
	 			if( !prevent && this.getMethods( 'onBeforeRemove' ) && this.executeMethod( 'onBeforeRemove', arrnme, arr[ crct ], this.$node ) == false ) {
		 			continue;
				 }
				cur = arr[ crct ]; 
				if(!prevent){
					this.removeFromTotalFileSize(cur.size)
				}
	 			if( cur.status == 'uploading' ) {
					flag = true ;
					if(cur.xhr){
						this.setData("abort",true);
						cur.xhr.ret.abort();
					}
					if(cur.isChunk){
						this.abortChunksFrmUpload(cur.id);
					}
	 			}
				Lyte.arrayUtils( arr, 'removeAt', crct );
				if(arrnme === "queueList"){
					var lxhrs = this.getData("lxhrs");
					var lxhr = $L.search(lxhrs,"fileId",cur.id)[0],index;
					if(cur.isChunk && flag){
						this.getMethods("onFileFailure") && this.executeMethod('onFileFailure',lxhr,cur,this.$node,true);
					}
					Lyte.arrayUtils( this.data.ltPropFiles, 'removeAt', crct );
					var temparray=this.data.uploadedFiles,tempId = this.findIndex( temparray,  this.chkId.bind( this, id ) )
					if( tempId >= 0 ) {
						Lyte.arrayUtils( temparray, 'removeAt', tempId );
					}
					var temparray=this.data.retryFiles,tempId = this.findIndex( temparray,  this.chkId.bind( this, id ) )
					if( tempId >= 0 ) {
						Lyte.arrayUtils( temparray, 'removeAt', tempId );
					}
					index = lxhrs.indexOf(lxhr);
					index > -1 && Lyte.arrayUtils(lxhrs,'removeAt',index);
					if( crct <= i ) {
						i--;
					}
				}
				!prevent && this.getMethods( 'onRemove' ) && this.executeMethod( 'onRemove', arrnme, cur, this.$node );
			 }
	 	}
	 	if(!this.data.ltPropUploadMultiple && ((arrnme == "queueList" && flag) || check)) {
			 //check is a flag to used to trigger the finishcallback
	 		this.data.retry?this.retrySendingFile():this.processqueue(undefined,true);
	 	}
 	},

 	uploadFile : function( file ){
		var props = Lyte.deepCopyObject( this.data.ltPropAjax );
		file.isChunk ? this.proceedChunk( file, props ) : this.proceedUpload( file, props, false );
		//comments may be need in future please check git 
		// if( this.getMethods( 'onBeforeUpload' ) ) {
		// 	ret = this.executeMethod( 'onBeforeUpload', file, props, this.$node );
		// }
		// if( ret && ret.then ) {
		// 	Promise.resolve( ret ).then( function(){
		// 		file.isChunk ? this.proceedChunk( file, props ) : this.proceedUpload( file, props );
		// 	}.bind( this ))
		// } else if( ret != false ) {
			
		// } else {
		// 	if( file.constructor != Array ){
		// 		file = [ file ];
		// 	}
		// 	for( var i = 0; i < file.length; i++ ){
		// 		//this.removeFrmUpload( file[ i ].id, 'queueList' );
		// 		this.removeFrmUpload( file[ i ].id, 'currentUpload',true);//need to be checked
		// 	}
		// }
 	},

 	succFunc : function( evt ){
		if(this.$node){
			var file = arguments[ 2 ].xhr.file,ret = arguments[2].xhr.ret,tempRet = [],duplicate;
			file.xhr && delete file.xhr;
			this.getMethods( 'onRequestSuccess' ) && this.executeMethod( 'onRequestSuccess', ret, file, this.$node );
			if( file.constructor != Array ){
				file = [ file ];
			}
			for( var i = 0; i < file.length; i++ ){
				Lyte.Component.set( file[ i ], 'status', 'success' );
				Lyte.objectUtils( file[ i ], 'delete', 'xhr' );
				if(!this.data.ltPropUploadMultiple){
					var lxhrs =this.getData("lxhrs");
					duplicate = $L.search(lxhrs,"fileId",file[i].id);
					duplicate.length  && Lyte.arrayUtils(lxhrs,'removeAt',lxhrs.indexOf(duplicate[0]));
					ret.fileId = file[i].id;
					Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
					this.getMethods( 'onFileSuccess' ) && this.executeMethod( 'onFileSuccess', ret, file[ i ], this.$node );
					this.removeFrmUpload( file[ i ].id, 'currentUpload' , true, true ); //need to be checked
				}
				 else{
					tempRet.push(file[ i ].id);
					this.removeFrmUpload( file[ i ].id, 'currentUpload',true); //need to be checked
				}
			}
			if(this.data.ltPropUploadMultiple){
				ret.fileId = tempRet;
				Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
				this.setData("uploadMultipleRetry",0);
				this.processqueue(undefined,true);
			}
			delete arguments[ 2 ].xhr.file;
		}
 	},

 	reject : function( evt ){
		if(this.$node){
			var file = evt.xhr.file,ret=evt.xhr.ret,retry = file.retry,tempRet = [],duplicate;
			if(this.data.abort || retry >= this.data.ltPropRetry  || (this.data.ltPropUploadMultiple && this.data.uploadMultipleRetry  >= this.data.ltPropRetry) ) {
				file.xhr && delete file.xhr;
				this.getMethods( 'onRequestFailure' ) && this.executeMethod( 'onRequestFailure', ret, file, this.$node,this.data.abort );
				if( file.constructor != Array ){
					file = [ file ];
				}
				for( var i = 0; i < file.length; i++ ){
					Lyte.Component.set( file[ i ], 'status', 'error' );
					Lyte.objectUtils( file[ i ], 'delete', 'xhr' );
					if(! this.data.ltPropUploadMultiple){
						var lxhrs =this.getData("lxhrs");
						duplicate = $L.search(lxhrs,"fileId",file[i].id);
						duplicate.length  && Lyte.arrayUtils(lxhrs,'removeAt',lxhrs.indexOf(duplicate[0]));
						ret.fileId = file[i].id;
						this.getMethods("onFileFailure") && this.executeMethod('onFileFailure',ret,file[i],this.$node,this.data.abort);
						!this.data.abort  && Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
					}
					else{
						tempRet.push(file[ i ].id);
					}
					this.removeFrmUpload( file[ i ].id, 'currentUpload',true,!this.data.abort); //need to be checked
					
				}
				if(this.data.ltPropUploadMultiple){
					ret.fileId = tempRet;
					Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
					this.setData("uploadMultipleRetry",0);
					this.processqueue(undefined,true);
				}
				if(this.data.abort){
					Lyte.objectUtils( evt.xhr.file, 'add', 'retry', this.data.ltPropRetry );
					this.setData("abort",false);
				}
				delete evt.xhr.file;
			} else {
				if(!this.data.ltPropUploadMultiple){
					Lyte.Component.set( evt.xhr.file, 'status', 'retrying' );
					Lyte.objectUtils( evt.xhr.file, 'add', 'retry', retry + 1 );
					this.getMethods( 'onRetry' ) && this.executeMethod( 'onRetry', ret, file, this.$node );
					this.uploadFile( file );
				}
				else{
					delete file.xhr;
					for( var i = 0; i < file.length; i++ ){
						Lyte.Component.set( evt.xhr.file[i], 'status', 'retrying' );
						Lyte.Component.set( evt.xhr.file[i], 'retry', evt.xhr.file[i].retry +1 );
					}
					this.setData("uploadMultipleRetry",this.data.uploadMultipleRetry+1);
					this.getMethods( 'onRetry' ) && this.executeMethod( 'onRetry', ret, file, this.$node );
					this.uploadFile(file);
				}
			}
		}
 	},

 	progress : function( evt ){
 		if( evt.lengthComputable ) {
	 		var total = evt.total, upload = evt.loaded, xhr = evt.target.xhr,
	 		file = xhr.file;

	 		if( file.constructor != Array ){
	 			file = [ file ];
	 		}
	 		for( var i = 0; i < file.length; i++ ){ 
				if(this.data.ltPropUploadMultiple){
					Lyte.Component.set( file[ i ] , { loaded : file[i].size, percentage : 100 } );
				}
				else{
					Lyte.Component.set( file[ i ] , { loaded : upload, percentage : Math.round( upload * 100 / total ) } );
				}
	 			this.getMethods( 'onProgress' ) && this.executeMethod( 'onProgress', evt, xhr, file[ i ], this.$node );
	 		}
	 	}
 	},

 	removeChunk : function( id, origin, prevent ) {
 		var arr = this.data.chunkUpload, cur = this.findIndex( arr, function( obj ){
 			return obj.chunkProp.chunkId == id
 		} )
 		if( cur > -1 ) {
 			Lyte.arrayUtils( arr, 'removeAt', cur );
 			!prevent && this.processChunkQueue( origin.chunks )
 		}
 	},

 	chunkReject : function( evt ){
		if(this.$node){
			var file = evt.xhr.file, origin = file.chunkProp.origin,ret = arguments[0].xhr.ret;
			if( !this.data.abort && file.retry < this.data.ltPropChunkRetry) {
				Lyte.Component.set( file, 'status', 'retrying' );
				Lyte.objectUtils( file, 'add', 'retry', file.retry + 1 );
				this.removeChunk( file.chunkProp.chunkId, origin, true );
				this.getMethods( 'onRetry' ) && this.executeMethod( 'onRetry',ret, file, this.$node );
				Lyte.Component.set( origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1 );
				this.processChunkQueue( file, true );
			} else {
				this.getMethods( 'onRequestFailure' ) && this.executeMethod( 'onRequestFailure', ret, file, this.$node,this.data.abort );
				Lyte.Component.set( file, 'status', 'error' );
				this.removeChunk( file.chunkProp.chunkId, origin, true );
				this.getMethods( 'onChunkError' ) && this.executeMethod( 'onChunkError', ret, file, origin, this.$node,this.data.abort );
				Lyte.objectUtils( file, 'delete', 'xhr' );
				delete evt.xhr.file; 	
				Lyte.Component.set( origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1 );
				Lyte.Component.set( origin, 'error', origin.error + 1 );
				if( origin.status != 'error' ) {
					var lxhrs =this.getData("lxhrs"),duplicate;
					Lyte.Component.set( origin, 'status', 'error' );
					//Lyte.Component.set( this.getData("lxhrs"), origin.id, ret );
					duplicate = $L.search(lxhrs,"fileId",origin.id);
					duplicate.length  && Lyte.arrayUtils(lxhrs,'removeAt',lxhrs.indexOf(duplicate[0]));
					ret.fileId = origin.id;
					Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
				}
				if(!this.data.abort){
					this.abortChunksFrmUpload(origin.id);
					this.getMethods("onFileFailure") && this.executeMethod('onFileFailure',ret,origin,this.$node,this.data.abort);
					this.data.retry ? this.retrySendingFile()
					:this.processqueue(undefined,true);
				}
				else{
					this.setData("abort",false);
				}
			}
		}
 	},

 	chunkSuccess : function( evt ){
		if(this.$node){
			var file = arguments[ 2 ].xhr.file, origin = file.chunkProp.origin,ret = arguments[ 2 ].xhr.ret;
			this.getMethods( 'onRequestSuccess' ) && this.executeMethod( 'onRequestSuccess', ret, file, this.$node );
			Lyte.Component.set( file, 'status', 'success' );
			this.removeChunk( file.chunkProp.chunkId, origin,true );
			this.getMethods( 'onChunkSuccess' ) && this.executeMethod( 'onChunkSuccess', ret, file, origin, this.$node );
			Lyte.objectUtils( file, 'delete', 'xhr' );
			delete arguments[ 2 ].xhr.file;
			Lyte.Component.set( origin, 'finished', origin.finished + 1 );
			Lyte.Component.set( origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1 );
			if( origin.finished == origin.total ) {
				var lxhrs =this.getData("lxhrs"),duplicate;
			   	Lyte.Component.set( origin, 'status', 'success' );
				duplicate = $L.search(lxhrs,"fileId",origin.id);
				duplicate.length  && Lyte.arrayUtils(lxhrs,'removeAt',lxhrs.indexOf(duplicate[0]));
				ret.fileId = origin.id;
				Lyte.arrayUtils(this.getData("lxhrs"),'push',ret);
				this.getMethods( 'onFileSuccess' ) && this.executeMethod( 'onFileSuccess', ret, origin, this.$node );
				this.data.retry ? this.retrySendingFile()
				:this.processqueue(undefined,true);
			}
			else {
				this.processChunkQueue( origin.chunks, true );
			}
		}
		
 	},

 	chunkProgress : function( evt ){
 		if( evt.lengthComputable ) {
 			var total = evt.total, upload = evt.loaded, file = evt.target.xhr.file, origin = file.chunkProp.origin, diff = upload - file.loaded;
 			Lyte.Component.set( file, 'loaded', upload );
 			Lyte.Component.set( origin, { loaded : Math.min( origin.loaded + diff, origin.size ), percentage : Math.min( Math.round( ( origin.loaded + diff ) * 100 / origin.size ), 100 ) } );
 			this.getMethods( 'onProgress' ) && this.executeMethod( 'onProgress', evt, evt.target.xhr, origin, this.$node )
 		}
 	},

 	proceedChunk : function( files, props ) {
 		var data = this.data, chunkSize = data.ltPropChunkSize, oriSize = files.size, size = 0, blobs = [];
 		while( size <= oriSize ){
			var start = size, end =  Math.min( oriSize, size += chunkSize ),totalChunkSize = end - start;
 			blobs.push( { file : files.file.slice( start, end ), chunkProp : {
 			  chunkOffset : start, 
			  chunkEnd : end, 
			  chunkSize : totalChunkSize,
 			  chunkId : "lyteChunk" + new Date().getTime() + parseInt( Math.random() * 10E10 ), 
 			  chunkIndex : blobs.length, 
 			  origin : files,
 			  chunkCount : Math.ceil( files.size / chunkSize ),
 			  totalSize : files.size 
 			}, name : files.file.name, loaded : 0, retry : 0 });
 		}
		 Lyte.Component.set( files, { chunks : blobs, error : 0, finished : 0, total : blobs.length } );
		 if(data.ltPropParallelChunkCount === Infinity){
			 this.setData("chunkCount", blobs.length);
		 }
 		this.processChunkQueue( blobs )
 	},

 	processChunkQueue : function( blobs, frmFail ){
 		var data = this.data, idx = 0;
		if( blobs.constructor != Array ) {
			blobs = [ blobs ];
		} 
		while( (!data.ltPropParallelChunkUpload && data.chunkUpload.length < 1) || (data.ltPropParallelChunkUpload && (data.ltPropParallelChunkCount === Infinity ) ||( data.ltPropParallelChunkCount != Infinity &&/*data.ltPropMultipleUpload &&*/ data.chunkUpload.length < data.ltPropParallelChunkCount ) /*|| ( !data.ltPropMultipleUpload && !data.currentUpload.length )*/ ) ) {
			var bb = blobs[ idx ];
			if( !bb ) {
				if(data.retry){
					this.retrySendingFile();
				}
				else if(data.ltPropParallelChunkUpload){
					data.ltPropParallelChunkCount != Infinity && data.chunkUpload.length < data.ltPropParallelChunkCount && this.processqueue();
					data.ltPropParallelChunkCount == Infinity && this.processqueue();
				}
				break;
			}
			if( !/success|uploading/.test( bb.status ) && ( !frmFail || ( frmFail && !/error/.test( bb.status ) ) ) ) {
				var file = bb.chunkProp.origin;
				Lyte.Component.set( file, { status : 'uploading', percentage : file.percentage || 0, loaded : file.loaded || 0, size : file.size , currentUploadingChunks : file.currentUploadingChunks+1 || 1 } )
				this.proceedUpload( bb, Lyte.deepCopyObject( data.ltPropAjax ), true );
				Lyte.arrayUtils( data.chunkUpload, 'push', bb );
				idx++;
			} else {
				idx++;
				continue;
			}
		}
 	},

 	proceedUpload : function( file, props, isChunk ){
 		if( /success|uploading/.test( ( file[ 0 ] && file[ 0 ].status ) || file.status ) ){
 			return;
 		}
		var formdata = new FormData(), callback,keys=["chunkOffset","chunkSize","chunkIndex","chunkCount","totalSize"],fileName;
 		if( file.constructor == Array ){
 			for( var j = 0; j < file.length; j++ ){
				fileName = this.data.ltPropFolder ?file[ j ].file.webkitRelativePath:file[ j ].name;
 				formdata.append( this.data.ltPropParamName + '[' + j + ']', file[ j ].file, fileName );
 			}
 		} else {
			fileName = this.data.ltPropFolder && !isChunk ?file.file.webkitRelativePath:file.name;
			formdata.append(this.data.ltPropParamName, file.file, fileName );
		 }
		 if(isChunk){
			 for(var index=0;index<keys.length;index++){
				formdata.append(keys[index],file.chunkProp[keys[index]]);
			 }
			 var origin = file.chunkProp.origin;
			 formdata.append("fileId",origin.id);
			 fileName = this.data.ltPropFolder ?origin.file.webkitRelativePath:origin.name;
			 formdata.append("fileName",fileName);
		}
 		props.success = isChunk ? this.chunkSuccess.bind( this ) : this.succFunc.bind( this );
 		props.error =  isChunk ? this.chunkReject.bind( this ) : this.reject.bind( this );
 		var xhr = new XMLHttpRequest();
 		props.type = 'POST';
 		file.xhr = xhr;
 		xhr.file = file;
 		xhr.upload.xhr = xhr;
 		xhr.upload.addEventListener( 'progress', isChunk ? this.chunkProgress.bind( this ) : this.progress.bind( this ), false );
 		props.xhr = xhr;
 		props.data = formdata;
		props.processData = false;
		// set content-type false and make sure browser
 		props.contentType = false;
 		if( this.getMethods( 'onBeforeSend' ) ) {
 			callback = this.executeMethod( 'onBeforeSend', xhr, file, isChunk, this.$node, formdata, props );
 		}
 		if( callback && callback.then ) {
 			Promise.resolve( callback ).then( function(){
 				this.finishSend( props, xhr, file );
 			}.bind( this ) )
 		} else if( callback == false ) {
 			if( file.constructor != Array ){
 				file = [ file ];
 			}
 			for( var i = 0; i < file.length; i++ ){
 				//this.removeFrmUpload( file[ i ].id, 'queueList' );
				this.removeFrmUpload( file[ i ].id, 'currentUpload',true); //need to be checked
 			}
 			return
 		} else {
 			if( callback && callback.constructor == FormData ){
	 			props.data = callback;
	 		}
 			this.finishSend( props, xhr, file, isChunk )
 		}
 		
 	},

 	finishSend : function( props, xhr, file, isChunk ){
 		if( file.constructor == Array ){
 			for( var i = 0; i < file.length; i++ ){
 				Lyte.Component.set( file[ i ], 'status', 'uploading' );
 			}
 		} else {
 			Lyte.Component.set( file, 'status', 'uploading' );
 		}
 		var ret = $L.ajax( props );
 		ret.xhr = xhr;
 		xhr.ret = ret;
 		this.getMethods( 'onSend' ) && this.executeMethod( 'onSend', xhr, ret, file, !!isChunk, this.$node, props );
	},
	finishcallback :function(files){
		var currentFiles = files || this.data.uploadedFiles,chunk=this.data.chunkUpload,lxhr=this.data.lxhrs,flag;
		if(!currentFiles.length){
			return ;
		}
		for(var index=0;index < currentFiles.length;index++){
			if(!currentFiles[index].status || currentFiles[index].status == "uploading"){
				return;
			}
			else if(currentFiles[index].status == "error"){
				flag = true;
			}
		}
		for(var index=0;index < chunk.length;index++){
			if(chunk[index].status == "uploading"){
				return;
			}
			else if(chunk[index].status == "error"){
				flag = true;
			}
		}
		if(!this.data.ltPropMultiple)  {
			currentFiles = currentFiles[0];
			lxhr = lxhr[0];
		}
		if(flag){
			this.getMethods( 'onFailure' ) && this.executeMethod( 'onFailure', currentFiles, this.$node ,lxhr);
			this.setData("uploadedFiles",[]);
			this.setData("lxhrs",[]);
			this.data.manualUpload == true && this.setData("manualUpdFiles",[]) || this.getData("manualUpload",false);
		}
		else{
			this.getMethods("onSuccess") && this.executeMethod('onSuccess',currentFiles, this.$node ,lxhr);
			this.setData("uploadedFiles",[]);
			this.setData("lxhrs",[]);
			this.data.manualUpload == true && this.setData("manualUpdFiles",[]) ||this.getData("manualUpload",false);
		}
	 },
	 convertToBytes : function(){
		var size = this.getData("ltPropTotalFilesSize");
		 if(size){
			var fileUnit =  size.substring(size.length-2),
			totalSize  = parseInt(size.substring(0,size.length-2)),
			validFormat = ["KB","MB","GB"],
			indexOf = validFormat.indexOf(fileUnit);
			if(indexOf > -1){
				this.setData("totalFilesSize",totalSize*(Math.pow(1000,indexOf+1)))
			}
		 }
	 }.observes("ltPropTotalFilesSize").on("didConnect"),
	 checkTotalFilessize : function(fileSize){
		var size = this.getData("totalFilesSize"),
		totalSize  = this.getData("curTotFilesSize");
		if(size && (totalSize+fileSize) > size){
			return true;
		}
		return false;
	 },
	 addToTotalFilesSize : function(fileSize){
		var size = this.getData("totalFilesSize");
		if(size){
			var total =  this.getData("curTotFilesSize");
			this.setData("curTotFilesSize",total+fileSize);
		}
	 },
	 removeFromTotalFileSize : function(fileSize){
		var size = this.getData("totalFilesSize");
		if(size){
			var total =  this.getData("curTotFilesSize");
			this.setData("curTotFilesSize",total-fileSize);
		}
	 },
	 openFileWindow : function(evt){
		if( !this.data.ltPropYield  && this.data.ltPropMultiple ) {
			if( !evt.shiftKey ){
				$L( '#lyteFileUpdSelectedFile.lyteFileUpdListFile' ).removeAttr( 'id' );
			} else{
				evt.preventDefault();
			}
			if(evt.target.className != "lyteFileUpdRetryMsg"){
				$L( evt.target ).closest( '.lyteFileUpdListFile' ).attr( 'id', 'lyteFileUpdSelectedFile' );
			}
		}
		if( evt.ctrlKey || evt.shiftKey || evt.metaKey ){
			return
		}
		var res, close = $L( evt.target ).closest( 'lyte-file-close' );
		if( close.length ) {
			this.$node.removeUpload( close.eq( 0 ).attr( 'data-value' ) )
			return;
		}
		var retry = $L( evt.target ).closest( 'lyte-file-retry' );
		if( retry.length ) {
			this.$node.upload( retry.eq( 0 ).attr( 'data-value' ),undefined,true );
			return;
		}
		res = $L( evt.target ).closest( 'lyte-file-select-area' );
		if( res.length && this.data.ltPropMultiple || (this.data.queueList.length == 0 && this.data.predefinedList.length == 0) || this.data.ltPropAllowReplace){
			if( this.getMethods( 'onBeforeOpen' ) && this.executeMethod( 'onBeforeOpen', evt, this.$node ) == false ) {
				return
			}
			this._file.click();
		}
	 },
	actions : {
		change : function( evt, _this ){
			if(_this.files.length){
				if(!this.data.ltPropMultiple &&this.data.ltPropAllowReplace){
					this.removeFrmUpload( this.data.queueList, 'queueList', true );
					this.data.predefinedList.length && this.removeFrmUpload( this.data.predefinedList, 'predefinedList', true );
				}
				var files = Array.from(_this.files);
				if(this.getMethods("onSelect") && this.executeMethod("onSelect",files, evt) === false){
					this._file.value = "";
					return;
				}
				this.validate( files );
			}
		},	

		drag : function( evt ){
			var type = evt.type, nwStr = "onDrag", match = type.match(/drag(.+)/ );
			if( match && match[ 1 ] ) {
				nwStr += match[ 1 ].slice( 0, 1 ).toUpperCase() + match[ 1 ].slice( 1 );
				if( /enter|over/.test( evt.type ) ) {
					if( evt.type == 'dragover' ) {
						var tran = evt.dataTransfer;
						if( tran ) {
							var effect = tran.effectAllowed;
							tran.dropEffect = 'move' === effect || 'linkMove' === effect ? 'move' : 'copy';
						}
					}
					evt.preventDefault();
				}
			}
			if( type == "dragenter" ){
				this.setData( 'fileClass', 'fileDragEnter' );
			} else if( type == "dragleave" ){
			 	 this.setData( 'fileClass', '' );
			}
			this.getMethods( nwStr ) && this.executeMethod( nwStr, evt, this.$node );
		},

		drop : function( evt ){
			this.setData( 'fileClass', '' );
			var dT = evt.dataTransfer;
			if( dT ) {
				if( this.getMethods( 'onBeforeDrop' ) && this.executeMethod( 'onBeforeDrop', evt, this.$node ) == false ) {
					return;
				}
				evt.preventDefault();
				if( !this.data.ltPropMultiple ) {
					this.$node.removeUpload();
				}
				this.validate( dT.files );
				this.getMethods( 'onDrop' ) && this.executeMethod( 'onDrop', evt, this.$node );
			}	
		},

		click : function( evt ) {
			this.openFileWindow(evt);
		},

		paste : function( evt ){
			var clip = evt.clipboardData || window.clipboardData, items = clip.items, files = [];
			for( var i = 0; i < items.length; i++ ) {
				var file = items[ i ].getAsFile();
				if( file ) {
					files.push( file )
				}
			}
			if( files.length ) {
				if( this.getMethods( 'onBeforePaste' ) && this.executeMethod( 'onBeforePaste', evt, files, this.$node ) == false ) {
					return;
				}
				if( !this.data.ltPropMultiple ) {
					this.$node.removeUpload();
				}
				this.validate( files );
				this.getMethods( 'onPaste' ) && this.executeMethod( 'onPaste', evt, files, this.$node );
			}
		},

		keydown : function( evt ){
			if( evt.which == 8 ){
				var elem = $L( "#lyteFileUpdSelectedFile lyte-file-close", this.$node )
				for( var i = 0; i < elem.length; i++ ) {
				   this.$node.removeUpload( elem.eq( i ).attr( 'data-value' ) );
				}
				elem.length && evt.preventDefault();
			}
			else if(evt.which === 13 ) {
				this.openFileWindow(evt);
				evt.preventDefault();
			}
		}
	}
});
/**
 * @syntax nonYielded
 * <lyte-fileupload></lyte-fileupload>
 */
/**
 * @syntax 
 * @attribute ltPropYield=true 
 * @attribute ltPropMultiple=true
 *	<lyte-fileupload lt-prop-yield=true lt-prop-multiple = true> 
 *  	<template is = "registerYield" yield-name = "file"> 
 *	 	<lyte-file-select-area> 
 *	  	 	<lyte-file-message class="lyteFileUpdMsgWrap"> <span class="lyteFileUpdMsg"> Drag file here or browse to upload </span> </lyte-file-message>
 *	 	</lyte-file-select-area> 
 *		<div class="lyteFileUpdList">
 *			<template lyte-for="{{predefinedList}} as item index">
 *				<div class="lyteFileUpdListFile">
 *					<div class="lyteFileUpdTypePreview">
 *						<template lyte-if="{{item.src}}">
 *								<img class="lyteFileUpdThumb" src={{item.src}}>
 *						</template>
 *						<template lyte-else>
 *							<span class="lyteFileUpdTypeIcon {{item.fileType}}"></span>
 *						</template>
 *					</div>
 *					<lyte-text class = "lyteFileUpdFileName" lt-prop-value = {{item.name}}></lyte-text>
 *					<span class="lyteFileUpdFileSize">( {{lyteUiFileSize(item.size, ltPropFileUnit, ltPropDigits)}} )</span>
 *					<lyte-file-close data-value = {{item.id}} class = {{item.status}}></lyte-file-close>
 *				</div>
 *			</template>
 *	  	  	<template lyte-for="{{queueList}} as item index">
 *	  	  		<div class="lyteFileUpdListFile {{item.status}}"> 
 *	  				<div class="lyteFileUpdTypePreview"> 
 *	  	  	  	 		<template lyte-if="{{item.src}}"> 
 *	  	  	  	  	  		<img class="lyteFileUpdThumb" src={{item.src}}>
 * 						</template>				
 *	  	  	  	  	  	<template lyte-else> 
 *	  	  	  	  	  		<span class="lyteFileUpdTypeIcon {{item.fileType}}"></span>
 *	  	  	  	  	  	</template>
 *	  	  	  	  	</div> 
 *	  	  	  	  	<lyte-text class = "lyteFileUpdFileName" lt-prop-value = {{item.name}}> </lyte-text>
 *	  	  	  	  	<span class="lyteFileUpdFileSize"> ( {{lyteUiFileSize(item.size, 'KB', 2)}} ) </span>
 *	  	  	  	  	<template lyte-if="{{!ltPropUploadMultiple && item.percentage != undefined}}"> 
 *	  	  	  	  		<div class="lyteFileUpdFileStatus" data-completed = {{item.percentage}}> 
 *	  	  	  	  	  		<div class="lyteFileUpdProgressBar {{item.status}}"> 
 *	  	  	  	  	  	  		<div class="lyteFileUpdProgressFill" style="width: {{item.percentage}}%"> </div>
 *	  	  	  	  	  		</div> 
 *	  	  	  	  		</div>
 *					</template>
 * 					<template lyte-if='{{item.status=="error"}}'>
 *	  	  	  	  		<lyte-file-retry data-value = {{item.id}}> 
 *	  	  	  	  	  		<span class="lyteFileUpdFailMsg">Attachment failed </span>
 *	  	  	  	  	  		<template lyte-if="{{!ltPropUploadMultiple}}"> 
 *	  	  	  	  	  			<span class="lyteFileUpdRetryMsg"> Retry </span>
 *	  	  	  	  	  		</template> 
 *	  	  	  	  		</lyte-file-retry> 
 *	  	  	  	  	</template> 
 *               	<template lyte-if='{{(!ltPropUploadMultiple)||(!item.status||item.status=="error"||item.status=="success")}}'>
 *	  	  	  	  		<lyte-file-close data-value = {{item.id}} class = {{item.status}}> </lyte-file-close>
 *	  	  	  	  	</template> 
 *	  	  	  	</div> 
 *	  		</template> 
 *	 	</div> 
 *		</template> 
 *	</lyte-fileupload>  
 */
/**
 * @syntax 
 * @attribute ltPropYield=true 
 * @attribute ltPropMultiple=false
 *	<lyte-fileupload lt-prop-yield = true lt-prop-multiple = false> 
 *		<template is = "registerYield" yield-name = "file"> 
 *	  		<lyte-file-select-area> 
 *	  	  		<lyte-file-message class="lyteFileUpdMsgWrap{{if(queueList.length, 'lyteHide', '')}}"> 
 *	  	  	  		<span class="lyteFileUpdMsg"> Drag file here or browse to upload </span>
 *	  	  	  	</lyte-file-message> 
 *	  	  	  	<div class="lyteFileUpdList">
 *					<template lyte-for="{{predefinedList}} as item index">
 *						<div class="lyteFileUpdListFile">
 *							<div class="lyteFileUpdTypePreview">
 *								<template lyte-if="{{item.src}}">
 *										<img class="lyteFileUpdThumb" src={{item.src}}>
 *								</template>
 * 								<template lyte-else>
 *									<span class="lyteFileUpdTypeIcon {{item.fileType}}"></span>
 *								</template>
 *							</div>
 *							<lyte-text class = "lyteFileUpdFileName" lt-prop-value = {{item.name}}></lyte-text>
 *							<span class="lyteFileUpdFileSize">( {{lyteUiFileSize(item.size, ltPropFileUnit, ltPropDigits)}} )</span>
 *							<lyte-file-close data-value = {{item.id}} class = {{item.status}}></lyte-file-close>
 *						</div>
 *					</template>
 *					<template lyte-for="{{queueList}} as item index">
 *	  	  	  	  		<div class="lyteFileUpdListFile {{item.status}}"> 
 *	  	  	  	  	 		<div class="lyteFileUpdTypePreview">
 *	  	  	  	  	  	  		<template lyte-if="{{item.src}}"> 
 *	  	  	  	  	  	  			<img class="lyteFileUpdThumb" src={{item.src}}>
 *	  	  	  	  	  	  		</template>
 *								<template lyte-else>
 *	  	  	  	  	  	  			<span class="lyteFileUpdTypeIcon {{item.fileType}}"> </span>
 *	  	  	  	  	  	  		</template>
 *	  	  	  	  	  		</div> 
 *	  	  	  	  	  		<lyte-text class = "lyteFileUpdFileName" lt-prop-value = {{item.name}}> </lyte-text>
 *	  	  	  	  	  		<span class="lyteFileUpdFileSize"> ( {{lyteUiFileSize(item.size, 'KB', 2)}} ) </span>
 *	  	  	  	  	  		<div lyte-if="{{item.percentage != undefined}}" class="lyteFileUpdFileStatus" data-completed = {{item.percentage}}> 
 *	  	  	  	  	  	 		<div class="lyteFileUpdProgressBar {{item.status}}"> 
 *	  	  	  	  	  	  			<div class="lyteFileUpdProgressFill" style="width: %"> </div> 
 *	  	  	  	  	  	 		</div> 
 *	  	  	  	  	  		</div> 
 *	  	  	  	  	  		<lyte-file-retry lyte-if='{{item.status=="error"}}' data-value = {{item.id}}> 
 *	  	  	  	  	  	  		<span class="lyteFileUpdFailMsg"> Attachment failed </span>
 *	  	  	  	  	  	  		<span class="lyteFileUpdRetryMsg"> Retry </span>
 *	  	  	  	  	  		</lyte-file-retry> 
 *	  	  	  	  	  		<lyte-file-close data-value = {{item.id}} class = {{item.status}}> </lyte-file-close>
 *	  	  	  	 		</div> 
 *	  	  	  		</template>
 *	 			</div> 
 *	  		</lyte-file-select-area> 
 *		</template> 
 *	</lyte-fileupload>  
 */
/**
 * This component is used to create draggable and resizable grids
 * @component lyte-gridstack
 * @version 1.0.0
 * @utility addGrid,removeGrid,setProperty,reRender
 * @methods onWindowResize,onDragStart,onBeforeSelect,onSelect,onBeforeDrop,onDrop,ondrag,onItemAdd,onPropertyChange,onScroll
 */


Lyte.Component.register('lyte-gridstack', {
_template:"<template tag-name=\"lyte-gridstack\"> <lyte-yield yield-name=\"lyteGridStack\"> </lyte-yield> </template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropScope","ltPropHandler","ltPropMarginLeft","ltPropMarginTop","ltPropUnitX","ltPropUnitY","ltPropResizeDirection","ltPropFloat","ltPropDirection","ltPropUndo","ltPropResize","ltPropBestfit","ltPropMinUnitX","ltPropMinMarginLeft","ltPropBestfitClass","ltPropFreezeMode","ltPropDefaultLength","ltPropDefaultHeight","ltPropDefaultMinLength","ltPropDefaultMinHeight","ltPropDefaultMaxHeight","ltPropDefaultMaxLength","ltPropColumnMode","ltPropColumn","ltPropPrevent","ltPropGridLength","ltPropBestfitType","ltPropForcedReposition","ltPropSquareGrid","ltPropGridSpaceColor","ltPropHitBottom","ltPropGridSelectionClass","ltPropVisibleBoundary","ltPropVisible","ltPropCheckCurrentPosition","ltPropContainment","gridLength","ltPropGridHeight","ltPropMarginLeftCopy","ltPropUnitxCopy","lyteGridStack","elements","oriNode","xElements","yElements","iniData","lyteQuerySelector","direction"],
    init : function(){
        var uA = navigator.userAgent; 
        this.isSaf = { safari : !!window.safari, isIE11Lyte : /rv:11/ig.test( uA ), isEdgeLyte : /Edge/ig.test( uA ), chrome  : !!window.chrome , firefox : /firefox/ig.test( uA ) };
        this._childGrids = [];
        this.freeezeModeObs.call( this, this.data.ltPropFreezeMode );
       /**
        * @method beforeRender
        * @version 1.0.1
        */
        this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node );
    }, 
    didDestroy : function(){
        document.removeEventListener( 'keydown', this.data.lyteQuerySelector.keydown );
        window.removeEventListener( 'resize', this._resizeFunc, true );
        window.removeEventListener( 'orientationchange', this._resizeFunc, true );        
        document.removeEventListener( 'click', this._click );
        this.$node.removeEventListener( 'scroll', this._scroll, true );
        if( this._parentGrid ){
            var arr = this._parentGrid.component._childGrids;
            Lyte.arrayUtils( arr, 'removeAt',  arr.indexOf( this._parentGridIndex ) )
        }

        if( this._parentComp ){
            delete this._parentComp._childGrid;
        }
         
        if( document._lyteCurrentGrid == this ){
            delete document._lyteCurrentGrid;
        }
        delete this.scopeElement; delete this._style; this.data.lyteGridStack = []; delete this.data.lyteQuerySelector.previousNode;
        delete this.$node.addGrid; delete this.$node.removeGrid; delete this.$node.reRender; delete this.$node.setProperty;
    },

    rtlfunc : function( lft, node ) {
        if( this.data.direction ) {
            if( lft == 'left' ){
                return 'right';
            } else if( lft == 'right' ){
                return 'left';
            } else if( node == 'clientX' ){
                return window.innerWidth - lft;
            } else if( node == 'bccr' ) {
                return window.innerWidth - lft.right
            } else {
                return node.offsetParent.getBoundingClientRect().right - node.getBoundingClientRect().right ;
            }
        }
        if( node == 'bccr' ) {
            return lft.left;
        }
        return node && node != 'clientX' ? node.offsetLeft : lft;
    },

    windowResize : function( evt ){
         if( evt && evt.type == 'resize' && _lyteUiUtils.isMobile ) {
            return;
        }
        clearTimeout( window._gridResize )
        window._gridResize = setTimeout(function(){
            if( !this.$node.offsetParent ) {
                return
            }
            var minX = this.data.ltPropMinUnitX;
            var wid = this.scopeElement.getBoundingClientRect().width - this.data.gridLength * this.data.ltPropMarginLeft ,
            temp1 = this._initialXRatio * wid;
            this.setData('ltPropUnitxCopy', Math.max(temp1 ,minX)) 
            this.MarginLeftAndXObs.call(this, true);
            this.observerFunc.call(this); 
            delete window._gridResize;
            if(this.getMethods('onWindowResize')){
                $L.fastdom.measure( function(){
                     $L.fastdom.mutate( function(){
                         this.executeMethod('onWindowResize', event, this.$node);
                    }.bind( this ) )
                }.bind( this ) )
            }
        }.bind(this), evt && evt.type == "orientationchange" ? 500 : 250 );    
    },

    MarginLeft : function(){
       this.MarginLeftAndXObs.apply(this, arguments);
    }.observes('ltPropMarginLeft', 'ltPropUnitX'),

    MarginLeftAndXObs : function(flag){
        if(flag.constructor == Object)
            {
                this.setData('ltPropUnitxCopy', this.data.ltPropUnitX );
                this.setData('ltPropMarginLeftCopy', this.data.ltPropMarginLeft );
            }
        var ltPropUnitxCopy = this.getData('ltPropUnitxCopy')
        var margin = this.getData('ltPropMarginLeftCopy')
        this.setData('gridLength', Math.round(((this.scopeElement.getBoundingClientRect().width - margin) / (ltPropUnitxCopy + margin))))
    },

    squareGridObs :  function() {
        if(arguments[0].newValue) {
            this._originalY = this.getData( 'ltPropUnitY' );
            this.setData( 'ltPropUnitY', this.data.ltPropUnitX );
        } else {
            if(this._originalY) {
                this.setData( 'ltPropUnitY', this._originalY );
                delete this._originalY;
            } else {
                this.setData( 'ltPropUnitY', 50 );
            }
        }
    }.observes( 'ltPropSquareGrid' ),

    obsfunc : function(){
        if(this.getData('ltPropSquareGrid')){
            if(arguments[0].item == "ltPropUnitX"){
                this.setData('ltPropUnitY', arguments[0].newValue)
            }else if(arguments[0].item == "ltPropUnitY"){
                this.setData('ltPropUnitX', arguments[0].newValue)
            }
       }
      if(!this._prevObs){
            this.observerFunc.apply(this, arguments);
        }
    }.observes('ltPropUnitX', 'ltPropUnitY', 'ltPropMarginLeft', 'ltPropMarginTop'),

    observerFunc : function(flag){
        var style = this._style;
        if(style){
            this.$node.removeChild(style);
            delete this._style;
            this.initialValSet.call(this, null, !flag);
        }
    },

    freezeobs : function(){
        this.freeezeModeObs.apply(this, arguments);
    }.observes('ltPropFreezeMode'),

    freeezeModeObs : function(arg){
        if(arg.constructor == Object || arg.constructor == Boolean){
            if(arg.oldValue == false || arg == true){
                this.$node.classList.add('gridFreezeMode');
            }
            else if(arg.oldValue == true || arg == false){
                this.$node.classList.remove('gridFreezeMode');
            }
        }
    },

    columnMode : function(arg){
        if(arg.newValue == false)
            {
                 var handQuer = this.getData('ltPropHandler');
                 var iniData = this.getData('iniData');
                 var elements = this.scopeElement.querySelectorAll( handQuer ) ;
                 for(var i = 0; i < elements.length; i++)
                    {
                        for(var yy in iniData[i])
                            {
                                if( iniData[ i ][ yy ] ) {
                                        elements[ i ].setAttribute( 'lyte-grid-' + yy, iniData[ i ][ yy ] );
                                    }
                            }
                    }
                if( this.data.ltPropUnitX == ( this._originalX || this.getData( 'ltPropUnitxCopy' ) )){
                    this.initialValSet( true )
                } else {
                    this.setData('ltPropUnitX', this._originalX || this.getData( 'ltPropUnitxCopy' ));
                }    
            } else {
                this._originalX = this.getData('ltPropUnitxCopy')
                if( arg.item != 'ltPropForcedReposition' ) {
                    this.columnModeLengthFind();
                    this.setData('gridLength', this.gridLength(null, this.getData('ltPropUnitxCopy')));
                }
                this.initialValSet.call(this);
            }
    }.observes('ltPropColumn', 'ltPropColumnMode', 'ltPropForcedReposition' ),

    bestFitObs : function(arg){
        var bestfit  = this._bestfit;
        if(bestfit){
                if( arg.newValue ) {
                    bestfit.classList.add( arg.newValue );
                }
                if( arg.oldValue ){
                    bestfit.classList.remove( arg.oldValue );
                }
            }
    }.observes('ltPropBestfitClass'),

    bfObs : function() {
        var bf = this.getData( 'ltPropBestfit' ), bftype = this.getData( 'ltPropBestfitType' )
        if( bf && bftype == 'grid' ) {
                var color = this.getData( 'ltPropGridSpaceColor' ), MarginLeft = this.getData( 'ltPropMarginLeftCopy' ), marginTop = this.getData( 'ltPropMarginTop' ), unitX = this.getData( 'ltPropUnitxCopy' ), unitY = this.getData( 'ltPropUnitY' );
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + MarginLeft + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + marginTop + 'px,transparent 0px)'; 
                this.scopeElement.style.backgroundSize = ( unitX + MarginLeft ) + 'px ' + ( unitY + marginTop ) + 'px';
                if( this._bestfit ) {
                    if( arguments[0].newValue == 'grid' ) {
                        this._bestfit.classList.add('lyteGrid')
                    }
                    this._bestfit.style.transform = "translate(-" + MarginLeft + "px,-" + marginTop +"px)"

                }
        } else if( !bf || bftype == 'default' ) {
            this.scopeElement.style.removeProperty( 'background-image' );
            this.scopeElement.style.removeProperty( 'background-size' )
            if( this._bestfit ) {
                this._bestfit.style.removeProperty( 'background-image' );
                this._bestfit.style.removeProperty( 'background-size' );
                this._bestfit.style.removeProperty( 'transform' );
                if( arguments[0].newValue == 'default' ) {
                    this._bestfit.classList.remove('lyteGrid')
                }
            }
        }
    }.observes( 'ltPropBestfit', 'ltPropBestfitType' ),

    lengthObs : function(){
        this.setData('gridLength', 0);
        this.$node.reRender();
    }.observes('ltPropGridLength'),

    gridColorObs :  function(arg) {
          if( this.getData( 'ltPropBestfitType' ) == 'grid' && this.getData( 'ltPropBestfit' )) {
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + arg.newValue +' ' + this.getData( 'ltPropMarginLeftCopy' ) + 'px,transparent 0px),linear-gradient(to bottom,'+ arg.newValue + ' ' + this.getData( 'ltPropMarginTop' ) + 'px,transparent 0px)'; 
            }
    }.observes('ltPropGridSpaceColor'), 

    dataSetting : function(elements1, i, columnMode, column,gridLength){
        var data1 = {x : undefined, y : undefined, length : 1, height : 1, nodeName : '', preX : [], preY : [], preLength : [], preHeight : [], component : undefined}
        if(!columnMode)
            {
                data1 = this.initialPosFind.call(this, elements1);
            }
        else
            {
                var tem = parseInt(gridLength / column);
                data1.x = undefined;
                data1.y = undefined;
                data1.length = tem;
                data1.height = parseInt(this.getData('ltPropDefaultHeight'));
                this._dopeHgt = data1.height;
            }    
        data1.nodeName = elements1;
        data1.nodeName.dataSet = {};
        data1.oldX = []; 
        data1.oldY = []; 
        data1.oldLength = []; 
        data1.oldHeight = []; 
        elements1.elemNum = i;
        data1.minLength = elements1.getAttribute('lyte-grid-min-length') ? this.returnWid(elements1.getAttribute('lyte-grid-min-length'), true) : this.returnWid(this.getData('ltPropDefaultMinLength'), true);
        data1.minHeight = elements1.getAttribute('lyte-grid-min-height') ? this.returnWid(elements1.getAttribute('lyte-grid-min-height')) : this.returnWid(this.getData('ltPropDefaultMinHeight'));
        data1.maxLength = elements1.getAttribute('lyte-grid-max-length') ? this.returnWid(elements1.getAttribute('lyte-grid-max-length'), true) : this.returnWid(this.getData('ltPropDefaultMaxLength'), true);
        data1.maxHeight = elements1.getAttribute('lyte-grid-max-height') ? this.returnWid(elements1.getAttribute('lyte-grid-max-height')) : this.returnWid(this.getData('ltPropDefaultMaxHeight'));
        data1.component = this;
        return data1;
    },

    append : function(element, classes, clsName, resizeDir){
        $L.fastdom.mutate(function(){
             var divElem = document.createElement('div');
             if( !element.querySelector( '.lyteGridResize' + '.' + classes[ clsName.indexOf( resizeDir ) ] ) ){
                divElem.setAttribute('class', classes[clsName.indexOf(resizeDir)] + " lyteGridResize");
                element.appendChild(divElem);
            }
        })
    },

    maxPosFind : function(elements, lyteQuerySelector, columnMode, data, flag){
        var  b = [], a = [], c = [], d = [];
        for(var i = 0; i < elements.length; i++ )
                {
                    if(!flag){
                        var retVal = this.emptySpaceFind.call(this, {length : data[i].length, height : data[i].height, x : data[i].x, y : data[i].y, nodeName : data[i].nodeName});
                        if(!elements[ i ]._addGrid || columnMode )
                            {
                                data[i].x = retVal[0].x;
                                data[i].y = retVal[0].y;
                            }  
                        if( elements[ i ]._addGrid ){
                            delete elements[ i ]._addGrid;
                          }  
                        }
                    a.push(data[i].length);             
                    b.push(data[i].height);
                    c.push(data[i].y + data[i].height) 
                    d.push(data[i].x + data[i].length) 
                }
         if(!flag){           
            this.previousPos.call(this, elements, true) 
        }
        lyteQuerySelector.MaxLength = Math.max.apply(null, a.length ? a : [ 0 ]); 
        lyteQuerySelector.MaxHeight = Math.max.apply(null, b.length ? b : [ 0 ]); 
        lyteQuerySelector.MaxBottom = Math.max.apply(null, c.length ? c : [ 0 ]);
        lyteQuerySelector.MaxLeft = Math.max.apply(null, d.length ? d : [ this.getData('gridLength') ]);
    },

    // default css construction and getting data from grids
    initialValSet : function(styleFlag, resizeFlag){
    // collecting data and calculating max height and width of the scope
        var lyteQuerySelector = this.getData('lyteQuerySelector');
        var data = this.getData('lyteGridStack');
        var scope = this.$node.querySelector( this.data.ltPropScope );
        var ltPropUnitxCopy =  parseFloat( this.getData('ltPropUnitxCopy') ), ltPropUnitY =  parseFloat(this.getData('ltPropUnitY')), ltPropUnitX =  parseFloat(this.data.ltPropUnitX );
        var ltPropMarginTop = parseFloat( this.getData('ltPropMarginTop') ), ltPropMarginLeftCopy = parseFloat(this.getData('ltPropMarginLeftCopy'))
        var gridLength  = parseInt(this.getData('gridLength')), columnMode = this.getData('ltPropColumnMode'), column = this.getData('ltPropColumn');
        var thisnodeClient = this.bcrrelem ? this.bcrrelem : this.scopeElement.getBoundingClientRect();
        var resizeDir = this.getData('ltPropResizeDirection');
        lyteQuerySelector.occupied = [];
        lyteQuerySelector.currentPos = 0;
        lyteQuerySelector.verticalMove = true;
        var elements = scope.querySelectorAll( this.data.ltPropHandler );
        scope.dataSet = {};
        lyteQuerySelector.elementCount = [];
        if(!resizeFlag)
            {
                for(var i = 0; i < elements.length; i++ )
                    {
                        data[i] = this.dataSetting.call(this, elements[i], i, columnMode, column, gridLength);
                        lyteQuerySelector.elementCount.push(i);
                        if(this.getData('ltPropResize') == true)
                            {
                                var prevResize = data[i].nodeName.querySelectorAll( '.lyteGridResize' );
                                if(prevResize.length == 0 && data[i].nodeName.getAttribute('lyte-grid-resize') != "disabled")
                                    {
                                        for(var j = 0;j < resizeDir.length;j++ )
                                            {
                                                var classes = ['lyteGridStackLeft', 'lyteGridStackRight', 'lyteGridStackBottom', 'lyteGridStackBottomLeft', 'lyteGridStackBottomRight', 'lyteGridStackTop', 'lyteGridStackTopLeft', 'lyteGridStackTopRight'];
                                                var clsName = ['left', 'right', 'bottom', 'bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight']
                                                if(clsName.indexOf(resizeDir[j]) != -1)
                                                    {
                                                        this.append(elements[i], classes, clsName, resizeDir[j])
                                                    }
                                            }
                                    }
                            }
                    }
                 this.maxPosFind(elements, lyteQuerySelector, columnMode, data)   
                 
        }
        if(this._initialWindowWidth == window.innerWidth){
            this._initialXRatio = ltPropUnitX / ( thisnodeClient.width - this.data.gridLength * this.data.ltPropMarginLeft );
            // this._initialMarginRatio = this.getData('ltPropMarginLeft') / ltPropUnitX  
        }
        $L.fastdom.mutate(function(){
            scope.style.height = ((lyteQuerySelector.MaxBottom) * ltPropUnitY + ((lyteQuerySelector.MaxBottom + 1) * parseInt(this.getData('ltPropMarginTop')))) + 'px'  
            if(this.getData('ltPropBestfitType') == "grid" && this.getData( 'ltPropBestfit' )){
                var color = this.getData('ltPropGridSpaceColor');
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + ltPropMarginLeftCopy + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + ltPropMarginTop + 'px,transparent 0px)'; 
                this.scopeElement.style.backgroundSize = ( ltPropUnitxCopy + ltPropMarginLeftCopy ) + 'px ' + ( ltPropUnitY + ltPropMarginTop ) + 'px';
            }
        }.bind(this))
        if(!styleFlag)    
                {
                    var style = this._style, elem
                    if(!style)     
                        {
                            style = document.createElement('style');
                            style.type = "text/css";
                            style.id = "lyteGridStack";
                            this._style = style;
                            $L.fastdom.mutate(function(){
                                this.$node.appendChild(style)
                            }.bind(this))
                        }
                     var hand = this.$node.querySelectorAll( this.data.ltPropHandler );
                     if(hand && hand.length){
                        for( var ii = 0; ii < hand.length; ii++ ) {
                            hand[ ii ].classList.add( 'lyteGridstackHandler' )
                        }
                     }   
                    // Constructing initial CSS     
                    var totalWid = thisnodeClient.width;
                    this._initialXRatio = ltPropUnitxCopy / ( thisnodeClient.width - this.data.gridLength * this.data.ltPropMarginLeft  );
                    // this._initialMarginRatio = this.data.ltPropMarginLeft / ltPropUnitX 
                    for(var i = 1;i <= Math.max(gridLength , lyteQuerySelector.MaxBottom) + 1;i++ )
                        {
                            if(i <= gridLength)
                                {
                                    if( this.$node.querySelectorAll( '.' + this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridx" + ( i - 1 ) ).length == 0 ) {
                                        elem = this.data.ltPropScope + " " + this.data.ltPropHandler + "[lyte-grid-x = \"" + ( i - 1 ) + "\"]{"+ this.rtlfunc( 'left' ) +":" +  ( ( ( i - 1 ) * ltPropUnitxCopy + ( i * ltPropMarginLeftCopy ) ) * 100 / totalWid ) + "%;}"
                                        this.styleFormation.call(this, elem, this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridx" + (i-1))
                                    }
                                    if( i <= gridLength && this.$node.querySelectorAll( '.' + this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridlength" + ( i - 1 ) ).length == 0 )
                                        {
                                            elem = this.data.ltPropScope + " " +this.data.ltPropHandler + "[lyte-grid-length = \"" + i + "\"]{width:" +  ((i * ltPropUnitxCopy + ((i - 1) * ltPropMarginLeftCopy)) * 100 / totalWid) + "%;}"
                                            this.styleFormation.call(this, elem, this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridlength" + (i-1) )
                                        }
                                }
                            if(i <= lyteQuerySelector.MaxBottom + 1)
                                {
                                    if( this.$node.querySelectorAll( '.' + this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridy" + ( i - 1 ) ).length == 0 ) {
                                        elem =this.data.ltPropScope + " " + this.data.ltPropHandler + "[lyte-grid-y = \"" + (i-1) + "\"]{top:" + ((i - 1) * ltPropUnitY + (i * ltPropMarginTop)) + "px;}"
                                        this.styleFormation.call(this, elem, this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridy" + (i-1))
                                    }
                                    if(i <= lyteQuerySelector.MaxHeight && this.$node.querySelectorAll( '.' + this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridheight" + ( i - 1 ) ).length == 0)
                                        {
                                            elem =this.getData('ltPropScope') + " " + this.data.ltPropHandler + "[lyte-grid-height = \"" + i + "\"]{height:" + (i * ltPropUnitY + (i - 1) * ltPropMarginTop) + "px;}"
                                            this.styleFormation.call(this, elem, this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridheight" + (i-1))
                                        }
                                }   
                        }
                    this.setData('ltPropGridHeight', lyteQuerySelector.MaxBottom)
            }
        this.displayGrid.call(this, null);  
        if(this.bcrrelem){
            delete this.bcrrelem;
        }
    }, 
    // function for finding maximum height of the scope 
    maxHeight : function(data){
            var elements = this.$node.querySelectorAll( this.data.ltPropHandler );
            var b = [], a = [], c = [];
            for(var i = 0;i < elements.length;i++ )
                {   
                    a.push(data[i].length);             
                    b.push(data[i].height);
                    c.push(data[i].y + data[i].height)
                }
            return [Math.max.apply(null,a), Math.max.apply(null,b), Math.max.apply(null,c)] 
    }, 
    // function for Constructing css dynamically while changing lyte-grid-y && lyte-grid-length && lyte-grid-height
    styleFormation : function(elem, id){
                 $L.fastdom.mutate(function(){
                    if( this.$node.querySelectorAll( '.' + id ).length == 0 ) {
                        var style = document.createElement('style');
                        style.type = "text/css";
                        style.setAttribute('class',id)
                        this._style.appendChild(style)
                        style.append(elem)
                    }
                }.bind(this))
    }, 
    // Checking and initiating css construction
    cssConstruct : function(target, attributeName, faldd){
        var data = this.data.lyteGridStack, scope = this.$node.querySelector( this.data.ltPropScope ), lyteQuerySelector = this.data.lyteQuerySelector, elem;
        var lyteGridHeight  = this.returnWid(target.getAttribute('lyte-grid-height'), null, target), lyteGridLength  = this.returnWid(target.getAttribute('lyte-grid-length'), true, target), lyteGridX  = parseInt(target.getAttribute('lyte-grid-x')),lyteGridY = parseInt(target.getAttribute('lyte-grid-y'))
        var ltPropUnitxCopy = this.data.ltPropUnitxCopy, ltPropUnitY = this.data.ltPropUnitY, ltPropMarginTop = this.data.ltPropMarginTop, ltPropMarginLeftCopy = this.data.ltPropMarginLeftCopy
        // Checking for height
        if(attributeName == "lyte-grid-height")
            {     
                var maxOne = Math.max( lyteGridHeight, lyteQuerySelector.MaxHeight )
                for( var i = 0; i <=  maxOne; i++ )
                    {
                        var qr = this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridheight" + i;
                        if( this.$node.querySelectorAll( '.' + qr ).length == 0  ) {
                            elem =this.data.ltPropScope + " " + this.data.ltPropHandler + "[lyte-grid-height = \"" + ( ( i + 1 ) + "\"]{height:" + ( ( i + 1 ) * ltPropUnitY + ( i * ltPropMarginTop))) + "px;}"
                            this.styleFormation.call(this, elem, qr )
                        }
                    }
            }
        // Checking for top position    
        else if(attributeName == "lyte-grid-y")
            {
                if((lyteGridY + (lyteGridHeight)) >= (lyteQuerySelector.MaxBottom))
                    {
                        for(var i = lyteQuerySelector.MaxBottom - lyteGridHeight; i <= (lyteGridY + lyteGridHeight); i++ )
                            {
                                var qr = this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridy" + i ;
                                if( this.$node.querySelectorAll( '.' + qr ).length == 0 ) {
                                    elem =this.data.ltPropScope + " " + this.data.ltPropHandler + "[lyte-grid-y = \"" + (i) + "\"]{top:" + ((i) * ltPropUnitY + (i + 1) * ltPropMarginTop) + "px;}"
                                    this.styleFormation.call(this, elem, qr )
                                }
                            }
                        lyteQuerySelector.previousNode = target   
                    }
            }
         if(["lyte-grid-height", "lyte-grid-y"].indexOf(attributeName) != -1){
               var ret = this.maxHeight(data);
               this.setData('ltPropGridHeight', ret[2])
               if(lyteQuerySelector.MaxBottom > ret[ 2 ])
                    {
                        for(var j = lyteQuerySelector.MaxBottom;j > ret[2];j--)
                            {
                                if(this.$node.querySelector('.'+this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridy" + j ) )
                                    {
                                        var temporary = this._style
                                        if(temporary)
                                            {
                                                var dummy = this.$node.querySelector('.'+this.data.ltPropHandler.replace(/[.|#]/gi,'') + "lytegridy" + j )
                                                if(dummy && dummy.parentElement == temporary)
                                                    {
                                                        // unused styles are removed here
                                                        temporary.removeChild(dummy)
                                                    }
                                            }
                                    }
                            }
                    } 
               lyteQuerySelector.MaxBottom = ret[2]   
           }   
            scope.style.height = ((lyteQuerySelector.MaxBottom) * ltPropUnitY + ((lyteQuerySelector.MaxBottom + 1) * ltPropMarginTop)) + 'px'        
        }, 
    // initiating css construction  
    setVal : function(target, attributeName, attributeValue){
            // can't use fastdom here because of delay causes issue caching previous data
                target.setAttribute(attributeName, attributeValue);
                if(attributeName == 'lyte-grid-y' || attributeName == 'lyte-grid-height' || attributeName == 'lyte-grid-length' || attributeName == 'lyte-grid-x')
                    {
                        this.cssConstruct.call(this, target, attributeName)
                    }
                target.dataSet[attributeName] = attributeValue; 
    }, 
    // initiating css construction  and finding grid positions
    displayGrid : function(x, flag){
                var elements = this.scopeElement.querySelectorAll( this.data.ltPropHandler ), lyteQuerySelector = this.data.lyteQuerySelector;
                var data = this.data.lyteGridStack;
                for(var k = 0;k < elements.length;k++ )
                    {
                        if((k != x) && !flag || (flag && k == x))
                            {
                                this.setVal(elements[k], 'lyte-grid-y', data[k].y)  
                                this.setVal(elements[k], 'lyte-grid-x', data[k].x)
                                if(data[k].length != data[k].nodeName.getAttribute('lyte-grid-length-old'))
                                    {   
                                        this.setVal(elements[k], 'lyte-grid-length', data[k].length, true)
                                    }
                                if(data[k].height != data[k].nodeName.getAttribute('lyte-grid-height-old'))
                                    {
                                        this.setVal(elements[k], 'lyte-grid-height', data[k].height)
                                    }
                            }
                    }
                this.scopeElement.dataSet['lt-prop-grid-height'] = lyteQuerySelector.MaxBottom
                this.scopeElement.dataSet['lt-prop-grid-length'] = parseInt( this.data.gridLength )   
                 $L.fastdom.mutate(function(){
                     this.positionFind.call(this, elements)
                 }.bind(this))
                        
        }, 
    // To find all grid positions   
    positionFind : function(elements){
                elements = elements || this.scopeElement.querySelectorAll( this.data.ltPropHandler );
                var xCor = [], yCor = [], xCorEnd = [], yCorEnd = [], x = [], y = [], a = [], b = [], Max, data = this.getData('lyteGridStack');
                for(var k = 0;k < elements.length;k++ )
                    {
                        if( !data[k] ){
                            continue;
                        }
                        x.push(data[k].x);
                        y.push(data[k].y);
                        a.push(data[k].x + data[k].length);
                        b.push(data[k].y + data[k].height);
                    }
                Max = Math.max(Math.max.apply(null,x), Math.max.apply(null,y), Math.max.apply(null,a), Math.max.apply(null,b));
                for(var j = 0;j <= Max;j++ )
                    {
                        x = [], y = [], a = [], b = [];
                        for(var i = 0;i < data.length;i++ )
                            {   
                                if(data[i].x <= j && j <= data[i].x + data[i].length)
                                    {
                                        x.push(i);
                                    }   
                                if(data[i].y <= j && j <= data[i].y + data[i].height)
                                    {
                                        y.push(i);
                                    }               
                            }
                        xCor.push(x);
                        yCor.push(y);
                    }
                Lyte.arrayUtils(this.data.xElements, 'remove', 0, this.data.xElements.length)
                Lyte.arrayUtils(this.data.xElements, 'concat', xCor)    
                Lyte.arrayUtils(this.data.yElements, 'remove', 0, this.data.yElements.length)
                Lyte.arrayUtils(this.data.yElements, 'concat', yCor)      
       
    }, 
    // To remove same elements from Checking    
    multipleRemoval : function(elementsToCheck){
            elementsToCheck = elementsToCheck || [];
            for(var z = 0;z < elementsToCheck.length;z++ )
                {
                    for(var y = z + 1;y < elementsToCheck.length;y++ )
                    {
                        if(elementsToCheck[z] == elementsToCheck[y])
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', y)
                            y--;
                        }
                    }
                }
             return elementsToCheck 
    }, 
    // To check elements in hori and vertical directions
    similarData : function(elementsToCheck1, elementsToCheck2){
            var temp = []
            if(!(elementsToCheck1 == undefined || elementsToCheck2 == undefined))
                {
                    for(var i = 0;i < elementsToCheck1.length;i++ )
                        {
                            for(var j = 0;j < elementsToCheck2.length;j++ )
                                {
                                    if(elementsToCheck1[i] == elementsToCheck2[j])
                                        {
                                            temp.push(elementsToCheck1[i]);
                                            break;
                                        }
                                }
                        }
                }
            else
                {
                    temp = elementsToCheck1 ? elementsToCheck1 : elementsToCheck2;
                }   
            return temp;    
    }, 
    // To find the other elements on selected element
    elementCheck : function(element, node, flag){
            var elementsToCheck = [], k, xElements = this.getData('xElements'), dum = 1;
             var data = this.getData('lyteGridStack');
            if(data[node.elemNum].length > 1)
                {
                    if(flag)
                        {
                            k = data[node.elemNum].x
                            dum = 0;
                        }
                    else
                        {
                             k = data[node.elemNum].x + 1;
                        } 
                   elementsToCheck = this.yElementsFind( k, data[node.elemNum].x + data[node.elemNum].length - dum, xElements)       
                }
            else
                {
                    elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x + 1])
                }
            if(elementsToCheck)                 
                {
                    return this.multipleRemoval.call(this, elementsToCheck);    
                }
            else
                {
                    return [];
                }   
    }, 
    // To find clicked Pos
    nodeName : function(event){
            var nodeName = event.target.correspondingElement || event.target;
            if(nodeName) {
                var flag = false, val;
                var element = this.$node.querySelector( this.data.ltPropScope );
                if( event.type == 'mousedown' || !event.type ) {
                    while( nodeName && nodeName != element && nodeName.classList && nodeName.tagName != "BODY" && nodeName.tagName != "HTML")
                        {
                            if(nodeName.classList.contains('lyteGridStackLeft'))
                                {
                                    val = 'left'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackRight'))
                                {
                                    val = 'right'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottom'))
                                {
                                    val = 'bottom'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottomLeft'))
                                {
                                    val = 'BottomLeft'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottomRight'))
                                {
                                    val = 'BottomRight'
                                    flag = true
                                    break;
                                } 
                            else if(nodeName.classList.contains('lyteGridStackTop'))
                                {
                                    val = 'top'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackTopLeft'))
                                {
                                    val = 'topLeft'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackTopRight'))
                                {
                                    val = 'topRight'
                                    flag = true
                                    break;
                                }       
                            else if(nodeName.tagName == 'LYTE-GRID-CONTENT')
                                {
                                    val = 'content'
                                    flag = true
                                    break;
                                }           
                            else
                                {
                                    nodeName = nodeName.parentNode;
                                } 
                        }
                    if(nodeName != element && flag)
                        {
                            return [val, nodeName.parentElement, nodeName.parentElement.parentElement];
                        }
                } else if( event.type == 'click' ) {
                    while( nodeName && nodeName != element && nodeName.classList && nodeName.tagName != "BODY" && nodeName.tagName != "HTML" ) {
                        if( nodeName.classList.contains( 'lyteGridstackHandler' )  && nodeName.querySelectorAll( '.lyteGridResize' ).length) {
                            flag = true;
                            break;
                        } else {
                            nodeName = nodeName.parentNode;
                        } 
                    }
                    if( flag ) {
                        return nodeName
                    }
                }
            }
         return null;
    },
    // updating value on every changes 
    valueUpdating : function(i, x, attributeName){
        var data = this.getData('lyteGridStack')
        if(data[i][x] != data[i].nodeName.dataSet[attributeName])
            {
                data[i].nodeName.dataSet[attributeName + '-old'] =  data[i].nodeName.dataSet[attributeName]
                data[i].nodeName.dataSet[attributeName] = parseInt(data[i][x])
            }
    }, 
    // Number of elements adjacent around selected elements
    bottomElementsCount : function(node, direction){
        var x, y, length, height, yElements1, xElements1, offsetLeft, initialLeft, lytegridlength, x, ltPropMarginLeftCopy, ltPropUnit ;
        if(direction == 'vertical')
            {
                x = 'y', y = 'x', length = 'height', height = 'length', yElements1 = 'xElements', xElements1 = 'yElements', offsetLeft = 'offsetTop', lytegridlength = 'lyte-grid-height', ltPropMarginLeftCopy ='ltPropMarginTop', ltPropUnit = 'ltPropUnitY'
            }
        else
            {
                x = 'x', y = 'y', length = 'length', height = 'height', yElements1 = 'yElements', xElements1 = 'xElements', offsetLeft = 'offsetLeft', lytegridlength = 'lyte-grid-length', ltPropMarginLeftCopy ='ltPropMarginLeftCopy', ltPropUnit = 'ltPropUnitxCopy'
            }
        var data = this.getData('lyteGridStack'), yElements = this.getData(yElements1), xElements = this.getData(xElements1), elementsToCheck = [], elementsToCheck1 = [], elementsToCheck2 = [];
        if(data[node.elemNum][length] > 1)
            {
                elementsToCheck = this.yElementsFind(data[node.elemNum][x] + 1, data[node.elemNum][x] + data[node.elemNum][length] - 1, xElements)
            }
        else
            {
                elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum][x]], xElements[data[node.elemNum][x] + data[node.elemNum][length]])
            }  
        elementsToCheck1 = this.multipleRemoval.call(this, elementsToCheck1.concat(yElements[data[node.elemNum][y] + data[node.elemNum][height]]))
        elementsToCheck2 = this.multipleRemoval.call(this,elementsToCheck2.concat(yElements[data[node.elemNum][y]]))
        elementsToCheck = this.multipleRemoval.call(this, elementsToCheck)  
        if(elementsToCheck1.length)
            {
                Lyte.arrayUtils(elementsToCheck1, 'removeAt', elementsToCheck1.indexOf(node.elemNum));
            }
        if(elementsToCheck2.length)
            {
                Lyte.arrayUtils(elementsToCheck2, 'removeAt', elementsToCheck2.indexOf(node.elemNum));
            }
        if(elementsToCheck.length)
            {    
                Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum));
            }
        var array = [];
        array[array.length] = this.similarData.call(this, elementsToCheck, elementsToCheck1).length
        array[array.length] = this.similarData.call(this, elementsToCheck, elementsToCheck2).length
        return array;
    },

     returnY : function(node, flag){
        var offtop, margin, unit, ret;
        if(flag) {
            offtop = "offTop", margin = this.getData('ltPropMarginTop'), unit = this.getData('ltPropUnitY')
        } else {
            offtop = "offLeft", margin = this.getData('ltPropMarginLeftCopy'), unit = this.getData('ltPropUnitxCopy')
        }
        return  parseInt( ( ( node[ offtop ] - margin ) / ( unit + margin ) ).toFixed( 0 ) );
     }, 

     scrollCheckY : function( node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollWidth, scrollLeft, flag, flag2) {
        if( this._scrollCheck && !flag2) {
            return
        }
        var al, scrollTop = "scrollTop", topPos = "top", clientY = "clientY", bottom = "bottom", prevEvY = 'prevEvY', prevEvX = 'prevEvX', clientX = "clientX", width = "height", scrWid = "scrollHeight";
        if( flag ) {
            scrollTop = "scrollLeft", topPos = "left", clientY = "clientX", bottom = "right", prevEvY = 'prevEvX', prevEvX = 'prevEvY', clientX = "clientY", width = "width", scrWid = "scrollWidth";
        }


        if(  thisClientRect[width] >= scrollWidth || Math.abs(  thisClientRect[ width ] - scrollWidth ) < 1 ){
            return
        }
        if( _lyteUiUtils.isIos && thisClientRect[ this.rtlfunc( bottom ) ] > innHgt ){
            return
        }
        function shouldPrevent( obj, sW, sL, mode, val, dir ){
            var wd = mode ? 'height' : 'width';
            if( ( val > 0 && sL  + obj[ wd ] >= sW  ) || ( val < 0 && -sL + obj[ wd ] >= sW ) ){
                return false
            } else if( !mode && this.isSaf.firefox && dir && ( val < 0 && sL == 0 ) ){
                return true
            } else if( ( val < 0 && sL == 0 ) && !( val < 0 && this.isSaf.safari && dir && sL == 0 ) ){
                return false;
            }
            return true
        }
        var check1 = Math.max( thisClientRect[ topPos ], 0 ) > Math.min( nodeClientRect[ topPos ], event[ clientY ] ) && !( thisClientRect[ bottom ] < nodeClientRect[ bottom ] ) && ( event[ clientY ] < node[ prevEvY ] || node[ prevEvY ] == undefined ),
        check2 = Math.min( thisClientRect[ bottom ], innHgt ) < Math.max( nodeClientRect[ bottom ], event[ clientY ] ) && !( thisClientRect[ topPos ] > nodeClientRect[ topPos ] ) && ( event[ clientY ] > node[ prevEvY ] || node[ prevEvY ] == undefined ),
        sT = this.$node[ scrollTop ], isIE = ( this.isSaf.isEdgeLyte || this.isSaf.isIE11Lyte ) && this.data.direction ? -1 : 1 ;
        if( shouldPrevent.call( this, thisClientRect, scrollWidth, scrollLeft, !flag, -unitY * isIE, this.data.direction ) && check1 ) {
            this.$node[ scrollTop ] -= 1 * unitY * isIE; al = true;
        } else if( shouldPrevent.call( this, thisClientRect, scrollWidth, scrollLeft, !flag, unitY * isIE, this.data.direction ) && check2 ) {
            this.$node[ scrollTop ] += 1 * unitY * isIE; al = true;
        } else {
            window.cancelAnimationFrame( this._reqId );
            delete this._reqId;
            delete  this._scrollCheck;
            node[ prevEvY ] = event[ clientY ]
            return;
        }
       if( al ) {
           this._scrollCheck = true;
           this._reqId = window.requestAnimationFrame( function() {
                nodeClientRect = node.getBoundingClientRect();
                this.scrollCheckY.call( this, node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollWidth, this.$node[ flag ? 'scrollLeft' : 'scrollTop' ], flag, true )
           }.bind( this ) ) 
       }
     },

    resetInitial : function( node, newoffleft, newofftop, offLeft, offTop ){
        var initialLeft = node.initialLeft,
        initialTop = node.initialTop;

        if( newoffleft > initialLeft && newoffleft < offLeft ){
            node.initialLeft = offLeft;
        } else if( newoffleft < initialLeft && newoffleft > offLeft ){
             node.initialLeft = offLeft;
        }

        if( newofftop > initialTop && newofftop < offTop ){
            node.initialTop = offTop;
        } else if( newofftop < initialTop && newofftop > offTop ){
            node.initialTop = offTop;
        }

    },


    checkLeftandWidth : function( left, nodeClientRect, MarginLeft, thisClientRect, newWidth ){
        var wid = newWidth == undefined ? nodeClientRect.width : newWidth;

        if( left + wid + MarginLeft > thisClientRect.width ){
            left = thisClientRect.width - MarginLeft - wid;
        }
        if( left < MarginLeft ) {
            left = MarginLeft;
        }
        return left;
    },

    checkTop : function( topPos, marginTop ){
        if( topPos < marginTop ) {
            topPos = marginTop;
        }
        return topPos;
    },

    widthcheck : function( tempWid, node, thisClientRect, MarginLeft ){
        if( thisClientRect.width - MarginLeft < node.offLeft + tempWid ){
            tempWid = thisClientRect.width - MarginLeft - node.offLeft;
        }
        return tempWid;
    },

    // Initial function on mousemove    
    mousemoveFun : function(element, event){
    // event.preventDefault()    
    if( this._scrollCheck ) {
        return
    }

    this._gridMoved = true;

    var lyteQuerySelector = this.elementSorting.call(this, this.data.lyteQuerySelector ), data = this.getData('lyteGridStack');
    if( !lyteQuerySelector.previousPosFind ) {
        lyteQuerySelector.previousPosFind = true;
        this.getMethods( 'onDragStart' ) && this.executeMethod( 'onDragStart', this.retNode( lyteQuerySelector.SelectedNodes, data ), this.$node );
    }
    for(var z = 0;z < lyteQuerySelector.SelectedNodes.length; z++)
        {   
            var i, j, k, left, flag = true, stackElements = [], stackElements1 = [], flag1 = true, flag2 = true, elementsToCheck = [], elementsToCheck1 = [], btmEl, btmEl1,
            node = data[lyteQuerySelector.SelectedNodes[z]].nodeName, valMove,
            xIni = node.xPos,
            yIni = node.yPos,
            elements = element.querySelectorAll( this.data.ltPropHandler ),
            xPos = this.rtlfunc( event.clientX, 'clientX' ),
            yPos = event.clientY,
            gridLength = this.data.gridLength, gridHeight = this.data.ltPropGridHeight,
            xElements = this.data.xElements,
            yElements = this.data.yElements,
            unitX = this.data.ltPropUnitxCopy, unitY = this.data.ltPropUnitY,
            marginTop = this.data.ltPropMarginTop,
            MarginLeft = this.data.ltPropMarginLeftCopy, dumm, prevent = this.data.ltPropPrevent,
            oldOffLeft = node.offLeft, oldOffTop = node.offTop,
            containment = this.getData( 'ltPropContainment' );

            node.offLeft = this.rtlfunc( 'offsetLeft', node ), node.offTop = node.offsetTop;
            node.classList.add( 'lyteGridStackMove' );
            var thisClientRect = this.$node.getBoundingClientRect(), scrollWidth = this.$node.scrollWidth, scrollHeight = this.$node.scrollHeight, nodeClientRect = node.getBoundingClientRect(), innWid = window.innerWidth,
            scrollLeft = this.$node.scrollLeft, scrollTop = this.$node.scrollTop, innHgt = window.innerHeight,
            scopeBcr = element.getBoundingClientRect();
            i = node.elemNum;
            if(data[i].length != parseInt(node.getAttribute('lyte-grid-length')) || data[i].height != parseInt(node.getAttribute('lyte-grid-height')) || ((node.offLeft < node.initialLeft) && (node.offTop < node.initialTop)))
                {
                    flag2 = true
                }
            else if((data[i].x) == parseInt(node.getAttribute('lyte-grid-x')))
                {
                    flag2 = false
                }
            else if(node.offTop > (node.initialTop + unitY))
                {
                    flag2 = false
                }           
            if(node.flag)   
                {
                    left = xPos - xIni;
                    var topPos = yPos-yIni; 
                    if(!prevent.horizontal){
                        if( containment ){
                            left = this.checkLeftandWidth( left, nodeClientRect, MarginLeft, scopeBcr );
                        } 
                        node.style[ this.rtlfunc( 'left' ) ] = (left) + 'px';
                        node.offLeft = left;
                    }
                    if(!prevent.vertical){
                        if( containment ){
                            topPos = this.checkTop( topPos, marginTop );
                        }
                        node.style.top = topPos + 'px'; 
                        node.offTop = topPos;
                    }
                    var temppp = this.returnY( node );
                    if(temppp != data[i].x){
                        dumm = true
                    }
                    data[i].x = temppp > 0 ? temppp : 0;
                    data[i].x = data[i].x > (gridLength - data[i].length) ? (gridLength - data[i].length) : data[i].x;
                    if( data[ i ].x < 0 ){
                        data[ i ].length -= data[ i ].x;
                        data[ i ].x = 0;
                    }
                    this.scrollCheckY.call( this, node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollHeight, scrollTop)
                    this.scrollCheckY.call( this, node , thisClientRect, unitX, nodeClientRect, innWid, event, scrollWidth, scrollLeft, true )
                }
            else
                {
                    // resizing functions
                    var minWidth = ( data[ i ].minLength * unitX + ( ( data[ i ].minLength - 1 ) * MarginLeft ) )
                    var maxWidth = ( data[ i ].maxLength * unitX + ( ( data[ i ].maxLength - 1 ) * MarginLeft ) )
                    var minHgt = ( data[ i ].minHeight * unitY + ( ( data[ i ].minHeight - 1 ) * marginTop ) );
                    var maxHgt = ( data[ i ].maxHeight * unitY + ( ( data[ i ].maxHeight - 1 ) * marginTop ) );
                    if( !prevent.horizontal && ( [ 'right', 'BottomRight', 'topRight' ].indexOf( node.value ) != -1 ) && (node.xOff + xPos -  this.rtlfunc( nodeClientRect, 'bccr' ) ) >= unitX)
                        {
                            var tempWid = node.xOff + xPos- this.rtlfunc( nodeClientRect, 'bccr' ) ;
                            
                            if( maxWidth >= minWidth ){
                                tempWid = Math.min( Math.max( tempWid, minWidth ), maxWidth );
                            } else {
                                tempWid = Math.max( tempWid, minWidth );
                            }

                            if( containment ){
                                tempWid = this.widthcheck( tempWid, node, scopeBcr, MarginLeft );
                            }

                            node.style.width = tempWid + 'px';  

                            data[ node.elemNum ].length = Math.min( parseInt( ( ( tempWid + MarginLeft ) / ( MarginLeft + unitX ) ).toFixed( 0 ) ), gridLength - data[ node.elemNum ].x );
      
                        }
                    else if(!prevent.horizontal && ([ 'left', 'BottomLeft', 'topLeft' ].indexOf( node.value ) != -1 ) && (node.xOff + Math.abs(xPos - this.rtlfunc( nodeClientRect, 'bccr' ) - nodeClientRect.width)) >= unitX)
                        {
                            var currentLeft = node.offLeft,
                            newLeft = xPos - xIni,
                            leftIncrease = newLeft - currentLeft,
                            newWidth = nodeClientRect.width;

                            if( containment ){
                                newLeft = this.checkLeftandWidth( newLeft, nodeClientRect, MarginLeft, scopeBcr, nodeClientRect.width - leftIncrease );
                            }

                            leftIncrease = newLeft - currentLeft;
                            newWidth -= leftIncrease;

                            if( newWidth > 0 && newWidth >= minWidth && (newWidth <= maxWidth || maxWidth < 0 ) )
                                {
                                    node.style.width = newWidth + 'px'
                                    node.style[ this.rtlfunc( 'left' ) ] = newLeft + 'px';
                                    node.offLeft = newLeft;
                                }

                             var leftToSet = Math.max( 0, this.returnY( node ) );

                             data[ node.elemNum ].length -= ( leftToSet - data[ node.elemNum ].x );
                             data[ i ].x = leftToSet;  
                        }   
                    
                    if(!prevent.vertical && ([ 'BottomRight' , 'BottomLeft', 'bottom' ].indexOf(node.value) != -1) && (node.yOff + yPos - nodeClientRect.top) >= unitY)
                        {
                            var tempHgt = node.yOff + yPos - nodeClientRect.top;
                            if(maxHgt >= minHgt)
                                {
                                    node.style.height = Math.min(Math.max(tempHgt, minHgt), maxHgt) + 'px';
                                }
                            else
                                {
                                    node.style.height = Math.max(tempHgt, minHgt) + 'px';
                                }   
                            data[node.elemNum].height = parseInt(((( node.style.height ? parseInt( node.style.height ) : nodeClientRect.height ) + marginTop)/(marginTop + unitY)).toFixed(0))                              
                        } 
                   else if(!prevent.vertical && (['top', 'topRight', 'topLeft' ].indexOf(node.value) != -1) && ( node.yOff + Math.abs( yPos - nodeClientRect.top - nodeClientRect.height ) ) >= unitY ) {
                        
                        var currentTop = node.offTop,
                        newTop = yPos - yIni,
                        topIncrease,
                        newHeight = nodeClientRect.height;

                        if( containment ){
                            newTop = this.checkTop( newTop, marginTop );
                        }

                        topIncrease = newTop - currentTop;
                        newHeight -= topIncrease;

                        if( newHeight > 0 && newHeight >= minHgt && ( newHeight <= maxHgt || maxHgt < 0 ) )
                            {
                                node.style.height = newHeight + 'px'
                                node.style.top = newTop + 'px';
                                node.offTop = newTop;
                            }

                         var topToSet = Math.max( 0, this.returnY( node, true ) );

                         data[ node.elemNum ].height -= ( topToSet - data[ node.elemNum ].y );
                         data[ i ].y = topToSet;  
                   }

                   if( this._parentGrid ) {
                        node._percentHeight = ( ( node.style.height ? parseInt( node.style.height )  : nodeClientRect.height + 2 * marginTop ) * 100 / thisClientRect.height ) + '%';
                        node._percentLength = ( ( node.style.width ? parseInt( node.style.width )  : nodeClientRect.width + 2 * MarginLeft) * 100 / thisClientRect.width ) + '%';
                   }        
                } 
            var btmEl = this.bottomElementsCount.call(this, node, 'horizontal'),btmEl1 = this.bottomElementsCount.call(this, node, 'vertical')
            if(node.initialTop > node.offTop && !prevent.vertical)
                {
                    this.verticalMoveBottomToTop.call(this, element, node)
                }
            else if(node.initialTop < node.offTop && !prevent. vertical)
                {
                    this.verticalMoveTopToBottom.call(this, element, node)
                }
            if(!prevent.horizontal){    
                if((btmEl1[0] != 0 && (node.offLeft > node.initialLeft)) || !node.flag || (btmEl1[1] != 0 && node.initialLeft > node.offLeft && data[node.elemNum].height <= parseInt(node.getAttribute('lyte-grid-height'))) || ((data[i].length) > node.dataSet['lyte-grid-length-old']) && data[node.elemNum].height <= parseInt(node.getAttribute('lyte-grid-height')))       
                    {
                        this.topCheck.call(this, node, element);  
                        if(!this.getData('ltPropFloat'))
                            {
                                this.topMoveFunc.call(this, node, null, null, null, true);
                            }
                    }
            }   
              // offsets are continuously changing during mousemove and grid interchanges. so it is nescessary to calculate offsets 
            if(!prevent.vertical){
                if(flag2|| (btmEl[0] == 0 && node.initialTop < node.offTop) || (btmEl[1] == 0 && node.initialTop > node.offTop) || !this.getData('ltPropFloat'))
                    {
                        var temp = parseInt(((node.offTop - marginTop)/(unitY + marginTop)).toFixed(0))
                        if( [ 'top', 'topLeft', 'topRight' ].indexOf( node.value ) != -1 ) {
                             data[i].y = temp
                        } else {
                            if( ( btmEl[ 0 ] == 0 && node.initialTop < node.offTop ) )
                                {
                                    if( data[ i ].y <= temp ) {
                                            data[i].y = temp
                                    }
                                }
                            else if( ( btmEl[ 1 ] == 0 && node.initialTop > node.offTop ) )
                                {
                                    if( data[ i ].y >= temp ){
                                            data[i].y = temp
                                    }
                                }
                        }
                        data[ i ].y = data[ i ].y > 0 ? data[ i ].y : 0;
                    }
            }
            if(dumm || data[node.elemNum].x != parseInt(node.getAttribute('lyte-grid-x')) || data[node.elemNum].length != parseInt(node.getAttribute('lyte-grid-length')) || data[node.elemNum].height != parseInt(node.getAttribute('lyte-grid-height')))    
                {    
                    this.valueUpdating.call(this, i, 'x', 'lyte-grid-x')
                    this.valueUpdating.call(this, i, 'y', 'lyte-grid-y')
                    this.valueUpdating.call(this, i, 'length', 'lyte-grid-length')
                    this.valueUpdating.call(this, i, 'height', 'lyte-grid-height')        
                    this.positionFind.call(this, elements)        
                    var l, count = 0, stackElements = [];
                    var data = this.getData('lyteGridStack');
                    if((node.initialLeft > node.offLeft || node.initialLeft < node.offLeft) || (node.dataSet['lyte-grid-length-old'] > data[node.elemNum].length))
                        {
                            elementsToCheck =  xElements[data[node.elemNum].x].concat(xElements[data[node.elemNum].x + data[node.elemNum].length])
                        }   
                    elementsToCheck1 = this.yElementsFind.call(this, data[node.elemNum].y + data[node.elemNum].height, lyteQuerySelector.MaxBottom, yElements)    
                    elementsToCheck = this.multipleRemoval.call(this, this.similarData.call(this, elementsToCheck, elementsToCheck1))
                    if(elementsToCheck.indexOf(node.elemNum) != -1) 
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                        }
                    for(l = 0;l < elementsToCheck.length;l++ )
                        {
                            if(data[node.elemNum].y + data[node.elemNum].height <= data[elementsToCheck[l]].y + 1)
                                {
                                    if((((node.initialLeft > node.offLeft) && data[elementsToCheck[l]].x == data[node.elemNum].x + data[node.elemNum].length)) || ((node.initialLeft < node.offLeft) && data[node.elemNum].x == data[elementsToCheck[l]].x + data[elementsToCheck[l]].length) || (node.dataSet['lyte-grid-length-old'] - data[node.elemNum].length == 1))
                                        {
                                            valMove = this.heightGet.call(this, data[elementsToCheck[l]].nodeName)
                                            if(!!valMove)
                                                {
                                                    flag1 = false
                                                    count = data[elementsToCheck[l]].y;
                                                    data[elementsToCheck[l]].y = data[elementsToCheck[l]].y - ( this.getData('ltPropFloat')? (data[elementsToCheck[l]].y - valMove < data[node.elemNum].y) ? data[elementsToCheck[l]].y - data[node.elemNum].y :valMove : valMove )
                                                    this.valueUpdating.call(this, elementsToCheck[l], 'y', 'lyte-grid-y')
                                                    this.positionFind.call(this, elements );
                                                    this.topMoveFunc.call(this, data[elementsToCheck[l]].nodeName, count, false, node);
                                                    this.displayGrid.call(this, node.elemNum);
                                                    break;
                                                }
                                        }
                                }
                        }
                    if((data[node.elemNum].y < (parseInt(node.getAttribute('lyte-grid-y'))) || (node.initialTop - node.offTop > parseInt(marginTop))) && !this.getData('ltPropFloat'))
                        {
                            this.topMoveFunc.call(this, node, parseInt(node.getAttribute('lyte-grid-y')), false, node);
                        }
                    if((data[node.elemNum].height > node.dataSet['lyte-grid-height-old'] && !node.flag))
                        {
                             lyteQuerySelector.verticalMove = false
                            node.setAttribute('lyte-grid-height', data[node.elemNum].height)
                            this.verticalCheck.call(this, data[node.elemNum], data[node.elemNum].y + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, node, true)
                            this.displayGrid.call(this, node.elemNum);
                        }   
                    else if((data[node.elemNum].height < node.dataSet['lyte-grid-height-old'] && !node.flag))
                        {
                            lyteQuerySelector.verticalMove = false
                            node.setAttribute('lyte-grid-height', data[node.elemNum].height)
                            this.topMoveFunc.call(this, node, data[node.elemNum].y, true);
                            this.displayGrid.call(this, node.elemNum);
                        }       
                    // event.preventDefault();
                    if(!this.getData('ltPropFloat'))   
                        {
                            this.topMoveAllGrid.call(this, node, data)
                        }
            } else if( this.getData( 'ltPropCheckCurrentPosition' ) ) {
                this.positionFind.call( this );
            }
        if(!this.getData('ltPropFloat'))   
            {
                valMove = this.heightGet.call(this, node)
            }
        else
            {
                valMove = 0
            }  
        this.getMethods('onDrag') && this.executeMethod('onDrag', node, event, this.$node);
        this.resetInitial( node, node.offLeft, node.offTop, oldOffLeft, oldOffTop );
    }
    var bestFit = this._bestfit;
    if(bestFit && node && this.getData('ltPropBestfit') && lyteQuerySelector.SelectedNodes.length == 1)
        {
                var offsetBestfit = this.getData('ltPropBestfitType');
                bestFit.style[ this.rtlfunc( 'left' ) ] = (data[node.elemNum].x * unitX + ( ( data[node.elemNum].x + 1) * MarginLeft )) + 'px';
                bestFit.style.top = (( data[node.elemNum].y - valMove ) * unitY + ((data[node.elemNum].y + 1 - valMove) * marginTop)) + 'px';
                bestFit.style.width = (data[node.elemNum].length * unitX + (data[node.elemNum].length - 1) * MarginLeft + (offsetBestfit == "grid" ? MarginLeft : 0)) + 'px';
                bestFit.style.height = ((data[node.elemNum].height) * unitY + (data[node.elemNum].height-1) * marginTop + (offsetBestfit == "grid" ? marginTop : 0)) + 'px';
                bestFit.style.display = "block";
                if(offsetBestfit == 'grid'){
                     var color = this.getData('ltPropGridSpaceColor')
                     bestFit.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + MarginLeft + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + marginTop + 'px,transparent 0px)' 
                     bestFit.style.backgroundSize = ( MarginLeft + unitX ) + 'px ' + ( unitY + marginTop ) + 'px';
                     bestFit.style.transform = "translate(-" + ( this.data.direction ? 0 : MarginLeft ) + "px,-" + marginTop +"px)"
                 }
        
        }
    },

    topMoveAllGrid : function(node, data){
        // this.positionFind.call(this, elements)
        var yElements = this.getData('yElements');
        var max = node.constructor == Number ? node : data[ node.elemNum ].y + data[ node.elemNum .height * 2];
        var elementCount = this.similarData(this.elementSorting(this.yElementsFind( node.constructor == Number ? node : ( data[ node.elemNum ].y + data[ node.elemNum ].height ), Math.min(this.getData('lyteQuerySelector').MaxBottom, isNaN(max) ? this.getData('lyteQuerySelector').MaxBottom : max ), yElements)));
        for(var j = 0; j < elementCount.length; j++){
            if(elementCount[j] != node.elemNum){
                var htmve = this.heightGet.call(this, data[elementCount[j]].nodeName)
                if(htmve)
                    {
                        data[elementCount[j]].y = data[elementCount[j]].y - htmve/*( this.getData('ltPropFloat')? htmve >= data[node.elemNum].height ? data[elementCount[j]].y - data[node.elemNum].y :htmve : htmve )*/
                        this.valueUpdating.call(this, elementCount[j], 'y', 'lyte-grid-y')
                        this.topMoveFunc.call(this, data[elementCount[j]].nodeName, data[elementCount[j]].y);
                        this.displayGrid.call(this, elementCount[j], true);
                    }
            }

        }
    },
    // check for movement from bottom to top
    verticalMoveBottomToTop : function(element, node){
            $L.fastdom.measure(function(){
                var topElements = [], i, temp1 = 0, ht = 0, flag = true, elementsToCheck = [], elementsToCheck1 = [];
                var ltPropFloat = this.getData('ltPropFloat'), ltPropMarginTop = this.getData('ltPropMarginTop'),data = this.getData('lyteGridStack'),
                forceTop = this.getData( 'ltPropCheckCurrentPosition' );

                elementsToCheck = this.elementCheck.call(this, element, node);
                temp1 = forceTop ? this.returnY( node, true ) : data[ node.elemNum ].y ;
                elementsToCheck1 = this.getData('yElements')[ Math.max( 0, temp1 ) ];
                // offsets are continuously changing during mousemove and grid interchanges. so it is nescessary to calculate offsets 
                var nodeOff = node.offTop;
                if(elementsToCheck1)
                    {
                        elementsToCheck = this.similarData.call(this, elementsToCheck, elementsToCheck1)
                    }
                if(elementsToCheck.indexOf(node.elemNum) != -1) 
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        // height and other grids offset are required here
                        var topPos = data[ elementsToCheck[ i ] ].nodeName.offsetTop,
                        allow;

                        allow = forceTop ?
                           ( ( nodeOff < ( topPos + data[ elementsToCheck[ i ] ].nodeName.offsetHeight - 0.5 * ltPropMarginTop ) ) && ( nodeOff > ( topPos + ltPropMarginTop ) || temp1 <= 0 ) &&( temp1 < data[ elementsToCheck[ i ] ].y + data[ elementsToCheck[ i ] ].height && ( temp1 > data[ elementsToCheck[ i ] ].y || temp1 <= 0 ) ) && ( node.initialTop > nodeOff ) ) :
                           ( ( nodeOff < ( topPos + data[ elementsToCheck[ i ] ].nodeName.offsetHeight - 0.5 * ltPropMarginTop ) ) && ( nodeOff > ( topPos + ltPropMarginTop ) ) &&( data[ node.elemNum ].y == data[elementsToCheck[ i ] ].y + data[ elementsToCheck[ i ] ].height ) && ( node.initialTop > nodeOff ) )

                        if ( allow ) {
                            topElements[topElements.length] = elementsToCheck[i];
                        }
                    }
                if(topElements.length)
                    {
                        topElements = this.elementSorting.call(this, topElements || [ ])
                        this._occupied = topElements.slice();
                        for(var i = 0; i < topElements.length; i++)
                          { 
                            ht = this.heightGet.call(this, node, data[topElements[i]].nodeName)
                            if(ltPropFloat)
                                {
                                    ht = data[topElements[i]].height > ht ? ht : data[topElements[i]].height
                                }   
                            var iniHgt = data[topElements[i]].y + data[topElements[i]].height
                            if( [ 'top' , 'topLeft', 'topRight' ].indexOf(node.value) == -1 ) {
                                data[node.elemNum].y = iniHgt - ht;
                                this.valueUpdating.call(this, node.elemNum, 'y', 'lyte-grid-y')
                            }
                            var temp =(data[node.elemNum].y + data[node.elemNum].height) < (data[topElements[i]].y-this.heightGet.call(this, data[topElements[i]].nodeName))?(data[topElements[i]].y-this.heightGet.call(this, data[topElements[i]].nodeName)):(data[node.elemNum].y + data[node.elemNum].height);
                            this.verticalCheck.call(this, data[topElements[i]],iniHgt, temp + data[topElements[i]].height, node, true)
                            data[topElements[i]].y = temp
                            this.valueUpdating.call(this, topElements[i], 'y', 'lyte-grid-y')
                            if(!ltPropFloat || (i == topElements.length -1 && i != 0))
                                {
                                    this.topMoveFunc.call(this, node, data[node.elemNum].y + ht, false)
                                }
                            if(!ltPropFloat)
                                {
                                    this.topMoveFunc.call(this, data[topElements[i]].nodeName, data[topElements[i]].y, true)
                                }
                        }
                        delete this._occupied;
                        this.displayGrid.call(this)
                    }  
                 }.bind( this ) )        
    }, 
    // check for movement top to bottom
    verticalMoveTopToBottom : function(element, node){
            $L.fastdom.measure(function(){
                var topElements = [], bottomElements = [], i, j, temp1, flag = true, elementsToCheck = [], elementsToCheck1 = [], upHeight = 0;
                var data = this.getData('lyteGridStack');
                var ltPropUnitY = this.getData('ltPropUnitY'),
                forceTop = this.getData( 'ltPropCheckCurrentPosition' );

                elementsToCheck = this.elementCheck.call(this, element, node)
                temp1 = data[node.elemNum].y                           
                elementsToCheck1 = this.getData('yElements')[ ( forceTop ? this.returnY( node, true ) : temp1 ) + data[node.elemNum].height];
                if(elementsToCheck1)
                    {
                        elementsToCheck = this.similarData.call(this, elementsToCheck, elementsToCheck1)
                    }
                if(elementsToCheck.indexOf(node.elemNum) != -1)
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }   
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        // height and other grids offset are required here
                        var topPos = data[elementsToCheck[i]].nodeName.offsetTop, height = data[elementsToCheck[i]].nodeName.offsetHeight, left =  this.rtlfunc( 'offsetLeft', data[elementsToCheck[i]].nodeName ), width = data[elementsToCheck[i]].nodeName.offsetWidth, nodeHgt = node.offsetHeight,
                        allow;

                        allow = forceTop ? 
                                ( ( node.offTop  > ( topPos + ( !this.getData( 'ltPropHitBottom' ) ? ( parseInt( this.getData( 'ltPropMarginTop' ) ) - nodeHgt ) : ( height - parseInt( this.getData( 'ltPropMarginTop' ) ) ) ) ) ) && (node.initialTop <= node.offTop) ) :
                                ( ( node.offTop  > (topPos + ( !this.getData( 'ltPropHitBottom' ) ? ( parseInt( this.getData( 'ltPropMarginTop' ) ) - nodeHgt ) : ( height - parseInt( this.getData( 'ltPropMarginTop' ) ) ) ) ) ) && ( node.initialTop <= node.offTop ) && ( ( left + width > node.initialLeft ) && ( node.initialLeft + node.clientWidth > left ) && ( node.initialTop + nodeHgt < topPos || node.initialTop > topPos + height ) ) ); 


                        if( allow ){
                                topElements[topElements.length] = elementsToCheck[i];
                            }
                    }
                if(topElements.length)
                    { 
                        var arr = [], max;
                        for(i = 0;i < topElements.length;i++ )
                            {
                                arr.push(data[topElements[i]].height + data[topElements[i]].y);
                            }
                        var ht = arr.reduce(function(a, b){return Math.max(a, b);});        
                        for(var j = 0;j < topElements.length;j++ )
                            {
                                if(!this.getData('ltPropFloat'))
                                    {
                                        upHeight = this.heightGet.call(this, data[topElements[j]].nodeName, node); 
                                        if(upHeight)
                                            {
                                                data[topElements[j]].y -= upHeight;
                                                this.valueUpdating.call(this, topElements[j], 'y', 'lyte-grid-y')
                                                if(j == 0)
                                                    {
                                                        ht = data[topElements[j]].height + data[topElements[j]].y
                                                    }
                                                else
                                                    {
                                                        ht = (data[topElements[j]].height + data[topElements[j]].y) > (data[topElements[j-1]].height + data[topElements[j-1]].y)?(data[topElements[j]].height + data[topElements[j]].y):(data[topElements[j-1]].height + data[topElements[j-1]].y);
                                                    }
                                            }
                                        data[node.elemNum].y = ht
                                        if(i == topElements.length -1 || i != 0)
                                            {
                                                this.topMoveFunc.call(this,data[topElements[j]].nodeName)
                                            }   
                                    }
                                else
                                    {
                                        data[node.elemNum].y = parseInt(((node.offsetTop - ltPropUnitY) / (ltPropUnitY + parseInt(this.getData('ltPropMarginTop')))).toFixed(0))
                                        this.verticalCheck.call(this, data[node.elemNum], parseInt(node.getAttribute('lyte-grid-y')) + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, node, true)
                                    }
                                }
                        this.valueUpdating.call(this, node.elemNum, 'y', 'lyte-grid-y')
                        this.verticalCheck.call(this, data[node.elemNum], parseInt(node.getAttribute('lyte-grid-y')) + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, data[node.elemNum].nodeName, true)      
                        this.displayGrid.call(this)
                    }  
                }.bind( this ) )                   
    }, 
    // to check any free space available above the particular grid
    heightGet : function(node, oldNode,flag){
        if(node.elemNum >= 0)
            {
                var topElements = [], i, j, temp = 0, elementsToCheck = [], elementsToCheck1 = [], data = this.getData('lyteGridStack');
                if(!oldNode)
                    {
                        oldNode = node
                    }
                var xElements = this.getData('xElements');
                var yElements = this.getData('yElements');
                if(data[node.elemNum].length > 1)
                    {
                        elementsToCheck = this.yElementsFind(data[node.elemNum].x + 1, data[node.elemNum].length + data[node.elemNum].x - 1, xElements)
                    }   
                else
                    {
                        elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x])
                    }   
                for(var k = data[node.elemNum].y + data[node.elemNum].height-1;k >= 0;k--)
                    {
                        elementsToCheck1 = this.yElementsFind(0, data[node.elemNum].y + data[node.elemNum].height-1, yElements)
                    }   
                elementsToCheck = this.multipleRemoval(this.elementSorting.call(this, this.similarData.call(this, elementsToCheck, elementsToCheck1)))
                if(elementsToCheck.indexOf(node.elemNum) != -1) 
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        if(elementsToCheck[i] != oldNode.elemNum || flag)
                            {
                                if(data[node.elemNum].y >= data[elementsToCheck[i]].y)
                                    {
                                        if(((data[elementsToCheck[i]].x > data[node.elemNum].x) && (data[elementsToCheck[i]].x < (data[node.elemNum].x + data[node.elemNum].length))) || (((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) > (data[node.elemNum].x)) && (((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) < (data[node.elemNum].x + data[node.elemNum].length)))) || ((data[elementsToCheck[i]].x > data[node.elemNum].x) && ((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) < (data[node.elemNum].x + data[node.elemNum].length))) || ((data[elementsToCheck[i]].x < data[node.elemNum].x) && ((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) > (data[node.elemNum].x + data[node.elemNum].length))) || ((data[elementsToCheck[i]].x == data[node.elemNum].x) || (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length == data[node.elemNum].length + data[node.elemNum].x)))
                                                {
                                                    topElements[topElements.length] = elementsToCheck[i];
                                                }
                                    }
                            }
                    }
                for(j = 0;j < topElements.length;j++ )
                    {
                        if(j == 0)
                            {
                                temp += -data[topElements[0]].y-data[topElements[0]].height + data[node.elemNum].y;
                            }
                        else if((-data[topElements[j]].y-data[topElements[j]].height + data[node.elemNum].y) < temp)
                            {
                                temp = -(data[topElements[j]].y + data[topElements[j]].height-data[node.elemNum].y);
                            }
                    }
                if(topElements.length == 0)
                    {
                        temp = data[node.elemNum].y;
                    }
                if(temp < 0)
                    {
                        temp = 0;
                    }   
                return temp;    
            }       

    },
    // vertical movement towards top 
    topMoveFunc : function(node, count, flagie, currentNode, finalfg){
            var i, elementsToCheck = [], valMove,lyteQuerySelector = this.getData('lyteQuerySelector'), occupied = lyteQuerySelector.occupied, element = lyteQuerySelector.element, data = this.getData('lyteGridStack');
            occupied.push(node.elemNum)
            currentNode = currentNode ? currentNode : node;
            elementsToCheck = this.elementSorting.call(this, this.elementCheck.call(this, element, node, finalfg))
            if(elementsToCheck.indexOf(node.elemNum) != -1) 
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                }
            occupied =occupied.concat(elementsToCheck)  
            for(i = 0; i < elementsToCheck.length; i++ )
                {
                    if(!data[elementsToCheck[i]].nodeName.classList.contains('gridSelected'))
                         {
                            if((data[node.elemNum].x >= data[elementsToCheck[i]].x && data[node.elemNum].x + data[node.elemNum].length <= data[elementsToCheck[i]].x) || (data[node.elemNum].x + data[node.elemNum].length >= data[elementsToCheck[i]].x && (data[node.elemNum].x + data[node.elemNum].length <= data[elementsToCheck[i]].x + data[elementsToCheck[i]].length)) || (data[node.elemNum].x > data[elementsToCheck[i]].x) || ((data[node.elemNum].x + data[node.elemNum].length) > (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length)))
                                {
                                    if(data[node.elemNum].y + data[node.elemNum].height <= data[elementsToCheck[i]].y + data[elementsToCheck[i]].height ||flagie)
                                        {
                                            valMove = this.heightGet.call(this, data[elementsToCheck[i]].nodeName,null,!flagie)
                                            data[elementsToCheck[i]].y = data[elementsToCheck[i]].y-valMove;
                                            this.valueUpdating.call(this, elementsToCheck[i], 'y', 'lyte-grid-y')
                                            this.positionFind.call(this);
                                            if(valMove)
                                                {
                                                    this.topMoveFunc.call(this, data[elementsToCheck[i]].nodeName, data[elementsToCheck[i]].y + valMove, flagie, currentNode);
                                                    if(!flagie)
                                                        {
                                                            this.displayGrid.call(this, currentNode.elemNum)
                                                        }
                                                }
                                        }
                                }
                        }
                }
    }, 
    // to sort selected elements according to directions
    elementSorting : function(stackElements, flag){
            var y;
            if( flag ) {
                y = 'x';
            }
            else {
                y = 'y';
            }   
            var data = this.getData('lyteGridStack')
            for(var j = 0;j < stackElements.length;j++ )
                    {
                        for(var k = j + 1;k < stackElements.length;k++ )
                            {
                                if(data[stackElements[j]][y] > data[stackElements[k]][y])
                                    {
                                        var temp = stackElements[j];
                                        stackElements[j] = stackElements[k];
                                        stackElements[k] = temp;
                                    }
                            }
                    }
             return stackElements    
    }, 
    // horizontal movement check
    topCheck : function(node, element,timeoutFlag, fourth, allowHorizontal, width){
                var i, flag = false, stackElements = [], temp1, elementsToCheck = [], elementsToCheck1 = [], hgt, ht=0;
                    var data = this.getData('lyteGridStack'), currentTop;
                    var xElements = this.getData('xElements');
                    var yElements = this.getData('yElements');
                    temp1 = data[node.elemNum].y
                    if(data[node.elemNum].length > 1)   
                        {
                            elementsToCheck = this.elementSorting(this.multipleRemoval(this.yElementsFind.call(this, data[node.elemNum].x + 1, data[node.elemNum].x + data[node.elemNum].length-1, xElements)));
                        }
                    else
                        {
                            elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x + 1])
                        }
                    if(data[node.elemNum].height > 1)   
                        {
                            elementsToCheck1 = this.yElementsFind(temp1 + 1, data[node.elemNum].y + data[node.elemNum].height - 1, yElements)
                        }
                    else
                        {
                            elementsToCheck1 = this.similarData.call(this, yElements[data[node.elemNum].y], yElements[data[node.elemNum].y + 1])
                        }
                    if(elementsToCheck1)        
                        {
                            elementsToCheck = this.similarData.call(this, elementsToCheck, this.multipleRemoval.call(this, elementsToCheck1))
                        }
                    elementsToCheck = this.elementSorting.call(this, this.multipleRemoval.call(this, elementsToCheck))  
                    if(elementsToCheck.indexOf(node.elemNum) != -1) 
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                        }
                    for(i = elementsToCheck.length - 1; i > -1; i-- )
                        {
                            if(timeoutFlag)
                                {
                                    if(data[node.elemNum].x != node.getAttribute('lyte-grid-x') || data[node.elemNum].length != node.getAttribute('lyte-grid-length'))
                                        {   
                                            flag=true
                                        }
                                }
                            else
                                {
                                    if(((data[node.elemNum].x + data[node.elemNum].length > data[elementsToCheck[i]].x && data[node.elemNum].x < data[elementsToCheck[i]].x) || (data[node.elemNum].x < data[elementsToCheck[i]].x + data[elementsToCheck[i]].length && data[elementsToCheck[i]].x + data[elementsToCheck[i]].length <= data[node.elemNum].x + data[node.elemNum].length)) && (temp1 + data[node.elemNum].height > data[elementsToCheck[i]].y && temp1 < data[elementsToCheck[i]].y) || (temp1 < data[elementsToCheck[i]].y + data[elementsToCheck[i]].height && data[elementsToCheck[i]].y + data[elementsToCheck[i]].height < temp1 + data[node.elemNum].height) || (temp1 >= data[elementsToCheck[i]].y && data[elementsToCheck[i]].y + data[elementsToCheck[i]].height >= temp1 + data[node.elemNum].height) || (data[elementsToCheck[i]].y + data[elementsToCheck[i]].height < temp1 + data[node.elemNum].height && temp1 < data[elementsToCheck[i]].y ))
                                        {
                                            flag=true
                                        }
                                }   
                            if(flag && !data[elementsToCheck[i]].nodeName.classList.contains('gridSelected'))    
                                {
                                    if(((data[node.elemNum].x <= (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length-1))) || ((data[elementsToCheck[i]].x + 1 >= (data[node.elemNum].x + data[node.elemNum].length))))   
                                            {
                                                stackElements[stackElements.length] = elementsToCheck[i]
                                                ht += data[elementsToCheck[i]].height
                                                if(this.getData('ltPropDirection') != 'horizontal' && !fourth)
                                                    {
                                                        break;
                                                    }
                                            }   
                                }
                            flag=false  
                        }
                    if(stackElements.length)
                        {
                            if(!timeoutFlag)
                                {
                                    this.valueUpdating.call(this, node.elemNum, 'x', 'lyte-grid-x')  
                                } 
                            stackElements = this.elementSorting.call(this, stackElements, true)
                            for(var z = 0 ; z < stackElements.length ; z++)
                                {
                                    var valMove = this.heightGet.call(this, data[stackElements[z]].nodeName), totalHeight = data[node.elemNum].height + data[node.elemNum].y -valMove, ret = true;
                                    hgt = totalHeight;
                                    if(this.getData('ltPropDirection') != 'horizontal' && !allowHorizontal) 
                                        {
                                            this.verticalCheck.call(this, data[stackElements[z]], data[stackElements[z]].y + data[stackElements[z]].height, totalHeight + valMove + data[stackElements[z]].height, node, data[node.elemNum].height < data[stackElements[z]].height);  
                                            data[stackElements[z]].y = (hgt > (data[node.elemNum].height + data[node.elemNum].y)?hgt:(data[node.elemNum].height + data[node.elemNum].y)) - (this.getData('ltPropFloat')? 0 : this.heightGet.call(this,data[node.elemNum].nodeName));
                                            this.valueUpdating.call(this, stackElements[z], 'y', 'lyte-grid-y')
                                        }
                                    else
                                        {
                                            if(z > 0 &&  ((parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-x')) + parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-length'))) == (this.getData('gridLength')) || parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-x')) == 0))
                                                {
                                                    break;
                                                }
                                            if(( this.rtlfunc( 'offsetLeft', node ) > this.rtlfunc( 'offsetLeft', data[stackElements[z]].nodeName ) ) && !allowHorizontal)
                                                {
                                                    this.horiMovement.call(this, node, stackElements[z], 'left', ht, stackElements.length == 1 || (stackElements.length > 2 && z != 1), width)                                                   
                                                }
                                            else if(( this.rtlfunc( 'offsetLeft', node ) < this.rtlfunc( 'offsetLeft', data[stackElements[z]].nodeName ) ) || allowHorizontal) 
                                                {
                                                    this.horiMovement.call(this, node, stackElements[z], 'right', ht, stackElements.length == 1 || (stackElements.length > 2 && z != 1), width)                                                  
                                                }   
                                        }
                                    if(!this.data.ltPropFloat)    
                                        {
                                            this.topMoveFunc.call(this, data[stackElements[z]].nodeName, z == 0 || (data[stackElements[z]].x != 0 && data[stackElements[z]].x + data[stackElements[z]].length != parseInt( this.data.gridLength ) ) ) 
                                        }
                                    this.displayGrid.call(this, node.elemNum);
                                }
                    }
},
// if given direction is horizontal
    horiMovement : function(node, stackElements, direction, ht, flag, wid){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector');
            data[stackElements].x = direction == "left"?(data[stackElements].x - ( wid ? wid : 1 )):(data[stackElements].x + ( wid ? wid : 1 ));
            if(data[stackElements].x < 0 || (data[stackElements].x + data[stackElements].length) > parseInt(this.getData('gridLength')))
                {
                    if(data[stackElements].x < 0)
                        {
                            data[stackElements].x = 0;
                        }
                    else
                        {
                            data[stackElements].x = parseInt(this.getData('gridLength')) - data[stackElements].length;
                        }
                    this.valueUpdating.call(this, stackElements, 'x', 'lyte-grid-x')
                    var dumHgt = data[stackElements].y + data[stackElements].height
                    data[stackElements].y = data[node.elemNum].y + data[node.elemNum].height;   
                    var handQuer = this.getData('ltPropHandler');
                    this.positionFind.call(this, this.scopeElement.querySelectorAll( handQuer ) );
                    this.verticalCheck.call(this, data[ stackElements ], dumHgt, data[node.elemNum].y + data[node.elemNum].height + data[stackElements].height /*ht*/, node);
                    this.valueUpdating.call(this, stackElements, 'y', 'lyte-grid-y')
                    this.displayGrid.call(this);    
                }
            else
                {
                    this.valueUpdating.call(this, stackElements, 'x', 'lyte-grid-x')
                    data[stackElements].nodeName.initialLeft = []
                    data[stackElements].nodeName.initialTop = []
                    for(var k = 0; k < 3; k++)
                        {
                            data[stackElements].nodeName.initialLeft[k] = this.rtlfunc( 'offsetLeft', data[stackElements].nodeName );
                            data[stackElements].nodeName.initialTop[k] = data[stackElements].nodeName.offsetTop;
                        }
                    this.topCheck.call(this, data[stackElements].nodeName, lyteQuerySelector.element, true, null, wid ? true : false, wid)
                    if(flag)
                        {
                            var valMove = this.heightGet.call(this, data[stackElements].nodeName)
                            if(! this.getData('ltPropFloat'))
                                {
                                    data[stackElements].y -= valMove
                                    if(valMove)
                                        {
                                            this.topMoveFunc.call(this, data[stackElements].nodeName)
                                        }   
                                }
                        }
                    this.displayGrid.call(this)
                }
    },
    // vertical movement top to bottom  
    verticalCheck : function(node, currentHeight, totalHeight, currentNode, flagie, direction){
            var topElements = [], elementsToCheck = [], elementsToCheckDum = [], i, count, ht, flag = false, flag2 = false, elementsToCheck1 = [], maxElem = [], temp = [], data = this.getData('lyteGridStack'), fixFlag;
            currentNode = currentNode ? currentNode : node.nodeName;
            var xElements = this.getData('xElements'), yElements = this.getData('yElements'), element = this.scopeElement;
            if(direction == 'left')
                {   
                    elementsToCheck = elementsToCheck.concat(xElements[node.x] || [])
                }
            else if(direction == "right")
                {
                    elementsToCheck = elementsToCheck.concat(xElements[node.x + node.length] || [])
                }   
            else
                {   
                    if(node != data[currentNode.elemNum])
                        {
                            if(node.length > 1)
                                {
                                    elementsToCheck = this.yElementsFind(node.x + 1, node.x + node.length - 1, xElements)
                                }
                            else
                                {
                                    elementsToCheck = this.similarData.call(this, xElements[node.x] || [], xElements[node.x + 1] || [])
                                }   
                        }
                    else
                        {
                            elementsToCheck = this.elementCheck.call(this, element, node.nodeName)
                        }
                }
            elementsToCheck = this.multipleRemoval.call(this, elementsToCheck); 
            // elementsToCheckDum = elementsToCheckDum.concat(elementsToCheck); 
             for(var z = totalHeight - node.height; z <= totalHeight; z++)
                {
                    elementsToCheck1 = elementsToCheck1.concat(yElements[z] || [])
                }
            if(elementsToCheck1)
                {
                    elementsToCheck = this.similarData.call(this, elementsToCheck, this.multipleRemoval.call(this, elementsToCheck1))    
                }
            elementsToCheck = this.elementSorting.call(this, elementsToCheck);  
            if(elementsToCheck.indexOf(node.nodeName.elemNum) != -1)
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.nodeName.elemNum))
                }
            if(elementsToCheck.indexOf(currentNode.elemNum) != -1)  
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(currentNode.elemNum))
                } 
            if(direction)
                {
                    if(!this.similarData.call(this, elementsToCheck, yElements[node.y + node.height].concat(yElements[node.y])).length)
                        {
                            elementsToCheck = []
                        }
                }       
            for(i = 0;i < elementsToCheck.length;i++ )
                {
                    if(elementsToCheck[i] != node.nodeName.elemNum && elementsToCheck[i] != currentNode.elemNum)
                        {
                            if(flagie)
                                {
                                    if((node.y) == data[elementsToCheck[i]].y)
                                        {
                                            flag2 = true;
                                        }
                                }
                            if((node.y) < (data[elementsToCheck[i]].y + data[elementsToCheck[i]].height) || flag2)
                                {   
                                    topElements[topElements.length] = elementsToCheck[i];
                                    flag = true
                                }
                            else if(flagie && ((data[elementsToCheck[i]].y + data[elementsToCheck[i]].height) >= (node.y + node.height)))
                                {
                                    topElements[topElements.length] = elementsToCheck[i];
                                    flag = true
                                }       
                        }
                    if(flag)
                        {
                            flag = false
                            maxElem.push(data[topElements[topElements.length-1]].height + data[topElements[topElements.length-1]].y)
                            if(topElements.length > 1)
                                {
                                    temp.push(data[topElements[topElements.length - 1]].y-(data[topElements[0]].y + data[topElements[0]].height))     
                                }
                        }   
                }
             if(topElements.length)
                {   
                    topElements = this.elementSorting.call(this, topElements)
                    ht = totalHeight;
                    var elem = [], elem1 = [];
                    totalHeight = Math.max.apply(null,maxElem) - data[topElements[0]].y + ht   
                        for(var j = 0;j < topElements.length;j++ )
                            {
                                var htmove = this.heightGet.call(this, data[topElements[j]].nodeName)
                                if(j == 0)
                                    {
                                        if((ht <= data[topElements[j]].y) && flagie ) {
                                            break
                                        }
                                        else {
                                            if( data[ topElements[ j ] ].y - ht < 1 )  {
                                                data[ topElements [ j ] ].y = ht
                                                htmove = this.heightGet.call( this, data[ topElements[ j ] ].nodeName )
                                                if( ( data[ topElements[ j ] ].y - htmove >= ht ) ) {
                                                    data[ topElements[ j ] ].y -= htmove
                                                }
                                            }   
                                        }
                                    }
                                else
                                    {
                                        data[topElements[j]].y = data[topElements[0]].y + data[topElements[0]].height + temp[j-1];
                                        htmove = this.heightGet.call(this, data[topElements[j]].nodeName)
                                        if((data[topElements[j]].y - htmove >= ht))
                                            {
                                                data[topElements[j]].y -= htmove
                                            }
                                    }   
                                this.valueUpdating.call(this, topElements[j], 'y', 'lyte-grid-y')      
                            }
                        elem = this.yElementsFind.call(this,Math.min(node.x, data[currentNode.elemNum].x), Math.max((node.x + node.length), data[currentNode.elemNum].x + data[currentNode.elemNum].length), xElements)
                        elem = this.elementSorting.call(this,this.multipleRemoval.call(this, this.similarData.call(this, elem, topElements)))
                        for(var i = elem.length - 1;i >= 0 ;i-- )
                            {
                                var elem1 = [], elem2 = [], elem3 = [];
                                for(var j = data[elem[i]].x + 1;j < (data[elem[i]].x + data[elem[i]].length);j++ )
                                    {
                                        elem1 = elem1.concat(xElements[j])
                                    }
                                 if(data[elem[i]].length == 1)
                                    {
                                         elem1 = this.similarData.call(this, xElements[data[elem[i]].x], xElements[data[elem[i]].x + 1])
                                    }
                                if(flagie)   
                                    {
                                        elem2 = this.elementSorting.call(this,this.multipleRemoval.call(this,this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + 1 ,parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + data[elem[i]].height, yElements))));
                                    }
                                else
                                    {
                                        elem2 = this.elementSorting.call(this, this.multipleRemoval.call(this,this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + 1 ,parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + data[elem[i]].height, yElements)).concat(this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].y) + 1 ,parseInt(data[elem[i]].y) + data[elem[i]].height, yElements)))))                                   
                                    }   
                                for(var k = 0;k < elem2.length;k++ )
                                    {
                                        if(topElements.indexOf(elem2[k]) == -1 && node.nodeName.elemNum != elem2[k] && currentNode.elemNum != elem2[k])
                                            {
                                                if( this._occupied && this._occupied.indexOf( elem2[ k ] ) != -1 ) {
                                                    continue;
                                                }
                                                this.additionalCheck.call(this, elem2[k], data[elem[i]].y + data[elem[i]].height, topElements);
                                            }
                                    }   
                            }
                    }               
},
// to find elements on given height 
yElementsFind : function(start, end, yElements){
    var elements = [];
    for(var i = start;i <= end;i++ )
        {
            elements = elements.concat(yElements[i] || [])
        }
    return elements;    
}, 
// to propagate vertical check 
additionalCheck : function(element, height, topElements1){
        var xElements = this.getData('xElements'), yElements = this.getData('yElements'), data = this.getData('lyteGridStack'), elem1 = [], elem2 = [], hgt = height, elementNo = element;
        elem1 = elem1.concat(this.yElementsFind.call(this, parseInt(data[element].nodeName.getAttribute('lyte-grid-y')) + data[element].height, data[element].y + data[element].height, yElements))
        if(data[element].length>1)
            {
                elem2 = elem2.concat(xElements[data[element].x + 1])
                elem2 = elem2.concat(xElements[data[element].x + data[element].length - 1])
            }
        else
            {
                elem2 =elem2.concat(this.similarData.call(this, xElements[data[element].x], xElements[data[element].x + 1]))
            }   
        elem1 = this.similarData.call(this, elem1, elem2);
        if(elem1.indexOf(element) != -1)
            {
                Lyte.arrayUtils(elem1, 'removeAt', elem1.indexOf(element))
            }   
        for(var i = 0;i < elem1.length;i++ )
            {
                if(topElements1.indexOf(elem1[i]) == -1)
                    {
                        topElements1.push(elem1[i])
                        this.additionalCheck.call(this, elem1[i], height + data[element].height, topElements1)
                    }
            }
        if(data[elementNo].y > hgt)
            {
                 var htmove = this.heightGet.call(this, data[elementNo].nodeName);
                 if(data[elementNo].y - htmove <= hgt)
                    {
                        data[elementNo].y = hgt
                    }
                else
                    {
                        data[elementNo].y -= htmove
                    }
                    
            }
          else  
            {
               data[elementNo].y = hgt
            }
        topElements1.push(elementNo); 
        this.valueUpdating.call(this, elementNo, 'y', 'lyte-grid-y'); 
}, 
// finding previous position for undo
previousPos : function(elementCount, flag){
    if(!elementCount || !elementCount.length){
        return;
    }
    var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector');
    for(var i = 0;i < elementCount.length;i++ )
        {
            if(lyteQuerySelector.currentPos < data[i].oldX.length)
                {
                    Lyte.arrayUtils(data[i].oldX, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldX.length)
                    Lyte.arrayUtils(data[i].oldY, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldY.length)
                    Lyte.arrayUtils(data[i].oldLength, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldLength.length)
                    Lyte.arrayUtils(data[i].oldHeight, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldHeight.length)
                }
            data[i].oldX[data[i].oldX.length] = flag ? data[i].x : data[i].nodeName.getAttribute('lyte-grid-x');
            data[i].oldY[data[i].oldY.length] = flag ? data[i].y : data[i].nodeName.getAttribute('lyte-grid-y');
            data[i].oldLength[data[i].oldLength.length] = flag ? data[i].length : data[i].nodeName.getAttribute('lyte-grid-length');
            data[i].oldHeight[data[i].oldHeight.length] = flag ? data[i].height : data[i].nodeName.getAttribute('lyte-grid-height');
        }
    lyteQuerySelector.currentPos = data[0].oldX.length-1;
},  

mousedown : function ( evt, isTch ){
        if(!this.getData('ltPropFreezeMode'))
            {
                var lyteQuerySelector = this.data.lyteQuerySelector, currentElement = this, data = this.data.lyteGridStack
                var ret = this.nodeName.call( this, isTch ? evt.touches[ 0 ] : evt ); 
                if(ret)
                    {
                        this.mvefunc = this.mvefunc || this.mMove.bind(this), this.upfunc = this.upfunc || this.mouseup.bind(this);
                        // evt.stopPropagation();
                        var val = ret[ 0 ],
                        nodeName = ret[ 1 ],
                        element = this.$node.querySelector( this.data.ltPropScope ),
                        ev = isTch ? evt.touches[ 0 ] : evt;
                        if(!evt.shiftKey)   
                            {
                                lyteQuerySelector.BottomToTopFlag = true, lyteQuerySelector.allowMovement = true, this.mvefunc = this.mMove.bind(this) ;
                                var prevSelected =  element.querySelectorAll( this.data.ltPropHandler + '.gridSelected' );
                                if( ( prevSelected.length == 0 ) )
                                    {   
                                        if( nodeName ){
                                            if( nodeName.classList.contains( 'gridSelected' ) ){
                                                return;
                                            }
                                        }
                                        var method;
                                        if(this.getMethods('onBeforeSelect'))
                                            {
                                                method = this.executeMethod('onBeforeSelect', ret[1], evt, this.$node);
                                            }
                                        if(nodeName && method != false)
                                            {
                                                lyteQuerySelector.SelectedNodes = [];
                                                // $L.fastdom.mutate(function(){
                                                //     nodeName.classList.add('gridSelected')
                                                //     $L( this.data.ltPropHandler + '.lyteGridFocused:not(.gridSelected)', this.$node ).removeClass( 'lyteGridFocused' )
                                                // }.bind( this ) )
                                                // $L.fastdom.measure(function(){
                                                    lyteQuerySelector.SelectedNodes.push(nodeName.elemNum);
                                                    lyteQuerySelector.element = element
                                                    nodeName.initialLeft = this.rtlfunc( 'offsetLeft', nodeName );
                                                    nodeName.initialTop = nodeName.offsetTop;
                                                    nodeName.initialy = data[nodeName.elemNum].y
                                                    nodeName.initialx = data[nodeName.elemNum].x
                                                    nodeName.xPos = this.rtlfunc( ev.clientX, 'clientX' ) - this.rtlfunc( 'offsetLeft', nodeName );
                                                    nodeName.yPos = ev.clientY - nodeName.offsetTop;
                                                    if(val == "content")
                                                        {
                                                            nodeName.flag = true;
                                                        }
                                                    else
                                                        {
                                                            nodeName.value = val;
                                                            var bccr = nodeName.getBoundingClientRect();
                                                            if( [ 'BottomRight', 'right', 'topRight' ].indexOf(val) != -1 )      
                                                                {
                                                                    nodeName.xOff = this.rtlfunc( bccr, 'bccr' ) + bccr.width - this.rtlfunc( ev.clientX, 'clientX' );
                                                                }
                                                            else
                                                                {
                                                                    nodeName.xOff = - this.rtlfunc( bccr, 'bccr' ) + this.rtlfunc( ev.clientX, 'clientX' );
                                                                }   
                                                            if( [ 'BottomRight', 'bottom', 'BottomLeft' ].indexOf(val) != -1 )      
                                                                {
                                                                    nodeName.yOff = bccr.top + bccr.height - ev.clientY;
                                                                }
                                                            else
                                                                {
                                                                    nodeName.yOff = - bccr.top + ev.clientY;
                                                                }       
                                                            nodeName.flag = false;
                                                            this._resizeSelected = true;
                                                        }
                                                // }.bind( this ) )
                                                nodeName.classList.add('gridSelected')
                                                $L( this.data.ltPropHandler + '.lyteGridFocused:not(.gridSelected)', this.$node ).removeClass( 'lyteGridFocused' )
                                                
                                                if(this.getData('ltPropBestfit'))     
                                                    {
                                                        if(!this._bestfit)
                                                            {
                                                                var ltPropBestfitClass = this.getData('ltPropBestfitClass');
                                                                var bestFit = document.createElement('div');
                                                                bestFit.classList.add('lyteBestFit');
                                                                if(this.getData('ltPropBestfitType') == 'grid'){
                                                                    bestFit.classList.add('lyteGrid')
                                                                }
                                                                if(ltPropBestfitClass){
                                                                    bestFit.classList.add(ltPropBestfitClass);
                                                                }
                                                                bestFit.style.display = "none"
                                                                this._bestfit = bestFit;
                                                                $L.fastdom.mutate(function(){
                                                                    element.appendChild(bestFit);
                                                                })
                                                            }
                                                             
                                                        
                                                    }
                                                document.body.addEventListener( isTch ? 'touchmove' : 'mousemove', this.mvefunc, true );
                                                this.getMethods('onSelect') && this.executeMethod( 'onSelect', nodeName, evt, this.$node );
                                            }
                                    }
                                else
                                    {   
                                        lyteQuerySelector.SelectedNodes = [];
                                        var nodeName = this.$node.querySelectorAll( this.data.ltPropHandler + '.gridSelected')
                                        // $L.fastdom.measure(function(){
                                            for(var i = 0;i < nodeName.length; i++ )
                                                {
                                                    lyteQuerySelector.SelectedNodes.push(element.querySelectorAll(currentElement.getData('ltPropHandler') + '.gridSelected')[i].elemNum);
                                                    nodeName[i].left = nodeName[i].offsetLeft;
                                                    nodeName[i].top = nodeName[i].offsetTop;
                                                    nodeName[i].flag = true;
                                                    nodeName[i].initialLeft = nodeName[i].offsetLeft;
                                                    nodeName[i].initialTop = nodeName[i].offsetTop;
                                                    nodeName[i].xPos = this.rtlfunc( ev.clientX, 'clientX' )-nodeName[i].offsetLeft;
                                                    nodeName[i].yPos = ev.clientY-nodeName[i].offsetTop;
                                                }
                                            lyteQuerySelector.SelectedNodes = this.elementSorting.call(this, lyteQuerySelector.SelectedNodes);
                                        // }.bind(this))
                                        document.body.addEventListener( isTch ? 'touchmove' : 'mousemove', this.mvefunc, true );
                                        this.getMethods( 'onSelect' ) && this.executeMethod( 'onSelect', nodeName, evt, this.$node );
                                    }
                            }
                        else if(!lyteQuerySelector.allowMovement)
                            {
                                var method;
                                if(this.getMethods('onBeforeSelect'))
                                    {
                                        method = this.executeMethod('onBeforeSelect', ret[1], evt, this.$node);
                                    }
                                if(method != false)
                                    {
                                        nodeName = ret[1]
                                        nodeName.initialLeft = [], nodeName.initialTop = []
                                        if(nodeName.classList.contains('gridSelected'))
                                            {
                                                nodeName.classList.remove('gridSelected')
                                            }
                                        else    
                                            {
                                                nodeName.classList.add('gridSelected')
                                            }
                                    }
                            }   
                        lyteQuerySelector.previousPosFind = false
                    } 
              // evt.preventDefault()      
            }
},
mMove : function(evt){
    var isTch = evt.type == "touchmove";
    if( isTch && evt.touches.length != 1 ) {
        return;
    }
    this.mousemoveFun.call(this, this.scopeElement, isTch ? evt.touches[ 0 ] : evt);
    if( !isTch ) {
        evt.preventDefault()    
        evt.stopPropagation();
        evt.preventDefault();
    }
} ,
mouseup : function (evt){   
    var lyteQuerySelector = this.getData('lyteQuerySelector'), i, data = this.getData('lyteGridStack'), isTch = evt.type == "touchend",
    ret = this.nodeName.call(this, evt ), 
    element = this.$node.querySelector( this.data.ltPropScope ),
    elementCount = this.elementSorting.call(this, lyteQuerySelector.elementCount);
    if(!evt.shiftKey || lyteQuerySelector.allowMovement)   
        {
            var method, nodes, bestfit = this._bestfit;
            lyteQuerySelector.verticalMove = true, lyteQuerySelector.allowMovement = false;
            if(lyteQuerySelector.SelectedNodes.length)
                {
                    nodes =  this.$node.querySelectorAll( this.data.ltPropHandler + '.gridSelected');
                    if( this._gridMoved && this.getMethods('onBeforeDrop')){
                        method = this.executeMethod('onBeforeDrop', nodes, event, this.$node, !!this._resizeSelected );
                    }
                    for(i = lyteQuerySelector.SelectedNodes.length-1;i >= 0;i--)    
                        {
                            var nodeName = data[lyteQuerySelector.SelectedNodes[i]].nodeName
                            if(nodeName.classList.contains('gridSelected'))
                                {
                                    if( this._gridMoved && !this.getData('ltPropFloat') && method != false)
                                        {
                                            var valMove = this.heightGet.call(this, nodeName)
                                            data[nodeName.elemNum].y -= (valMove);
                                            this.topCheck.call(this, nodeName, this.scopeElement);
                                            // valMove = this.heightGet.call(this, nodeName)
                                            // if( valMove ){
                                            //     data[nodeName.elemNum].y -= (valMove);
                                            //     this.topCheck.call(this, nodeName, this.scopeElement);
                                            // }
                                            this.topMoveFunc.call(this, nodeName, data[nodeName.elemNum].y + valMove, false)
                                        }
                                    this.displayGrid.call(this);    
                                    nodeName.classList.remove('gridSelected');
                                    nodeName.classList.remove( 'lyteGridStackMove' );
                                    nodeName.style.removeProperty( this.rtlfunc( 'left' ) )
                                    nodeName.style.removeProperty('top')
                                    nodeName.style.removeProperty('height')
                                    nodeName.style.removeProperty('width')
                                    Lyte.arrayUtils(lyteQuerySelector.occupied, 'remove', 0, lyteQuerySelector.occupied.length)
                                    if( this._gridMoved ){
                                        if(method != false)
                                            {
                                                this.topCheck.call(this,nodeName,element);
                                            }
                                          if(nodeName.flag == false && nodeName._childGrid){
                                                setTimeout(nodeName._childGrid.reRender, 150, true)
                                           } 
                                       }
                                    delete nodeName.initialy; delete nodeName.xPos; delete nodeName.yPos; delete nodeName.flag; delete nodeName.offLeft; delete nodeName.offTop;
                                    delete nodeName.initialx; delete nodeName.instantPreviousX;delete nodeName.instantPreviousY;delete nodeName.val; delete nodeName.xOff; delete nodeName.yOff; delete  nodeName.initialLeft; /*delete  nodeName.initialLeft[1];*/
                                    /*delete  nodeName.initialLeft[2];*/ delete  nodeName.initialTop; /*delete  nodeName.initialTop[1]; delete  nodeName.initialTop[2];*/ delete nodeName.flag; delete nodeName.value; delete nodeName.prevEvX; delete nodeName.prevEvY;

                                }
                            if(bestfit)    
                                {
                                    bestfit.style.display = 'none' 
                                }
                             this.findGrid();   
                        } 
                    window.cancelAnimationFrame( this._reqId );  
                    delete this._reqId; delete this._scrollCheck;   
                    evt.stopPropagation();
                    if( !isTch ) {
                        evt.preventDefault();   
                    }
                }
            if( this._gridMoved ){
                if(method != false)       
                    {
                        this.displayGrid.call(this);
                            if(lyteQuerySelector.SelectedNodes.length && lyteQuerySelector.previousPosFind) 
                                {
                                    var handQuer = this.data.ltPropHandler
                                    this.previousPos.call(this, element.querySelectorAll( handQuer ) );
                                }
                            if(this.getMethods('onDrop')){
                                var isresize = !!this._resizeSelected;
                                window.requestAnimationFrame( function(){
                                    this.executeMethod('onDrop', nodes, evt, this.$node, isresize  );
                                }.bind( this ) )
                            }  
                    }
                else
                    {    
                        lyteQuerySelector.currentPos += 1;
                        this.undoPrevious.call(this);
                    }
            }

            document.body.removeEventListener( isTch ? 'touchmove' : 'mousemove', this.mvefunc, true );
            lyteQuerySelector.SelectedNodes = []   
            delete this._gridMoved; delete this._resizeSelected;  
       }
       document.removeEventListener( isTch ? 'touchend' : 'mouseup', this.upfunc, true )
    },
    keydown : function (event){

        if(document._lyteCurrentGrid == this && this.getData('ltPropUndo') && !this.getData('ltPropFreezeMode'))
            {
                if((event.ctrlKey || event.metaKey) && event.shiftKey && event.keyCode == 90)
                    {
                        this.undoNext.call(this);
                    }
                else if((event.ctrlKey || event.metaKey) && !event.shiftKey && event.keyCode == 90)
                    {
                        this.undoPrevious.call(this);
                    }  
            }  
  },

  returnWid : function(length, x, div){
    if(!length){
        return
    }
    if(length.constructor != String){
        return length;
    }
    var match = length.match(/[\w|.]+(?=%)/gi)
    if(match && match.length){
        var unitX, margin, width;
        if(x){
            width = "width";
            unitX = this.getData('ltPropUnitxCopy');
        }else{
            width = "height";
            unitX = this.getData('ltPropUnitY');
            margin = "ltPropMarginTop"
        }
        // grid length will be based on actual width
        return this.gridLength((this.bcrrelem ? this.bcrrelem[width] : this.scopeElement.getBoundingClientRect()[width]) * parseFloat(match[0]) / 100, unitX, margin)
    }else{
        return parseInt(length);
    }
  },

   initialPosFind : function(elementtt){
            var iniData1 = {}, repose = this.getData('ltPropForcedReposition')
            iniData1.x = (elementtt.getAttribute('lyte-grid-x') && !repose ) ? parseInt(elementtt.getAttribute('lyte-grid-x')) : undefined;
            iniData1.y = (elementtt.getAttribute('lyte-grid-y') && !repose ) ? parseInt(elementtt.getAttribute('lyte-grid-y')) : undefined;
            iniData1.length = elementtt.getAttribute('lyte-grid-length') ? this.returnWid(elementtt.getAttribute('lyte-grid-length'), true, elementtt) : this.returnWid(this.getData('ltPropDefaultLength'), true);
            iniData1.height = elementtt.getAttribute('lyte-grid-height') ? this.returnWid(elementtt.getAttribute('lyte-grid-height'), null, elementtt) : this.returnWid(this.getData('ltPropDefaultHeight'));
            return iniData1;
  },

  checkPreviousGrid : function(){
     var nodeName  = this.$node.parentElement;
     while(nodeName && nodeName.tagName != "BODY"){
        if(nodeName.tagName == "LYTE-GRIDSTACK"){
            this._parentGrid = nodeName;
            this._parentGridIndex = nodeName.component._childGrids.length;
            nodeName.component._childGrids.push(this.$node);
            break;
        }
        if(nodeName.tagName == "LYTE-GRID-CONTENT"){
            nodeName.parentElement._childGrid = this.$node
            this._parentComp = nodeName.parentElement;
        }
        nodeName = nodeName.parentElement;
     } 
     if(nodeName && nodeName.tagName == "LYTE-GRIDSTACK"){
        return true
     }
     return false;  
  },

  retNode : function(sim, data) {
    var arr = [];
    for( var i = 0; i < sim.length; i++ ) {
        if( data[ sim[ i ] ] ){
            arr.push( data[ sim[ i ] ].nodeName );
        }
     }
    return arr; 
  },

  findGrid : function() {
     var bccr = this.$node.getBoundingClientRect(), sim, data = this.getData( 'lyteGridStack' ), arr;
     var x = this.$node.scrollLeft, y = this.$node.scrollTop, length = x + bccr.width, height = y + bccr.height;
     var vis = { left : this.returnY( { offLeft : x } ), top : this.returnY( { offTop : y } , true), right : this.returnY( { offLeft : length } ), bottom : this.returnY( { offTop : height }, true ) };
     this.setData('ltPropVisibleBoundary', vis)
     sim = this.similarData( this.multipleRemoval( this.yElementsFind( vis.top + 1, vis.bottom - 1, this.getData( 'yElements' ) ) ), this.multipleRemoval( this.yElementsFind( vis.left + 1, vis.right - 1, this.getData( 'xElements' ) ) ) );
     arr = this.retNode( sim, data );
     this.setData( 'ltPropVisible', arr );
  },

  scroll :  function( event ) {
    this.findGrid();
    if( this.getMethods( 'onScroll' ) ) {
        this.executeMethod( 'onScroll', this.getData( 'ltPropVisible' ), this.getData( 'ltPropVisibleBoundary' ), this.$node)
    }
  },

  click : function( event ) {
    var className =  this.data.ltPropGridSelectionClass;
    if( className ) {
        var nodeName = this.nodeName( event ), temp = this.$node.querySelectorAll( '.' + className );
        for( var i = 0; i < temp.length; i++ ) {
            temp[ i ].classList.remove( className );
        }
        if( nodeName ) {
            nodeName.classList.add( className )
        }
    }
  },

   mousebind : function(event){
        if(event.target != this && event.button != 2)
            {  
                var isTouch = event.type == "touchstart";
                if( isTouch && event.touches.length != 1  ){
                    return;
                }
                this.component.mousedown.call(this.component, event, isTouch );
                if(!event.shiftKey){
                    document.addEventListener(isTouch ? 'touchend' : 'mouseup', this.component.upfunc, true)
                }
                event.stopPropagation();
            }
        document._lyteCurrentGrid = this.component;                  
    },

    prevent : function( evt ) {
        if( evt.touches.length == 1 && this.nodeName.call( this, evt.touches[ 0 ] ) ) {
            if( document.activeElement != document.body ) {
                document.activeElement.blur();
            }
            evt.preventDefault();
        }
    },

// after rendering properties
    didConnect : function(){    
            var scopeDiv = this.data.ltPropScope.trim(), ltPropUnitX = this.data.ltPropUnitX, ltPropMarginLeft = this.data.ltPropMarginLeft;
            this.setData('ltPropUnitxCopy', ltPropUnitX);
            this.setData('ltPropMarginLeftCopy', ltPropMarginLeft);
            this._scroll = this.scroll.bind(this);
            this._click = this.click.bind(this);
            this._prevtch = this.prevent.bind( this ); 
            this.$node.addEventListener( 'scroll', this._scroll, true);
            document.addEventListener( 'click', this._click );
            var element = this.$node.querySelector( scopeDiv );
            var lyteQuerySelector = this.data.lyteQuerySelector;
            this.scopeElement = element;   
            element.classList.add( 'lyteGridstackScope' );
            if(element.tabIndex == -1){
                 element.tabIndex = 0
            }     
            element.lyteData = {};
            element.component = this;
            element.addEventListener('mousedown', this.mousebind );
            element.addEventListener( 'touchmove', this._prevtch )
            element.addEventListener( 'touchstart', this.mousebind );
            this.setData('lyteQuerySelector.keydown', this.keydown.bind(this));
            document.addEventListener('keydown',this.getData('lyteQuerySelector').keydown)
            this.$node.getEmptyPos = function( obj ){
                return this.emptySpaceFind.call( this, obj || { } )
            }.bind( this )
            this.$node.addGrid = function(div, obj) {
                $L.fastdom.mutate(function(){
                    div._addGrid  = true;
                    var ltPropColumnMode = this.getData('ltPropColumnMode');
                    obj = obj != undefined ? obj : {};
                    var x = parseInt( div.getAttribute( 'lyte-grid-x' ) ), y = parseInt( div.getAttribute( 'lyte-grid-y' ) ), le = parseInt( div.getAttribute( 'lyte-grid-length' ) ),
                    hg = parseInt( div.getAttribute( 'lyte-grid-height' ) )
                    if( !isNaN( x ) ) {
                        obj.x = x 
                    }
                    if( !isNaN( y ) ) {
                        obj.y = y 
                    }
                    if( !isNaN( le ) ) {
                        obj.length = le 
                    }
                    if( !isNaN( hg ) ) {
                        obj.height = hg; 
                    }
                    if(obj.length){
                        obj.length = this.returnWid(obj.length, true, div)
                    }
                    if(obj.height){
                        obj.height = this.returnWid(obj.height, null, div)
                    }
                    for(var i in obj){
                        if(obj[i])
                            {
                                if(i != 'resize' ) {
                                   obj[i] = parseInt(obj[i]);
                                } 
                            }
                    }
                    obj.nodeName = div;
                    div.classList.add('lyteGridstackHandler');
                    if(!ltPropColumnMode)
                        {
                            var newVal = this.emptySpaceFind.call(this, obj);
                            if(newVal[1])    
                                {
                                    div.setAttribute('lyte-grid-x', newVal[0].x);
                                    div.setAttribute('lyte-grid-y', newVal[0].y);
                                }
                            else
                                {
                                    div.setAttribute('lyte-grid-x', ( obj.x != undefined  && obj.x.constructor == Number) ? obj.x : newVal[0].x);
                                    div.setAttribute('lyte-grid-y', ( obj.y != undefined  && obj.y.constructor == Number) ? obj.y : newVal[0].y);
                                }    
                            div.setAttribute('lyte-grid-length', obj.length ? obj.length : this.returnWid(this.getData('ltPropDefaultLength'), true));
                            div.setAttribute('lyte-grid-height', obj.height ? obj.height : this.returnWid(this.getData('ltPropDefaultHeight')));
                            div.setAttribute('lyte-grid-min-length', obj.minLength ? obj.minLength : this.returnWid(this.getData('ltPropDefaultMinLength'), true));
                            div.setAttribute('lyte-grid-min-height', obj.minHeight ? obj.minHeight : this.returnWid(this.getData('ltPropDefaultMinHeight')));
                            div.setAttribute('lyte-grid-max-length', obj.maxLength ? obj.maxLength : this.returnWid(this.getData('ltPropDefaultMaxLength'), true));
                            div.setAttribute('lyte-grid-max-height', obj.maxHeight ? obj.maxHeight : this.returnWid(this.getData('ltPropDefaultMaxHeight')));
                        }
                    if(obj.resize == 'disabled')
                        {
                            div.setAttribute('lt-prop-resize', obj.resize)
                        }
                    // new grid is appended to the dom here  
                    if( !this.scopeElement.contains( div ) ) { 
                        _lyteUiUtils.appendChild( this.scopeElement, div ) 
                    }
                    this.initialValSet.call( this );
                    this.cssConstruct.call(this, div, 'lyte-grid-y');
                    this.getData('iniData').push(this.initialPosFind.call(this, div));
                    var data = this.getData('lyteGridStack');
                    this.previousPos.call(this, data.length);
                    $L.fastdom.mutate(function(){
                        if(newVal && newVal[1] == false && !ltPropColumnMode)
                            {
                                
                                 this.topCheck.call(this, div, this.scopeElement, null, true);
                                 if(!this.getData('ltPropFloat'))
                                    {
                                        // var hgtMove = this.heightGet.call(this, div);
                                        // if(hgtMove)
                                        //     {   
                                        //         data[div.elemNum].y -= hgtMove; 
                                        //         this.valueUpdating.call(this, div.elemNum, 'lyte-grid-y', data[div.elemNum].y);
                                        //         this.setVal.call(this, div, 'lyte-grid-y', data[div.elemNum].y);
                                        //         this.previousPos.call(this, data.length);
                                        //     }
                                        // this.topMoveFunc.call(this, div, null, null, null, true);
                                        this.topCheck.call(this, div, this.scopeElement, null, true);
                                        var hgtMove = this.heightGet.call(this, div);
                                        if(hgtMove)
                                            {   
                                                data[div.elemNum].y -= hgtMove; 
                                                this.valueUpdating.call(this, div.elemNum, 'lyte-grid-y', data[div.elemNum].y);
                                                this.setVal.call(this, div, 'lyte-grid-y', data[div.elemNum].y);
                                                this.previousPos.call(this, data.length);
                                            }
                                        this.topMoveFunc.call(this, div, null, null, null, true);
                                    }
                                 this.findGrid();   

                            }
                        if(div._childGrid){
                           div._childGrid.reRender(null, true)
                       } 
                       if( this.getMethods( 'onItemAdd' ) ) {
                           $L.fastdom.measure( function(){
                                $L.fastdom.mutate( function(){
                                    this.executeMethod( 'onItemAdd', div, this.data.lyteGridStack[ div.elemNum ], this.$node )
                                }.bind( this ) )
                           }.bind( this ) )
                        }
                    }.bind(this))
                }.bind(this))                    
             }.bind(this); 
             this.$node.removeGrid = function(div){
                if(this.scopeElement.contains(div))
                    {
                        var handQuer = this.getData('ltPropHandler'), data = this.getData( 'lyteGridStack' ), hgt = data[ div.elemNum ].y + data[ div.elemNum ].height;
                        Lyte.arrayUtils(this.getData('iniData'), 'removeAt', div.elemNum);
                        // grid removed
                        if( document.body.contains( div ) ){
                            div.parentElement.removeChild(div);
                        }
                        Lyte.arrayUtils( this.getData( 'lyteGridStack' ), 'remove', 0, data.length);
                        // called for removal of unused styles
                        this.initialValSet.call(this);
                        this.positionFind.call(this, (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? this.scopeElement.querySelectorAll(handQuer) : this.scopeElement.querySelectorAll( handQuer ) );
                        this.findGrid();
                        this.topMoveAllGrid( hgt , data)
                    }
             }.bind(this);
             this.$node.reRender = function(flag){
                // previous styles are removed and new will be constructed
                    if(this._style){
                        this.$node.removeChild(this._style);
                        delete this._style;
                    }
                    var data = this.getData('lyteGridStack');
                    Lyte.arrayUtils(data, 'remove', 0 , data.length);
                    this.didConnectWrk.call(this, true, flag);
             }.bind(this),
             this.$node.setProperty = function(targetDiv, propertyName, propValue){
                if(propertyName == "height" || propertyName == "length"){ 
                        propValue = this.returnWid(propValue, propertyName == "length" ? true : false, targetDiv)
                }else{
                    propValue = parseInt(propValue)
                }
                var data = this.getData('lyteGridStack');
                var comProp = ['x', 'y', 'length', 'height'];
                var dataVal = {};
                if(comProp.indexOf(propertyName) != -1){
                    for(var yy in data[targetDiv.elemNum]){
                        if(comProp.indexOf(yy) != -1)
                            {
                                dataVal[yy] = data[targetDiv.elemNum][yy];
                            }
                    }
                    
                    dataVal[propertyName] = propValue;
                    dataVal.nodeName = targetDiv;
                    var newVal = this.emptySpaceFind.call(this, dataVal);
                    if(newVal[1]){
                        for(var zz in newVal[0]){
                            this.setVal.call(this, targetDiv, 'lyte-grid-' + zz, newVal[0][zz]);
                        } 
                    }
                }
                this.setVal.call(this, targetDiv, 'lyte-grid-' + propertyName, propValue);
                var pp = propertyName.replace(/(-\w)/g, function (m) {
                        return m[1].toUpperCase();
                    });
                data[targetDiv.elemNum][pp] = propValue
                if(comProp.indexOf(propertyName) != -1)
                    {
                        this.valueUpdating.call(this, targetDiv.elemNum, 'lyte-grid-' + propertyName, propValue);
                        this.previousPos.call(this, data.length);
                        if(newVal[1] == false){
                            this.topCheck.call(this, targetDiv, this.scopeElement, null, true);
                        }
                        if(!this.getData('ltPropFloat')){
                            var hgtMove = this.heightGet.call(this, targetDiv);
                            if(hgtMove)
                                {   
                                    data[targetDiv.elemNum].y -= hgtMove; 
                                    this.valueUpdating.call(this, targetDiv.elemNum, 'lyte-grid-y', data[targetDiv.elemNum].y);
                                    this.setVal.call(this, targetDiv, 'lyte-grid-y', data[targetDiv.elemNum].y);
                                    this.previousPos.call(this, data.length);
                                }
                            this.topMoveFunc.call(this, targetDiv, null, null, null, true);
                        }
                        this.previousPos.call(this, this.scopeElement.querySelectorAll( this.data.ltPropHandler ) );
                    }
                if(targetDiv._childGrid){
                        if((propertyName == "height" || propertyName == "length")){
                            targetDiv._childGrid.reRender(true)
                        }
                   }
                this.findGrid();  
                if( this.getMethods( 'onPropertyChange' ) ) {
                       $L.fastdom.measure( function(){
                            $L.fastdom.mutate( function(){
                                this.executeMethod( 'onPropertyChange', targetDiv, propertyName, this.data.lyteGridStack[ targetDiv.elemNum ], this.$node )
                            }.bind( this ) )
                       }.bind( this ) )
                    }
             }.bind(this);
            this._resizeFunc = this.windowResize.bind(this);   
            this._initialWindowWidth = window.innerWidth
            window.addEventListener('resize', this._resizeFunc, true); 
            window.addEventListener( 'orientationchange', this._resizeFunc, true );
            if(this.checkPreviousGrid()){
                return
            }
            this.didConnectWrk.call(this, true)
    },

    gridLength : function(width, ltPropUnitX1, ltPropMarginLeftCopy){
       ltPropMarginLeftCopy = ltPropMarginLeftCopy ? ltPropMarginLeftCopy : 'ltPropMarginLeftCopy';
       var margin = parseInt(this.getData(ltPropMarginLeftCopy));
       var ltPropUnitX = ltPropUnitX1 ? ltPropUnitX1 : this.data.ltPropUnitX , len = parseInt((((width ? width : (this.bcrrelem ? this.bcrrelem.width : this.scopeElement.getBoundingClientRect().width)) - (margin)) / (ltPropUnitX + margin)).toFixed(0));
       return len;
    },

    columnModeLengthFind : function(){
        this._prevObs = true;
        var length = this.getData('ltPropGridLength') || this.getData('ltPropColumn');
        var margin = this.getData('ltPropMarginLeftCopy'),
        valueToSet;
        margin = margin ? margin : this.getData('ltPropMarginLeft');

        valueToSet = (( this.bcrrelem ? this.bcrrelem.width : this.scopeElement.getBoundingClientRect().width) - ( length + 1 ) * margin) / length;

        valueToSet = parseFloat( valueToSet.toFixed( 2 ) );

        this.setData('ltPropUnitX', valueToSet );
        delete this._prevObs;
    },

    didConnectWrk : function(flag, flag2){
        $L.fastdom.measure(function(){
                if(!this.$node.offsetParent){
                    return
                }
                this.data.direction = _lyteUiUtils.getRTL();
                if( this.data.direction ) {
                    this.$node.classList.add( 'lyteRTL' )
                } else {
                    this.$node.classList.remove( 'lyteRTL' )
                }
                var bcrrelem = this.scopeElement.getBoundingClientRect(), element = this.scopeElement, lyteQuerySelector = this.getData('lyteQuerySelector');
                this.bcrrelem = bcrrelem;  
                var ltPropColumnMode = this.getData('ltPropColumnMode') 
                var handQuer = this.getData('ltPropHandler');
                var iniData = this.getData('iniData');
                var data = this.getData('lyteGridStack');
                Lyte.arrayUtils(iniData, 'remove', 0, iniData.length);
                var elements = (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? element.querySelectorAll(handQuer) : element.querySelectorAll( handQuer );
                if( this._parentGrid && !this.getData('ltPropGridLength')) {
                    var grL = this.gridLength();
                    this.setData( 'ltPropGridLength', grL);
                    this.setData('gridLength', grL);
                }
                if(ltPropColumnMode || this.getData('ltPropGridLength')){
                    this.columnModeLengthFind();
                }
                if(!this.getData('gridLength') || flag2 || ltPropColumnMode){
                    this.setData('gridLength', this.gridLength())
                }
                if(!this.$node.ltProp('gridHeight') && !flag2 || ltPropColumnMode){
                        this.$node.ltProp('gridHeight', this.getData('gridLength'));
                }else if(flag2){
                    this.$node.ltProp('gridHeight', this.getData('gridLength'));
                } 
             for(var i = 0; i < elements.length; i++)
                {
                    iniData.push(this.initialPosFind.call(this, elements[i]));
                }
                $L.fastdom.mutate(this.initialValSet.bind(this))    
                var elements = element.querySelectorAll( this.data.ltPropHandler ), ltPropUnitX = this.data.ltPropUnitX;
                element.lyteData.gridLength = this.data.gridLength
                element.lyteData.gridHeight = lyteQuerySelector.maxHeight;
                
                this._initialXRatio = ltPropUnitX / ( bcrrelem.width - this.data.gridLength * this.data.ltPropMarginLeft  );
                // this._initialMarginRatio = this.data.ltPropMarginLeft / ltPropUnitX;
                $L.fastdom.mutate(function(){
                        if(this._childGrids.length){
                            for(var i = 0; i < this._childGrids.length; i++){
                               this._childGrids[i].reRender()
                            }
                        }
                        if(flag){
                            if(this.getMethods('afterRender')){
                                $L.fastdom.measure( function(){
                                    $L.fastdom.mutate( function(){
                                        this.findGrid();
                                       /**
                                        * @method afterRender
                                        * @version 1.0.1
                                        */
                                        this.executeMethod('afterRender', this.$node);
                                    }.bind( this ) )
                                }.bind( this ) )
                            }
                        }
                }.bind(this))
            }.bind(this)) 
    },
    // data 
    data : function(){
        return {
            // user data
           /**
            * @componentProperty {string} ltPropScope=''
            * @version 1.0.0
            */
            ltPropScope : Lyte.attr("string",{"default": ''}), 
           /**
            * @componentProperty {string} ltPropHandler=''
            * @version 1.0.0
            */
            ltPropHandler : Lyte.attr("string",{"default":''}),
           /**
            * @componentProperty {number} ltPropMarginLeft=10
            * @version 1.0.0
            */ 
            ltPropMarginLeft : Lyte.attr("number",{"default":10}), 
           /**
            * @componentProperty {number} ltPropMarginTop=10
            * @version 1.0.0
            */ 
            ltPropMarginTop : Lyte.attr("number",{"default":10}), 
           /**
            * @componentProperty {number} ltPropUnitX=50
            * @version 1.0.0
            */
            ltPropUnitX : Lyte.attr("number",{"default":50}), 
           /**
            * @componentProperty {number} ltPropUnitY=50
            * @version 1.0.0
            */
            ltPropUnitY : Lyte.attr("number",{"default":50}), 
           /**
            * @componentProperty {string[]} ltPropResizeDirection
            * @version 1.0.0
            * @default ["left","right","bottom","bottomRight","bottomLeft","top","topLeft","topRight"]
            */
            ltPropResizeDirection : Lyte.attr("array",{"default":['left', 'right', 'bottom', 'bottomRight', 'bottomLeft', 'top', 'topLeft', 'topRight']}), 
           /**
            * @componentProperty {boolean} ltPropFloat=false
            * @version 1.0.0
            */
            ltPropFloat : Lyte.attr("boolean",{"default": false}), 
           /**
            * @componentProperty {vertical | horizontal} ltPropDirection=vertical
            * @version 1.0.0
            */
            ltPropDirection : Lyte.attr("string",{"default":"vertical"}), 
           /**
            * @componentProperty {boolean} ltPropUndo=true
            * @version 1.0.0
            */
            ltPropUndo : Lyte.attr("boolean",{"default": true}), 
           /**
            * @componentProperty {boolean} ltPropResize=true
            * @version 1.0.0
            */
            ltPropResize : Lyte.attr("boolean",{"default": true}), 
           /**
            * @componentProperty {boolean} ltPropBestfit=true
            * @version 1.0.0
            */
            ltPropBestfit : Lyte.attr("boolean",{"default": true}), 
           /**
            * @componentProperty {number} ltPropMinUnitX=0
            * @version 1.0.0
            */
            ltPropMinUnitX : Lyte.attr('number',{default : 0}),
           /**
            * @componentProperty {number} ltPropMinMarginLeft=0
            * @version 1.0.1
            */
            ltPropMinMarginLeft : Lyte.attr('number',{default : 0}),
           /**
            * @componentProperty {string} ltPropBestfitClass=''
            * @version 1.0.1
            */
            ltPropBestfitClass : Lyte.attr('string', {default : ''}),
           /**
            * @componentProperty {boolean} ltPropFreezeMode=false
            * @version 1.0.1
            */
            ltPropFreezeMode : Lyte.attr('boolean', {default : false}),
           /**
            * @componentProperty {string} ltPropDefaultLength=2
            * @version 1.0.1
            */
            ltPropDefaultLength : Lyte.attr('string',{default : '2'}),
           /**
            * @componentProperty {string} ltPropDefaultHeight=2
            * @version 1.0.1
            */
            ltPropDefaultHeight : Lyte.attr('string',{default : '2'}),
           /**
            * @componentProperty {string} ltPropDefaultMinLength=1
            * @version 1.0.1
            */
            ltPropDefaultMinLength : Lyte.attr('string',{default : '1'}),
           /**
            * @componentProperty {string} ltPropDefaultMinHeight=1
            * @version 1.0.1
            */
            ltPropDefaultMinHeight : Lyte.attr('string',{default : '1'}),
           /**
            * @componentProperty {string} ltPropDefaultMaxHeight=0
            * @version 1.0.1
            */
            ltPropDefaultMaxHeight : Lyte.attr('string',{default : '0'}),
           /**
            * @componentProperty {string} ltPropDefaultMaxLength=0
            * @version 1.0.1
            */
            ltPropDefaultMaxLength : Lyte.attr('string',{default : '0'}),
           /**
            * @componentProperty {boolean} ltPropColumnMode=false
            * @version 1.0.1
            */
            ltPropColumnMode : Lyte.attr('boolean', {default : false}),
           /**
            * @componentProperty {number} ltPropColumn=false
            * @version 1.0.1
            */
            ltPropColumn : Lyte.attr('number', {default : 3}),
            /**
             * @typedef {object} preventObject
             * @property {boolean} horizontal=false
             * @property {boolean} vertical=false
             */

           /**
            * @componentProperty {preventObject} ltPropPrevent
            * @version 1.0.2
            */
            ltPropPrevent : Lyte.attr('object', { default : { horizontal : false, vertical : false }}),
           /**
            * @componentProperty {number} ltPropGridLength
            * @version 1.0.2
            */
            ltPropGridLength : Lyte.attr('number', {default : undefined}),
           /**
            * @componentProperty {default | grid } ltPropBestfitType=default
            * @version 1.0.2
            */
            ltPropBestfitType : Lyte.attr('string', { default : 'default'}),
           /**
            * @componentProperty {boolean} ltPropForcedReposition=false
            * @version 1.0.2
            */
            ltPropForcedReposition : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {boolean} ltPropSquareGrid=false
            * @version 1.0.2
            */
            ltPropSquareGrid : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {string} ltPropGridSpaceColor=#f8f8f8
            * @version 1.0.2
            */
            ltPropGridSpaceColor : Lyte.attr('string', { default : '#f8f8f8' }),
           /**
            * @componentProperty {boolean} ltPropHitBottom=false
            * @version 1.0.2
            */
            ltPropHitBottom : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {string} ltPropGridSelectionClass=lyteGridFocused
            * @version 1.0.4
            */
            ltPropGridSelectionClass: Lyte.attr( 'string', { default : 'lyteGridFocused' } ),
           /**
            * @componentProperty {object} ltPropVisibleBoundary={}
            * @version 1.0.4
            */
            ltPropVisibleBoundary : Lyte.attr( 'object', { default : {} } ),
           /**
            * @componentProperty {array} ltPropVisible
            * @version 1.0.4
            * @default []            
            */
            ltPropVisible : Lyte.attr( 'array', { default : [] } ),
           /**
            * @componentProperty {boolean} ltPropCheckCurrentPosition=false
            * @version 2.2.6
            */
            ltPropCheckCurrentPosition : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {boolean} ltPropContainment=false
            * @version 2.2.6
            */
            ltPropContainment : Lyte.attr( 'boolean', { default : false } ),

            // system data
            /**
             * @experimental gridLength
             */
            gridLength : Lyte.attr("number",{"default":undefined}), 
            /**
             * @experimental ltPropGridHeight
             */
            ltPropGridHeight : Lyte.attr("number",{"default":undefined}),
            /**
             * @experimental ltPropMarginLeftCopy
             */
            ltPropMarginLeftCopy : Lyte.attr("number",{"default":10}), 
            /**
             * @experimental ltPropUnitxCopy
             */
            ltPropUnitxCopy : Lyte.attr("number",{"default":50}), 
            /**
             * @experimental lyteGridStack
             */ 
            lyteGridStack : Lyte.attr("array",{"default":[]}), 
            /**
             * @experimental elements
             */
            elements : Lyte.attr("object",{"default":undefined}), 
            /**
             * @experimental oriNode
             */
            oriNode : Lyte.attr("object",{"default":undefined}), 
            /**
             * @experimental xElements
             */
            xElements : Lyte.attr("array",{"default":[]}), 
            /**
             * @experimental yElements
             */
            yElements : Lyte.attr("array",{"default":[]}),
            /**
             * @experimental iniData
             */
            iniData : Lyte.attr('array', {'default' : []}),
            /**
             * @experimental lyteQuerySelector
             */
            lyteQuerySelector : Lyte.attr('object',{'default' : { SelectedNodes : [] }}),
            /**
             * @experimental direction
             */
            direction : Lyte.attr( 'boolean', { default : false } )
        }
    },  
    // undo
    undoPrevious : function(){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector') ;
            var elements = this.scopeElement.querySelectorAll( this.data.ltPropHandler );
            if((lyteQuerySelector.currentPos) <= data[data.length - 1].oldHeight.length && lyteQuerySelector.currentPos >= 1)
                {
                    for(var i = 0;i < elements.length;i++ )
                        {
                            data[i].x = parseInt(data[i].oldX[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-x-old'] = data[i].x
                            data[i].y = parseInt(data[i].oldY[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-y-old'] = data[i].y
                            data[i].length = parseInt(data[i].oldLength[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-length-old'] = data[i].length
                            data[i].height = parseInt(data[i].oldHeight[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-height-old'] = data[i].height
                        }
                    this.displayGrid.call(this);
                    lyteQuerySelector.currentPos = (lyteQuerySelector.currentPos - 1) >= 0 ? (lyteQuerySelector.currentPos - 1) : 0;  
                }
        },
        // redo 
    undoNext : function(){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector') ;
           var elements = this.scopeElement.querySelectorAll( this.data.ltPropHandler );
            if((lyteQuerySelector.currentPos) <= (data[data.length - 1].oldHeight.length-1))
                {
                    var dumm = lyteQuerySelector.currentPos < (data[data.length - 1].oldHeight.length - 1) ? (lyteQuerySelector.currentPos + 1) : (data[data.length - 1].oldHeight.length - 1);
                    for(var i = 0; i < elements.length; i++)
                        {
                            data[i].x = parseInt(data[i].oldX[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-x-old'] = data[i].x;
                            data[i].y = parseInt(data[i].oldY[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-y-old'] = data[i].y;
                            data[i].length = parseInt(data[i].oldLength[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-length-old'] = data[i].length;
                            data[i].height = parseInt(data[i].oldHeight[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-height-old'] = data[i].height;
                        }
                    this.displayGrid.call(this);
                    lyteQuerySelector.currentPos = dumm;
                }
    },

     emptySpaceFind : function(objj, flagg, mappArray1, flag2){
        var data = this.getData('lyteGridStack'), hgtShort;
        var mappArray = [], i ,j ,gridLength = this.getData('gridLength'), gridHeight = this.getData('ltPropGridHeight');
        if(!flagg)       
            {
                for(i = 0; i < gridLength; i++)
                    {
                        mappArray.push([]);
                        for(var z = 0; z < gridHeight; z++)
                            {
                                mappArray[i].push(false)
                            }
                    }
                for(i = 0; i < data.length; i++)
                    {   
                        if(data[i].x != undefined && data[i].y != undefined)
                            {
                                for(var k = data[i].x; k < (data[i].x + data[i].length); k++)
                                    {
                                        for(var m = data[i].y; m < (data[i].y + data[i].height); m++)
                                            {
                                                if(data[i].nodeName != objj.nodeName && mappArray[k] != undefined && mappArray[k][m] != 'res')
                                                    {
                                                        mappArray[k][m] = true;
                                                    }
                                                 else if(mappArray[k] && mappArray[k][m] == false)
                                                    {
                                                        mappArray[k][m] = 'res';
                                                    }   
                                            }
                                    }
                            }
                    } 
            }
          else
            {
                mappArray = mappArray.concat(mappArray1.slice());
            }  
        objj.length = objj.length != undefined ? objj.length : this.returnWid(this.getData('ltPropDefaultLength'), true);  
        objj.height = objj.height != undefined ? objj.height : this.returnWid(this.getData('ltPropDefaultHeight'));
        var xStar = objj.x ? objj.x : 0;    
        var yStar = objj.y ? objj.y : 0; 
        var xLim = objj.x != undefined && !isNaN(objj.x) ? (objj.x + 1) : (gridLength + 1 - objj.length);
        var yLim = objj.y != undefined && !isNaN(objj.x) ? (objj.y) : (gridHeight - 1);
        for(var i = yStar; i <= yLim; i++)
            {
                for(var j = xStar; j < xLim; j++)
                    {
                        var flag = true;
                        for(var k = j; k < (j + objj.length); k++)
                            {
                                for(var l = i; l < (i + objj.height); l++)
                                    {
                                        if(mappArray[k] && mappArray[k][l] == true)
                                            {
                                                flag = false;
                                                hgtShort = l - i;
                                                break;
                                            }
                                    }
                                 if(!flag)
                                    {
                                        break;
                                    }   
                            }
                        if(flag && j < (gridLength + 1 - objj.length))
                            {
                                return [{x : j, y : i}, !flagg];
                            }    
                    }   
            }
        var temp;
        if(!flagg){
            var sdObj = {length : objj.length, height : objj.height, nodeName : objj.nodeName};
                if( objj.x && !objj.y ) {
                    this.setData('ltPropGridHeight', gridHeight + objj.height); 
                    sdObj.x = objj.x;
                }
                temp = this.emptySpaceFind.call(this, sdObj, true, mappArray);
            }
       if( !temp ){
                this.setData('ltPropGridHeight', gridHeight + objj.height);
                temp = this.emptySpaceFind.call(this, {length : objj.length, height : objj.height, nodeName : objj.nodeName}, true, mappArray, true);

            }  
          return (temp.constructor == Array ? temp : [temp, false]);   
    }

}); 


/**
* @syntax yielded
* <lyte-gridstack lt-prop-scope="div.lyteGridStack " lt-prop-handler=".lyteGridStackItem " lt-prop-grid-length= 11  lt-prop-bestfit-type="grid " >
*    <template is="registerYield" yield-name="lyteGridStack">
*       <div class="lyteGridStack">
*          <div class="lyteGridStackItem" lyte-grid-x="2" lyte-grid-y="0" lyte-grid-length="2" lyte-grid-height="3" >
*             <lyte-grid-content> 1</lyte-grid-content>
*          </div>
*          <div  class="lyteGridStackItem" lyte-grid-x="2" lyte-grid-y="3" lyte-grid-length="2" lyte-grid-height="3"  lyte-prop-resize="disabled" >
*             <lyte-grid-content  > 1</lyte-grid-content>
*          </div>
*      </div>
*    </template>
* </lyte-gridstack>
*/   


/**
 * Renders a grouper
 * @component lyte-grouper
 * @version 3.1.0
 */
Lyte.Component.register("lyte-grouper", {
_template:"<template tag-name=\"lyte-grouper\" style=\"width:{{ltPropWidth}}\"> <lyte-yield yield-name=\"yield\" onclick=\"{{action('onclick',event)}}\" class=\"lyteGroupWrap lyteGroup{{ltPropAlignment}} {{ltPropAppearance}}Type\"> </lyte-yield> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}],
_templateAttributes :{"type":"attr","position":[],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width:'","ltPropWidth"]}}}},
_observedAttributes :["ltPropAlignment","ltPropAppearance","ltPropWidth","ltPropSelectedClass","currentClass"],
	data : function(){
		return {
			/** 
			 * @componentProperty {Horizontal | Vertical} ltPropAlignment=Horizontal
			 * @default Horizontal
			 */
			ltPropAlignment : Lyte.attr("string", {"default" : "Horizontal"}),
			/** 
			 * @componentProperty {line | fill} ltPropAppearance=line
			 */
			ltPropAppearance : Lyte.attr("string",{"default" : "line"}),
			/** 
			 * @componentProperty {string} ltPropWidth=auto
			 */
			ltPropWidth : Lyte.attr("string",{"default" : "auto"}),
			/** 
			 * @componentProperty {array} ltPropSelectedClass
			 */
			ltPropSelectedClass : Lyte.attr("array",{"default" : ["selected1","selected2"]}),

			currentClass : Lyte.attr("string",{"default" : ""})
		}		
	},
	getClass : function(index){
		var selectedClass = this.data.ltPropSelectedClass;
		return selectedClass[index]? selectedClass[index] : selectedClass[0];
	},
	getContainer : function(){
		return this._container;
	},
	removeOldClass : function(container){
		var currentClass = this.data.currentClass;
		if(currentClass){
			container.classList.remove(currentClass);
			this.storeCurrentClassAsOld("");
		}
	},
	addNewClass : function(target){
		var container = this.getContainer(),
		children = container.children;
		for(var index=0;index<children.length;index++){
			var child  =  children[index],newClass;
			if(child.contains(target)){
				newClass = this.getClass( index );
				if(newClass){
					container.classList.add(newClass);
					this.storeCurrentClassAsOld(newClass);
				}
				break;
			} 
		}
	},
	storeCurrentClassAsOld : function(className){
		this.setData("currentClass",className);
	},
	didConnect : function(){
		this._container = this.$node.querySelector("lyte-yield");
	},
	didDestory : function(){
		delete this._container;
	},
	actions:{
		onclick : function(event){
			var container = this.getContainer();
			this.removeOldClass(container);
			this.addNewClass(event.target);
		}
	},
	classChange : function(changes){
		var oldClasses = changes.oldValue, indexOfOldClass, currentClassClass = this.data.currentClass,newClass,
		container = this.getContainer(); 
		indexOfOldClass = oldClasses.indexOf(currentClassClass);
		if(indexOfOldClass > -1){
			newClass =  this.getClass(indexOfOldClass);
			this.removeOldClass(container);
			if(newClass){
				container.classList.add(newClass);
				this.storeCurrentClassAsOld(newClass);
			}
		}
	}.observes("ltPropSelectedClass")
});
document.addEventListener("click",function(event){
	var groupers = document.querySelectorAll("lyte-grouper"),target = event.target;
	groupers.forEach(function(node){
		var comp = node.component,
		container = comp.getContainer();
		if(container){
			if(!container.contains(target) && comp.data.currentClass){
				comp.removeOldClass(container);
			}
		}
	});
},true);
/**
 * Renders a hovercard
 * @component lyte-hovercard
 * @dependencies lyte-popover
 * /components/lyte-popover.js
 * /theme/compiledCSS/default/ltr/lyte-ui-popover.css
 * @version  3.1.0
 * @methods beforeRender,afterRender,onHovercardShow,onHovercardHide,onHovercardBeforeHide
 */
Lyte.Component.register( 'lyte-hovercard', {
_template:"<template tag-name=\"lyte-hovercard\"> <template is=\"if\" value=\"{{ltPropShow}}\"><template case=\"true\"> <lyte-wormhole case=\"true\" style=\"{{if(ltPropShowCopy,'visibility:visible','visibility:hidden')}}\" on-before-append=\"{{method(&quot;beforeWormholeAppend&quot;)}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"hoverCardWrapper {{ltPropClass}}\" id=\"{{ltPropId}}\"> <lyte-yield yield-name=\"hoverCardYield\"></lyte-yield> </div> </template> </lyte-wormhole> </template></template> <lyte-popover class=\"lyteHoverCard\" lt-prop-wrapper-class=\"lyteHovercardPopover\" lt-prop-close-on-body-click=\"false\" lt-prop-show-close-button=\"false\" lt-prop-bind-to-body=\"true\"> <template is=\"registerYield\" yield-name=\"popover\"> </template> </lyte-popover> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropShowCopy","'visibility:visible'","'visibility:hidden'"]}}}},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1,1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"registerYield","position":[3,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[3]}],
_observedAttributes :["ltPropDisplay","ltPropShow","ltPropOriginElem","ltPropMaxHeight","ltPropWidth","ltPropHeight","ltPropPlacement","ltPropClass","ltPropId","ltPropShowDelay","ltPropHideDelay","ltPropMaxDisplayTime","ltPropKeepAlive","ltPropFollowCursor","ltPropPopoverWrapperClass","ltPropOffset","ltPropCloseOnEscape","ltPropAutoShow","ltPropHideOnClick","mousePosition","mouseover","originEle"],
  data : function(){
    return {
      /** 
       * @componentProperty {boolean} ltPropDisplay=true
       * @version 3.1.0
       */
      'ltPropDisplay' : Lyte.attr( 'boolean', { 'default' : true } ),
      /** 
       * @componentProperty {boolean} ltPropShow=false
       * @version 3.1.0
       */
        'ltPropShow' : Lyte.attr( 'boolean', { 'default' : false } ),
        /** 
       * @componentProperty {string} ltPropOriginElem=''
       * @version 3.1.0
       */
        'ltPropOriginElem' : Lyte.attr( 'string', { 'default' : '' } ),
        /** 
       * @componentProperty {string} ltPropMaxHeight=''
       * @version 3.1.0
       */
        'ltPropMaxHeight' : Lyte.attr( 'string', { 'default' : '' } ),
        /** 
       * @componentProperty {string} ltPropWidth=''
       * @version 3.1.0
       */
        'ltPropWidth' : Lyte.attr( 'string', { 'default' : '' } ),
        /** 
       * @componentProperty {string} ltPropHeight=auto
       * @version 3.1.0
       */
        'ltPropHeight' : Lyte.attr( 'string', { 'default' : 'auto' } ),
        /** 
       * @componentProperty {string} ltPropPlacement=''
       * @version 3.1.0
       */
        'ltPropPlacement' : Lyte.attr( 'string', { 'default' : '' } ),
        /** 
       * @componentProperty {number} ltPropClass=''
       * @version 3.1.0
       */
        'ltPropClass' : Lyte.attr( 'string', { 'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'class', '' ) } ),
        /** 
       * @componentProperty {string} ltPropId=''
       * @version 3.1.0
       */
        'ltPropId' : Lyte.attr( 'string', { 'default' : '' } ),
        /** 
       * @componentProperty {number} ltPropShowDelay=0
       * @version 3.1.0
       */
        'ltPropShowDelay' : Lyte.attr( 'number', { 'default': 0 } ),
        /** 
       * @componentProperty {number} ltPropHideDelay=0
       * @version 3.1.0
       */
        'ltPropHideDelay' : Lyte.attr( 'number', { 'default': 0 } ),
        /** 
       * @componentProperty {number} ltPropMaxDisplayTime=5000
       * @version 3.1.0
       */
        'ltPropMaxDisplayTime' : Lyte.attr( 'number', { 'default' : 5000 } ),
        /** 
       * @componentProperty {boolean} ltPropKeepAlive=false
       * @version 3.1.0
       */
        'ltPropKeepAlive' : Lyte.attr( 'boolean', { 'default' : false } ),
        /** 
       * @componentProperty {boolean} ltPropFollowCursor=false
       * @version 3.1.0
       */
        'ltPropFollowCursor' : Lyte.attr( 'boolean', { 'default' : false } ),
        /** 
       * @componentProperty {string} ltPropPopoverWrapperClass
       * @version 3.1.0
       */
        'ltPropPopoverWrapperClass' : Lyte.attr( 'string',{'default': _lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'popoverWrapperClass', '' ) }),
        /** 
       * @componentProperty {object} ltPropOffset={}
       * @version 3.1.0
       */
        'ltPropOffset' : Lyte.attr( 'object', { 'default' : {} } ),
        /** 
       * @componentProperty {boolean} ltPropCloseOnEscape=true
       * @version 3.1.0
       */
        'ltPropCloseOnEscape' : Lyte.attr( 'boolean', { 'default' : true } ),
        /** 
        * @componentProperty {boolean} ltPropAutoShow=false
        * @version 3.1.0
        */
        'ltPropAutoShow' : Lyte.attr( 'boolean', { 'default' : false}),
        'ltPropHideOnClick' : Lyte.attr( 'boolean', { 'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'hideOnClick', false ) } ),
        'mousePosition' : Lyte.attr( 'array', { 'default' : [] } ),
        'mouseover' : Lyte.attr( 'boolean', { 'default' : false } ),
        'originEle' : Lyte.attr( 'string', { 'default' : ''})

    }   
  },
  init : function() {
    this._dir = _lyteUiUtils.getRTL();
    if( this.getMethods( 'beforeRender' ) ){
            this.executeMethod( 'beforeRender', this.$node );
      }
  },
  didConnect : function(){
    this._popover = this.$node.getElementsByTagName('lyte-popover')[0]
    this._hovercardScroll = this.hovercardScroll.bind( this );
    this._hovercardHideOnClick = this.hovercardHideOnClick.bind(this)
    this._mousemove = this.mousemove.bind(this);
    if(this.getData('ltPropAutoShow')){
      this.setMouseMove()
    }
    $L.fastdom.measure( function() {
         var fg = window.getComputedStyle( this.$node ).getPropertyValue( 'direction' ) == 'rtl';
         $L.fastdom.mutate( function(){
           if( fg ) {
             this.direction = true;
           }
         }.bind( this ) )
    }.bind( this ) )
    if( this.getMethods( 'afterRender' ) ) {
       this.executeMethod('afterRender', this.$node);
    }
  },
  didDestroy : function(){
    this.$node.classList.remove('lyteActive')
    if( this.getData( 'ltPropHideOnClick') ){
      document.removeEventListener( 'click' , this._hovercardHideOnClick )
    }
    var originElem = document.querySelector( this.$node.ltProp( 'originElem' ) ) 

    if(originElem && this._closeHoverCard){
      originElem.removeEventListener( 'mouseleave', this._closeHoverCard )
    }
    if(this._popover){
      this._popover.setData('ltPropShow',false)
    }
    if(_lyteUiUtils.lyteHovercard){
      delete _lyteUiUtils.lyteHovercard[this.$node.ltProp( 'originElem' ) ]

    }
    delete this.prevHoverCardNode;
    delete this._childComp;
    delete this._popover;
  },
  addEventListenerForOriginElem : function( originElem ) {
    if(originElem){
      originElem.addEventListener( 'mousemove', this.oriEleMousemove.bind( this ) )
    }
  },
  removeEventListenerForOriginElem : function(originElem ) {
    if(originElem){
      originElem.removeEventListener( 'mousemove', this.oriEleMousemove.bind( this ) )
    }
    this.setData( 'mousePosition', [] )
    this.setData( 'mouseover', false )

  },
  hovercardHideOnClick : function(event){
    var target = event.target,
    popoverWormhole = this._popover.component.actualModalDiv;
    if( this.getData( 'ltPropHideOnClick' ) && this.getData( 'ltPropShow' ) && !( target === popoverWormhole || popoverWormhole.contains( target ) ) ){
          this.setData( 'ltPropShow', false )
      }
  },
  oriEleMousemove : function( eve ) {

    if( !this.getData( 'mouseover' ) ) {
        this.mouseovereve( eve )
        this.setData( 'mouseover', true )
    }
    var currMpos = [ eve.clientX, eve.clientY ];
    var mpos = this.getData( 'mousePosition' );
    var diff = [ currMpos[ 0 ] - ( mpos[ 0 ]? mpos[ 0 ] : 0 ), currMpos[ 1 ] - ( mpos[ 1 ] ? mpos[ 1 ] : 0 ) ];
    if( this._popover.ltProp( 'show' ) && this._popover.component.childComp) {
      var popupEle = $L( '.lyteHoverCardFollowCursor .lytePopover' ,this._popover.component.childComp)[ 0 ];
      var clientRect = popupEle.getBoundingClientRect();
      popupEle.style.top = clientRect.top + diff[ 1 ] + 'px';
      popupEle.style.left = clientRect.left + diff[ 0 ] + 'px';
    }
    this.setData( 'mousePosition', currMpos );
  },
  mouseovereve : function( eve ) {
    var mpos = [ eve.clientX, eve.clientY ];
    var pos = '';
    var clientRect = document.querySelector( this.$node.ltProp( 'originElem' ) )
    
    this._popover.ltProp( {
      offset : { left : mpos[ 0 ] - 9, top : mpos[ 1 ] - 9, height : 18, width : 18 }
    } )
    this.setData('ltPropOffset',{ left : mpos[ 0 ] , top : mpos[ 1 ] , height : 18, width : 18 })
    this.setData( 'mousePosition', mpos );
  },
  mousemove : function(event){
    var nodeName1 = event.target.correspondingElement || event.target;
    while(nodeName1 && nodeName1.tagName != 'BODY' && nodeName1 != document && nodeName1.tagName != 'HTML' ){
        
        var iHovercard = nodeName1.getAttribute( 'lyte-hovercard' );

        if( iHovercard ){
          var hovercard = this.findMatchingHoverCard(nodeName1);
          if( hovercard && !hovercard.getData('ltPropShow')){
             hovercard.setData('ltPropShow',true);
          } 
          break;
          
        }
        else {
            nodeName1 = nodeName1.parentNode;
        }  
    }
  
},
 findMatchingHoverCard : function(node){
   for(var item in _lyteUiUtils.lyteHovercard){
      if(node.matches(item)){
        return _lyteUiUtils.lyteHovercard[item];
      }
  }
 },
 setMouseMove : function(){
    var map = _lyteUiUtils.lyteHovercard ? _lyteUiUtils.lyteHovercard : []
    map[this.$node.ltProp( 'originElem' )] = this.$node;
    _lyteUiUtils.lyteHovercard = map;
    document.addEventListener('mousemove',this._mousemove)
  },
  
  compouteOffset : function( popover ) {
      var arr = [ 'ltPropWidth', 'ltPropHeight', 'ltPropMaxHeight', 'ltPropMaxWidth' ];
      for( var i = 0; i < arr.length; i++ ) {
            if( this.getData( arr[ i ] ) ) {
                  popover.setData( arr[ i ], this.getData( arr[ i ] ) )
            }
       }
  },
  createHoverCard : function( event, popoverWormhole ) {
    var popover = this._popover
    if(popover){
        popover.ltProp( 'show', true )
        popover.ltProp( 'allowMultiple', true)
        this.$node.classList.add( 'lyteActive' )
        if( this.getMethods( 'onHovercardShow' ) ) {
                this.executeMethod('onHovercardShow', this.$node );
        }
    }
    if( !this.getData( 'ltPropKeepAlive' ) && !this.getData('ltPropFollowCursor')) {
          var originElem = document.querySelector( this.$node.ltProp( 'originElem' ) )

          popover._maxdisp = setTimeout( function() {
            this.removeHoverCard(popover, originElem, event, popoverWormhole)
          }.bind( this ), this.getData( 'ltPropMaxDisplayTime' ) );
    }
    
  },
  removeTimeout : function( popover ) {
        clearTimeout( popover._settime )
        clearTimeout( popover._maxdisp )
        clearTimeout( popover._bodyTimeout )
  },
  originEleObs : function(){
    
    if(this.getData('originEle') && _lyteUiUtils.lyteHovercard){
      delete _lyteUiUtils.lyteHovercard[ this.$node.ltProp( 'originElem' ) ]
    }
    this.setData( 'originEle', this.getData( 'ltPropOriginElem' ) )
  }.observes('ltPropOriginElem'),
  showToggled : function() {

      var popover = this._popover
      if( popover.component && !popover.getData( 'ltPropBindToBody' ) ) {
          popover.ltProp( 'bindToBody', true )
      }
      var wormHole = this._childComp.querySelector('.hoverCardWrapper' ),
       popoverWormhole = this._popover.component.actualModalDiv,
       originElem = document.querySelector( this.$node.ltProp( 'originElem' ) ) 
      if( this.getData( 'ltPropShow' ) && originElem ) {
          this.prevHoverCardNode = originElem;
          if( this.getData( 'ltPropHideOnClick') ){
              document.addEventListener( 'click' , this._hovercardHideOnClick )
          }
          if( this.getData( 'ltPropPlacement' ) != '' ) {
            popover.ltProp( 'placement', this.getData( 'ltPropPlacement' ) )
          }
          _lyteUiUtils.appendChild( popoverWormhole, wormHole )

          popover.ltProp( 'originElem', this.getData( 'ltPropOriginElem' ) )
          popover.ltProp( 'freeze', false )
          popover.ltProp( 'duration', undefined )
          popover.ltProp('offset',this.getData('ltPropOffset'))
          popover.ltProp( 'closeOnEscape', this.getData( 'ltPropCloseOnEscape' ) )
          this.compouteOffset( popover );
          if(this.getData('ltPropPopoverWrapperClass')){
             popover.setData( 'ltPropWrapperClass', popover.getData( 'ltPropWrapperClass' )+' '+ this.getData('ltPropPopoverWrapperClass'))
          }
          if( this.getData( 'ltPropFollowCursor' ) ) {
              this.addEventListenerForOriginElem( originElem )
              popover.setData( 'ltPropWrapperClass', popover.getData( 'ltPropWrapperClass' )+ ' lyteHoverCardFollowCursor' )
          }
        
          popover._settime = setTimeout( this.createHoverCard.bind( this ), this.getData( 'ltPropShowDelay' ), event, popoverWormhole );
          
          this._closeHoverCard = this.closeHoverCard.bind( this )
          originElem.addEventListener( 'mouseleave', this._closeHoverCard )
      }
      else{
           popover.ltProp( 'show', false )

          popover.ltProp( 'bindToBody', false )
          popover.ltProp( 'originElem', '' )
          popover.setData( 'ltPropWrapperClass', 'lyteHovercardPopover' )
          this.$node.classList.remove( 'lyteActive' )
          if(originElem){
            originElem.removeEventListener( 'mouseleave', this._closeHoverCard )
          }
          if( this._popovermouseleave ){
              popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )

          }
           if( this.getData( 'ltPropHideOnClick') ){
            document.removeEventListener( 'click' , this._hovercardHideOnClick )
          }
          this.removeEventListenerForOriginElem( originElem )
          if( this.getMethods( 'onHovercardHide' ) ) {
              this.executeMethod( 'onHovercardHide', this.$node );
          }
          if( this.prevHoverCardNode ) {
              delete this.prevHoverCardNode
          }
          delete this._mousedownFlag;
          this.removeTimeout( popover )
      }
  }.observes( 'ltPropShow' ),
  closeHoverCard : function( event ) {
      var wormHole = this._childComp,
       popoverWormhole = this._popover.component.actualModalDiv,
       popover = this._popover,
       originElem = document.querySelector( this.$node.ltProp( 'originElem' ) )
      if(  this.prevHoverCardNode && ( this.getData('ltPropFollowCursor') || event.target == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.target ) ) && popoverWormhole && event.relatedTarget != popoverWormhole && !popoverWormhole.contains( event.relatedTarget )) {
                popover._bodyTimeout = setTimeout( this.removeHoverCard.bind( this ), this.getData( 'ltPropHideDelay' ), popover, originElem, event ) ;

          } else if( popoverWormhole && (event.relatedTarget == popoverWormhole || popoverWormhole.contains( event.relatedTarget )  )  ) {  
              this.removeTimeout( popover )
              this._popovermouseleave = this.popoverMouseLeave.bind( this )
              popoverWormhole.addEventListener( 'mouseleave', this._popovermouseleave )
              originElem.removeEventListener( 'mouseleave', this._closeHoverCard )
  
           } 
  },
  removeHoverCard : function( popover, originElem, event, popoverWormhole ) {
    var res = true
    if(this.getMethods( 'onHovercardBeforeHide' ) ) {
          res = this.executeMethod( 'onHovercardBeforeHide', this.$node, event );
          if( !res && originElem){
              originElem.removeEventListener( 'mouseleave', this._closeHoverCard )
              if( this._popovermouseleave && popoverWormhole ){
                popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )
              }
          }
    }
    if( res && ( ( this.prevHoverCardNode && ( event.target == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.target ) ) ) || ( popoverWormhole && ( event.target == popoverWormhole || popoverWormhole.contains( event.target ) ) ) ) ){
            this.removeTimeout( popover )

            if( this.getData( 'ltPropShow' ) && popover ) {
                    this.setData( 'ltPropShow', false )
                    popover.setData( 'ltPropShow',false )
                }  
    }
  },
  popoverMouseLeave : function( event ) {
      var wormHole = this._childComp ,
       popoverWormhole = this._popover.component.actualModalDiv ,
       popover = this._popover ,
       originElem = document.querySelector( this.$node.ltProp( 'originElem' ) )

      if( popoverWormhole && ( event.target == popoverWormhole || popoverWormhole.contains( event.target ) ) && event.relatedTarget != this.prevHoverCardNode && !this.prevHoverCardNode.contains( event.relatedTarget ) ) {
        popover._bodyTimeout = setTimeout( this.removeHoverCard.bind( this ), this.getData( 'ltPropHideDelay' ), popover, originElem, event, popoverWormhole );
      }
      else if( this.prevHoverCardNode && ( event.relatedTarget == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.relatedTarget ) ) ) {
            popover._settime = setTimeout( this.createHoverCard.bind( this ), this.getData( 'ltPropShowDelay' ), event, popoverWormhole );
            this._closeHoverCard = this.closeHoverCard.bind( this )
            originElem.addEventListener( 'mouseleave', this._closeHoverCard )
            if( this._popovermouseleave ){
              popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )
            }

      }
  }, 
  hovercardScroll : function( event ) {
    if($L(this.$node).hasClass("lyteActive")){
    var res = true
        var component = this,
            wormHole = component._childComp ,
            popoverWormhole = component._popover.component.actualModalDiv ,
            popover =component._popover ,
            originElem = document.querySelector( this.getData('ltPropOriginElem') )
            
        if(component.getMethods( 'onHovercardBeforeHide' ) ) {
            res = component.executeMethod( 'onHovercardBeforeHide', component.$node );
            if( !res && originElem){
                originElem.removeEventListener( 'mouseleave', component._closeHoverCard )
                if(  component._popovermouseleave && popoverWormhole ){
                    popoverWormhole.removeEventListener( 'mouseleave', component._popovermouseleave )
                  }
            }
        }
        if(res ){
            
            if( component.getData( 'ltPropShow' ) && popover ) {
                component.setData( 'ltPropShow', false )
                
            }
            if( component.prevHoverCardNode ) {
              delete component.prevHoverCardNode
            }
            component.removeTimeout( popover )
        }
      
      }
  },
  methods :{
    beforeWormholeAppend : function(args){
      this._childComp = args
    }
  }
});


window.addEventListener( 'scroll', function(event) {
   window.clearTimeout( _lyteUiUtils._expressDebounce );

  _lyteUiUtils._expressDebounce = setTimeout( function() {

    var activeHovercard = document.querySelector('lyte-hovercard.lyteActive')
    if(activeHovercard){
       var popover = activeHovercard.component._popover
       if(popover){
        var childComp = popover.component.actualModalDiv
        var target = arguments[0].target
        if(childComp.contains(target)){
          return;
        }
       }
    }


      var hovercard = document.getElementsByTagName( 'lyte-hovercard' ),
      i = 0;
     
          for( ; i < hovercard.length; i++ ) {
              if( hovercard[ i ] ){
                  hovercard[ i ].component.hovercardScroll();
              }
          
      }   
  }, 250,event );
  
}, true );
/**
 * This component is used to get responses from user
 * @component lyte-input
 * @version 1.0.0
 * @dependency lyte-calendar
 *  /components/lyte-calendar.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-calendar.css 
 *  /plugins/lyte-moment.js
 * @dependency lyte-dropdown
 *  /components/lyte-dropdown.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-dropdown.css
 * @dependency lyte-wormhole
 *  /components/lyte-wormhole.js
 * @utility focus,blur,click,select
 * @import lyte-dropdown
 * @condition ltPropType time,datetime
 * @ignoreMethods
 * @ignoreUtils
 * @ignoreProperties ltPropRemoveMultiple,ltPropYield,ltPropOptions,ltPropUserValue,ltPropSystemValue,ltPropIconClass,ltPropPlaceholder,ltPropNoResult,ltPropMaxCount,ltPropAjaxRequest,ltPropDisplayValue,ltPropDisabledList,ltPropTooltip,ltPropBoxClass,ltPropIsOpen,ltPropFixPositionOnOpen
 * @import lyte-calendar
 * @condition ltPropType date,datetime
 * @ignoreMethods
 * @ignoreUtils
 */

Lyte.Component.register("lyte-input",{
_template:"<template tag-name=\"lyte-input\"> <template is=\"switch\" value=\"{{ltPropType}}\"> <template case=\"password\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{if(ltPropValue,'ltIconShow','')}} {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"{{ltPropType}}\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" style=\"{{ltPropStyle}}\" readonly=\"{{ltPropReadonly}}\" onfocus=\"{{action('focusClass',event)}}\" onblur=\"{{action('blurThrow',event)}}\" title=\"{{ltPropInputTitle}}\" oninput=\"{{action('input',event)}}\"> <template is=\"if\" value=\"{{ltPropCloseIcon}}\"><template case=\"true\"> <span class=\"inputCloseIcon\" onclick=\"{{action('clsIcon',event)}}\" style=\"{{if(ltPropValue,'display: block;','display: none;')}}\"></span> </template></template> </div> </template> <template case=\"number\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{if(ltPropValue,'ltIconShow','')}} {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"number\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" style=\"{{ltPropStyle}}\" onkeydown=\"{{action('numberKeydown',event,this)}}\" onfocus=\"{{action('focusClass',event)}}\" onblur=\"{{action('blurThrow',event)}}\" step=\"{{ltPropStep}}\" max=\"{{ltPropMax}}\" min=\"{{ltPropMin}}\" title=\"{{ltPropInputTitle}}\" onpaste=\"{{action('numberPaste',event,this)}}\" oninput=\"{{action('input',event,this)}}\"> <template is=\"if\" value=\"{{ltPropCloseIcon}}\"><template case=\"true\"> <span class=\"inputCloseIcon\" onclick=\"{{action('clsIcon',event)}}\" style=\"{{if(ltPropValue,'display: block;','display: none;')}}\"></span> </template></template> </div> </template> <template case=\"textarea\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <textarea autocomplete=\"{{ltPropAutocomplete}}\" pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" value=\"{{lbind(ltPropValue)}}\" rows=\"{{ltPropRows}}\" cols=\"{{ltPropCols}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" style=\"{{ltPropStyle}}\" onfocus=\"{{action('focusClass',event)}}\" onblur=\"{{action('blurThrow',event)}}\" title=\"{{ltPropInputTitle}}\" oninput=\"{{action('input',event)}}\"></textarea> <template is=\"if\" value=\"{{resize}}\"><template case=\"true\"> <span class=\"lyteTextareaResize\"></span> </template></template> </div> </template> <template case=\"date\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"text\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" value=\"{{lbind(ltPropCurrentDate)}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onkeydown=\"{{action('calendarKeydown',event,this)}}\" onclick=\"{{action('calendarClick',event,this)}}\" onfocus=\"{{action('showcalendar',event,this)}}\" onblur=\"{{action('blurThrow',event)}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\" oninput=\"{{action('input',event)}}\" ondragstart=\"{{action('preventDrag',event)}}\"> </div> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole on-before-append=\"{{method('wormholeAppend')}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div id=\"lyteCalendar\" class=\"lyteInputCalendar lyteCalendarHidden {{ltPropCalendarClass}}\" onmousedown=\"{{action('calmsdown',event,this)}}\"> <lyte-calendar lt-prop-fill-rows=\"{{ltPropFillRows}}\" lt-prop-number-of-rows=\"{{ltPropNumberOfRows}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" lt-prop-year=\"{{lbind(ltPropYear)}}\" lt-prop-month-header-format=\"{{ltPropMonthHeaderFormat}}\" on-date-selected=\"{{method('on-dateselected')}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-start-week-day=\"{{ltPropStartWeekDay}}\" lt-prop-header-type=\"{{ltPropHeaderType}}\" on-navigate=\"{{method('calendarNavigate')}}\" on-viewdate-change=\"{{method('viewDateChange')}}\" on-view-change=\"{{method('viewChange')}}\" lt-prop=\"{{stringify(ltPropCalendarProperties)}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <template is=\"registerYield\" yield-name=\"footer\"> <lyte-yield yield-name=\"footer\"></lyte-yield> </template> </template></template> </lyte-calendar> </div> </template> </lyte-wormhole> </template></template> </template> <template case=\"datetime\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <template is=\"if\" value=\"{{showPlaceholder}}\"><template case=\"true\"> <span class=\"lyteInputDateTimePlaceholder\">{{ltPropCommonPlaceholder}}</span> </template></template> <input autocomplete=\"{{ltPropAutocomplete}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"text\" class=\"{{ltPropClass}}\" id=\"date\" placeholder=\"{{ltPropPlaceholder}}\" value=\"{{lbind(ltPropCurrentDate)}}\" onkeydown=\"{{action('calendarKeydown',event,this)}}\" onclick=\"{{action('calendarClick',event,this)}}\" onfocus=\"{{action('showcalendar',event,this)}}\" onblur=\"{{action('blurThrow',event)}}\" oninput=\"{{action('input',event)}}\" ondragstart=\"{{action('preventDrag',event)}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\"> <input autocomplete=\"{{ltPropAutocomplete}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"text\" placeholder=\"{{ltPropTimePlaceholder}}\" class=\"{{ltPropTimeClass}}\" value=\"{{ltPropDefaultTime}}\" id=\"time\" onblur=\"{{action('timeBlur',event,this)}}\" onfocus=\"{{action('timeFocus',event,this)}}\" onkeydown=\"{{action('timeKeydown',event,this)}}\" onclick=\"{{action('timeClick',event,this)}}\" style=\"{{ltPropStyle}}\" ondragstart=\"{{action('preventDrag',event)}}\" disabled=\"{{ltPropDisabled}}\" oninput=\"{{action('timeInput',this)}}\" readonly=\"{{ltPropReadonly}}\"> </div> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole on-before-append=\"{{method('wormholeAppend')}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div id=\"lyteCalendar\" class=\"lyteInputCalendar lyteCalendarHidden {{ltPropCalendarClass}}\" onmousedown=\"{{action('calmsdown',event,this)}}\"> <lyte-calendar lt-prop-fill-rows=\"{{ltPropFillRows}}\" lt-prop-number-of-rows=\"{{ltPropNumberOfRows}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" lt-prop-year=\"{{lbind(ltPropYear)}}\" lt-prop-month-header-format=\"{{ltPropMonthHeaderFormat}}\" on-date-selected=\"{{method('on-dateselected')}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-start-week-day=\"{{ltPropStartWeekDay}}\" lt-prop-header-type=\"{{ltPropHeaderType}}\" on-navigate=\"{{method('calendarNavigate')}}\" on-viewdate-change=\"{{method('viewDateChange')}}\" on-view-change=\"{{method('viewChange')}}\" lt-prop=\"{{stringify(ltPropCalendarProperties)}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <template is=\"registerYield\" yield-name=\"footer\"> <lyte-yield yield-name=\"footer\"></lyte-yield> </template> </template></template> </lyte-calendar> </div> </template> </lyte-wormhole> </template></template> <lyte-dropdown style=\"display: none;\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-yield=\"true\" lt-prop-disabled=\"{{ltPropDropdownDisabled}}\" lt-prop-show=\"{{ltPropDropdownShow}}\" lt-prop-callout=\"{{ltPropDropdownCallout}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-freeze=\"{{ltPropDropdownFreeze}}\" on-hide=\"{{method('hide')}}\" on-show=\"{{method('show')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-option-selected=\"{{method('optionSelected')}}\" on-position-changed=\"{{method('positionChange')}}\" on-scroll=\"{{method('scroll')}}\" lt-prop-selected=\"{{ltPropDefaultTime}}\" lt-prop-animate=\"{{ltPropAnimate}}\" lt-prop-scope=\"{{ltPropScope}}\" lt-prop=\"{{stringify(ltPropDropdownProperties)}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button style=\"display: none;\"></lyte-drop-button> <lyte-drop-box id=\"{{ltPropDropdownId}}\" class=\"{{ltPropDropdownClass}}\"> <template is=\"if\" value=\"{{ltPropHeaderYield}}\"><template case=\"true\"> <lyte-drop-head> <lyte-yield yield-name=\"timeheader\"></lyte-yield> </lyte-drop-head> </template></template> <lyte-drop-body> <template is=\"for\" items=\"{{dropdownData}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item.time}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\" item-value=\"{{item}}\"></lyte-yield> </template><template case=\"false\"> <span>{{item.time}}</span> <template is=\"if\" value=\"{{ltPropShowInterval}}\"><template case=\"true\"> <span style=\"opacity: 0.5;float: right;margin-left: 5px; \">{{item.interval}}</span> </template></template></template></template> </lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template> <template case=\"time\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" value=\"{{ltPropDefaultTime}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onblur=\"{{action('timeBlur',event,this)}}\" onfocus=\"{{action('timeFocus',event,this)}}\" onkeydown=\"{{action('timeKeydown',event,this)}}\" onclick=\"{{action('timeClick',event,this)}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\" ondragstart=\"{{action('preventDrag',event)}}\" oninput=\"{{action('timeInput',this)}}\"> </div> <template is=\"if\" value=\"{{ltPropDropdown}}\"><template case=\"true\"> <lyte-dropdown style=\"display: none;\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-yield=\"true\" lt-prop-disabled=\"{{ltPropDropdownDisabled}}\" lt-prop-show=\"{{ltPropDropdownShow}}\" lt-prop-callout=\"{{ltPropDropdownShow}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-freeze=\"{{ltPropDropdownFreeze}}\" on-hide=\"{{method('hide')}}\" on-show=\"{{method('show')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-option-selected=\"{{method('optionSelected')}}\" on-position-changed=\"{{method('positionChange')}}\" on-scroll=\"{{method('scroll')}}\" lt-prop-selected=\"{{ltPropDefaultTime}}\" lt-prop-animate=\"{{ltPropAnimate}}\" lt-prop-scope=\"{{ltPropScope}}\" lt-prop=\"{{stringify(ltPropDropdownProperties)}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button style=\"display: none;\"></lyte-drop-button> <lyte-drop-box id=\"{{ltPropDropdownId}}\" class=\"{{ltPropDropdownClass}}\"> <template is=\"if\" value=\"{{ltPropHeaderYield}}\"><template case=\"true\"> <lyte-drop-head> <lyte-yield yield-name=\"timeheader\"></lyte-yield> </lyte-drop-head> </template></template> <lyte-drop-body> <template is=\"for\" items=\"{{dropdownData}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item.time}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\" item-value=\"{{item}}\"></lyte-yield> </template><template case=\"false\"> <span>{{item.time}}</span> <template is=\"if\" value=\"{{ltPropShowInterval}}\"><template case=\"true\"> <span style=\"opacity: 0.5;float: right;margin-left: 5px; \">{{item.interval}}</span> </template></template></template></template> </lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template></template> </template> <template default=\"\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField{{if(ltPropValue,' ltIconShow','')}} {{isBox}} {{ltPropWrapperClass}}\" style=\"{{ltPropWrapperStyle}}\"> <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onfocus=\"{{action('focusClass',event)}}\" onblur=\"{{action('blurThrow',event)}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\" pattern=\"{{ltPropPattern}}\" oninput=\"{{action('input',event)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropType,'==',&quot;search&quot;)}}\"><template case=\"true\"> <span class=\"searchIcon\"></span> </template></template> <template is=\"if\" value=\"{{ltPropCloseIcon}}\"><template case=\"true\"> <span class=\"inputCloseIcon\" onclick=\"{{action('clsIcon',event)}}\" style=\"{{if(ltPropValue,'display: block;','display: none;')}}\"></span> </template></template> </div>  </template> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"password":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"},"type":{"name":"type","dynamicValue":"ltPropType"}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}}]}},"default":{}}]},"number":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"},"value":{"name":"value","dynamicValue":"ltPropValue","isLbind":true}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}}]}},"default":{}}]},"textarea":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"},"placeholder":{"name":"placeholder","dynamicValue":"ltPropPlaceholder"}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]},"date":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"datetime":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3,3]},{"type":"attr","position":[3,5],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[7]},{"type":"registerYield","position":[7,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[3,3,1]},{"type":"for","position":[3,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[7]}]},"time":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[3,3,1]},{"type":"for","position":[3,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,3]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[3,5]},{"type":"if","position":[3,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}}]}},"default":{}}]}}],
_observedAttributes :["ltPropDisabled","ltPropAutofocus","ltPropAutocomplete","ltPropMaxlength","ltPropName","ltPropPlaceholder","ltPropReadonly","ltPropValue","ltPropWidth","ltPropTabIndex","ltPropType","ltPropAppearance","ltPropDirection","ltPropLabel","ltPropId","ltPropClass","ltPropStyle","ltPropWrapperStyle","ltPropHeight","ltPropPattern","ltPropInputTitle","ltPropRows","ltPropCols","ltPropTextAreaResize","ltPropMax","ltPropMin","ltPropStep","ltPropTimeFormat","ltPropHourInterval","ltPropDefaultTime","ltPropMinuteInterval","ltPropDropdown","ltPropShowInterval","ltPropStartTime","ltPropEndTime","ltPropConvertToNearest","ltPropValidateOnBlur","ltPropFillRows","ltPropNumberOfRows","ltPropMinDate","ltPropMaxDate","ltPropStartWeekDay","ltPropMonthHeaderFormat","daysOfWeek","ltPropYear","ltPropFormat","viewDate","ltPropStartDate","ltPropEndDate","ltPropCurrentDate","ltPropBindToBody","ltPropCalendarClass","ltPropHeaderType","ltPropDropdownDisabled","ltPropDropdownShow","ltPropDropdownCallout","ltPropDropdownFreeze","ltPropDropdownId","ltPropDropdownClass","ltPropPosition","ltPropBoundary","ltPropWheel","ltPropYield","ltPropAnimate","ltPropPreventSelection","ltPropPreventKeys","ltPropUpdateDelay","ltPropAutoUpdate","ltPropCallbackDelay","ltPropCloseIcon","ltPropTimePlaceholder","ltPropCommonPlaceholder","ltPropTimeClass","ltPropAria","ltPropAriaAttributes","ltPropFocus","ltPropCalendarProperties","ltPropDropdownProperties","ltPropScope","ltPropHeaderYield","ltPropConvertedDate","ltPropConvertedTime","ltPropPreventDropdownNavigation","ltPropInputWrapperClass","ltPropWrapperClass","eventListeners","selectedField","endMinute","startMinute","dropdownData","originalData","dateRange","meridian","hour","min","selectedDateField","preventObs","resize","pos","isSearch","isBox","dateOrder","showPlaceholder","lyteUnbound"],
    init:function(){ 
        var data = this.data, type = data.ltPropType;
          if( type == 'time' || type == "datetime" ){
            this._prevent = true
            this.timeInValChange.call(this);
            this.startEndTimeObs.call(this);
            delete this._prevent;
            if( type.indexOf( 'time' ) != -1 && data.ltPropDropdown ){
                this.dropdownConstruct();
                if( type == "time" ) {
                    data.ltPropDefaultTime = data.ltPropDefaultTime || data.ltPropValue;
                }
            }
          } 
          if( type == 'date' || type == "datetime" ){
            if( type == 'date' ) {
                data.ltPropCurrentDate = data.ltPropCurrentDate || data.ltPropValue; 
            } 
            this.dateRegexFind();
          }

          this.$node.classList.add('lyteInput');
          this.$node.classList.add('horizontal');
          if( this.getMethods( 'beforeRender' ) ) {
           /**
            * @method beforeRender
            * @version 1.0.1
            */
                this.executeMethod( 'beforeRender', this.$node );
            }
    },

    englishDate : function(){
        if( $L.moment && this.data ){
            var format = this.data.ltPropFormat,
            date = this.data.ltPropCurrentDate,
            final = '';

            if( date ){
                final = $L.moment( date, format, { i18n : true } ).format( format );
            } 
            this.setData( 'ltPropConvertedDate', final );
        }
    },

    englishTime : function(){
        if( $L.moment && this.data ){
            var final = this.data.ltPropDefaultTime;

            if( this.data.ltPropTimeFormat == 12 ){
                var format = 'hh:mm A';
                final = $L.moment( final, format, { i18n : true } ).format( format );
            }
            this.setData( 'ltPropConvertedTime', final );
        }
    },

    didConnect:function(){
           var type = this.data.ltPropType/*, divIdInput= this.$node, lyteLabelDiv= this.$node.querySelector( '.lyteLabel' ),lyteFieldDiv= this.$node.querySelector( '.lyteField' )*/; 
           if( type == 'date' || type == "datetime" )
                { 
                    window._lyteUiUtils.input = window._lyteUiUtils.input || {};
                    this.$node._random = 'LyteInput' + Date.now();
                    window._lyteUiUtils.input[ this.$node._random ] = this.$node;
                    this.englishDate();
                }   
            if(type == 'time' || type == "datetime" ){
                if(this.getData('ltPropDropdown')){
                    this.dropdown = this.$node.querySelector( 'lyte-dropdown' );
                    this.dropbox =  this.dropdown.component.childComp ? this.dropdown.component.childComp : this.dropdown.querySelector( 'lyte-drop-box' );
                    this.dropdown.element = this.$node.querySelectorAll( 'input' )[ type == 'datetime' ? 1 : 0 ];
                }
                this.englishTime();
            }
            if(type == 'time' || type == 'date' || type == "datetime"){
                if(this.getData('ltPropWheel')){
                    var func = this.handleWheel.bind(this);
                    this.setData('eventListeners.timeWheel', func);
                    this.$node.addEventListener('wheel', func);
                }
                this._manualset = true
                if( type == "time" ){
                    this.setData( 'ltPropValue', this.data.ltPropDefaultTime );
                } else if( type == "date" ) {
                    this.setData( 'ltPropValue', this.data.ltPropCurrentDate );
                } 
                delete this._manualset;
            }  
            type = type == "textarea" ? "textarea" : 'input';  
              [ 'focus', 'blur', 'click', 'select' ].forEach( function( item ){
                    this.$node[ item ] = function( arg ){
                      this.$node.querySelector( type )[item]( arg );
                    }.bind( this )      
              }.bind( this ) )                      
            if(this.getMethods('afterRender')){
               /**
                * @method afterRender
                * @version 1.0.1
                */                
                this.executeMethod('afterRender', this.$node);
            }
            $L.fastdom.measure( function(){
                this._dir = _lyteUiUtils.getRTL();
                if( this._dir ) {
                    $L.fastdom.mutate( function(){
                        this.$node.classList.add( 'lyteRTL' );
                        if( this.$node.calendarDiv ) {
                            this.$node.calendarDiv.classList.add( 'lyteRTL' );
                        }
                    }.bind( this ) )
                }   
            }.bind( this ) )
    },

    didDestroy : function(){
        if(this.$node.calendarComp){
            this.$node.calendarComp.remove();
            delete this.$node.calendarComp; delete this.$node.calendarDiv;delete this._assCalendar;
            delete this.$node.revertToSelected;
        }
        var evt = this.getData('eventListeners'), type = this.getData('ltPropType');
        if(type == 'date' || type == "datetime" ){
            delete window._lyteUiUtils.input[ this.$node._random ];
        }
        if(type == 'time' || type == "datetime" ){
            delete this.dropdown; delete this.dropbox;
        }
        if(evt.hasOwnProperty('mouseup')){
            document.removeEventListener('mouseup', evt.mouseup);
        }   
    },

    rtlfunc : function( lft, bcr, ww ) {
        if( this._dir ) {
            if( bcr ) {
                if( lft == 'left' ) {
                    return ww - bcr.right;
                } else if( lft == 'clientX' ) {
                    return ww - bcr.clientX
                } else if( lft == 'offsetLeft' ) {
                    return ww - bcr.width - bcr.offsetLeft;
                }
                return ww - bcr.left;
            } else if( lft == 'left' ) {
                return 'right';
            } 
        }
        return bcr ? bcr[ lft ] : 'left';
    },

    calenderClickHide : function(event){
        if( !this.data.ltPropBindToBody ){
            return
        }
        var calendarComp = this.$node.calendarDiv, tgt = event.target.correspondingElement || event.target;
        if( calendarComp.classList.contains( 'lyteCalendarHidden' ) ){
            return;
        }
        if( tgt && [ "LYTE-DROP-BOX", "LYTE-DROP-ITEM", "LYTE-DROP-BODY" ].indexOf( tgt.tagName ) != -1 ) {
            while( tgt.tagName != "LYTE-DROP-BOX" && tgt.tagName != "BODY" ) {
                tgt = tgt.parentNode;
            }
            if( tgt.tagName == "LYTE-DROP-BOX" ) {
                tgt = tgt.origindd
            }
        }
        if(  !this.$node.contains( tgt ) && !calendarComp.contains( tgt ) ) {         
            this._hideCalendar( this.$node );
        } else if( tgt && /*!tgt.classList.contains( 'lyteCalDateSpan' ) && !tgt.classList.contains( 'lyteCalCdate' ) &&*/ calendarComp.contains( tgt ) ) {
            this._byManual = true;
            this.$node.focus();
        }
    },

    scrollFunc : function(event){
        if( event && event.type == 'resize' && _lyteUiUtils.isMobile ) {
            return;
        }
        var thisCalendar = this.$node.calendarDiv;
         $L.fastdom.mutate(function(){
            event && event.type == "orientationchange" ? setTimeout( this.setCss.bind( this ), 500 ) : this.setCss();
             $L.fastdom.measure(function(){
                var boundary = this.data.ltPropBoundary, input = this.$node.getBoundingClientRect(), wwidth = window.innerWidth;
                if(thisCalendar && event && event.type == 'scroll' && !thisCalendar.classList.contains('lyteCalendarHidden')){
                    if((boundary.hasOwnProperty('left') ? ( this.rtlfunc.call( this, 'left', input, wwidth ) < boundary.left) : false) || (boundary.hasOwnProperty('right') ? ( this.rtlfunc.call( this, 'right', input, wwidth ) > boundary.right) : false)  || (boundary.hasOwnProperty('top') ? (input.top < boundary.top) : false)  || (boundary.hasOwnProperty('bottom') ? (input.bottom > boundary.bottom) : false))      
                        {  

                            this._hideCalendar( this.$node, true );                        }
                 } else if( this._closedbyscrl ){
                    if( ( boundary.left != undefined ? ( this.rtlfunc.call( this, 'left', input, wwidth ) >= boundary.left ) : true ) && ( boundary.right != undefined ? ( this.rtlfunc.call( this, 'right', input, wwidth ) <= boundary.right ) : true )  && ( boundary.top != undefined ? (input.top >= boundary.top) : true )  && (boundary.bottom != undefined ? ( input.bottom <= boundary.bottom ) : true ) ){
                        this._byManual = true;
                        this.$node.focus();
                        delete this._byManual;
                        this.showCalendar( {}, this.$node.querySelector( 'input' ) );
                        delete this._closedbyscrl;
                    }    
                 }
             }.bind(this))  
         }.bind(this))
    },

    textareaFuncObs : function(){
        if(this.getData('ltPropType') == 'textarea'){
            var resize = this.getData('ltPropTextAreaResize');
            if(!(resize.horizontal || resize.vertical)){
                this.setData('resize', false);
            }else{
                this.setData('resize', true);
                if(!this._resizeBinded){
                    this.textareaFunc();
                    this._resizeBinded = true;
                }
            }

            var instance = $L( '.lyteTextareaResize', this.$node ),
            ver = 'lyteTextareaResizeVertical',
            hori = 'lyteTextareaResizeHorizontal',
            no_resize = 'lyteTextareaNoResize';

            if( ( resize.vertical && resize.horizontal ) || !( resize.horizontal || resize.vertical ) ){
                instance.removeClass( ver + ' ' + hori + ' ' );
            } else if( resize.vertical ){
                instance.addClass( ver ).removeClass( hori + ' ' );
            } else if( resize.horizontal ){
                instance.removeClass( ver + ' ' ).addClass( hori );
            } 

            if( !( resize.horizontal || resize.vertical ) ) {
                $L( this.$node ).addClass( no_resize );
            }
        }
    }.observes('ltPropTextAreaResize', 'ltPropTextAreaResize.{}').on('didConnect'),

    btobody : function( arg ){
        if( !arg.newValue ){
            delete this.$node.revertToToday;
        }
    }.observes( 'ltPropBindToBody' ),

    disAbs : function(){
        this.$node.classList[ this.data.ltPropDisabled ? 'add' : 'remove' ]( 'lyteInputDisabled' );
    }.observes( 'ltPropDisabled' ).on( 'didConnect' ),

    readAbs : function(){
        this.$node.classList[ this.data.ltPropReadonly ? 'add' : 'remove' ]( 'lyteInputReadonly' );
    }.observes( 'ltPropReadonly' ).on( 'didConnect' ),

    rsizefun : function( evt ){
        var isTch = evt.type == "touchstart", ev = evt;
        if( isTch && evt.touches.length != 1 ) {
            return;
        } else if( isTch ){
            ev = evt.touches[ 0 ];
        }

        if( this.getMethods( 'onResizeStart' ) && this.executeMethod( 'onResizeStart', evt, this.$node ) == false ){
            return;
        }

        var textarea= this.$node.querySelector( 'textarea' ),
        resize = this.getData('ltPropTextAreaResize') || {};
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        document.addEventListener( isTch ? 'touchmove' : 'mousemove', this.data.eventListeners.resizeFunc, true);
        document.addEventListener( isTch ? 'touchend' : 'mouseup', this.data.eventListeners.mouseup, true);
        var label = this.$node.querySelector( 'label' ),parHeight, parWidth, parPaddLeft, minWidth, maxWidth, minHeight, maxHeight, labelRect, thisRect, parentClient, clientRect, compStyle,  direction = this.data.ltPropDirection, wwidth;
        $L.fastdom.measure(function(){
            // for textarea manual resizing label width is fixed if it is present
            if(label){
                labelRect = label.getBoundingClientRect();  
            }
            compStyle = window.getComputedStyle(textarea);
            clientRect = textarea.getBoundingClientRect();
            parentClient = window.getComputedStyle(textarea.parentElement);
            thisRect = this.$node.getBoundingClientRect();
            this._resizeDirection = compStyle.resize;
            minWidth = compStyle.minWidth; maxWidth = compStyle.maxWidth;
            minHeight = compStyle.minHeight; maxHeight = compStyle.maxHeight;
            parHeight = parentClient.height; parWidth = parentClient.width;
            parPaddLeft = parentClient.paddingLeft;
            this._ww = wwidth = window.innerWidth;
        }.bind(this))
        $L.fastdom.mutate(function(){
            if(resize.horizontal){
                // for proper resizing width are calculated in pixels and set to corresponding elements
                this.$node.style.width = thisRect.width + 'px';
                if(label){
                    label.style.width = labelRect.width + 'px';
                    label.style.minWidth = labelRect.width + 'px';
                }
                textarea.style.width = clientRect.width + 'px';
                textarea.parentElement.style.width = 'auto';
                this._iniLeft = this.rtlfunc.call( this, 'left', clientRect, wwidth );
                this._offLeft = this.rtlfunc.call( this, 'right', clientRect, wwidth ) - this.rtlfunc.call( this, 'clientX', ev, wwidth );
                this._minWidth = (minWidth.indexOf('%') != -1 ? (parseInt(parWidth) * parseInt(minWidth) / 100) : parseFloat(minWidth)) + parseInt(parPaddLeft);
                this._maxWidth = maxWidth.indexOf('%') != -1 ? (parseInt(parWidth) * parseInt(maxWidth) / 100) : parseFloat(maxWidth);
            } 
            if(resize.vertical){
                this.$node.style.height = thisRect.height + 'px';
                if(label){
                    label.style.height = labelRect.height + 'px';
                }
                textarea.style.height = clientRect.height + 'px';
                textarea.parentElement.style.height = "auto";
                textarea.parentElement.style.minWidth = 'auto';
                this._iniTop = clientRect.top;
                this._offTop = clientRect.bottom - ev.clientY;
                this._minHeight = (minHeight.indexOf('%') != -1 ? (parseInt(parHeight) * parseInt(minHeight) / 100) : parseFloat(minHeight));
                this._maxHeight = maxHeight.indexOf('%') != -1 ? (parseInt(parHeight) * parseInt(maxHeight) / 100) : parseFloat(maxHeight);
            }
            this.$node.classList.add( 'resizeStart' );
        }.bind(this))
    },

    textareaFunc : function () {
        var resizeFunc = this.textareaResize.bind(this), mouseup = this.mouseup.bind(this);
        this.setData('eventListeners.resizeFunc', resizeFunc);
        this.setData('eventListeners.mouseup', mouseup);
        if(this.getData('ltPropTextAreaResize')){
            var resizeSpan = this.$node.querySelector( '.lyteTextareaResize' );
            resizeSpan.addEventListener('mousedown', this.rsizefun.bind( this ) , true);
            resizeSpan.addEventListener('touchstart', this.rsizefun.bind( this ) , true);
        }
    },

    mouseup : function(event){
        this.$node.classList.remove( 'resizeStart' );
        var events = this.getData('eventListeners'), isTch = event.type == "touchend";
        document.removeEventListener( isTch ? 'touchmove' : 'mousemove', events.resizeFunc, true );
        document.removeEventListener( isTch ? "touchend" : 'mouseup', events.mouseup, true );

        this.getMethods( 'onResizeEnd' ) && this.executeMethod( 'onResizeEnd', event, this._resize_move, this.$node );

        delete this._iniLeft; delete this._iniTop; delete this._offLeft; delete this._offTop; delete this._ww;
        delete this._minHeight; delete this._maxHeight; delete this._minWidth; delete this._maxWidth; delete this._resize_move;
    },

    textareaResize:function(event){

        this._resize_move = true;

        var textarea = this.$node.querySelector( 'textarea' ), isTch = event.type == "touchmove", ev = event;
        if( isTch ) {
            if( ev.touches.length != 1 ) {
                return;
            }
            ev.preventDefault();
            ev = ev.touches[ 0 ];
        }
        $L.fastdom.measure(function(){
            var prevWidth = textarea.getBoundingClientRect();
            if(this._iniLeft){
                var cx = this.rtlfunc.call( this, 'clientX', ev, this._ww );
                var newWid = ( ( cx > this._iniLeft ) ? cx : this._iniLeft ) - this._iniLeft + this._offLeft;
                var newOut = parseFloat( this.$node.style.width ) + newWid - prevWidth.width;
                if(newWid >= this._minWidth && (isNaN(this._maxWidth) || (!isNaN(this._maxWidth) && newWid <= this._maxWidth))){
                    // new calculated width is set to text area and lyte-input
                    textarea.style.width = newWid + 'px'; 
                    this.$node.style.width = newOut + 'px';
                    this._prevent = true;
                    this.$node.ltProp( 'width', newOut );
                    delete this._prevent;
                }
            }
            if(this._iniTop){
                var newHgt = ((ev.clientY > this._iniTop) ? ev.clientY : this._iniTop) - this._iniTop + this._offTop;
                var newOut = parseFloat(this.$node.style.height) + newHgt - prevWidth.height;
                if(newHgt >= this._minHeight && (isNaN(this._maxHeight) || (!isNaN(this._maxHeight) && newHgt <= this._maxHeight))){
                    // new calculated height is set to text area and lyte-input
                    textarea.style.height = newHgt + 'px'; 
                    this.$node.style.height = newOut + 'px';
                    this._prevent = true;
                    this.$node.ltProp( 'height', newHgt );
                    delete this._prevent;
                }
            }
        }.bind(this))
    },

    heightFuncObs : function(){
        this.heightFunc.call(this, arguments[0]);
    }.observes('ltPropHeight').on('didConnect'),

    heightFunc : function (arg){
        var height = this.getData( 'ltPropHeight' );
        if(/*height && */!this._prevent){

                $L( 'input,textarea', this.$node ).eq( 0 ).css( 'height', height ); 
            }
     },

    widthfunObs : function(){
        this.widthfun();
    }.observes('ltPropWidth').on('didConnect'),

    widthfun : function (){
        var width = this.getData('ltPropWidth');
        if( /*width &&*/ !this._prevent ){
            // $L.fastdom.mutate(function(){
            //     // given width set to input
                this.$node.style.width = width;
            // }.bind(this))
        }
    },

    appearanceFunObs : function(){
        this.appearanceFun();
    }.observes('ltPropAppearance').on('didConnect'),

    appearanceFun : function () {
        var type = this.data.ltPropType, 
        $node = $L( this.$node );

        if( this.getData( 'ltPropAppearance' ) == 'box' ) {
            if(type =='search') {
                $node.find( '.lyteField' ).addClass( 'lyteInputBoxSearch' );
            }

            $node.addClass( 'lyteInputBox' ).removeClass( 'lyteInput' );
        } else {
            if(type =='search') {
                $node.find( '.lyteField' ).removeClass( 'lyteInputBoxSearch' );
            }

            $node.addClass( 'lyteInput' ).removeClass( 'lyteInputBox' );
        }       
    },

    directionfunObs : function(){
        this.directionfun();
    }.observes('ltPropDirection').on('didConnect'),

    directionfun : function (){
        var $node = $L( this.$node );

        if( this.data.ltPropDirection == 'vertical' ){
            $node.addClass( 'vertical' ).removeClass( 'horizontal' );
        } else {
            $node.removeClass( 'vertical' ).addClass( 'horizontal' );
        }
    },
    data : function(){
        return {
           /**
            * @componentProperty {boolean} ltPropDisabled=false
            * @version 1.0.0
            */            
            ltPropDisabled :  Lyte.attr("boolean",{"default" : false}),
           /**
            * @componentProperty {boolean} ltPropAutofocus=false
            * @version 1.0.0
            */            
            ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
           /**
            * @componentProperty {on | off} ltPropAutocomplete=off
            * @version 1.0.0
            */            
            ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
           /**
            * @componentProperty {number} ltPropMaxlength
            * @version 1.0.0
            */            
            ltPropMaxlength : Lyte.attr("number",{"default" : undefined}),
           /**
            * @componentProperty {string} ltPropName=''
            * @version 1.0.0
            */            
            ltPropName : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropPlaceholder=''
            * @version 1.0.0
            */            
            ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {boolean} ltPropReadonly=false
            * @version 1.0.0
            */            
            ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
           /**
            * @componentProperty {string} ltPropValue=''
            * @version 1.0.0
            */            
            ltPropValue : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropWidth=''
            * @version 1.0.0
            */            
            ltPropWidth : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropTabIndex=0
            * @version 1.0.0
            */            
            ltPropTabIndex : Lyte.attr('string',{default : '0'}),
           /**
            * @componentProperty {text | number | password | date | time | textarea | datetime} ltPropType=text
            * @version 1.0.0
            */            
            ltPropType : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {flat | box} ltPropAppearance=box
            * @version 1.0.0
            */            
            ltPropAppearance : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {vertical | horizontal} ltPropDirection=vertical
            * @version 1.0.0
            */            
            ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
           /**
            * @componentProperty {string} ltPropLabel=''
            * @version 1.0.0
            */            
            ltPropLabel : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropId=''
            * @version 1.0.0
            */            
            ltPropId : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropClass=''
            * @version 1.0.0
            */            
            ltPropClass : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropStyle=''
            * @version 1.0.0
            */            
            ltPropStyle : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropWrapperStyle=''
            * @version 1.0.0
            */            
            ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
           /**
            * @componentProperty {string} ltPropHeight=''
            * @version 1.0.0
            */            
            ltPropHeight : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropPattern='.+'
            * @version 1.0.2
            */            
            ltPropPattern : Lyte.attr('string', { default : '.+'}),
           /**
            * @componentProperty {string} ltPropInputTitle=''
            * @version 1.0.2
            */            
            ltPropInputTitle : Lyte.attr('string', { default : '' }),

            // data for textarea
           /**
            * @componentProperty {number} ltPropRows
            * @version 1.0.0
            * @condition ltPropType textarea
            */            
            ltPropRows : Lyte.attr("number",{"default" : undefined}),
           /**
            * @componentProperty {number} ltPropCols
            * @version 1.0.0
            * @condition ltPropType textarea
            */            
            ltPropCols : Lyte.attr("number",{"default" : undefined}),
            /**
             * @typedef {object} inputResize
             * @property {boolean} vertical=true
             * @property {boolean} horizontal=true
             */

            /**
             * @componentProperty {inputResize} ltPropTextAreaResize
             * @version 1.0.0
             * @condition ltPropType textarea
             */            
            ltPropTextAreaResize : Lyte.attr("object",{"default" : {vertical : true, horizontal : true}}),

            // data for number
           /**
            * @componentProperty {number} ltPropMax
            * @version 1.0.0
            * @condition ltPropType number
            */            
            ltPropMax : Lyte.attr("number",{"default" : undefined}),  
           /**
            * @componentProperty {number} ltPropMin
            * @version 1.0.0
            * @condition ltPropType number
            */                      
            ltPropMin : Lyte.attr("number",{"default" : undefined}),
           /**
            * @componentProperty {number} ltPropStep=1
            * @version 1.0.0
            * @condition ltPropType number
            */                        
            ltPropStep : Lyte.attr("number",{"default" : 1}),

            // data for time
           /**
            * @componentProperty {12 | 24} ltPropTimeFormat=12
            * @version 1.0.0
            * @condition ltPropType number
            */            
            ltPropTimeFormat : Lyte.attr("number",{"default" : 12}),
           /**
            * @componentProperty {number} ltPropHourInterval=1
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */            
            ltPropHourInterval : Lyte.attr("number",{"default" : 1}),
           /**
            * @componentProperty {string} ltPropDefaultTime=''
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */            
            ltPropDefaultTime : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {number} ltPropMinuteInterval=30
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */            
            ltPropMinuteInterval : Lyte.attr("number",{"default" : 30}),
           /**
            * @componentProperty {boolean} ltPropDropdown=false
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */            
            ltPropDropdown : Lyte.attr("boolean",{"default" : false}),
           /**
            * @componentProperty {boolean} ltPropShowInterval=false
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */            
             ltPropShowInterval : Lyte.attr("boolean",{"default" : false}),
           /**
            * @componentProperty {string} ltPropStartTime=''
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */
            ltPropStartTime : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropEndTime=''
            * @version 1.0.0
            * @condition ltPropType time,datetime
            */
            ltPropEndTime : Lyte.attr("string",{"default" : ''}),
             /**
            * @componentProperty {boolean} ltPropConvertToNearest=false
            * @version 2.2.14
            * @condition ltPropType time,datetime
            */
            ltPropConvertToNearest : Lyte.attr( 'boolean', { default : false } ),
             /**
            * @componentProperty {boolean} ltPropValidateOnBlur=false
            * @version 2.2.14
            * @condition ltPropType time,datetime
            */
            ltPropValidateOnBlur : Lyte.attr( 'boolean', { default : false } ),

            // data for calendar
            ltPropFillRows : Lyte.attr('boolean', {default : true}),
            ltPropNumberOfRows : Lyte.attr('number', {default : 6}),
            ltPropMinDate : Lyte.attr('string', { default : ""}),
            ltPropMaxDate : Lyte.attr('string', { default : ""}),
            ltPropStartWeekDay : Lyte.attr('number', { default : 1}),
            ltPropMonthHeaderFormat : Lyte.attr("string",{"default":'MMMM YYYY'}),
            daysOfWeek : Lyte.attr("array",{"default":['Sun','Mon','Tue','Wed','Thu','Fri','Sat']}),
            ltPropYear : Lyte.attr("boolean",{"default":true}),
            ltPropFormat : Lyte.attr("string",{"default":"MM/DD/YYYY"}),
            viewDate : Lyte.attr("object",{"default":{}}),
            ltPropStartDate : Lyte.attr("string",{"default" : ''}),
            ltPropEndDate : Lyte.attr("string",{"default" : ''}),
            ltPropCurrentDate : Lyte.attr("string",{"default" : ''}),
            /**
            * @componentProperty {boolean} ltPropBindToBody=true
            * @version 2.1.0
            * @condition ltPropType time,date,datetime
            */
            ltPropBindToBody : Lyte.attr( 'boolean', { default : true } ),
            // ltPropMonthHeader : Lyte.attr("string",{"default" : ''}),
           /**
            * @componentProperty {string} ltPropCalendarClass=''
            * @version 2.1.0
            * @condition ltPropType date,datetime
            */
            ltPropCalendarClass : Lyte.attr( 'string', { default : "" } ),
            ltPropHeaderType : Lyte.attr("string",{"default" : "default"}),

            // data for dropdown
           /**
            * @componentProperty {boolean} ltPropDropdownDisabled=false
            * @version 1.0.2
            * @condition ltPropType time,datetime
            */
            ltPropDropdownDisabled : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {boolean} ltPropDropdownShow=false
            * @version 1.0.2
            * @condition ltPropType time,datetime
            */
            ltPropDropdownShow : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {boolean} ltPropDropdownCallout=false
            * @version 2.0.0
            * @condition ltPropType time,datetime
            */
            ltPropDropdownCallout : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {boolean} ltPropDropdownFreeze=false
            * @version 1.0.2
            * @condition ltPropType time,datetime
            */
            ltPropDropdownFreeze : Lyte.attr('boolean', { default : false}),
           /**
            * @componentProperty {string} ltPropDropdownId=''
            * @version 2.2.2
            * @condition ltPropType time,datetime
            */
            ltPropDropdownId : Lyte.attr( 'string', { default : '' } ),
           /**
            * @componentProperty {string} ltPropDropdownClass=''
            * @version 2.2.2
            * @condition ltPropType time,datetime
            */
            ltPropDropdownClass : Lyte.attr( 'string', { default : '' } ),

            // for dropdown and calendar
            ltPropPosition : Lyte.attr('string', { default : 'down'}),
            ltPropBoundary : Lyte.attr('object', { default : {}}),

            // for date and time
            /**
            * @componentProperty {boolean} ltPropWheel=false
            * @version 2.0.0
            * @condition ltPropType time,datetime,date
            */
            ltPropWheel : Lyte.attr('boolean', {default : false}),
           /**
            * @componentProperty {boolean} ltPropYield=false
            * @version 1.0.2
            * @condition ltPropType time,datetime,date
            */
            ltPropYield : Lyte.attr('boolean', { default : false}),
            ltPropAnimate : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {boolean} ltPropPreventSelection=false
            * @version 2.2.9
            * @condition ltPropType date
            */
            ltPropPreventSelection : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {boolean} ltPropPreventKeys=false
            * @version 2.2.11
            * @condition ltPropType date
            */
            ltPropPreventKeys : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {number} ltPropUpdateDelay=250
            * @version 2.0.0
            */
            ltPropUpdateDelay : Lyte.attr( 'number', { default : 250 } ),
           /**
            * @componentProperty {boolean} ltPropAutoUpdate=true
            * @version 1.0.2
            * @default true
            */
            ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),
           /**
            * @componentProperty {number} ltPropCallbackDelay=0
            * @version 2.2.8
            */
            ltPropCallbackDelay : Lyte.attr( 'number', { default : 0 } ),
           /**
            * @componentProperty {boolean} ltPropCloseIcon=false
            * @version 2.0.0
            * @condition ltPropType date,text,password,number
            */
            ltPropCloseIcon : Lyte.attr( 'boolean', { default : false } ),

            // datetime type
            /**
             * @experimental ltPropTimePlaceholder
             */
            ltPropTimePlaceholder : Lyte.attr( 'string', { default : "" } ),

            ltPropCommonPlaceholder : Lyte.attr( 'string', { default : '' } ),
            /**
             * @experimental ltPropTimeClass
             */
            ltPropTimeClass : Lyte.attr( 'string', { default : "" } ),

            // aria
           /**
            * @componentProperty {boolean} ltPropAria=false
            * @version 3.1.0
            */
            ltPropAria : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {object} ltPropAriaAttributes
            * @version 3.1.0
            * @default {}
            */
            ltPropAriaAttributes : Lyte.attr( 'object', { default : {} } ),
           /**
            * @componentProperty {boolean} ltPropFocus=false
            * @version 3.2.0
            */
            ltPropFocus : Lyte.attr( 'boolean', { default : false } ),
           /**
            * @componentProperty {object} ltPropCalendarProperties
            * @version 2.2.20
            * @default {}
            * @component lyte-calendar
            * @condition ltPropType date,datetime
            */

            ltPropCalendarProperties : Lyte.attr( 'object', { default : {} } ),
           /**
            * @componentProperty {object} ltPropDropdownProperties
            * @version 2.2.20
            * @default {}
            * @component lyte-dropdown
            * @condition ltPropType time,datetime
            */

            ltPropDropdownProperties : Lyte.attr( 'object', { default : {} } ),

           /**
            * @componentProperty {string} ltPropScope=''
            * @version 2.2.20
            * @condition ltPropType date,datetime
            */

            ltPropScope : Lyte.attr( 'string', { default : "" } ),

           /**
            * @componentProperty {boolean} ltPropHeaderYield=false
            * @version 3.20.0
            * @condition ltPropType date,datetime
            */

            ltPropHeaderYield : Lyte.attr( 'boolean', { default : false } ),

           /**
            * @componentProperty {string} ltPropConvertedDate=''
            * @version 3.20.0
            * @condition ltPropType date,datetime
            */

            ltPropConvertedDate : Lyte.attr( 'string', { default : '' } ),

           /**
            * @componentProperty {string} ltPropConvertedTime=''
            * @version 3.20.0
            * @condition ltPropType date,datetime
            */

            ltPropConvertedTime : Lyte.attr( 'string', { default : '' } ),

            /**
            * @componentProperty {boolean} ltPropPreventDropdownNavigation=false
            * @version 3.28.0
            * @condition ltPropType date,datetime
            */

            ltPropPreventDropdownNavigation : Lyte.attr( "boolean", { default : false } ),

            /**
            * @componentProperty {string} ltPropInputWrapperClass=""
            * @version 3.30.0
            */
            ltPropInputWrapperClass : Lyte.attr( 'string', { default : '' } ),

            /**
            * @componentProperty {string} ltPropWrapperClass=""
            * @version 3.32.0
            */
            ltPropWrapperClass : Lyte.attr( "string", { default : "" } ),

            // system data

            eventListeners : Lyte.attr('object', {default : {}}),
            selectedField : Lyte.attr('object', { default : {}}),
            endMinute : Lyte.attr('number', { default : ''}),
            startMinute : Lyte.attr('number', { default : ''}),
            dropdownData : Lyte.attr('array', { default : []}),
            originalData : Lyte.attr('array', { default : []}),
            dateRange : Lyte.attr('object', { default : { day : [], month : [], year : []}}),
            // Dont change this property name. Already some people from crm using this for passing their custom translations
            meridian : Lyte.attr('object', { default : {AM : (window._lyteUiUtils ? _lyteUiUtils.i18n('AM') : 'AM'), PM : (window._lyteUiUtils ? _lyteUiUtils.i18n('PM') : 'PM')}}),
            hour : Lyte.attr('string', { default : _lyteUiUtils.i18n('hour')}),
            min : Lyte.attr('string', { default : _lyteUiUtils.i18n('min')}),
            selectedDateField : Lyte.attr('string', { default : ""}),
            preventObs : Lyte.attr('boolean', { default : true}),
            resize : Lyte.attr('boolean', { default : true}),
            pos : Lyte.attr('string', { default : ""}),
            isSearch : Lyte.attr( 'boolean', { default : false } ),
            isBox : Lyte.attr( 'string', { default : '' } ),
            dateOrder : Lyte.attr( 'array', { default : [] } ),
            showPlaceholder : Lyte.attr( 'boolean', { default : false } ),

            lyteUnbound : Lyte.attr( 'boolean', { default : false } )
        }
    },

    input_wrap_obs : function( arg ){
        var oldValue = ( arg || { oldValue : "" } ).oldValue,
        newValue = this.data.ltPropInputWrapperClass;

        $L( this.$node ).removeClass( oldValue ).addClass( newValue );

    }.observes( 'ltPropInputWrapperClass' ).on( 'didConnect' ),

    focusObs : function(){
        if( this.data.ltPropFocus ){
            this.$node.focus();
        }
        // this.data.ltPropFocus = false
        this.$node.ltProp( 'focus', false );
    }.observes( 'ltPropFocus').on( 'didConnect' ),

    boxObs : function(){
        var type = this.data.ltPropType,
        appearance = this.data.ltPropAppearance;

        if( type == "search" && appearance == "box" ){
            this.setData( 'isBox', 'lyteInputBoxSearch' );
        } else {
            this.setData( 'isBox', '' );
        }
    }.observes( 'ltPropType', 'ltPropAppearance' ).on( 'init' ),

    getDateFromFormat:function(tdate,format){

        var is_i18n = this.data.ltPropCalendarProperties.i18n;

        if( is_i18n ){
            var format = this._assCalendar.component.getRelevantFormat( format );

            return $L.moment( tdate ).i18N( format ); 
        } else {
            return this._assCalendar.component.getDateFromFormat(tdate, format);
        }

    },

    dateValidation : function(date){
        if( !this._assCalendar ){
            return false;
        }
        var timeObj = this._assCalendar.component.stringToDate( date, this.data.ltPropFormat );
         if( timeObj == 'Invalid Date'){
            return false
         }
         return timeObj;
    },

   dateRegexFind : function(arg){
        var format, dateRange = this.getData('dateRange'),
        dateOrder = [];
        if(!arg){
            format = this.getData('ltPropFormat');
        }else{
            format = arg.newValue;
        }
        var dayReg = /D+/ig.exec(format), monthReg = /M+/ig.exec(format), yearReg = /Y+/ig.exec(format);
        if( dayReg ){
            dateRange.day[0] = dayReg.index; dateRange.day[1] = dayReg.index + dayReg[0].length;
            dateOrder.push( { value : dateRange.day[ 0 ], name : "day", format : format.match( /D+/ig )[ 0 ] } );
        }
        if( monthReg ){
            dateRange.month[0] = monthReg.index; dateRange.month[1] = monthReg.index + monthReg[0].length;
            dateOrder.push( { value : dateRange.month[ 0 ], name : "month", format : format.match( /M+/ig )[ 0 ] } );
        }
        if( yearReg ){
            dateRange.year[0] = yearReg.index; dateRange.year[1] = yearReg.index + yearReg[0].length;
            dateOrder.push( { value : dateRange.year[ 0 ], name : "year", format : format.match( /Y+/ig )[ 0 ] } )
        }
        dateOrder.sort( function( a, b ){
            return a.value - b.value;
        } )
        this.setData( 'dateOrder', dateOrder );
    },

    dateRegexObs : function( arg ){
        this.dateRegexFind( arg );
    }.observes('ltPropFormat'),

    constructingArr : function(i, startTime, format){
        if(i < startTime){
            i += 1440;
        }
        var interval = (i - startTime) / 60,
        temp = {};
        temp.time = this.convertToRailway(i, true, format).trim();
        temp.interval = interval < 1 ? ((i - startTime) + ' '+ this.getData('min')) : ((interval % 1 == 0 ? interval : interval.toFixed(1)) + ' ' + this.getData('hour'));
        return temp;
    },

    dropdownConstruct : function(){
        if( this._prevent ) {
            return
        }
        var startTime = this.getData('startMinute'), i, temp = [], endTime = this.getData('endMinute'), hrInter = this.getData('ltPropHourInterval'), minInt = this.getData('ltPropMinuteInterval'), format = this.getData('ltPropTimeFormat'),
        arr = [];
        if(startTime >= endTime){
            endTime += 1440;
        }
        for(i = startTime; i <= endTime; i += minInt){
             var current = this.constructingArr(i, startTime, format);
             if( arr.indexOf( current.time ) == -1 ){
                 temp.push( current );
                 arr.push( current.time );
             }
        }
        this.setData('originalData', temp);
    },

    constructNewDrop : function(input, format){
        var temp = [], startTime = this.getData('startMinute');
        if(format == 12){
            var min = this.convertToRailway(input.value.trim());
            var ret = this.maxValCheck(min);
            if(ret != false){
                temp.push(this.constructingArr(min, startTime, 12));
            }
            min += 720;
            ret = this.maxValCheck(min % 1440);
            if(ret != false){
                temp.push(this.constructingArr(min, startTime, 12));
            }
        }else{
            var min = this.convertToRailway(input.value.trim());
            var ret = this.maxValCheck(min);
            if(ret != false){
                temp.push(this.constructingArr(min, startTime, 24));
            }
        }
        this.dropdown.ltProp( 'selected', '' );
        if( temp.length == 0 && this.data.ltPropValidateOnBlur ){
            this.data.ltPropStartTime && temp.push( { time : this.data.ltPropStartTime, interval : "" } );
            this.data.ltPropEndTime && temp.push( { time : this.data.ltPropEndTime, interval : "" } );
        }
        this.setData('dropdownData', temp);
        this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );
    },

    getCorrectTime : function(timeFormat){

        if( $L.moment ){
            var date = $L.moment();
            if( timeFormat == 12 ){
                return date.i18N( "hh:mm A" );
            } else{
                return date.format( "HH:mm" );
            }
        }

        var time = new Date(), hr = time.getHours(), min = time.getMinutes().toString(), meridian = this.getData('meridian'), mer = hr > 11 ? meridian.PM : meridian.AM;
        if(min.length == 1){
            min = '0' + min;
        }
        if(timeFormat == 12){
            if( hr != 12 ) {
                hr = (hr%12).toString();
                if(hr.length == 1){
                    hr = '0' + hr;
                }
            }
            return hr + ':' + min + " " + mer;
        }else{
            if(hr < 10){
                hr = '0' + hr;
            }
            return hr + ":" + min;
        }

    },

    timeFormatChange : function(){
        this.timeInValChange();
    }.observes('ltPropTimeFormat'),

    handleWheel : function(evt){
        var input = evt.target, type = this.getData('ltPropType');
        if( input.tagName != 'INPUT' || Math.abs( evt.deltaY ) <= Math.abs( evt.deltaX ) ) {
            return
        }
        if(type == 'time' || ( type == "datetime" && input.id == "time" ) ){
            if( this._emptytimeValue ){
                return;
            }
            $L.fastdom.mutate(function(){
               var selectedField = this.getData('selectedField');
                if(!selectedField.prop || input.selectionStart > 3){
                    // settting initial selection if input is not focused
                    input.selectionStart = 0;
                    input.selectionEnd = 2;
                    this.setData('selectedField', {prop : 'hour', val : 0});
                    selectedField = {prop : 'hour', val : 0};
                }
                if(evt.deltaY < -10){
                    this.timeDecrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)
                }else if(evt.deltaY > 10){
                    this.timeIncrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)
                }
            }.bind(this))
        }else if( type == 'date' || ( type == "datetime" && input.id == "date" ) ){
            if(evt.deltaY < -10){
                evt.keyCode = 40;
                this.calendarKeydown.call(this, evt, input);
            }else if(evt.deltaY > 10){
                evt.keyCode = 38;
                this.calendarKeydown.call(this, evt, input);
            }
        }
        evt.preventDefault();   
    },                                            

    wheelObs : function(arg){
        if(arg.newValue){
            this.$node.addEventListener('wheel', this.getData('eventListeners.timeWheel'));
        }else{
            this.$node.removeEventListener('wheel', this.getData('eventListeners.timeWheel'));
        }
    }.observes('ltPropWheel'),

    convertToRailway : function(val, flag, format){
        var meridian = this.getData('meridian');
        if(!flag){
            var hr = parseInt(val.slice(0, 2));
            var min = parseInt(val.slice(3, 5));
            if(val.length != 5){
                var mer = val.slice(6, val.length);
                return (mer == meridian.PM ? ((hr % 12) + 12) : hr % 12) * 60 + min;
            }else{
                return (hr * 60 + min);
            }
        }else{
            var hr = parseInt(val / 60) % 24;

            var min = val % 60;
            if(min < 10){
                min = '0' + min;
            }
            var mer = ''
            if(format == 12){
                if(parseInt(hr / 12) == 1){
                    if(hr > 12){
                        hr = hr % 12;
                    }
                    mer = meridian.PM;
                }else{
                    mer = meridian.AM;
                    hr = hr || 12;
                }
            }
            if(hr < 10){
                hr = '0' + hr;
            }
            return (hr + ":" + min + " " + mer);
        }
    },

    maxValCheck : function(val){
        var endTime = this.getData('endMinute');
        var startTime = this.getData('startMinute');
        var toChangeTime;
        if(typeof val == 'string'){
            toChangeTime =  this.convertToRailway(val);
        }else{
            toChangeTime = val
        }
        if(startTime < endTime){
            if(toChangeTime <= endTime && toChangeTime >= startTime){
                return true
            }
        }else{
            if((toChangeTime < 1440 && toChangeTime >= startTime) || (toChangeTime >= 0 && toChangeTime <= endTime)){
                return true;
            }
        }
        return false
    },

    timeInValChange : function(arg){
        var timeFormat = this.getData('ltPropTimeFormat'), value,
        val = this.data.ltPropValue,
        type = this.data.ltPropType;

        if(arg){
            value = arg.newValue;
        }else{
            value = this.getData('ltPropDefaultTime');
            if( ( val == undefined || type == 'datetime' ) && !value && $L.moment && ( type == "time" ? this.data.ltPropPlaceholder : ( this.data.ltPropTimePlaceholder || this.data.ltPropCommonPlaceholder ) ) ){
                this._emptytimeValue = true;
                if( type == 'datetime' ){
                    this.checkCommonPlaceHolder();
                }
                return;
            }
        }
        if(!value){
            var startTime =  this.getData('ltPropStartTime');
            if(startTime){
                value = startTime;
            }else{
                value = this.getCorrectTime(timeFormat);
            }
        }
        this.setData('ltPropDefaultTime', value.slice(0, timeFormat != 12 ? 5 : value.length));
    },

    checkCommonPlaceHolder : function(){
        if( ( this.data || {} ).ltPropCommonPlaceholder ){
            this.setData( 'showPlaceholder', !( this.data.ltPropCurrentDate || this.data.ltPropDefaultTime ) );
        }
    },

    startEndTimeObs : function(arg){
        if(!arg || arg.item == 'ltPropStartTime')
            {
                var defaultVal = this._emptytimeValue ? this.getCorrectTime( this.data.ltPropTimeFormat ) : this.getData('ltPropDefaultTime');
                var startTime = this.getData('ltPropStartTime')
                if(!startTime){
                    this.setData('ltPropStartTime', defaultVal)
                    startTime = defaultVal
                }
                this.setData('startMinute', this.convertToRailway(startTime));
            }
        if(!arg || arg.item == 'ltPropEndTime') 
            {
                var  endTime = this.getData('ltPropEndTime'), flag = 0
                if(!endTime){
                    var min = Math.max(0, parseInt(startTime.slice(3, 5)) - 1).toString();
                    if(min.length == 1){
                        min = '0' + min;
                    }
                    endTime = ( startTime.slice(0, 3) + min + " " + startTime.slice(6, startTime.length) ).trim();
                    this.setData('ltPropEndTime', endTime)
                }
                this.setData('endMinute',  this.convertToRailway(endTime));
            }
        this.data.ltPropDropdown && this.dropdownConstruct();    
    },

    timeBoundObs : function(arg){
        if(arg &&  arg.newValue == "" && arg.oldValue == undefined) {
            return
        }
        if(!arg || (arg && arg.item != 'ltPropDefaultTime')){
            this.startEndTimeObs(arg);
        }else{
            if( arg && !arg.newValue ){
                this.timeInValChange();
                return;
            }
            if(this.setData('preventObs')){
                this.setData('ltPropValue', arg.newValue);
            }

            this.englishTime();

            if(this.getMethods('onTimeChange')){
               /**
                * @method onTimeChange
                * @version 1.0.2
                * @condition ltPropType time,datetime
                */                
                this.executeMethod('onTimeChange', arg, this.$node);
            }
            this._manualset = true;
            if( this.data.ltPropType == 'time' ) {
                this.setData( 'ltPropValue', arg.newValue )
            } else {
                this.checkCommonPlaceHolder();
            }
            delete this._manualset;
        }
    }.observes('ltPropStartTime', 'ltPropEndTime', 'ltPropDefaultTime'),

    dateChangeCallback : function( arg ){
        var callDelay = this.data.ltPropCallbackDelay;

        this._manualset = true;
        if( this.data.ltPropType == 'date' ) {
            this.setData( 'ltPropValue', arg.newValue )
        } 
        delete this._manualset;
        if( callDelay == undefined ){
            this.dateCallback( arg );
        } else {
            setTimeout( this.dateCallback.bind( this ), callDelay, arg );
        }
        this.checkCommonPlaceHolder();
    }.observes('ltPropCurrentDate'),

    dateCallback : function(arg){
        if( arg.newValue == "" && arg.oldValue == undefined) {
            return
        }

        this.englishDate();

        if(this.getMethods('onDateChange')){
           /**
            * @method onDateChange
            * @version 1.0.2
            * @condition ltPropType date,datetime
            */            
            this.executeMethod('onDateChange', arg, this.$node, this._selected);
        }
        this.checkCommonPlaceHolder();
        delete this._selected;
    },

    timeCallback : function(arg){
        if( arg.newValue == "" && arg.oldValue == undefined) {
            return
        }
        if(this.getMethods('onValueChange')){
           /**
            * @method onValueChange
            * @version 1.0.2
            */            
            this.executeMethod('onValueChange', arg, this.$node)
        }
    },

    valChangeObs : function(arg){
        var callDelay = this.data.ltPropCallbackDelay;
        if( !this._manualset ){
            var tp = this.data.ltPropType;
            if( tp == 'date' ) {
                this.setData( 'ltPropCurrentDate', arg.newValue );
            } else if( tp == "time" ) {
                this.setData( 'ltPropDefaultTime', arg.newValue );
            }
        }
        if( callDelay == undefined ){
            this.timeCallback( arg );
        } else {
            setTimeout(this.timeCallback.bind(this), callDelay , arg);
        }
    }.observes('ltPropValue'),

    firePosCallBack: function() {

        var calendar = this.$node.calendarDiv,
        pos = this.data.pos;

        $L( calendar ).removeClass( 'lyteInputCalendarUp lyteInputCalendarDown' ).addClass( 'lyteInputCalendar' + ( /up/i.test( pos ) ? 'Up' : 'Down' ) );

        if( this.getMethods( 'onPositionChanged' )) {
           /**
            * @method onDateChange
            * @version 1.0.6
            * @condition ltPropType time,datetime
            */            
            this.executeMethod( 'onPositionChanged', pos, calendar );
        }
    }.observes('pos'),

    /*
        Calculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
    */
    setLeftExceedForDown: function( element, container, bcr, containerbcr, xscroll, ww ) {
        var scrolledLeft = xscroll,
        elementBCR = bcr,
        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),
        elementWidth = elementBCR.width,
        containerBCR = containerbcr,
        containerWidth = containerBCR.width,
        total = scrolledLeft + elementLeft + elementWidth - containerWidth;

        return total
    },
    /*
        Calculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth
    */
    setLeftNotExceedForDown: function( element, bcr, xscroll, ww ) {
        var scrolledLeft = xscroll,
        elementBCR = bcr,
        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),
        total = scrolledLeft + elementLeft;

        return total
    },
    /*
        Calculate top of dropdown container when it has to come above the select element
    */
    setTopAboveForDown: function( element, container, bcr, containerbcr, yscroll ) {
        var scrolledHeight = yscroll,
        elementBCR = bcr,
        elementTop = elementBCR.top,
        containerBCR = containerbcr,
        containerHeight = containerBCR.height,
        total = scrolledHeight + elementTop  - containerHeight;

        return total
    },
    /*
        Calculate top of dropdown container when it has to come below the select element
    */
    setTopBelowForDown: function( element, bcr, yscroll ) {
        var scrolledHeight = yscroll,
        elementBCR = bcr,
        elementTop = elementBCR.top,
        elementHeight = elementBCR.height,
        total = scrolledHeight + elementTop + elementHeight;

        return total
    },
    /*
        Calculate left of dropdown container when it has to come to right of the select element
    */
    setLeftForRight:function( element, bcr, xscroll, ww ) {
        var scrolledWidth = xscroll,
        elementBCR = bcr,
        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),
        elementWidth = elementBCR.width,
        total = scrolledWidth + elementLeft + elementWidth;

        return total
    },
    /*
        Calculate right of dropdown container when it has to come to left of the select element of right dropdown
    */
    setRightForRight: function( element, container, bcr, elembcr, xscroll, ww ) {
        var scrolledWidth = xscroll,
        elementBCR = bcr,
        containerBCR = elembcr,
        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),
        containerWidth = containerBCR.width,
        total = scrolledWidth + elementLeft - containerWidth;

        return total
    },
    /*
        Calculate top of dropdown container when it has to come to right of dropdown and there is space below
    */
    setTopForRight:function( element, bcr, yscroll ) {
        var scrolledHeight = yscroll,
        elementBCR = bcr,
        elementTop = elementBCR.top,
        total = scrolledHeight + elementTop;

        return total
    },
    /*
        Calculate top of dropdown container when it has to come to right of dropdown and there is no space below
    */
    setTopForRightAbove:function( element, container, bcr, elembcr, yscroll ) {
        var scrolledHeight = yscroll,
        elementBCR = bcr,
        elementTop = elementBCR.top,
        elementHeight = elementBCR.height,
        containerBCR = elembcr,
        containerHeight = containerBCR.height,
        total = scrolledHeight + elementTop + elementHeight - containerHeight;

        return total
    },
    /**
     * Set the CSS for your calendar
     * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
     * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
     */ 
    setCss : function() {
        var link = this.$node.calendarDiv;

        if( !link 
            || link.classList.contains( 'lyteCalendarHidden' ) 
        ) {
            return;
        }

        // Get properties

        // Get button
        var body = link,
        par = this.$node.querySelector( 'input' ).parentElement;

        // Get Geometric propotions
        var wwidth, wheight, flag, 
        bleft = 0, btop = 0,
        wwidth = window.innerWidth,
        wheight= window.innerHeight,
        iwdth = wwidth,
        drop = body.getBoundingClientRect(), 
        x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? - 1 : 1 ),
        y = window.pageYOffset || document.documentElement.scrollTop,
        height = body.offsetHeight,
        width = body.offsetWidth, 
        position = this.getData( 'ltPropPosition' ),
        offsets = par.getBoundingClientRect(),
        scope = this.data.ltPropScope,
        scopeElement = scope ? $L( this.$node ).closest( scope ).get( 0 ) : void 0,
        scopeBcr = scopeElement ? scopeElement.getBoundingClientRect() : void 0;

        if( scopeBcr ){
            bleft = Math.max( bleft, scopeBcr.left );
            btop = Math.max( btop, scopeBcr.top );
            wwidth = Math.min( wwidth, scopeBcr.right );
            wheight = Math.min( wheight, scopeBcr.bottom );
        }

        // Intialize flags
        var downPos, 
        rightPos, 
        topPos, 
        leftPos,
        pos;

        // temp stores
        var tempStore,
        tempTop, 
        tempLeft, 
        tempMarginLeft, 
        tempMarginTop,
        tempNum, 
        tempDenom, 
        tempPer,
        oL = this.rtlfunc.call( this, 'left', offsets, iwdth ),
        lT = this.rtlfunc.call( this, 'left' );

        if( position === 'down' ) {
            downPos = true;
            tempTop = offsets.top + offsets.height; 
            if( tempTop + height > wheight 
                /*&& offsets.top > height */
            ) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );        
            }

            rightPos = true;
            tempLeft = oL;
            if( tempLeft + width > wwidth 
                && tempLeft > tempLeft + offsets.width - body.offsetWidth 
            ) {
                rightPos = false;
                
            }
            // else if( oL + width <= wwidth ) {
            //     rightPos = true;
            // }

            if( downPos ) {
                this.setData( 'pos', 'down' );
                body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';
                
            }
            else {
                this.setData( 'pos', 'up' );
                body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y, iwdth ) + 'px';
            }

            if( rightPos ) {
                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[ lT ] = this.setLeftNotExceedForDown( par, offsets, x, iwdth ) + 'px';  
            }
            else {
                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[ lT ] = this.setLeftExceedForDown( par, body, offsets, drop, x, iwdth ) + 'px'
            }

            
        }
        else if( position === 'right' ) {
            rightPos = true;
            if( oL + offsets.width + width > wwidth
                && oL - drop.width > bleft 
            ) {   
                rightPos = false;
                
            }

            downPos = true;
            if( offsets.top + drop.height > wheight ) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop )
            }

            if( rightPos ) {
                this.setData( 'pos', 'right' );
                body.style[ lT ]= this.setLeftForRight( par, offsets, x, iwdth ) + 'px'
            }
            else {
                this.setData( 'pos', 'left' );
                body.style[ lT ] = this.setRightForRight( par, body, offsets, drop, x, iwdth ) + 'px';
            }

            if( downPos ) {
                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];
                body.style.top = this.setTopForRight( par, offsets, y ) + 'px' 
            }
            else {
                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];
                body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'
            }
        }
        else if( position === 'up' ) {
            topPos = true
            if( offsets.top - drop.height < btop 
                /*&& offsets.top + offsets.height + height < wheight */
            ) {
                topPos = ( wheight - offsets.top ) < ( offsets.bottom - btop )
            }

            rightPos = true
            if( oL + width > wwidth 
                && oL > oL + offsets.width - body.offsetWidth 
            ) {
                rightPos = false
            }
            // else if( oL + width <= wwidth ) {
            //     rightPos = true
            // }

            if( topPos ) {
                this.setData( 'pos', 'up' );
                body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
            }
            else {
                this.setData( 'pos', 'down' );
                body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'
            }
            if( rightPos ) {
                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[ lT ] = this.setLeftNotExceedForDown( par, offsets, x, iwdth ) + 'px';
            }
            else{
                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[ lT ] = this.setLeftExceedForDown( par, body, offsets, drop, x, iwdth ) + 'px';
            }
        } else if( position === 'left' ) {
            leftPos = true;
            if( oL - drop.width < bleft 
                && oL + drop.width < wwidth 
            ) {
                leftPos = false;
            }
            // else {
            //     leftPos = true;
            // }

            downPos = true;
            if( offsets.top + drop.height > wheight ) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );
            }

            if( leftPos ) {
                this.setData( 'pos', 'left' );
                body.style[ lT ] = this.setRightForRight( par, body, offsets, drop, x, iwdth ) + 'px';
            }
            else {
                this.setData( 'pos', 'right' );
                body.style[ lT ] = this.setLeftForRight( par, offsets, x, iwdth ) + 'px';
            }
            if( downPos ){
                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];
                body.style.top = this.setTopForRight( par, offsets, y ) + 'px';
            }
            else{
                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];
                body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';
            }
        } else if( position === 'downLeft' ) {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );
            } 
            // else {
            //     downPos = true;
            // }
            if( !downPos ) {
                tempTop = offsets.top - height;
            }
            rightPos = false
            tempLeft = oL + offsets.width / 2 - width;
            if( tempLeft < bleft ) {
                tempLeft = bleft
                rightPos = true
            } 
            // else { 
            //     rightPos  = false
            // }

            body.style.top = tempTop + y + 'px';

            body.style[ lT ] = tempLeft + x + 'px';
            if( downPos ){
                pos = 'downLeft';
            } else {
                pos = 'upLeft';
            }
            this.setData( 'pos', pos);

        } else if( position === 'downRight' ) {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );
            } 
            // else {
            //     downPos = true;
            // }
            if( !downPos ) {
                tempTop = offsets.top - height
            }
            rightPos = true
            tempLeft = oL + offsets.width / 2;
            if( tempLeft + width > wwidth ) {
                tempLeft = wwidth - width;
                rightPos = false;
            } 
            // else { 
            //     rightPos  = true;
            // }

            body.style.top = tempTop + y + 'px';

            body.style[ lT ] = tempLeft + x + 'px';
            if( downPos ){
                pos = 'downRight';
            } else {
                pos = 'upRight';
            }
            this.setData( 'pos', pos);
        } else if( position === 'upLeft' ) {
            downPos = false;
            tempTop = offsets.top - height;
            if( tempTop < btop) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );
            } 
            // else {
            //     downPos = false;
            // }
            if( downPos ) {
                tempTop = offsets.top + offsets.height;
            }
            rightPos = false
            tempLeft = offsets[ lT ] + offsets.width / 2 - width;
            if( tempLeft < bleft ) {
                tempLeft = bleft
                rightPos = true
            } 
            // else { 
            //     rightPos  = false
            // }

            body.style.top = tempTop + y + 'px';

            body.style[ lT ] = tempLeft + x + 'px';
            if( downPos ){
                pos = 'downLeft';
            } else {
                pos = 'upLeft';
            }
            this.setData( 'pos', pos);

        } else if( position === 'upRight' ) {
            downPos = false;
            tempTop = offsets.top - height;
            if( tempTop < btop) {
                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );
            } 
            // else {
            //     downPos = false;
            // }
            if( downPos ) {
                tempTop = offsets.top + offsets.height
            }
            rightPos = true
            tempLeft = oL + offsets.width / 2;
            if( tempLeft + width > wwidth ) {
                tempLeft = wwidth - width;
                rightPos = false;
            } 
            // else { 
            //     rightPos  = true;
            // }

            body.style.top = tempTop + y + 'px';

            body.style[ lT ] = tempLeft + x + 'px';
            if( downPos ){
                pos = 'downRight';
            } else {
                pos = 'upRight';
            }
            this.setData( 'pos', pos);
        }
            
    },

    preventFn : function(){
        this.preventFocus = true;
    },

    methods: {
        wormholeAppend : function( element, outlet ){
            this.$node.calendarComp = element;
            element.nodeN=this.$node;
            this.$node.calendarDiv = element.querySelector( 'div#lyteCalendar' );
            this._assCalendar = this.$node.calendarDiv.querySelector( 'lyte-calendar' );
            var func1 = this.calendarMousedown.bind(this);
            this.$node.calendarDiv.addEventListener('mousedown', func1, true);
            this.setData('eventListeners.mousedown', func1);
           /**
            * @utility revertToToday
            * @condition ltPropType date,datetime
            * @version 2.2.12
            */            
            this.$node.revertToToday = this._assCalendar.revertToToday;
           /**
            * @utility revertToSelected
            * @condition ltPropType date,datetime
            * @version 2.2.12
            */            
            this.$node.revertToSelected = this._assCalendar.revertToSelected;

            var dropdown = this._assCalendar.querySelectorAll('lyte-dropdown');
            for( var i = 0; i < dropdown.length; i++ ){
                var dropbody = dropdown[ i ].component.childComp || dropdown[ i ].querySelector( 'lyte-drop-box' );
                dropbody.addEventListener( 'mousedown', this.preventFn.bind( this ) );
            }
        },

        "on-dateselected":function(){
               this._selected = true;
               this._hideCalendar( this.$node );
         },
         hide : function(){
            $L( this.$node ).removeClass( 'lyteInputDropdownOpen' );
            if(this.getMethods('onHide')){
               /**
                * @method onHide
                * @condition ltPropType time,datetime
                * @version 1.0.2
                */                
                this.executeMethod('onHide', arguments[0], arguments[1], this.$node);
            }
         },
         beforeHide : function(){
            if(this.getMethods('onBeforeHide')){
               /**
                * @method onBeforeHide
                * @condition ltPropType time,datetime
                * @version 1.0.2
                */                
                return this.executeMethod('onBeforeHide', arguments[0], arguments[1], this.$node);
            }
         },
         show : function(){
            $L( this.$node ).addClass( 'lyteInputDropdownOpen' );
            if(this.getMethods('onShow')){
               /**
                * @method onShow
                * @condition ltPropType date,datetime
                * @version 1.0.2
                */                
                this.executeMethod('onShow', arguments[0], arguments[1], this.$node);
            }
         },
         beforeShow : function(){
            if(this.getMethods('onBeforeShow')){
               /**
                * @method onShow
                * @condition ltPropType date,datetime
                * @version 1.0.2
                */                
                return this.executeMethod('onBeforeShow', arguments[0], arguments[1], this.$node);
            }
         },
         optionSelected : function(){
            this._calmsfg = true;
            delete this._emptytimeValue;
            this.setData('ltPropDefaultTime', arguments[1].trim());

            $L( 'input', this.$node ).get( -1 ).focus();
         },

         scroll : function(){
            if(this.getMethods('onScroll')){
               /**
                * @method onScroll
                * @condition ltPropType time,datetime
                * @version 1.0.2
                */                
                this.executeMethod('onScroll', arguments[0], arguments[1]);
            }
         },

         positionChange : function(){
            if(this.getMethods('onPositionChanged')){
               /**
                * @method onPositionChanged
                * @condition ltPropType time,datetime
                * @version 1.0.2
                */                
                this.executeMethod('onPositionChanged', arguments[0], arguments[1]);
            }
         },

         calendarNavigate : function( arg1, arg2, arg3, arg4 ){
            $L.fastdom.measure( this.setCss.bind( this ) );
            if( this.getMethods( 'onNavigate' ) ) {
               /**
                * @method onNavigate
                * @condition ltPropType date,datetime
                * @version 2.0.0
                */                
                this.executeMethod( 'onNavigate', arg1, arg2, arg3, arg4 )
            }
         },

         viewDateChange : function( arg1, arg2 ){
               /**
                * @method onViewdateChange
                * @condition ltPropType date,datetime
                * @version 2.2.11
                */            
            this.getMethods( 'onViewdateChange' ) && this.executeMethod( 'onViewdateChange', arg1, arg2, this.$node );
         },

         viewChange : function( evt, viewType, _this ){
            $L.fastdom.measure( this.setCss.bind( this ) );
               /**
                * @method onViewChange
                * @condition ltPropType date,datetime
                * @version 2.2.11
                */            
            this.getMethods( 'onViewChange' ) && this.executeMethod( 'onViewChange', evt, viewType, _this, this.$node )
         }
    },
   valUpdate : function( ){
        if( !this.$node || !this) {
            return;
        }
        delete this._timeout;
        var type = this.data.ltPropType;
        if( type == 'date' || type == "datetime" ){
            var inn = this.$node.querySelector( 'input' ).value;
            this.setData('ltPropCurrentDate', inn ? inn : "");
        }else if(type == "textarea"){
            var inn = this.$node.querySelector( 'textarea' ).value;
            this.setData('ltPropValue', inn ? inn : "");
        }else{
            var inn = this.$node.querySelector( 'input' ).value;
            // if( this.data.ltPropType == "number" && !frmblur && ( !inn || inn == this.$node.ltProp( 'value' ) ) ){
            //  return
            // }
            this.setData('ltPropValue', inn ? inn : "");
        }  
   },
   fixSelection : function(val, selectedField, input){
    if( this.data.ltPropReadonly ){
        return;
    }
    // changing selection range
            input.selectionStart = selectedField.val + val;
            input.selectionEnd = input.selectionStart + 2;
            this.timeClick.call(this, {}, input, selectedField.val + val );
   },
   replaceVal : function(input, val, start, end){
        var value;
        if(typeof input == 'string'){
            value = input
        }else{
            value = input.value
        }
        var regex = new RegExp('('+ value.slice(start, start + end) +')','i');
         return value.trim().replace(regex, val);   
   },

   retVal : function( val1, val2, limit ) {
     if( parseInt( val1 + val2 ) > limit ) {
        return '0' + val2
     }
     return val1 + val2;
   },

   convertToPm :function( limit, val, meridian ){
        if( limit == 12 ) {
            var mer = val.slice( 6, val.length ), time = val.slice( 0, 5 ), hr = val.slice( 0, 2 ), min = val.slice( 3, 5 )
            if( hr == '00' && mer == 'AM' || hr == '12' && mer == 'PM' ) {
                return val
            }
            return hr + ':' + min + " " + ( meridian.AM == mer ? meridian.PM : meridian.AM )
        }
        return val
   },

   hourTimeSet : function(input, evt, selection, start, end){
         var inputVal = input.value.trim(), limit, meridian = this.getData('meridian');
         var typedValue  = _lyteUiUtils.getCorrectNumberCode( evt.which || evt.keyCode ) - 48;
         var newVal = inputVal.slice(start + 1, end) + typedValue;
         var timeFormat = this.data.ltPropTimeFormat,
         blur = this.data.ltPropValidateOnBlur;
         if(selection == 'hour'){
            limit = timeFormat == 12 ? 12 : 24;
         }else{
            delete this._lasttyped;
            limit = 60
         }
        // if(parseInt(newVal) > limit){
            // newVal = '0' + typedValue;
            // if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){
            //     inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.AM.length);
            // }else
             if(limit == 60 && parseInt( newVal ) >= 60){
                newVal = '0' + typedValue;
            }
        // }else{
            // if((limit == 12 && newVal == '12' && inputVal.slice(6, 8) == meridian.AM)){
            //     inputVal = this.replaceVal.call(this, input, meridian.PM, 6, meridian.AM.length);
            // } else if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){
            //     inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.PM.length);
            // }
        // }

        // if( selection == 'hour' && timeFormat == 12 && newVal == "00" ){
        //     newVal = "12";
        // }
        if( selection == "hour" ){
            final = this.getCrctHour( inputVal, start, end, limit, typedValue, meridian );
            this._lasttyped = typedValue + '';
        } else {
            var final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
            if( !blur || blur && evt.type != 'keydown' ){
                var returnV1 = this.maxValCheck(final);
                if(returnV1 == false ){
                    final = inputVal.slice(0, start) + this.retVal( inputVal.slice(start, start + 1), typedValue, limit ) + inputVal.slice(end, inputVal.length);
                    returnV1 = this.maxValCheck(final);
                    if(returnV1 == false){
                        final = inputVal.slice(0, start) + '0' + typedValue + inputVal.slice(end, inputVal.length);
                        returnV1 = this.maxValCheck(final);
                        if(returnV1 == false){
                            final = this.convertToPm( limit, final, meridian)
                            returnV1 = this.maxValCheck(final);
                            if(returnV1 == false){
                                return false;
                            }
                        }
                    }
                }
            }
        }
        this.setData('ltPropDefaultTime', final);
        // restore current selection
        $L.fastdom.mutate(function(){
            input.selectionStart = start;
            input.selectionEnd = end;
        })
   }, 

   _getCrctHour : function( str, limit, meridian ){
        if( this.maxValCheck( str ) == false ){
            if( limit == 12 ){
                 str = this.convertToPm( limit, str, meridian );
                 if( this.maxValCheck( str ) == false ){
                    return false;
                 } 
                 return str;
            }
            return false;
        }
        return str;
   },

   getCrctHour : function( inputVal, start, end, limit, typedValue, meridian ){
        var str, hr, ret, allow,
        blur = this.data.ltPropValidateOnBlur;
        if( this._lasttyped != undefined ){
            hr = this._lasttyped + typedValue;
            if( hr == "00" && limit == 12 ){
                allow = true;
                hr = "12"
            }
            if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
                ret = false;
            } else {
                str = hr + inputVal.slice( end );
                if( !blur ){
                    ret = this._getCrctHour( str, limit, meridian );
                } else {
                    return str;
                }
            }
            if( ret != false ){
                return ret;
            } else if( str ) {
                var em = this.data.endMinute,
                endTime = this.convertToRailway( str );
                if( endTime - em < 60 && endTime - em >= 0 ){
                    return this.convertToRailway( em, true, limit ).trim();
                }
            }
        }
        hr = inputVal.slice( start + 1, end ) + typedValue;
        if( hr == "00" && limit == 12  ){
            if( !allow ){
                return inputVal;
            }
            hr = "12"
        }
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            str = hr + inputVal.slice( end );
            if( !blur ){
                ret = this._getCrctHour( str, limit, meridian );
            } else {
                return str;
            }
        }
        if( ret != false ){
            return ret;
        }

        hr = inputVal.slice( 0, start + 1 ) + typedValue;
        if( hr == "00" && limit == 12  ){
            if( !allow ){
                return inputVal;
            }
            hr = "12"
        }
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            str = hr + inputVal.slice( end );
            if( !blur ){
                ret = this._getCrctHour( str, limit, meridian );
            } else {
                return str;
            }
        }
        if( ret != false ){
            return ret;
        }

        hr = '0' + typedValue;
        if( hr == "00" && limit == 12  ){
            if( !allow ){
                return inputVal;
            }
            hr = "12"
        }
        str = hr + inputVal.slice( end );
        if( !blur ){
            ret = this._getCrctHour( str, limit, meridian );
        } else {
            return str;
        }
        if( ret != false ){
            return ret;
        }
        hr = typedValue + '0';
        if( hr == "00" && limit == 12  ){
            if( !allow ){
                return inputVal;
            }
            hr = "12"
        }
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            str = hr + inputVal.slice( end );
            if( !blur ){
                ret = this._getCrctHour( str, limit, meridian );
            } else {
                return str;
            }
        }
        if( ret != false ){
            return ret;
        }

        if( this.data.ltPropConvertToNearest ){
           return this.findNearestTime( inputVal, start, end, limit, typedValue, meridian );
        }
        return inputVal;
   },

   findNearestTime : function( inputVal, start, end, limit, typedValue, meridian ){
        var hr, ret;
        if( this._lasttyped != undefined ){
            hr = this._lasttyped + typedValue;
            if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
                ret = false;
            } else {
                return this._findNearest( hr + inputVal.slice( end ), limit );
            }
        }
        hr = inputVal.slice( start + 1, end ) + typedValue;
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            return this._findNearest( hr + inputVal.slice( end ), limit );
        }
        hr = inputVal.slice( 0, start + 1 ) + typedValue;
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            return this._findNearest( hr + inputVal.slice( end ), limit );
        }
        hr = '0' + typedValue;
        if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){
            ret = false;
        } else {
            return this._findNearest( hr + inputVal.slice( end ), limit );
        }
        return inputVal;
   },

   _findNearest : function( str, limit ){
      var value = this.convertToRailway( str ),
      end = this.data.endMinute,
      start = this.data.startMinute,
      startDiff = Math.abs( start - value ),
      endDiff = Math.abs( end - value );
      if( startDiff > endDiff ){
         return this.convertToRailway( end, true, limit ).trim();
      } else {
        return this.convertToRailway( start, true, limit ).trim();
      }
   },


  timeIncrease : function(input, evt, selection, start, end, flag){
         if( this.data.ltPropReadonly ){
            return
         }
         var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');
         if(selection == 'hour'){
            limit = timeFormat == 12 ? 12 : 24;
            if(flag){
                interval = 1;
            }else{
                interval =  this.data.ltPropHourInterval;
            }
         }else{
            limit = 60;
            interval =  this.data.ltPropMinuteInterval;
         }
         var newVal,
         allow;
         if( $L.moment && $L.moment.lyteMoment.prototype.add ){
            var momentFormat = timeFormat == 12 ? "hh:mm A" : "HH:mm",
            moment;
            inputVal = inputVal.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );
            moment = $L.moment( inputVal, momentFormat );
            if( moment.validate() ){
                final = moment.add( interval, limit == 60 ? 'minutes' : 'hours' ).format( momentFormat ).replace( 'AM', meridian.AM ).replace( 'PM', meridian.PM );
            } else {
                allow = true;
            }
         } 
         if( allow ) {
             newVal = (currentValue + interval) % limit;
             if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
                if(newVal == 0){
                    newVal = '12';
                }
               inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
             }else if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.PM){
                if(currentValue != 12 || newVal == 0){
                    inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);
                }
             }else if(limit == 12 && newVal == currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
                    newVal = '12';
                    inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
             }else if(limit == 60 && newVal <= currentValue) {
                 var ret = this.timeIncrease.call(this, input, evt, 'hour', 0, 2, true);
                 if(ret == false){
                    return false;
                 }
                 inputVal = input.value.trim();
             }
            newVal = newVal.toString();
            if(newVal.length == 1){
                newVal = '0' + newVal;
            }
            final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
        }
        var returnV = this.maxValCheck(final)
        if(returnV == false){
            return false
        }
        this.setData('ltPropDefaultTime', final);
        // restore current selection
        $L.fastdom.mutate(function(){
            input.selectionStart = start;
            input.selectionEnd = end;
        })
   },
    timeDecrease : function(input, evt, selection, start, end, flag){
        if( this.data.ltPropReadonly ){
            return
         }
         var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');
         if(selection == 'hour'){
            limit = timeFormat == 12 ? 12 : 24;
            if(flag){
                interval = 1;
            }else{
                interval =  this.getData('ltPropHourInterval');
            }
         }else{
            limit = 60;
            interval =  this.getData('ltPropMinuteInterval');
         }
         var newVal,
         allow;
         if( $L.moment && $L.moment.lyteMoment.prototype.subtract ){
            var momentFormat = timeFormat == 12 ? "hh:mm A" : "HH:mm",
            moment;
            inputVal = inputVal.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );
            moment = $L.moment( inputVal, momentFormat );
            if( moment.validate() ){
                final = moment.subtract( interval, limit == 60 ? 'minutes' : 'hours' ).format( momentFormat ).replace( 'AM', meridian.AM ).replace( 'PM', meridian.PM );
            } else {
                allow = true;
            }
         } 
         if( allow) {
             newVal = (currentValue - interval + limit) % limit;
             if(limit == 12 && newVal > currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
                 inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
             } else if(limit == 12 && (newVal > currentValue || currentValue == 12) && inputVal.slice(6, inputVal.length) == meridian.PM){
                inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);
             }else if(limit == 12 && newVal == 0){
                if(inputVal.slice(6, inputVal.length) == meridian.PM){
                    newVal = '12';
                } 
             }else if(limit == 60 && newVal >= currentValue) {
                var ret = this.timeDecrease.call(this, input, evt, 'hour', 0, 2, true);
                if(ret == false){
                    return false;
                }
                inputVal = input.value.trim()
             }
            newVal = newVal.toString();
            if(newVal.length == 1){
                newVal = '0' + newVal;
            }
            final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
        }
        var returnV = this.maxValCheck(final);
        if(returnV == false){
            return false
        }
        this.setData('ltPropDefaultTime', final);
        // restore current selection
        $L.fastdom.mutate(function(){
            input.selectionStart = start;
            input.selectionEnd = end;
        })
   },

   findCalendarRange : function(evt, input, allow ){
        // var flag = false;
        if(input.value && this.dateValidation(input.value) != false){
                var start = input.selectionStart, i;
                var end = input.selectionEnd;
                var range = this.getData('dateRange');
                for(i in range){
                    if( allow && i != this.data.selectedDateField ){
                        continue;
                    }
                    // checking selected pos
                     var returnedRange = this.setRangeByMoment( input, range, i );

                     // One bug in this check. It will cause error when format is given without separators like MMDDYYYY

                    if( ( returnedRange[ 0 ] <= start && returnedRange[ 1 ] >= start ) || allow ){
                        if( !this.data.ltPropPreventSelection ){
                            input.selectionStart = returnedRange[ 0 ];
                            input.selectionEnd = returnedRange[ 1 ];
                        } else if( allow ) {
                           input.selectionStart = input.selectionEnd = returnedRange[ 1 ]; 
                        }
                        this.setData('selectedDateField', i);
                        // flag = true;
                        break;
                    }
                }
            }
         // return flag;   
   },

   setRangeByMoment : function( input, range, key ){
      var start, end;
      if( $L.moment ){
          var format = this.data.ltPropFormat, 
          value = input.value,
          is_i18n = this.data.ltPropCalendarProperties.i18n,
          moment = $L.moment( value, this._assCalendar.component.getRelevantFormat( format ), {
            i18n : is_i18n
          }),
          ns = is_i18n ? 'i18N' : 'format';

          if( moment.validate() ){
            var length = 0, sliceForm = format.slice( range [ key ] [ 0 ], range  [ key ][ 1 ] );
            for( var i = 0; i < this.data.dateOrder.length; i++ ){
                var current = this.data.dateOrder[ i ], newValue = moment[ ns ]( current.format );
                if( current.format == sliceForm ){
                    break;
                }
                value = value.replace( newValue, '' );
                length += newValue.length
            }
            var formatted = moment[ ns ]( sliceForm );
            start = length + value.indexOf( formatted );
            end = start + formatted.length;
          } else {
             start = range[ key ] [ 0 ];
             end = range[ key ] [ 1 ];
          }
      } else {
        start = range[ key ][ 0 ];
        end = range[ key ][ 1 ];
      }
      return [ start, end ];
   },

   hideCalendar : function(){
            var inputs = document.getElementsByTagName( 'lyte-input' );
            for(var i = 0; i < inputs.length; i++){
                if(inputs[i] != this.$node && inputs[i].calendarDiv && !inputs[i].calendarDiv.classList.contains('lyteCalendarHidden')){
                    // hides calendar
                    this._hideCalendar( inputs[ i ] )
                }
            }
   },

   _hideCalendar : function( inputs, bool ){
        var callback;
        if( this.getMethods( 'onBeforeCalendarClose' ) ) {
               /**
                * @method onBeforeCalendarClose
                * @condition ltPropType date,datetime
                * @version 2.2.8
                */            
            callback = this.executeMethod( 'onBeforeCalendarClose', inputs.calendarDiv, inputs );
        }
        if( callback == false ){
            this.$node.focus();
            return
        } else if( callback && callback.then ){
            this._calendarCloseStart = true;
            Promise.resolve( callback ).then( this.mainHideFn.bind( this, inputs, bool ) );
        } else {
            this.mainHideFn( inputs, bool );
        }
   },

   mainHideFn : function( inputs, bool ){
        delete this._calendarCloseStart;
        inputs.calendarDiv.classList.add('lyteCalendarHidden')
        this.$node.classList.remove( 'calendarOpen' );

        Array.from( this._assCalendar.querySelectorAll( 'lyte-dropdown' ) ).forEach( function( item ){
            item.close();
        });

        if( inputs.component.getMethods( 'onCalendarClose' ) ) {
           /**
            * @method onCalendarClose
            * @condition ltPropType date,datetime
            * @version 1.0.2
            */            
            inputs.component.executeMethod( 'onCalendarClose', inputs.calendarDiv, inputs )
        }
        this.data.ltPropHeaderType == 'drilldown' && this.$node.revertToSelected();
        if( bool ){
            this.$node.blur();
            this._closedbyscrl = true;
        } 
   },

   showCalendar : function(event, input){
    if( this._byManual ) {
        delete this._byManual;
        return;
    }
     this.hideCalendar();
     // removing hidden class
      if( this.data.ltPropReadonly && !this.data.ltPropPreventKeys || this._calendarCloseStart ){
        return;
     }
     if( this.getMethods( 'onBeforeOpen' )  ){
        var retVal = this.executeMethod( 'onBeforeOpen', event, this.node );
        if( retVal == false ){
            this._prevclick = true;
            setTimeout( function(){
                delete this._prevclick;
            }.bind( this ), 100 );
            return;
        }
     }
     if( !this.data.ltPropBindToBody ){
         this.setData( 'ltPropBindToBody', true );   
     }
     this.$node.calendarDiv.classList.remove('lyteCalendarHidden')
     $L.fastdom.measure( this.scrollFunc.bind( this ) );
     // initial selection
     $L.fastdom.mutate(function(){
        if( !this.data.ltPropReadonly ){
             // if( !this.data.ltPropPreventSelection ){
             //    input.selectionStart = 0;
             //    input.selectionEnd = 0;
             // }
             this.findCalendarRange(event, input );
         }
         this.$node.classList.add( 'calendarOpen' );
         if( this.data.ltPropType == 'datetime' ){
            if( this.dropdown ){
                this.dropdown.close();
            }
         }
         if(this.getMethods('onCalendarOpen')){
           /**
            * @method onCalendarOpen
            * @condition ltPropType date,datetime
            * @version 1.0.2
            */            
            this.executeMethod('onCalendarOpen', this.$node.calendarDiv, this.$node);
         }   
     }.bind(this))
   },

   calendarMousedown : function(event){
        if( this.$node.calendarDiv.contains( event.target.correspondingElement || event.target ) ) {
            this.preventFocus = true
        }
   },

   timeClick : function( evt, input, startVal ){
    if( this.data.ltPropReadonly && !this.data.ltPropPreventKeys ){
        return;
    }
    if( !this.data.ltPropReadonly && !this._emptytimeValue ){
        var start, startVal, endVal;
        // measuring clicked position
            start = Math.min( 2, parseInt( ( startVal == undefined ? input.selectionStart : startVal ) / 3 ) );
        // measuring selection 
            switch(start){
                case 2 : {
                    startVal = 6;
                    endVal = input.value.length;
                    this.setData('selectedField', {prop : 'meridian', val : 6});
                }
                break;
                case 1 : {
                    startVal = 3;
                    endVal = 5;
                    this.setData('selectedField', {prop : 'minute', val : 3});
                }
                break;
                default : {
                    startVal = 0;
                    endVal = 2;
                    this.setData('selectedField', {prop : 'hour', val : 0});
                }
            }

        input.selectionStart = startVal;
        input.selectionEnd = endVal;
      }
      if(this.dropbox && this.dropbox.classList.contains('lyteDropdownHidden') && evt.type == "click"){
            this.dropdown.ltProp( 'selected', '' );
            this.setData('dropdownData', this.getData('originalData'));
            this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );
            this.dropdown.toggle();
        }
   },

   calendarKeydown : function( evt, input ){
        if( !input.value || this.data.ltPropReadonly ){
            return;
        }
        var keyCode = evt.keyCode,

        time = this.dateValidation(input.value);
            if(time != false){
                var selected = this.getData('selectedDateField');                       
                if([37, 38, 39, 40, 9].indexOf(keyCode) != -1){
                        if(input.selectionEnd == input.selectionStart){
                            this.findCalendarRange(evt, input);
                            selected = this.data.selectedDateField;
                        }
                        var start = input.selectionStart;
                        var end = input.selectionEnd;
                        if([38, 40].indexOf(keyCode) != -1){
                           evt.preventDefault();
                        switch(selected){
                            case 'year' : {
                                if(keyCode == 40){
                                    time.setFullYear(time.getFullYear() - 1);
                                }else{
                                    time.setFullYear(time.getFullYear() + 1);
                                }   
                            }
                            break;
                            case 'month' : {
                                if(keyCode == 40){
                                    time.setMonth(time.getMonth()  - 1);
                                }else{
                                    time.setMonth(time.getMonth() + 1);
                                }
                            }
                            break;
                            default : {
                                if(keyCode == 40){
                                    time.setDate(time.getDate() - 1);
                                }else{
                                    time.setDate(time.getDate() + 1);
                                }
                            }
                        }
                        if( this._assCalendar.component.checkDate( time ) ){
                            this.setData('ltPropCurrentDate', this.getDateFromFormat(time, this.getData('ltPropFormat')));
                        }
                        $L.fastdom.measure( this.findCalendarRange.bind( this, {}, input, true ) )
                    } else {
                        if((input.selectionEnd == input.value.length && (keyCode == 39 || (!evt.shiftKey && keyCode == 9))) || (input.selectionStart == 0 && (keyCode == 37 || (evt.shiftKey && keyCode == 9)))){
                            return
                        }else{
                            var daterange = this.getData('dateRange'),
                            dateOrder = this.data.dateOrder,
                            index;

                            for( var i = 0; i < dateOrder.length; i++ ){
                                if( dateOrder[ i ].name == selected ){
                                    index = i;
                                    break;
                                }
                            }

                            if( keyCode == 39 || ( !evt.shiftKey && keyCode == 9 ) ) {
                                if( i + 1 == dateOrder.length ){
                                    start = end = daterange[ selected ][ 1 ] + 1;
                                } else {
                                    var returned = this.setRangeByMoment( input, daterange, dateOrder[ index + 1 ].name );
                                    start = end = Math.abs( ( returned[ 0 ] + returned[ 1 ] ) * 0.5 )
                                }
                            }else if( keyCode == 37 || ( evt.shiftKey && keyCode == 9 ) ){
                                if( i == 0 ){
                                    start = end = daterange[ selected ][ 0 ] + 1;
                                } else {
                                    var returned = this.setRangeByMoment( input, daterange, dateOrder[ index - 1 ].name );
                                    start = end = Math.abs( ( returned[ 0 ] + returned[ 1 ] ) * 0.5 )
                                }
                            }
                            $L.fastdom.measure( this.findCalendarRange.bind( this, {}, input ) );
                            if( this.data.ltPropPreventSelection ){
                                return;
                            }
                            // start = input.selectionStart;
                            // end = input.selectionEnd;
                            evt.preventDefault();
                        }
                    }
                    // restore current selection
                    // $L.fastdom.mutate(function(){
                        input.selectionStart = start;
                        input.selectionEnd = end;
                    // })
                 }
             }
   },

   focusCallback : function( evt ){
        if( this.getMethods( 'onFocus' ) ) {
           /**
            * @method onFocus
            * @version 1.0.6
            */            
            this.executeMethod( 'onFocus', evt, this.$node )
        }
   },

   focusout : function(){
        if(!this.preventFocus){
            var cal = this.$node.calendarDiv;
            if( !cal || cal.classList.contains('lyteCalendarHidden') ) {
                return
            }

            setTimeout( this._hideCalendar.bind( this, this.$node ) )
                // cal.classList.add('lyteCalendarHidden')
                // this.$node.classList.remove( 'calendarOpen' )
                // setTimeout( function(){
                //     if( this.getMethods( 'onCalendarClose' ) ) {
                //     this.executeMethod( 'onCalendarClose', cal, this.$node )
                // }
                // }.bind( this ), 0  )
        }else {
            delete this.preventFocus;
        }
   },

   maxLen : function( value ) {

        var max = this.data.ltPropMaxlength;
        return max != undefined ? value.toString().match( new RegExp('.{0,' + max + '}') )[ 0 ] : value;
   },

    actions: {

            preventDrag : function( evt ){
                evt.preventDefault();
            },

            clsIcon : function( evt ){
                this.$node.ltProp( 'value', '' );
                this.$node.focus();
                if( this.data.isSearch ){
                    /**
                     * @event on-ip-clear
                     * @version 2.0.0
                     */                    
                    this.throwEvent( 'on-ip-clear', evt );
                }
                if( this.getMethods( 'onClear' ) ) {
                    /**
                     * @method onClear
                     * @version 2.0.0
                     */                    
                    this.executeMethod( 'onClear', evt, this.$node );
                }
            },

            calmsdown : function( evt, _this ){
                this._calmsfg = true;
            },

             numberKeydown : function( evt, _this ){
                var ff = /firefox/ig.test( navigator.userAgent );
                if( !( _lyteUiUtils.isAndroid && !( ff ) ) ) {
                    var key = evt.which || evt.keyCode, prev, value = _this.value, isIE = /rv:11/ig.test( navigator.userAgent );
                    if( /^(8|9|27|37|39|13|187|189)$/.test( key ) || ( ff && /^173$/i.test( key ) ) || ( key >= 48 && key <=57 ) || ( key >= 96 && key <= 105 ) || evt.metaKey || evt.ctrlKey || ( /^(38|40)$/.test( key ) && !isIE ) ){
                        return;
                    }
                    if( /^(69|190)$/.test( key ) ){
                        if( ( !/\./i.test( value ) && key == 190 ) || ( key == 69 && ( !/e/i.test( value ) && value != "" ) ) ) {
                            return;
                        }
                    }
                    evt.preventDefault();
                    if( key == 38 ){
                        value = Number( value || 0 ) + Number( _this.step );
                    } else if( key == 40 ) {
                        value = Number( value || 0 ) - Number( _this.step );
                    }
                    if( isIE && /^(38|40)$/.test( key ) ){
                        var newVal = parseInt( this.maxLen( value ) );
                        if( !isNaN( newVal ) ) {
                            newVal = Math.min( Math.max( newVal, _this.min ? _this.min : -Infinity ), _this.max ? _this.max : Infinity );
                            if( !isNaN( newVal ) ) {
                                _this.value = newVal;
                            }
                        }
                    }
                 }
             },

             numberPaste : function( evt, _this ) {
                var clip = evt.clipboardData || window.clipboardData,
                newVal = _this.value + clip.getData( 'text' ).replace(/\'|\"/g, '');
                if( /^([0-9]+|\.(?!e){1,}|\+|\-)([0-9\.\e]{0,}$)/i.test( newVal ) ){
                    return;
                }
                if( newVal.length == this.maxLen( newVal ) && !/rv:11/ig.test( navigator.userAgent ) ){
                    return;
                }
                evt.preventDefault();
             },

             focusClass : function(evt){
                this.$node.classList.add( 'lyteInputFocus' )
                this.focusCallback.call( this, evt )
             },

             "blurThrow":function(event, flag){
                delete this._lasttyped;
                var ty = /date/i.test( this.data.ltPropType ), mt = this.getMethods( 'onBlur' )
                this.$node.classList.remove( 'lyteInputFocus' )
                if( !flag ) {
                    var type = this.getData( 'ltPropType' )
                    if( this._calmsfg ) {
                        this.valUpdate();
                        setTimeout( function(){
                            if( ty ){
                                this.focusout.call( this )
                            }
                            if( mt ) {
                                this.executeMethod( 'onBlur', event, this.$node )
                            }
                        }.bind( this ), 0)
                        delete this._calmsfg;
                    } else {
                        if( type == "number" ) {
                            var max = this.data.ltPropMax,
                            min = this.data.ltPropMin,
                            value = parseFloat( event.target.value ),
                            happened = false;

                            if( !isNaN( value ) ){
                                if( [ undefined, null, '' ].indexOf( min ) == -1 && min.constructor == Number ){
                                    value = Math.max( min, value );
                                    happened = value == min;
                                } 
                                if( [ undefined, null, '' ].indexOf( max ) == -1 && max.constructor == Number ){
                                    value = Math.min( max, value );
                                    happened = happened || ( value == max );
                                }
                                if( happened ){
                                    event.target.value = value;
                                }
                            }
                        }
                        this.valUpdate.call( this );
                        if( ty ){
                            this.focusout.call( this )
                        }
                        if( mt ) {
                           /**
                            * @method onBlur
                            * @version 1.0.6
                            */                            
                            this.executeMethod( 'onBlur', event, this.$node )
                        }
                    }
                }
             },

             input : function( evt, _this ){
                if( this.data.ltPropType == 'number' ){
                    var value = _this.value, newVal1 = this.maxLen( value ), newVal;
                    newVal = Math.min( newVal1, _this.max != undefined && _this.max != '' ? _this.max : Infinity )
                    if( value !== newVal1 || newVal1 != newVal ){
                        if( newVal1 == newVal ) {
                            _this.value = newVal1;
                        } else if ( isNaN( newVal ) ){
                            _this.value = parseFloat( newVal1 );
                        } else {
                            _this.value = newVal;
                        }
                    }
                }
                if(this.getData('ltPropAutoUpdate')){
                    clearTimeout( this._iptime );
                    var updly = this.data.ltPropUpdateDelay;
                    if( updly != undefined ){
                        this._iptime = setTimeout( this.valUpdate.bind( this ), updly );
                    } else {
                        this.valUpdate.call( this );
                    }
                }
             },

             "showcalendar":function(event, input){
                this.$node.classList.add( 'lyteInputFocus' )
                this.focusCallback.call( this, event )
                this.showCalendar(event, input);
             },

             calendarClick : function(evt, input){
                if( this._focus && _lyteUiUtils.isMobile || ( this.data.ltPropReadonly && !this.data.ltPropPreventKeys ) ){      
                    delete this._focus;     
                    return;     
                }
                if( !this._focus && /date/i.test( this.data.ltPropType ) && !this._prevclick ){
                    if( $L( this.$node.calendarDiv ).hasClass( 'lyteCalendarHidden' ) ){
                        this.showCalendar( evt, input);
                    }
                }
                this.findCalendarRange(evt, input);
             },

             calendarKeydown : function(){
                this.calendarKeydown.apply(this, arguments)
             },

             timeBlur : function(evt, input){
                if( this._emptytimeValue && input.value ){
                    this.checkTimeStr( input, true );
                } else if( this.data.ltPropValidateOnBlur && !this._emptytimeValue ){
                    var ret = this._getCrctHour( input.value, this.data.ltPropTimeFormat, this.data.meridian );
                    this.setData( 'ltPropDefaultTime', ret ? ret : this._findNearest( input.value, this.data.ltPropTimeFormat ) );
                }
                this.$node.classList.remove( 'lyteInputFocus' )
                this.setData('selectedField', {});
                if( this.getMethods( 'onBlur' ) ) {
                    if( this._calmsfg ){
                        this.executeMethod( 'onBlur', evt, this.$node )
                    } else {
                        setTimeout( function(){ 
                            this.executeMethod( 'onBlur', evt, this.$node )
                        }.bind( this ), 0 )
                    }
                }
             },

             timeInput : function( _this ){
                if( this._emptytimeValue ){
                    this.checkTimeStr( _this );
                } else {
                    var value = _this.value || "",
                    format = this.data.ltPropTimeFormat,
                    form,
                    meridian = this.data.meridian;
                    if( format == 12 ){
                        form = "hh:mm A";
                        value = value.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );
                    } else {
                        form = "HH:mm";
                    }
                    if( value && $L.moment && !$L.moment( value, form ).validate() ){
                        _this.value = this.data.ltPropDefaultTime;
                    }
                }

             },

             timeFocus : function(evt, input){
                this.$node.classList.add( 'lyteInputFocus' )
                var value = input.value.trim();
                this.setData('selectedField', {prop : 'hour', val : 0});
                input.selectionStart = 0;
                this.fixSelection.call(this, 0, {prop : 'hour', val : 0}, input);
                this.focusCallback.call( this, evt )
             },

             timeKeydown : function(evt, input){
                if( this.data.ltPropReadonly || this._emptytimeValue ){
                    return;
                }
                var selectedField = this.getData('selectedField'), meridian = this.getData('meridian'), timeFormat = this.getData('ltPropTimeFormat'), flag = true, oriDrop = this.getData('originalData'), rendered = this.getData('dropdownData'),
                keyCode = _lyteUiUtils.getCorrectNumberCode( evt.which || evt.keyCode ),
                prev_nav = this.data.ltPropPreventDropdownNavigation,
                is_drop_open =  this.dropbox && !$L( this.dropbox ).hasClass( 'lyteDropdownHidden' );

                if( !prev_nav && is_drop_open && /38|40|13/.test( keyCode ) ){
                    return;
                }

                if( prev_nav && is_drop_open && /38|40/.test( keyCode ) ){
                    evt.stopPropagation();
                }

                if(selectedField.prop && !( evt.ctrlKey || evt.metaKey ))
                    {
                        var start = input.selectionStart, end = input.selectionEnd;
                        if(start == end){
                            this.timeClick( {}, input, start );
                            start = input.selectionStart, end = input.selectionEnd;
                            selectedField = this.getData('selectedField');
                        } else {
                            if( start == 0 && end == input.value.length ){
                                start = 0;
                                end = 2;
                                this.timeClick(  {}, input, start );
                                selectedField = this.getData( 'selectedField' );
                            }
                        }
                        var dontcall;
                        if(keyCode != 9){
                            evt.preventDefault();
                        }
                        if([9, 37, 39].indexOf(keyCode) != -1){
                            if((evt.shiftKey || keyCode == 37) && selectedField.prop != 'hour' && keyCode != 39){
                                this.fixSelection.call(this, -3, selectedField, input);
                                evt.preventDefault();
                                dontcall = true;
                            }
                            else if((((!evt.shiftKey || keyCode == 39) && selectedField.prop != 'minute' && timeFormat == 24) || (!evt.shiftKey && selectedField.prop != 'meridian' && timeFormat == 12)) && keyCode != 37){
                                this.fixSelection.call(this, 3, selectedField, input);
                                evt.preventDefault();
                                dontcall = true;
                            }
                            flag = false;

                        }else if(keyCode >=48 && keyCode <= 57 && selectedField.prop != 'meridian'){
                            if(selectedField.prop == 'hour'){
                                this.hourTimeSet.call(this, input, evt, "hour", start, end);
                            }else if(selectedField.prop == 'minute'){
                                this.hourTimeSet.call(this, input, evt, 'minute', start, end);
                            }
                            this.data.ltPropDropdown && this.constructNewDrop(input, timeFormat);
                        }else if((keyCode == 38 || keyCode == 40) && selectedField.prop != 'meridian'){
                            if(keyCode == 38){
                                this.timeIncrease.call(this, input, evt, selectedField.prop, start, end);
                            }
                            else{
                                this.timeDecrease.call(this, input, evt, selectedField.prop, start, end);
                            }
                            flag = false;
                            dontcall = true;
                        }else if(selectedField.prop == 'meridian'){
                            var val = input.value.trim().slice(6,input.value.length), final, key = String.fromCharCode(keyCode).toUpperCase();
                            if(meridian.PM.toUpperCase().indexOf(key) == 0){
                                val = meridian.PM;
                            }else if(meridian.AM.toUpperCase().indexOf(key) == 0){
                                val = meridian.AM;
                            }
                            else if([38, 40].indexOf(keyCode) != -1){
                                if(val == meridian.PM){
                                    val = meridian.AM
                                }else{
                                    val = meridian.PM
                                }
                            }
                            if(val != meridian.AM){
                            //  if(input.value.trim().slice(0, 2) == '12'){
                            //      final = this.replaceVal.call(this, input, '00', 0, 2);
                            //  }
                            // }else{
                                if(input.value.trim().slice(0, 2) == '00'){
                                    final = this.replaceVal.call(this, input, '12', 0, 2);
                                }
                            }
                            if(val){
                                final = this.replaceVal.call(this, final ? final : input, val, start, end);
                            }
                            if( !this.data.ltPropValidateOnBlur ){
                                var returnV = this.maxValCheck(final);
                                if(returnV == false){
                                    return false;
                                }
                            }
                            this.setData('ltPropDefaultTime', final);
                            flag = false;
                        }
                        !dontcall && this.fixSelection.call(this, 0, this.getData('selectedField'), input);
                     if(flag)
                        {
                            $L.fastdom.mutate(function(){
                                // restore current selection
                                input.selectionStart = start;
                                input.selectionEnd = end;
                            })
                        }
                     if(oriDrop.length != rendered.length && (keyCode < 48 || keyCode > 57)){
                        this.dropdown.ltProp( 'selected', '' );
                        this.setData('dropdownData', oriDrop);
                        this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );
                     }  
                  } else if( /^8|46$/i.test( keyCode ) ) {
                    evt.preventDefault();
                  }
             },

             timeClick : function(){
                this.timeClick.apply(this, arguments)
             }
     },

     attrObs : function( arg ){
        this.data.ltPropAria && _lyteUiUtils.setAttribute( this.$node.querySelector( 'input,textarea' ), this.data.ltPropAriaAttributes || {}, arg ? arg.oldValue : {} )
     }.observes( 'ltPropAriaAttributes', 'ltPropAriaAttributes.{}' ).on( 'didConnect' ),

     checkTimeStr : function( _this, frmblur ){
        if( this._emptytimeValue ){
            var value = _this.value || "",
            format = this.data.ltPropTimeFormat,
            form,
            meridian = this.data.meridian;
            if( format == 12 ){
                form = "hh:mm A";
                value = value.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );
            } else {
                form = "HH:mm";
            }
            if( value && $L.moment( value, form ).validate() ){
                var ret = this._getCrctHour( _this.value, format, meridian );
                this.setData( 'ltPropDefaultTime', ret ? ret : this._findNearest( _this.value, format ) );
                delete this._emptytimeValue;
            } else if( value && frmblur ){
                if( this.data.ltPropStartTime == this.data.ltPropDefaultTime ){
                    this.setData( 'ltPropDefaultTime', "" );
                }
                this.setData( 'ltPropDefaultTime', this.data.ltPropStartTime );
                delete this._emptytimeValue;
            }
        }
     }
});

function _lyteInput( evt ){
    // var inputs = document.body.getElementsByTagName( 'lyte-input' );
    var dateIp = window._lyteUiUtils.input, inputs = Object.keys( dateIp || {} )
    for( var i = 0; i < inputs.length; i++ ){
        // if( /date/i.test( inputs[ i ].ltProp( 'type' ) ) ){
            var comp = dateIp[ inputs[ i ] ].component;
            if( evt.type == "click" ){
                comp.calenderClickHide.call( comp, evt );
            } else {
                comp.scrollFunc.call( comp, evt );
            }
        // }
    }
}

[ 'click', 'scroll', 'resize', 'orientationchange' ].forEach( function( item ){
    window.addEventListener( item, _lyteInput, true ); 
} )

/**
 * @syntax 
 * @attribute ltPropType=text
 * <lyte-input  lt-prop-type="text" lt-prop-placeholder="enter text here" lt-prop-label="Name"> </lyte-input>
 */

/**
 * @syntax 
 * @attribute ltPropType=number
 * <lyte-input lt-prop-label="Age" lt-prop-type="number"  lt-prop-placeholder="Enter number here"> </lyte-input>
 */

/**
 * @syntax 
 * @attribute ltPropType=textarea
 * <lyte-input lt-prop-type="textarea" lt-prop-id="lyteinput" lt-prop-placeholder="Enter your comments" lt-prop-label="Comments" lt-prop-rows="5" lt-prop-cols="80" > </lyte-input>
 */

/**
 * @syntax 
 * @attribute ltPropType=date
 * <lyte-input lt-prop-type="date" lt-prop-id="lyteinput" lt-prop-format="MM/DD/YYYY" lt-prop-label="Select DOB" lt-prop-placeholder="Select your DOB" > </lyte-input>
 */

/**
 * @syntax 
 * @attribute ltPropType=time
 * <lyte-input lt-prop-type="time" lt-prop-time-format=12 lt-prop-wheel=true lt-prop-label="Select Time" > </lyte-input>
 */

/**
 * @syntax 
 * @attribute ltPropType=datetime
 * <lyte-input lt-prop-type="datetime" lt-prop-placeholder="Select Date" lt-prop-format="MM/DD/YYYY" lt-prop-label="Date & Time"  > </lyte-input>
 */

 /**
  * @syntax 
  * @attribute ltPropType=date
  * @attribute ltPropYield=true
  * <lyte-input lt-prop-type="date" lt-prop-yield = true lt-prop-format="MM/DD/YYYY" lt-prop-label="Select DOB" lt-prop-placeholder="Select your DOB" > 
  *     <template is = "registerYield" yield-name = "footer">
  *         calendar footer
  *     </template>
  * </lyte-input>
  */

 /**
  * @syntax 
  * @attribute ltPropType=time
  * @attribute ltPropYield=true
  * <lyte-input lt-prop-type="time" lt-prop-yield = true lt-prop-time-format=12 lt-prop-wheel=true lt-prop-label="Select Time" > </lyte-input>
  *     <template is = "registerYield" yield-name = "item">
  *         {{itemValue.time}}
  *     </template>
  * </lyte-input>
  */

 /**
  * @syntax 
  * @attribute ltPropType=datetime
  * @attribute ltPropYield=true
  * <lyte-input lt-prop-type="datetime" lt-prop-yield = true lt-prop-placeholder="Select Date" lt-prop-format="MM/DD/YYYY" lt-prop-label="Date & Time"  > </lyte-input>
  *     <template is = "registerYield" yield-name = "item">
  *         {{itemValue.time}}
  *     </template>
  *     <template is = "registerYield" yield-name = "footer">
  *         calendar footer
  *     </template>
  * </lyte-input>
  */

  /**
  * @syntax 
  * @attribute ltPropType=password
  * <lyte-input lt-prop-type="password" lt-prop-label="password" lt-prop-placeholder="Enter password here"> </lyte-input>
  * </lyte-input>
  */
/**
 * Renders an board
 * @component lyte-board
 * @version 3.1.0
 * @methods onBoardScroll
 */
Lyte.Component.register( 'lyte-board', {
_template:"<template tag-name=\"lyte-board\"> <div class=\"lyteBoardWrapper {{ltPropClass}}\"> <div class=\"lyteBoardHeader\"> <lyte-yield yield-name=\"headerItem\" board-detail=\"{{ltPropBoardDetail}}\" index=\"{{ltPropIndex}}\"></lyte-yield> </div> <div class=\"lyteBoardContainer\"> <div class=\"lyteKanbanNestedSortable {{ltPropKanbanId}}\" id=\"{{ltPropBoardDetail.id}}\" index=\"{{ltPropIndex}}\" data-loaded=\"{{dataLoaded}}\" cards-length=\"{{cardArray.length}}\" onscroll=\"{{action('boardScroll',event,this)}}\"> <template is=\"for\" items=\"{{cardArray}}\" item=\"itemContent\" index=\"index1\"> <div class=\"lyteBoardItemContentData {{itemContent[ltPropCardClassName]}}\"> <lyte-yield yield-name=\"contentItem\" lyte-card-item=\"{{itemContent}}\"></lyte-yield> </div> </template> </div> <template is=\"if\" value=\"{{expHandlers(cardArray.length,'==',0)}}\"><template case=\"true\"> <div class=\"lyteKanbanNoResultMsg\">{{ltPropNoResultMessage}}</div> </template></template> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"insertYield","position":[1,1,1]},{"type":"attr","position":[1,3,1]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"insertYield","position":[1,1]}]},{"type":"attr","position":[1,3,3]},{"type":"if","position":[1,3,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}],
_observedAttributes :["lyteViewPort","ltPropBoardDetail","ltPropIndex","ltPropBoardSortable","ltPropClass","ltPropKanbanId","ltPropMoreStageRecord","ltPropNoResultMessage","dummyId","ltPropCardClassName","cardArray"],
	data : function() {
		return {
		 	/**
            * @componentProperty {object} ltPropBoardDetail
            * @version 3.1.0
            */ 
			lyteViewPort : Lyte.attr("boolean", {"default" : true}),//No I18n
			'ltPropBoardDetail' : Lyte.attr( 'object' ), 
			/**
            * @componentProperty {number} ltPropIndex
            * @version 3.1.0
            */ 
			'ltPropIndex' : Lyte.attr( 'number' ),
			/**
            * @componentProperty {boolean} ltPropBoardSortable=true
            * @version 3.1.0
            */
            'ltPropBoardSortable' : Lyte.attr( 'boolean', {
				'default':  _lyteUiUtils.resolveDefaultValue( 'lyte-board', 'boardSortable', true )
			} ),
			/**
            * @componentProperty {string} ltPropClass
            * @version 3.1.0
            */
			'ltPropClass' : Lyte.attr('string',{
				'default':  _lyteUiUtils.resolveDefaultValue( 'lyte-board', 'class', '' )
			}),
			/**
            * @componentProperty {string} ltPropKanbanId=''
            * @version 3.1.0
            */
			'ltPropKanbanId' : Lyte.attr( 'string', {
				'default' : ''
			} ) ,
			'ltPropMoreStageRecord' : Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropNoResultMessage' : Lyte.attr('string',{'default': _lyteUiUtils.resolveDefaultValue( 'lyte-dropdown', 'noResultMessage', _lyteUiUtils.i18n( 'no.results.found' ) )}),
			'dummyId' : Lyte.attr( 'string', {
				'default' : ''
			} ),
			'ltPropCardClassName' : Lyte.attr('string',{'default':undefined}),
			'cardArray' : Lyte.attr( 'array', {
				'default':[]
			} )
		}		
	},
	init : function(){

		this.setCardArray()
	},
	didConnect : function(){
		this.$node.getVisibleCard =function(){
			    var scrollDiv = this.$node.getElementsByClassName('lyteKanbanNestedSortable')[0]
			    if(scrollDiv.scrollHeight>scrollDiv.clientHeight){
			    	return this.getVisibleNode()

			    }
			return (this.getData('ltPropBoardDetail').cards ? this.getData('ltPropBoardDetail').cards  : [])

		}.bind(this)
	},
	viewPortObs : function(){
		if( !this.getData('lyteViewPort') ) {
			var kanbanview = $L(this.$node ).closest( 'lyte-kanbanview' )[ 0 ]
			if(kanbanview){
				kanbanview.component.setupSortableForCard()
			} 
			console.log(kanbanview)
		}

	}.observes('lyteViewPort'),
	didDestroy: function() {
        clearTimeout( this.timeout1 );
	},
	getVisibleNode : function(){
        // return;
        var bcr=this.$node.getBoundingClientRect(),
        originalRows = Array.from( this.$node.getElementsByClassName( 'lyteBoardItemContentData' ) ),
        tValue = Math.max( bcr.top + 10 , -10 ),
        bValue = Math.min( window.innerWidth + 10, bcr.bottom),
        visible = [], boardDetails = this.getData('ltPropBoardDetail').cards;
        


       
        for( var i = 0; i < originalRows.length; i++ ){
            var row = originalRows[ i ],
            _bcr = row.getBoundingClientRect();
            if( _bcr.bottom > tValue && _bcr.top <bValue ){
                visible.push( boardDetails[i] );
                
            }
        }

        
        return visible;
    
	},
	contentObs : function(){
		this.setCardArray()
		if(this.getData('ltPropBoardSortable')){
			this.addSortableForNewRecords()
		}
		
	}.observes( 'ltPropBoardDetail.cards.[]' ),
	setCardArray : function(){
		var boardDetail = this.getData('ltPropBoardDetail')
		if( boardDetail && boardDetail.cards ){
			this.setData( 'cardArray', boardDetail.cards )
		}
	},
	addSortableForNewRecords : function() {
		var sortableClass = this.$node.querySelectorAll( '.lyteKanbanNestedSortable.'+this.getData('ltPropKanbanId') )[0].getSortableClass(),
		cardWithoutSortable = this.$node.querySelectorAll( '.lyteBoardItemContentData:not(.'+sortableClass+')' )
		$L(cardWithoutSortable).map(function(index,element){
			element.parentElement.addToSortable(element);
		})
		
	},
	addShadow : function() {
		this.$node.querySelector( '.lyteBoardHeader' ).classList.add( 'lyteKanbanviewHeaderShadow' ); 
	},
	hasScrollHeightReached : function(event) {
		if ( event.target.scrollHeight - 10 <= ( Math.ceil( event.target.offsetHeight ) + Math.ceil( event.target.scrollTop ) ) ) {
			if ( this.getData( 'ltPropMoreStageRecord' ) && this.getMethods( 'onBoardScroll' ) ) {
				this.executeMethod( 'onBoardScroll' , this.getData( 'ltPropBoardDetail' ), this, event  ); //NO i18n
			}
		}
	},
	removeShadow : function(){
		this.$node.querySelector('.lyteBoardHeader').classList.remove('cxKanbanShadow'); // No I18n
	},
	executeScrollStop : function(){
		if( this.getMethods( 'onBoardScrollStop' ) ) {
			var visible,boardDetail = this.getData('ltPropBoardDetail'),
			 scrollDiv = this.$node.getElementsByClassName('lyteKanbanNestedSortable')[0]
			if(scrollDiv.scrollHeight>scrollDiv.clientHeight){
			    	visible = this.getData('ltPropBoardDetail')
			 } else{
			 	visible = this.getVisibleNode()
			 }
			this.executeMethod( 'onBoardScrollStop', boardDetail, visible, this, scrollDiv.scrollTop, event );
		}
	},
	actions :{
		boardScroll : function( event ) {

			if ( event.target.scrollTop != 0 ) {
				this.addShadow();
			}

			this.timeout1 = setTimeout(function() {
				
				this.hasScrollHeightReached(event)
			}.bind( this ), 10 );

			if ( event.target.scrollTop == 0 ){
				this.removeShadow()
			}
			this.debounceTimeout = setTimeout( function(){
				this.executeScrollStop()
			}.bind(this),100)
		}

	}
});

/**
 * Renders a kanbanview
 * @component lyte-kanbanview
 * @version 3.1.0
 * @dependencies lyte-card,lyte-board
 * /components/lyte-card.js
 * /theme/compiledCSS/default/ltr/lyte-ui-card.css
 * /components/lyte-board.js
 * /theme/compiledCSS/default/ltr/lyte-ui-board.css
 * @methods onDragSelectForBoard, onDragSelectBoards, onBodyScroll, onDragSelectForCard, onRecordDropForBoard, onRecordDrop,onDragSelectCard
 */
Lyte.Component.register( 'lyte-kanbanview' , {
_template:"<template tag-name=\"lyte-kanbanview\"> <div class=\"lyteKanbanviewScrollDivSelector {{dummyId}}\" onscroll=\"{{action('onBodyScroll',event)}}\"> <template is=\"for\" items=\"{{ltPropBoardDetails}}\" item=\"item\" index=\"dataIndex\"> <div class=\"lyteKanbanViewItem\"> <lyte-yield yield-name=\"kanbanYield\" lyte-board-item=\"{{item}}\" lyte-index=\"{{dataIndex}}\" lyte-kanban-id=\"{{dummyId}}\"></lyte-yield> </div> </template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"insertYield","position":[1,1]}]}],
_observedAttributes :["ltPropBoardDetails","ltPropSortable","ltPropMoreStageRecord","ltPropId","dummyId"],
	data : function(){
		return {
			/** 
			 * @componentProperty {array} ltPropBoardDetails=[]
			 * @version 3.1.0
			 */

			'ltPropBoardDetails' : Lyte.attr( 'array', {
				'default': []
			} ), 
			/** 
			 * @typedef {object} sortable
			 * @property {boolean} board
			 * @property {boolean} card
			*/
			/** 
			 * @componentProperty {sortable} ltPropSortable={"board" : true, "card" : true }
			 * @version 3.1.0
			 */
			'ltPropSortable' : Lyte.attr( 'object', {
				'default': {"board" : true, "card" : true }

			} ) ,
			/** 
			 * @componentProperty {boolean} ltPropMoreStageRecord=false
			 * @version 3.1.0
			 */
			'ltPropMoreStageRecord' : Lyte.attr( 'boolean', {
				'default': false
			} ),
			/** 
			 * @componentProperty {string} ltPropId
			 * @version 3.1.0
			 */
			'ltPropId' : Lyte.attr( 'string'),
			'dummyId' : Lyte.attr( 'string', {
				'default' : ''
			} )
		}		
	},
	didDestroy : function() {
		clearTimeout(this.timeout2);
	},
	didConnect : function() {
		var kanbanviewList = document.querySelectorAll('lyte-kanbanview')
		this._dir = _lyteUiUtils.getRTL();

		if(this.getData('ltPropId') == undefined){
			var pos = Object.values(kanbanviewList).indexOf(this.$node)
			this.setData('dummyId', 'dummyId'+pos)
		}
		else{
			this.setData('dummyId',this.getData('ltPropId'))
		}
		this.doBoardSortable()
		this.doCardSortable()
		this.$node.getVisibleBoard =function(){
			var scrollDiv = this.$node.querySelector( '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') )
			if(scrollDiv.scrollWidth<scrollDiv.clientWidth){
				return this.getData('ltPropBoardDetails')
			}
			return this.getVisibleNode()
		}.bind(this)
	},
		
	getVisibleNode : function(){
        // return;
        var bcr=this.$node.getBoundingClientRect(),
        originalRows = Array.from( this.$node.getElementsByTagName( 'lyte-board' ) ),
        tValue = Math.max( bcr.left + (this._dir?0:10) , -10 ),
        bValue = Math.min( window.innerWidth + 10, bcr.right  - (this._dir?10:0)),
        visible = [],boardDetails = this.getData('ltPropBoardDetails');


       
        for( var i = 0; i < originalRows.length; i++ ){
            var row = originalRows[ i ],
            _bcr = row.getBoundingClientRect();
            if( _bcr.right > tValue && _bcr.left <bValue ){
                visible.push( boardDetails[i] );
                
            }
        }

        return visible;
    
	},
	boardObs : function() {
		if( this.getData('ltPropSortable').board ){
			this.addSortableForNewBoards()
		}
	}.observes( 'ltPropBoardDetails.[]' ),
	doCardSortable : function() {
		clearTimeout(this._cardSortableTimeout)
		this._cardSortableTimeout =setTimeout( function(){
			if( this.getData( 'ltPropBoardDetails' ).length > 0 && this.getData( 'ltPropSortable' ).card ) {
				this.setupSortableForCard()
			}
		}.bind(this),100)
		
	},
	doBoardSortable : function() {
		if( this.getData( 'ltPropBoardDetails' ).length > 0 && this.getData( 'ltPropSortable' ).board ) {
			this.setupSortableForBoard()
		}
	},
	stageBoardDetailsObs : function() {
		this.doCardSortable()
	}.observes( 'ltPropBoardDetails.[]' ).on, 
	hasSameColumnReordered : function( source, destination ) {
		var sourceIndex = source.getAttribute( 'index' ),
		destinationIndex = destination.getAttribute( 'index' )

		if( sourceIndex == destinationIndex ) {
			return true
		}
		return false
	},
	onRecordDropForBoard : function( boardDetails, droppedElement, fromIndex, toIndex, source, destination, draggedElement ){
		
		if( this.getMethods( 'onRecordDropForBoard') ) {
			this.executeMethod( 'onRecordDropForBoard', droppedElement, source, destination, fromIndex, toIndex ,boardDetails ,draggedElement[0] )
		}
	},
	onRecordDrop : function( boardDetails, sourceArray, destArray, draggedElement, fromIndex, toIndex, source, destination,droppedElement) {
		var sourceIndex = source.getAttribute( 'index' ),
		destinationIndex = destination.getAttribute( 'index' ),
		board,card


		board = this.$node.querySelectorAll( 'lyte-board' );
		card = droppedElement.querySelector( 'lyte-card' )
		if( !this.hasSameColumnReordered( source, destination ) ) {
			boardDetails[ sourceIndex ].cards = sourceArray; 
			board[ sourceIndex ].setData( 'ltPropContent' , sourceArray );
		}
		boardDetails[ destinationIndex ].cards = destArray; 
		board[ destinationIndex ].setData('ltPropContent' , destArray);

		if( this.getMethods( 'onRecordDrop') ) {
			this.executeMethod( 'onRecordDrop', card, board[ sourceIndex ], board[ destinationIndex ], fromIndex, toIndex,parseInt(sourceIndex),parseInt(destinationIndex),boardDetails,draggedElement[0] ) 
		}
	},
	setupSortableForBoard : function() {
		var self=this  ;

		$L( '.lyteKanbanviewScrollDivSelector ', this.$node ).sortable( {  
			scrollDivX  :  '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') ,  
			onSelect  : function( currentElem, fromIndex, source, event ) { 
					var	board = currentElem.querySelector( 'lyte-board' )
					
					if( self.getMethods( 'onDragSelectForBoard' ) ){
						return self.executeMethod( 'onDragSelectForBoard', board, fromIndex, source, event ); 
					}
					
					return true;
			},
			onDrag  : function ( draggableElement , belowElem, event, placeholder ){ 
				self.prevent =true
				var	board = draggableElement.querySelector( 'lyte-board' )

				if( self.getMethods( 'onDragForBoard' ) ){
						 self.executeMethod( 'onDragForBoard', board, belowElem, event, placeholder ); 
				}
			},
			onBeforeDrop : function ( droppableElement , belowElement , placeholderElement , fromIndex , toIndex , source , destination ) {
				var boardDetails=self.getData( 'ltPropBoardDetails' ),
				board = droppableElement.querySelector( 'lyte-board' ),
				flag = true;
				if( self.getMethods( 'onBeforeDropForBoard' ) ){
					flag = self.executeMethod( 'onBeforeDropForBoard', boardDetails, droppableElement, belowElement, placeholderElement, fromIndex, toIndex, source, destination ); 
				}
				return flag;
			},
			onDrop  : function( droppedElement , destination , belowElement , fromIndex , toIndex , source ) {
				var boardDetails=self.getData( 'ltPropBoardDetails' ),
				draggedElement, board = droppedElement.querySelector( 'lyte-board' )



				draggedElement = Lyte.arrayUtils( boardDetails, 'splice', fromIndex, 1 )
				Lyte.arrayUtils( boardDetails, 'splice', toIndex, 0, draggedElement[ 0 ] )
				delete self.prevent

				self.setData('ltPropBoardDetails',boardDetails)
				self.onRecordDropForBoard( boardDetails, board , fromIndex, toIndex, source, destination, draggedElement)

				
		 	} 
 		}); 
	},
	setupSortableForCard : function(){
		var self=this;

		$L( '.lyteKanbanNestedSortable', this.$node ).sortable( {  
			scrollDivX  : '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') ,  
			connectedWith  : '.lyteKanbanNestedSortable.'+this.getData('dummyId') , 

			onSelect  : function( currentElem, fromIndex, source, event ) { 
					console.log(currentElem)
					if($L(currentElem).hasClass('lyteKanbanNoResultMsg')){
						return false;
					}
					var	card = currentElem.querySelector( 'lyte-card' )

					if( self.getMethods( 'onDragSelectForCard' ) ){
						return self.executeMethod( 'onDragSelectForCard', card, fromIndex, source, event ); 
					}
					
					return true;
			},
			onDrag  : function ( draggableElement , belowElem, event, placeholder ){ 
				self.prevent =true
				var	card = draggableElement.querySelector( 'lyte-card' )
				if( self.getMethods( 'onDragForCard' ) ){
						 self.executeMethod( 'onDragForCard', card, belowElem, event, placeholder ); 
				}
			},
			onEnter : function(event){
				var element = arguments[1].sortable
				if(element.getAttribute('cards-length')==0){
					var div=element.nextElementSibling
					if($L(div).hasClass('lyteKanbanNoResultMsg')){
						div.classList.add('lyteHide')
					}
				}
				
			},
			onLeave : function ( event , obj) {
				var element = arguments[1].sortable
				if(element.getAttribute('cards-length')==0){
					var div=element.nextElementSibling
					if($L(div).hasClass('lyteKanbanNoResultMsg')){
						div.classList.remove('lyteHide')
					}
				}
			},
			onBeforeDrop : function ( droppableElement , belowElement , placeholderElement , fromIndex , toIndex , source , destination ) {
				var sourceIndex = source.getAttribute( 'index' ),
				destinationIndex = destination.getAttribute( 'index' ),
				boardDetails=self.getData( 'ltPropBoardDetails' ),
				sourceArray=boardDetails[ sourceIndex ].cards,
				destArray=boardDetails[ destinationIndex ].cards,
				flag = true;
				if( self.getMethods( 'onBeforeDropForCard' ) ){
					flag = self.executeMethod( 'onBeforeDropForCard', boardDetails, sourceArray, destArray, droppableElement, belowElement, placeholderElement, fromIndex, toIndex, source, destination ); 
				}
				return flag;
			},
			onDrop  : function( droppedElement , destination , belowElement , fromIndex , toIndex , source ) {
				var sourceIndex = source.getAttribute( 'index' ),
				destinationIndex = destination.getAttribute( 'index' ),
				boardDetails=self.getData( 'ltPropBoardDetails' ),
				sourceArray=boardDetails[ sourceIndex ].cards,
				destArray=boardDetails[ destinationIndex ].cards,
				draggedElement
				if(destArray.length==0){
					toIndex=0;
				}
				draggedElement = ( self.hasSameColumnReordered( source, destination ) ? Lyte.arrayUtils( destArray, 'splice', fromIndex, 1 ) : Lyte.arrayUtils( sourceArray, 'splice', fromIndex, 1 ) )
				Lyte.arrayUtils( destArray, 'splice', toIndex, 0, draggedElement[ 0 ] )
				delete self.prevent

				self.onRecordDrop( boardDetails, sourceArray, destArray, draggedElement, fromIndex, toIndex, source, destination ,droppedElement)

		 	} 
 		}); 
	},
	isDragging : function(){
		if(this.prevent){
			return true
		}
		return false
	},
	hasScrollEndReached : function() {
		var scrollDiv = this.$node.querySelector( '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') ),
			boardDetails = this.getData( 'ltPropBoardDetails' ),
			clientRect=this.$node.getBoundingClientRect(),
			lastClient=scrollDiv.lastElementChild.getBoundingClientRect()
			if((!this._dir && lastClient.right-3 < clientRect.right)||(this._dir&& lastClient.left+3>Math.min(window.innerWidth,clientRect.left))){
					if( this.getMethods( 'onBodyScroll' ) ) {
					this.executeMethod( 'onBodyScroll', this, boardDetails );
					
					}
			}
         
	},
	addSortableForNewBoards : function() {
		var sortableClass = this.$node.querySelectorAll( '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') )[ 0 ].getSortableClass(),
		boardWithoutSortable = this.$node.querySelectorAll( '.lyteKanbanViewItem:not(.'+sortableClass+')' )

		$L(boardWithoutSortable).addClass("sortable-element "+sortableClass );
	},
	executeScrollStop : function(){
		if( this.getMethods( 'onBodyScrollStop' ) ) {
			var visible,boardDetails=this.getData('ltPropBoardDetails'),
			scrollDiv = this.$node.querySelector( '.lyteKanbanviewScrollDivSelector.'+this.getData('dummyId') )
			if(scrollDiv.scrollWidth>scrollDiv.clientWidth){
				if(this.getData('ltPropSameWidth')){
					visible = this.getVisibleNodeWithSameWidth()
				}
				else{
					visible = this.getVisibleNode()
				} 
			}
			else{
				visible = boardDetails
			}	
			this.executeMethod( 'onBodyScrollStop', boardDetails, visible, this, scrollDiv.scrollLeft, event );
		}
	},
	actions :{
		onBodyScroll : function( ev ) {
			clearTimeout(this.debounceTimeout)
			this.timeout2 = setTimeout( function() {
				this.hasScrollEndReached()
			}.bind( this ), 10 );
			this.debounceTimeout = setTimeout( function(){
				this.executeScrollStop()
			}.bind(this),100)
		}
	}
});

Lyte.Component.register("lyte-dual-listbox", {
_template:"<template tag-name=\"lyte-dual-listbox\"> <div class=\"lyteListboxWrapper\"> <div class=\"lyteListboxLeftPanel lyteListboxPanels\"> <lyte-search class=\"lyteListBoxSearch\" lt-prop-query-selector=\"{&quot;scope&quot; : &quot;.{{ltPropSearchScope}}&quot;, &quot;search&quot; : &quot;.lyteLBMandatory&quot;, &quot;target&quot; : &quot;.lyteListBoxLeftWrap&quot;}\" lt-prop-check-from-parent=\"true\" lt-prop-component=\"duallistbox\" on-search=\"{{method('onSearch')}}\"></lyte-search> <template is=\"for\" items=\"{{ltPropLeftData}}\" item=\"item\" index=\"index\"> <template is=\"if\" value=\"{{item.childrenList}}\"><template case=\"true\"> <div class=\"lyteListBoxLeftWrap {{if(expHandlers(item.childrenList.length,'===',0),'lyteLBoxDisabledParent','')}} {{if(childitem.required,'lyteListBoxRequiredParent','')}}\"> <div class=\"lyteListBoxLeftElement lyteListBoxLeftParentElement lyteLeftLvl1 {{if(item.required,'lyteListBoxRequiredItem','')}} {{if(expHandlers(item.childrenList.length,'===',0),'lyteLBoxDisabledParent','')}}\" ondblclick=\"{{action('moveElementRight',this,'doubleClick')}}\" onclick=\"{{action('elementFN',this,event)}}\" index=\"{{lyteListBoxIndex(index)}}\"> <lyte-lb-collapse onclick=\"{{action('collapseFunction',this,'left')}}\"></lyte-lb-collapse> <lyte-yield yield-name=\"leftWidget\" left-widget-value=\"{{item}}\"></lyte-yield> <template is=\"if\" value=\"{{expHandlers(item.required,'!')}}\"><template case=\"true\"><lyte-lb-add class=\"lyteLbAdd\" onclick=\"{{action('addElementToRight',this)}}\"></lyte-lb-add></template></template> </div> <div class=\"lyteLBLeftChildWrap\"> <template is=\"for\" items=\"{{item.childrenList}}\" item=\"childitem\" index=\"ind\"> <div class=\"lyteListBoxLeftWrap lyteLeftLvl2Wrap {{if(childitem.required,'lyteListBoxRequiredParent','')}}\"> <div class=\"lyteListBoxLeftElement lyteLeftLvl2 {{if(childitem.required,'lyteListBoxRequiredItem','')}}\" ondblclick=\"{{action('moveElementRight',this,'doubleClick')}}\" onclick=\"{{action('elementFN',this,event)}}\" index=\"{{lyteListBoxIndex(ind,index)}}\"> <lyte-yield yield-name=\"leftWidget\" left-widget-value=\"{{childitem}}\"></lyte-yield> <template is=\"if\" value=\"{{expHandlers(childitem.required,'!')}}\"><template case=\"true\"><lyte-lb-add class=\"lyteLbAdd\" onclick=\"{{action('addElementToRight',this)}}\"></lyte-lb-add></template></template> </div> </div> </template> </div> </div> </template><template case=\"false\"> <div class=\"lyteListBoxLeftWrap {{if(item.required,'lyteListBoxRequiredParent','')}}\"> <div class=\"lyteListBoxLeftElement lyteLeftLvl1 {{if(item.required,'lyteListBoxRequiredItem','')}}\" ondblclick=\"{{action('moveElementRight',this,'doubleClick')}}\" onclick=\"{{action('elementFN',this,event)}}\" index=\"{{lyteListBoxIndex(index)}}\"> <lyte-yield yield-name=\"leftWidget\" left-widget-value=\"{{item}}\"></lyte-yield> <template is=\"if\" value=\"{{expHandlers(item.required,'!')}}\"><template case=\"true\"><lyte-lb-add class=\"lyteLbAdd\" onclick=\"{{action('addElementToRight',this)}}\"></lyte-lb-add></template></template> </div> </div> </template></template> </template> <template is=\"if\" value=\"{{noResultsFound}}\"><template case=\"true\"><div class=\"lyteListBoxNoResultsFound\">{{ltPropNoResultMessage}}</div></template></template> </div> <template is=\"if\" value=\"{{ltPropShowToolbar}}\"><template case=\"true\"><div class=\"lyteListboxToolbar\"> <template is=\"if\" value=\"{{moveRight}}\"><template case=\"true\"><div class=\"lyteLBToolbarItems lyteLBTBMoveRight\" onclick=\"{{action('moveElementRight',this,'toolbarClick')}}\" lt-prop-title=\"Move Right\" lt-prop-tooltip-config=\"{ &quot;position&quot;:&quot;bottom&quot;}\"></div></template></template> <template is=\"if\" value=\"{{moveLeft}}\"><template case=\"true\"><div class=\"lyteLBToolbarItems lyteLBTBMoveLeft\" onclick=\"{{action('moveElementLeft',this,'toolbarClick')}}\" lt-prop-title=\"Move Left\" lt-prop-tooltip-config=\"{ &quot;position&quot;:&quot;bottom&quot;}\"></div></template></template> <template is=\"if\" value=\"{{moveTop}}\"><template case=\"true\"><div class=\"lyteLBToolbarItems lyteLBTBMoveUp\" onclick=\"{{action('moveElementUp')}}\" lt-prop-title=\"Move Up\" lt-prop-tooltip-config=\"{ &quot;position&quot;:&quot;bottom&quot;}\"></div></template></template> <template is=\"if\" value=\"{{moveBottom}}\"><template case=\"true\"><div class=\"lyteLBToolbarItems lyteLBTBMoveDown\" onclick=\"{{action('moveElementDown')}}\" lt-prop-title=\"Move Down\" lt-prop-tooltip-config=\"{ &quot;position&quot;:&quot;bottom&quot;}\"></div></template></template> <template is=\"if\" value=\"{{deleteElement}}\"><template case=\"true\"><div class=\"lyteLBToolbarItems lyteLBTBDeleteMarked\" onclick=\"{{action('deleteElement')}}\" lt-prop-title=\"Delete\" lt-prop-tooltip-config=\"{ &quot;position&quot;:&quot;bottom&quot;}\"></div></template></template> </div></template></template> <div class=\"lyteListboxRightPanel lyteListboxPanels\"> <template is=\"for\" items=\"{{ltPropRightData}}\" item=\"item\" index=\"index\"> <div class=\"lyteListBoxRightWrap {{if(item.required,'lyteListBoxRequiredParent','')}}\"> <div class=\"lyteListBoxRightElement lyteRightLvl1 {{if(item.required,'lyteListBoxRequiredItem','')}}\" ondblclick=\"{{action('moveElementLeft',this,'doubleClick')}}\" onclick=\"{{action('elementFN',this,event)}}\" index=\"{{lyteListBoxIndex(index)}}\" setparent=\"{{lyteListBoxParentIndex(this,item,ltPropAssociateParent)}}\"> <lyte-yield yield-name=\"rightWidget\" right-widget-value=\"{{item}}\"></lyte-yield> <template is=\"if\" value=\"{{expHandlers(item.required,'!')}}\"><template case=\"true\"><lyte-lb-remove class=\"lyteLbAdd\" onclick=\"{{action('removeElementFromRight',this)}}\"></lyte-lb-remove></template></template> </div> </div> </template> </div> <template is=\"if\" value=\"{{moreLBElements}}\"><template case=\"true\"><lyte-badge class=\"lyteListboxBadge\" lt-prop-position=\"topRight\" lt-prop-max-length=\"3\"></lyte-badge></template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"for","position":[1,1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"insertYield","position":[1,1,3]},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"componentDynamic","position":[0]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"for","position":[1,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"insertYield","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"componentDynamic","position":[0]}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"insertYield","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"componentDynamic","position":[0]}]}},"default":{}}]}},"default":{}}]},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0,1]},{"type":"if","position":[0,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[0,3]},{"type":"if","position":[0,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[0,5]},{"type":"if","position":[0,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[0,7]},{"type":"if","position":[0,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[0,9]},{"type":"if","position":[0,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,5,1]},{"type":"for","position":[1,5,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"insertYield","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"componentDynamic","position":[0]}]}},"default":{}}]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[0]}]}},"default":{}}],
_observedAttributes :["ltPropLeftData","ltPropRightData","ltPropSortable","ltPropShortcut","ltPropAssociateParent","ltPropShowToolbar","ltPropSearchScope","ltPropToolbarItems","ltPropMaxCount","ltPropDoubleClick","ltPropSelectAllChild","ltPropNoResultMessage","noResultsFound","moveRight","moveLeft","moveTop","moveBottom","deleteElement","moreLBElements","selectedIndexLeft","selectedIndexRight","leftShiftSelectIndex","rightShiftSelectIndex","insertAtLeftInd","insertAtRightInd","elementPosition"],
  data: function() {
    return {
      ltPropLeftData: Lyte.attr('array', {
        default: []
      }),
      ltPropRightData: Lyte.attr('array', {
        default: []
      }),
      ltPropSortable: Lyte.attr('boolean', {
        default: false
      }),
      ltPropShortcut: Lyte.attr('boolean', {
        default: false
      }),
      ltPropAssociateParent: Lyte.attr('string', {
        default: 'value'
      }),
      ltPropShowToolbar: Lyte.attr('boolean', {
        default: false
      }),
      ltPropSearchScope: Lyte.attr('string', {
        default: 'lyteListboxLeftPanel'
      }),
      ltPropToolbarItems: Lyte.attr('array', {
        default: ['moveRight', 'moveLeft', 'moveTop', 'moveBottom']
      }),
      ltPropMaxCount: Lyte.attr('number', {
        default: -1
      }),
      ltPropDoubleClick: Lyte.attr('boolean', {
        default: true
      }),
      ltPropSelectAllChild : Lyte.attr('boolean',{
        default: false
      }),
      ltPropNoResultMessage : Lyte.attr('string' , {
        default : 'No Results Found'
      }),



      noResultsFound : Lyte.attr('boolean' , {
        default : false
      }),
      moveRight: Lyte.attr('boolean', {
        default: false
      }),
      moveLeft: Lyte.attr('boolean', {
        default: false
      }),
      moveTop: Lyte.attr('boolean', {
        default: false
      }),
      moveBottom: Lyte.attr('boolean', {
        default: false
      }),
      deleteElement: Lyte.attr('boolean', {
        default: false
      }),
      moreLBElements: Lyte.attr('boolean', {
        default: false
      }),
      selectedIndexLeft: Lyte.attr('array', {
        default: []
      }),
      selectedIndexRight: Lyte.attr('array', {
        default: []
      }),
      leftShiftSelectIndex: Lyte.attr('string', {
        default: ""
      }),
      rightShiftSelectIndex: Lyte.attr('string', {
        default: ""
      }),
      insertAtLeftInd: Lyte.attr('number', {
        default: 0
      }),
      insertAtRightInd: Lyte.attr('number', {
        default: 0
      }),
      elementPosition : Lyte.attr('number', {
        default : 0
      })
    }
  },
  init: function() {
    var th = this;

    if (this.getData('ltPropShortcut')) {
      shortcut.register('right', function() {
        th.actions.moveElementRight(th);
      });
      shortcut.register('shift+right', function() {
        th.actions.moveAllElementsRight(th);
      });
      shortcut.register('left', function() {
        th.actions.moveElementLeft(th);
      });
      shortcut.register('shift+left', function() {
        th.actions.moveAllElementsLeft(th);
      });
      shortcut.register('up', function() {
        th.actions.moveElementUp(th);
      });
      shortcut.register('down', function() {
        th.actions.moveElementDown(th);
      });
      shortcut.register('backspace', function() {
        th.actions.deleteElement(th);
      });
    }
  },
  dragDropFun: function() {

    var lB = this.$node

    var thisConnectedWith = $L(this.$node).find(".lyteListboxPanels")
    var childrenList = $L(this.$node).find('.lyteLBLeftChildWrap')

    var sortableObject = {
      multiSortable: true,
      cancel: ".lyteListBoxSearch,.lyteLBoxDisabledParent,.lyteListBoxRequiredParent,.lyteLBDisabledElement .lyteListBoxLeftWrap .lyteListBoxNoResultsFound",
      onSelect: function(cElem, fInd, src) {
        if (($L(cElem).find('.lyteLBLeftActive').length > 0) || ($L(cElem).find('.lyteLBRightActive').length > 0)) {
          return true
        }
        return false

      }.bind(this),
      helper: function(ele) {


        var th = $L(ele).closest('lyte-dual-listbox')[0];


        var element = document.createElement("DIV");
        element.setAttribute('class', 'lyteLBDragElement')

        var allActive
        var currentActive

        var activeString

        if ($L(ele).hasClass('lyteListBoxRightWrap')) {
          activeString = ".lyteLBRightActive"
          allActive = $L(th).find('.lyteLBRightActive')
          currentActive = $L(ele).find('.lyteLBRightActive')
        } else if ($L(ele).hasClass('lyteListBoxLeftWrap')) {
          activeString = ".lyteLBLeftActive"
          allActive = $L(th).find('.lyteLBLeftActive')
          currentActive = $L(ele).find('.lyteLBLeftActive')
        }

        if (currentActive.length > 0) {
          var index = allActive.indexOf(currentActive[0])
          var i = index
          if (allActive.length > 5) {
            var startInd = i - 2
            if (allActive.length / 2 > 0) {
              i += 1
            }
            var endInd = i + 2

            if (startInd < 0) {
              endInd = endInd + (-1 * startInd)
              startInd = 0
            }
            if (endInd > allActive.length - 1) {
              startInd = index - (endInd - (allActive.length - 2))
              endInd = allActive.length
            }

            for (var i = startInd; i <= index - 1; i++) {
              if ($L(th).find(activeString)[i]) {
                var e = $L(th).find(activeString)[i].cloneNode(true)
                $L(e).addClass('lyteLBdragClone')
                element.appendChild(e)
              }
            }
            var currentClone = currentActive[0].cloneNode(true)
            $L(currentClone).addClass('lyteLBdragClone')
            element.appendChild(currentClone)
            for (var i = index + 1; i < endInd; i++) {
              if ($L(th).find(activeString)[i]) {
                var e = $L(th).find(activeString)[i].cloneNode(true)
                $L(e).addClass('lyteLBdragClone')
                element.appendChild(e)
              }
            }


          } else {
            for (var i = 0; i <= index - 1; i++) {
              if ($L(th).find(activeString)[i]) {
                var e = $L(th).find(activeString)[i].cloneNode(true)
                $L(e).addClass('lyteLBdragClone')
                element.appendChild(e)
              }
            }
            var currentClone = currentActive[0].cloneNode(true)
            $L(currentClone).addClass('lyteLBdragClone')
            element.appendChild(currentClone)
            for (var i = index + 1; i < allActive.length; i++) {
              if ($L(th).find(activeString)[i]) {
                var e = $L(th).find(activeString)[i].cloneNode(true)
                $L(e).addClass('lyteLBdragClone')
                element.appendChild(e)
              }
            }
          }
        }

        if (event.detail !== 2) {
          return element
        }
      },
      onDragStart: function(draggableElement, source) {
        var th = $L(draggableElement).closest('lyte-dual-listbox')[0];
        var ind = 0
        if($L(th).find('.lyteLBLeftActive').length <= 0){
          ind = $L(th).find('.lyteLBRightActive').length - 5 - $L(th).find('.lyteLBdragClone').length
        } else {
          ind = $L(th).find('.lyteLBLeftActive').length - 5 - $L(th).find('.lyteLBdragClone').length
        }
        $L(th)[0].component.setData('moreLBElements', true)
        var element = $L(th).find('.lyteLBDragElement')[0]
        $L(th).find('.lyteListboxBadge')[0].component.setData('ltPropData', ind)
        var badge = $L(th).find('.lyteListboxBadge')[0].cloneNode(true);
        badge.style.display = "block";
        element.style.position = "relative";
        if (ind > 0) {
          element.appendChild(badge)
        }
      }.bind(this),
      onEnter: function(event, object) {
        var th = $L(object.sortable).closest('lyte-dual-listbox')[0]
        if (($L(object.sortable).hasClass('lyteListboxLeftPanel')) && (!$L(object.element._origin).hasClass('lyteListBoxLeftWrap'))) {
          if ($L(th).find('.lyteLBLeftPanelDropZone').length > 0) {
            $L(th).find('.lyteLBLeftPanelDropZone')[0].remove()
          }
          var leftPanelDropZone = document.createElement('DIV');
          var leftPanelDropZoneBorder = document.createElement('DIV');
          leftPanelDropZone.setAttribute('class', 'lyteLBLeftPanelDropZone')
          leftPanelDropZoneBorder.setAttribute('class', 'lyteLBLeftPanelDropZoneB')
          leftPanelDropZone.appendChild(leftPanelDropZoneBorder);
          object.sortable.appendChild(leftPanelDropZone)
          leftPanelDropZone.style.width = object.sortable.getBoundingClientRect().width + "px";
        } else {
          if ($L(th).find('.lyteLBLeftPanelDropZone').length > 0) {
            $L(th).find('.lyteLBLeftPanelDropZone')[0].remove()
          }
        }
      },
      onMultiSelectDrag: function(cElem, evt, placeholder, pParent) {
        cElem.style.top = (cElem.offsetTop - (cElem.getBoundingClientRect().height * $L(cElem).find('.lyteLBdragClone').length) / 2) + 'px';
      }.bind(this),
      onBeforeDrop: function(droppableElement, belowElement, placeholderElement, fromIndex, toIndex, source, destination) {
        $L(source).closest('lyte-dual-listbox')[0].component.executeMethod('onBeforeDrop', source, destination)
        var th = $L(droppableElement).closest('lyte-dual-listbox')[0];
        if ($L(th).find('.lyteLBLeftPanelDropZone').length > 0) {
          $L(th).find('.lyteLBLeftPanelDropZone')[0].remove()
        }
        var elementData;
        $L(source).hasClass('lyteListboxRightPanel')

        if (
          (($L(source).hasClass('lyteListboxLeftPanel')) || ($L(source).hasClass('lyteLBLeftChildWrap'))) &&
          ($L(destination).hasClass('lyteListboxRightPanel'))
        ) {
          th.component.setData('insertAtRightInd', toIndex)
          th.component.mERFN();
        }
        if (
          ($L(source).hasClass('lyteListboxRightPanel')) &&
          (($L(destination).hasClass('lyteListboxLeftPanel')) || ($L(destination).hasClass('lyteLBLeftChildWrap')))
        ) {
          th.component.setData('insertAtLeftInd', toIndex)
          th.component.mELFN();
        } else if ((source === destination) && ($L(source).hasClass('lyteListboxRightPanel'))) {
          th.component.setData('insertAtLeftInd', toIndex)
          $L(source).find('.lyteLBRightActive.lyteLBdragClone').removeClass('lyteLBRightActive')
          var actives = th.component.getActiveElements($L(th).find('.lyteLBRightActive'), 'ltPropRightData');
          th.component.sESPF($L(th).find('.lyteLBRightActive'), actives, 'ltPropRightData', toIndex, '.lyteRightLvl1');
        }
        $L(source).closest('lyte-dual-listbox')[0].component.executeMethod('onDrop', source, destination)
        if (th.component.getData('ltPropSortable')) {
          th.component.dragDropFun();
        }
        return false;
      }.bind(this)
    }

    $L(this.$node).find(".lyteListboxPanels", this.$node).sortable(Object.assign({
      connectedWith: Array.from(thisConnectedWith)
    }, sortableObject));
    var thisConnectedWithChild = []

    for (var i = 0; i < childrenList.length; i++) {
      thisConnectedWithChild = []
      thisConnectedWithChild.push(childrenList[i]);
      thisConnectedWithChild.push(thisConnectedWith[1]);
      $L(childrenList[i]).sortable(Object.assign({
        connectedWith: Array.from(thisConnectedWithChild)
      }, sortableObject));
    }


  },

  didConnect: function() {

    if ((this.getData('ltPropMaxCount') <= this.getData('ltPropRightData').length) && (this.getData('ltPropMaxCount') > -1)) {
      $L(this.$node).find('.lyteListboxLeftPanel').addClass('lyteLBDisabledElement')
    }

    if (this.getData('ltPropSortable')) {
      this.dragDropFun();
    }

    var toolbarItems = this.getData('ltPropToolbarItems')

    for (var i = 0; i < this.getData('ltPropToolbarItems').length; i++) {
      this.setData(toolbarItems[i], true);
    }

    this.setData('insertAtLeftInd', this.getData('ltPropLeftData').length)
    this.setData('insertAtRightInd', this.getData('ltPropRightData').length)

    var lB = $L(this)[0].$node;
    var leftPanel = $L(lB).find('.lyteListboxLeftPanel')[0];

  },
  methods: {
    onBeforeDrop: function() {},
    onDrop: function() {},
    onBeforeRight: function() {},
    onMoveRight: function() {},
    onBeforeLeft: function() {},
    onMoveLeft: function() {},
    onMoveElementUp: function() {},
    onMoveElementDown: function() {},
    onMoveAllRight: function() {},
    onMaxCountReached: function() {},
    onMoveAllLeft: function() {},
    onDeleteElement: function() {},
    onBeforeOpen: function() {},
    onBeforeClose: function() {},
    onOpen: function() {},
    onClose: function() {},
    onSearch : function(arr){
      if(arr.length === 0){
        console.log(this.setData('noResultsFound' , true));
      } else {
        console.log(this.setData('noResultsFound' , false));
      }
    }
  },
  indexCallback: function(x) {
    return parseInt(x)
  },

  moveElementInView: function(parent, elem) {
    var parentHeight = parent.getBoundingClientRect().height
    var elemTop = (elem.getBoundingClientRect().top - parent.getBoundingClientRect().top)
    var elemBottom = elemTop + elem.getBoundingClientRect().height

    if (elemBottom > parentHeight) {
      parent.scrollTo({
        top: (parent.scrollTop + (elemBottom - parentHeight)),
        behavior: "smooth"
      });
    }
    if (elemTop < 0) {
      parent.scrollTo({
        top: (parent.scrollTop + elemTop),
        behavior: "smooth"
      });
    }
  },

  actions: {

    addElementToRight: function(th) {
      var elem = $L(th).closest('.lyteListBoxLeftElement')
      this.selectionFunction(elem[0] , 'byBtn');
      this.mERFN();
      if (this.getData('ltPropSortable')) {
        this.dragDropFun();
      }
    },

    removeElementFromRight: function(th) {
      var elem = $L(th).closest('.lyteListBoxRightElement')
      this.selectionFunction(elem[0]);
      this.mELFN();
      if (this.getData('ltPropSortable')) {
        this.dragDropFun();
      }
    },

    collapseFunction: function(th, side) {
      event.stopPropagation();

      _this = this;
      var wrap
      var childWrap
      var elem
      var side

      if (side === 'left') {
        wrap = $L(th).closest('.lyteListBoxLeftWrap')
        childWrap = $L(wrap).find('.lyteLBLeftChildWrap')[0]
        elem = $L(wrap).find('.lyteListBoxLeftElement')
        side = 'left'
      } else {
        wrap = $L(th).closest('.lyteListBoxRightWrap')
        childWrap = $L(wrap).find('.lyteLBRightChildWrap')[0]
        elem = $L(wrap).find('.lyteListBoxRightElement')
        side = 'right'
      }

      var ind = parseInt(elem[0].getAttribute('index'))

      if (childWrap.getBoundingClientRect().height > 0) {

        if (side === "left") {
          _this.executeMethod('onBeforeClose', _this.getData('ltPropLeftData')[ind]);
        } else {
          _this.executeMethod('onBeforeClose', _this.getData('ltPropRightData')[ind]);
        }

        childWrap.style.height = childWrap.getBoundingClientRect().height + "px";

        setTimeout(function() {
          childWrap.style.height = "0px";

          if ($L(th.parentElement).hasClass('lyteListboxParentElementOpen')) {
            $L(th.parentElement).removeClass('lyteListboxParentElementOpen')
          }
          $L(th.parentElement).addClass('lyteListboxParentElementClose')

          if (side === "left") {
            _this.executeMethod('onClose', _this.getData('ltPropLeftData')[ind]);
          } else {
            _this.executeMethod('onClose', _this.getData('ltPropRightData')[ind]);
          }

        }, 10)

      } else {

        if ($L(th.parentElement).hasClass('lyteListboxParentElementClose')) {
          $L(th.parentElement).removeClass('lyteListboxParentElementClose')
        }
        $L(th.parentElement).addClass('lyteListboxParentElementOpen')

        if (side === "left") {
          _this.executeMethod('onBeforeOpen', _this.getData('ltPropLeftData')[ind]);
        } else {
          _this.executeMethod('onBeforeOpen', _this.getData('ltPropRightData')[ind]);
        }

        childWrap.style.height = "auto"
        var height = childWrap.getBoundingClientRect().height
        childWrap.style.height = "0px"

        setTimeout(function() {
          childWrap.style.height = height + "px"
          childWrap.addEventListener('transitionend', setHeight)
        }, 10)

        function setHeight() {
          childWrap.style.height = "auto"
          childWrap.removeEventListener('transitionend', setHeight)
          if (side === "left") {
            _this.executeMethod('onOpen', _this.getData('ltPropLeftData')[ind]);
          } else {
            _this.executeMethod('onOpen', _this.getData('ltPropRightData')[ind]);
          }
        }

      }

    },

    elementFN: function(th, ev) {
      this.selectionFunction(th);
    },

    moveElementRight: function(th, clickType) {
      if ((this.getData('ltPropDoubleClick')) || (clickType === 'toolbarClick')) {
        if ($L(th).hasClass('lyteListBoxRequiredItem')) {
          return
        }
        this.mERFN();
        if (this.getData('ltPropSortable')) {
          this.dragDropFun();
        }
      }
    },
    moveElementLeft: function(th, clickType) {
      if ((this.getData('ltPropDoubleClick')) || (clickType === 'toolbarClick')) {
        if ($L(th).hasClass('lyteListBoxRequiredItem')) {
          return
        }
        this.mELFN();
        if (this.getData('ltPropSortable')) {
          this.dragDropFun();
        }
      }
    },
    moveElementUp: function(th) {
      if (!th) {
        th = this;
      }


      var lB = th.$node;
      var activeElement;
      var elementArr;
      var index;

      var leftClickedElement = $L(lB).find('.lyteLBLeftMoveElement')[0];
      var rightClickedElement = $L(lB).find('.lyteLBRightMoveElement')[0];
      var leftEles
      var rightEles
      var index;
      var elementData
      var rightPanel = $L(lB).find('.lyteListboxRightPanel')[0]

      var lastActiveLeft = this.getData('selectedIndexLeft')[this.getData('selectedIndexLeft').length - 1]
      if (($L(lB).find('.lyteLBLeftActive.lyteLeftLvl1').length === 1) || ($L(lB).find('.lyteLBRightActive.lyteRightLvl1').length === 1)) {
        if (!(th.panelSide(leftClickedElement) === 'left')) {
          index = rightClickedElement.getAttribute("index").split(" ").map(this.indexCallback)
          if (index.length > 1) {
            if (index[1] > 0) {
              elementData = th.getData('ltPropRightData')[index[0]].childrenList[index[1]]
              Lyte.arrayUtils(th.getData('ltPropRightData')[index[0]].childrenList, 'removeAt', index[1], 1);
              Lyte.arrayUtils(th.getData('ltPropRightData')[index[0]].childrenList, 'insertAt', index[1] - 1, elementData);
              rightEles = $L(lB).find('.lyteRightLvl1')[index[0]].closest('.lyteListBoxRightWrap')
              var rightChildren = $L(rightEles).find('.lyteRightLvl2')
              $L(rightChildren[index[1] - 1]).addClass('lyteLBRightActive')
              $L(rightChildren[index[1] - 1]).addClass('lyteLBRightMoveElement')
            }
          } else {
            if (index[0] > 0) {
              elementData = th.getData('ltPropRightData')[index[0]];
              Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', index[0], 1);
              Lyte.arrayUtils(th.getData('ltPropRightData'), 'insertAt', index[0] - 1, elementData);
              rightEles = $L(lB).find('.lyteRightLvl1');
              $L(rightEles[index[0] - 1]).addClass('lyteLBRightActive')
              $L(rightEles[index[0] - 1]).addClass('lyteLBRightMoveElement')
              this.moveElementInView(rightPanel, $L(lB).find('.lyteLBRightActive')[0])
            }
          }
        }
      }

      th.executeMethod('onMoveElementUp', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), elementData)

      if (th.getData('ltPropSortable')) {
        th.dragDropFun();
      }
    },
    moveElementDown: function(th) {
      if (!th) {
        th = this;
      }
      var lB = th.$node;
      var activeElement;
      var elementArr;
      var index;
      var leftClickedElement = $L(lB).find('.lyteLBLeftMoveElement')[0];
      var rightClickedElement = $L(lB).find('.lyteLBRightMoveElement')[0];
      var leftEles
      var rightEles
      var index;
      var elementData
      var lastActiveLeft = this.getData('selectedIndexLeft')[this.getData('selectedIndexLeft').length - 1]
      var rightPanel = $L(lB).find('.lyteListboxRightPanel')[0]

      if (($L(lB).find('.lyteLBLeftActive.lyteLeftLvl1').length === 1) || ($L(lB).find('.lyteLBRightActive.lyteRightLvl1').length === 1)) {

        if (!(th.panelSide(leftClickedElement) === 'left')) {
          index = rightClickedElement.getAttribute("index").split(" ").map(this.indexCallback)
          if (index.length > 1) {
            rightEles = $L(lB).find('.lyteRightLvl1')[index[0]].closest('.lyteListBoxRightWrap')
            var rightChildren = $L(rightEles).find('.lyteRightLvl2')
            if (index[1] < rightChildren.length - 1) {
              elementData = th.getData('ltPropRightData')[index[0]].childrenList[index[1]]
              Lyte.arrayUtils(th.getData('ltPropRightData')[index[0]].childrenList, 'removeAt', index[1], 1);
              Lyte.arrayUtils(th.getData('ltPropRightData')[index[0]].childrenList, 'insertAt', index[1] + 1, elementData);
              rightEles = $L(lB).find('.lyteRightLvl1')[index[0]].closest('.lyteListBoxRightWrap')
              rightChildren = $L(rightEles).find('.lyteRightLvl2')
              $L(rightChildren[index[1] + 1]).addClass('lyteLBRightActive')
              $L(rightChildren[index[1] + 1]).addClass('lyteLBRightMoveElement')
            }
          } else {
            rightEles = $L(lB).find('.lyteRightLvl1');
            if (index[0] < rightEles.length - 1) {
              elementData = th.getData('ltPropRightData')[index[0]];
              Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', index[0], 1);
              Lyte.arrayUtils(th.getData('ltPropRightData'), 'insertAt', index[0] + 1, elementData);
              rightEles = $L(lB).find('.lyteRightLvl1');
              $L(rightEles[index[0] + 1]).addClass('lyteLBRightActive')
              $L(rightEles[index[0] + 1]).addClass('lyteLBRightMoveElement')
              this.moveElementInView(rightPanel, $L(lB).find('.lyteLBRightActive')[0])
            }
          }
        }


      }

      th.executeMethod('onMoveElementDown', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), elementData)

      if (th.getData('ltPropSortable')) {
        th.dragDropFun();
      }
    },
    moveAllElementsRight: function(th) {
      var lB = this.$node;
      $L(lB).find('.lyteListBoxLeftElement').addClass('lyteLBLeftActive');
      this.mERFN();
    },
    moveAllElementsLeft: function(th) {
      if (!th) {
        th = this;
      }
      if (th.getData('ltPropRightData').length > 0) {
        var rightData = th.getData('ltPropRightData');
        Lyte.arrayUtils(th.getData('ltPropLeftData'), 'push', th.getData('ltPropRightData'));
        th.setData('ltPropRightData', [])
      }
      th.executeMethod('onMoveAllLeft');
      if (th.getData('ltPropSortable')) {
        th.dragDropFun();
      }
    },
    deleteElement: function(th) {
      if (!th) {
        th = this;
      }
      var lB = th.$node;
      if ($L(lB).find('.lyteLBLeftActive')[0]) {
        var leftElements = $L(lB).find('.lyteListBoxLeftElement');
        var activeElement = $L(lB).find('.lyteLBLeftActive')

        for (var i = 0; i < activeElement.length; i++) {
          var elementData
          index = activeElement[i].getAttribute('index').split(' ').map(this.indexCallback);
          if ((index.length > 1) || ($L(activeElement[i]).hasClass('lyteListBoxLeftParentElement'))) {
            var childWrap = $L(activeElement[i]).closest('.lyteListBoxLeftWrap').find('.lyteLBLeftChildWrap')
            if (($L(activeElement[i]).hasClass('lyteListBoxLeftParentElement')) && (($L(childWrap[0]).find('.lyteLeftLvl2').length < 1) || ($L(childWrap[0]).find('.lyteLBLeftActive').length === $L(childWrap[0]).find('.lyteLeftLvl2').length))) {
              i += $L(childWrap[0]).find('.lyteLBLeftActive').length
              elementData = th.getData('ltPropLeftData')[index[0]];
              Lyte.arrayUtils(th.getData('ltPropLeftData'), 'removeAt', index[0], 1);
            }
            if (index.length > 1) {
              elementData = th.getData('ltPropLeftData')[index[0]].childrenList[index[1]];
              Lyte.arrayUtils(th.getData('ltPropLeftData')[index[0]].childrenList, 'removeAt', index[1], 1);
            }
          } else {
            elementData = th.getData('ltPropLeftData')[index[0]];
            Lyte.arrayUtils(th.getData('ltPropLeftData'), 'removeAt', index[0], 1);
          }
        }

      } else if ($L(lB).find('.lyteLBRightActive')[0]) {
        var rightElements = $L(lB).find('.lyteListBoxRightElement');
        var activeElement = $L(lB).find('.lyteLBRightActive');
        for (var i = 0; i < activeElement.length; i++) {
          var elementData
          index = activeElement[i].getAttribute('index').split(' ').map(this.indexCallback);
          if ((index.length > 1) || ($L(activeElement[i]).hasClass('lyteListBoxRightParentElement'))) {
            var childWrap = $L(activeElement[i]).closest('.lyteListBoxRightWrap').find('.lyteLBRightChildWrap')
            if (($L(activeElement[i]).hasClass('lyteListBoxRightParentElement')) && (($L(childWrap[0]).find('.lyteRightLvl2').length < 1) || ($L(childWrap[0]).find('.lyteLBRightActive').length === $L(childWrap[0]).find('.lyteRightLvl2').length))) {
              i += $L(childWrap[0]).find('.lyteLBRightActive').length
              elementData = th.getData('ltPropRightData')[index[0]];
              Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', index[0], 1);
            }
            if (index.length > 1) {
              elementData = th.getData('ltPropRightData')[index[0]].childrenList[index[1]];
              Lyte.arrayUtils(th.getData('ltPropRightData')[index[0]].childrenList, 'removeAt', index[1], 1);
            }
          } else {
            elementData = th.getData('ltPropRightData')[index[0]];
            Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', index[0], 1);
          }

        }
      }


      th.executeMethod('onDeleteElement');


      if (th.getData('ltPropSortable')) {
        th.dragDropFun();
      }
    }
  },


  selectionFunction: function(th , by) {

    var clickedEle = th;
    var lB = this.$node
    event.stopPropagation();
    var self = this

    if(by === 'byBtn'){
      if ($L(clickedEle).hasClass('lyteListBoxLeftParentElement')) {
        $L(clickedEle.parentElement).find('.lyteLeftLvl2').addClass('lyteLBLeftActive')
        return
      }
    }

    var leftEles = $L(lB).find('.lyteListBoxLeftElement').toArray()
    var rightEles = $L(lB).find('.lyteListBoxRightElement').toArray()
    var leftPanel = $L(lB).find('.lyteListboxLeftPanel')[0];
    var rightPanel = $L(lB).find('.lyteListboxRightPanel')[0];
    var wrap = clickedEle.parentElement

    var selectAllChild = this.getData('ltPropSelectAllChild')

    var lastActiveLeft = leftEles[this.getData('selectedIndexLeft')[this.getData('selectedIndexLeft').length - 1]]
    var lastActiveRight = rightEles[this.getData('selectedIndexRight')[this.getData('selectedIndexRight').length - 1]]

    var notDisabled = (clickedEle.getAttribute("index").split(" ").map(this.indexCallback))
    // notDisabled = notDisabled[notDisabled.length-1]

    var isCurrentElementDisabled = false;

    if ($L(clickedEle).hasClass('lyteListBoxRightElement')) {
      if (notDisabled.length > 1) {
        isCurrentElementDisabled = this.getData('ltPropRightData')[notDisabled[0]].childrenList[notDisabled[1]].required
      } else {
        isCurrentElementDisabled = this.getData('ltPropRightData')[notDisabled[0]].required
      }
    } else {
      if (notDisabled.length > 1) {
        isCurrentElementDisabled = this.getData('ltPropLeftData')[notDisabled[0]].childrenList[notDisabled[1]].required
      } else {
        isCurrentElementDisabled = this.getData('ltPropLeftData')[notDisabled[0]].required
      }
    }

    if (
      ($L(clickedEle).closest('.lyteListboxLeftPanel').hasClass('lyteLBoxDisabledParent')) ||
      ($L(clickedEle).closest('.lyteListboxLeftPanel').hasClass('lyteLBDisabledElement')) ||
      ($L(clickedEle).hasClass('lyteLBoxDisabledParent'))
    ) {
      isCurrentElementDisabled = true
    }

    if ((event.shiftKey) && (lastActiveLeft || lastActiveRight)) {

      /*

      * Shift key down and select elements

      */

      var initialElement,initialWrap,initialParentWrap,initialChildren
      var previousElement,previousWrap,previousParentWrap,previousChildren
      var currentElement,currentWrap,currentParentWrap,currentChildren
      var atrStr
      var nextPrevCheck
      var newSelection = true

      function setUpLeftElems(){
        atrStr = "'" + self.getData('leftShiftSelectIndex') + "'";

        initialElement = lastActiveLeft
        initialWrap = $L(initialElement).closest('.lyteListBoxLeftWrap');
        initialParentWrap = $L(initialWrap).closest('.lyteLBLeftChildWrap').closest('.lyteListBoxLeftWrap')
        initialChildren = initialParentWrap.find('.lyteListBoxLeftWrap')

        previousElement = $L(lB).find('.lyteListboxLeftPanel').find("[index*=" + atrStr + "]")[0]
        if(!previousElement){
          previousElement = initialElement
          newSelection = true
        } else {
          newSelection = false
        }
        previousWrap = $L(previousElement).closest('.lyteListBoxLeftWrap');
        if (!previousWrap[0]) {
          previousWrap = initialWrap;
        }
        previousParentWrap = $L(previousWrap).closest('.lyteLBLeftChildWrap').closest('.lyteListBoxLeftWrap')
        previousChildren = previousParentWrap.find('.lyteListBoxLeftWrap')

        currentElement = clickedEle
        currentWrap = $L(currentElement).closest('.lyteListBoxLeftWrap');
        currentParentWrap = $L(currentWrap).closest('.lyteLBLeftChildWrap').closest('.lyteListBoxLeftWrap')
        currentChildren = currentParentWrap.find('.lyteListBoxLeftWrap')

        if($L(currentElement).hasClass('lyteListBoxLeftParentElement')){
          currentChildren = currentWrap.find('.lyteListBoxLeftWrap')
        }
      }

      if (this.panelSide(clickedEle) === "left") {

          setUpLeftElems()

      } else {
        atrStr = "'" + this.getData('rightShiftSelectIndex') + "'";
        previousElement = $L(lB).find('.lyteListboxRightPanel').find("[index*=" + atrStr + "]")[0]
        previousWrap = $L(previousElement).closest('.lyteListBoxRightWrap');
        currentWrap = $L(clickedEle).closest('.lyteListBoxRightWrap');
        initialWrap = $L(lastActiveRight).closest('.lyteListBoxRightWrap');
        wrapArray = $L(lB).find('.lyteListBoxRightWrap')
        if(!previousElement){
          previousWrap = initialWrap
          previousElement = lastActiveRight
        }
      }

      /*

      To get indexes ===================================================================

      */

      function getClickedElemLevel(){
        if($L(clickedEle).hasClass('lyteLeftLvl1')){
          return 'lvl1'
        } else {
          return 'lvl2'
        }
      }

      function getPrevElemLevel(){
        if (!previousElement) {
          previousElement = $L(previousWrap).find('.lyteListBoxLeftElement')[0]
        }
        if($L(previousElement).hasClass('lyteLeftLvl1')){
          return 'lvl1'
        } else {
          return 'lvl2'
        }
      }

      function getPrevElemType(){
        if (!previousElement) {
          previousElement = $L(previousWrap).find('.lyteListBoxLeftElement')[0]
        }
        if($L(previousElement).hasClass('lyteListBoxLeftParentElement')){
          return 'parent'
        }
        return
      }

      function getClickedElemType(){
        if($L(clickedEle).hasClass('lyteListBoxLeftParentElement')){
          return 'parent'
        }
        return
      }

      function getIniParInd(){
        var iniEL = $L(initialWrap).find('.lyteListBoxLeftElement')[0]
        return parseInt($L(iniEL).attr('index').split(" ")[0]);
      }

      function getIniChildInd(){
        var iniEL = $L(initialWrap).find('.lyteListBoxLeftElement')[0]
        return parseInt($L(iniEL).attr('index').split(" ")[1]);
      }

      function getPreParInd() {
        if (!previousElement) {
          previousElement = $L(previousWrap).find('.lyteListBoxLeftElement')[0]
        }
        return parseInt($L(previousElement).attr('index').split(" ")[0]);
      }

      function getCurParInd() {
        return parseInt($L(clickedEle).attr('index').split(" ")[0]);
      }

      function getPreChildInd() {
        if (!previousElement) {
          previousElement = $L(previousWrap).find('.lyteListBoxLeftElement')[0]
        }
        if(!$L(previousElement).attr('index').split(" ")[1]){
          return 0
        }
        return parseInt($L(previousElement).attr('index').split(" ")[1]);
      }

      function getCurChildInd() {
        if (!clickedEle) {
          clickedEle = $L(currentWrap).find('.lyteListBoxLeftElement')[0]
        }
        if(!$L(clickedEle).attr('index').split(" ")[1]){
          return 0
        }
        return parseInt($L(clickedEle).attr('index').split(" ")[1]);
      }

      function getCurLastIndex(){
        if(!currentChildren.length){
          return currentWrap.find('.lyteLeftLvl2Wrap').length-1
        }
        return currentChildren.length-1
      }

      function getPreLastIndex(){
        if(!previousChildren.length){
          return previousWrap.find('.lyteLeftLvl2Wrap').length-1
        }
        return previousChildren.length-1
      }

      /*

      To get indexes ends ===================================================================

      */

      if(clickedEle.getAttribute('index') === previousElement.getAttribute('index')){
        return
      }

      if ($L(clickedEle).hasClass('lyteListBoxLeftElement') && !(clickedEle === lastActiveLeft)) {

        // $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
        $L(lB).find('.leftShiftElement').find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')

        if(getIniParInd() < getCurParInd()){
          /*

          Selection from top to bottom

          */

          if((getIniParInd() > getPreParInd()) && (getCurParInd() > getIniParInd()) ||
             (getIniChildInd() > getPreChildInd()) && (getCurParInd() > getIniParInd())
            ){
            $L(lB).find('.leftShiftElement').removeClass('leftShiftElement')
            previousElement = initialElement
            previousWrap  = initialWrap
            previousParentWrap  = initialParentWrap
            previousChildren  = initialChildren
          }

          if(getPreParInd() < getCurParInd()){
            // console.log('add top to bottom');
            $L(previousWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
            if(getClickedElemLevel() === 'lvl1'){
              if(getPrevElemLevel() === 'lvl2'){
                $L(previousParentWrap).nextUntil(currentWrap).addClass('leftShiftElement')
                $L(previousParentWrap).nextUntil(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
                $L(currentWrap).addClass('leftShiftElement')
              } else {
                $L(previousParentWrap).nextUntil(currentWrap,'',true).addClass('leftShiftElement')
              }
              $L(previousWrap).nextUntil(currentWrap,'',true).addClass('leftShiftElement')
              if((getClickedElemType() === 'parent')){
                $L(previousWrap).nextUntil(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              } else {
                $L(previousWrap).nextUntil(currentWrap,'',true).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              }
            } else {
              $L(previousWrap).nextUntil(currentParentWrap,'',true).addClass('leftShiftElement')
              $L(previousWrap).nextUntil(currentParentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              if(getPrevElemLevel() === 'lvl2'){
                $L(previousParentWrap).nextUntil(currentParentWrap).addClass('leftShiftElement')
                $L(currentParentWrap).addClass('leftShiftElement')
              } else {
                $L(previousParentWrap).nextUntil(currentParentWrap,'',true).addClass('leftShiftElement')
              }
              if(getCurChildInd() === 0){
                $L(currentChildren[0]).addClass('leftShiftElement')
              } else {
                $L(currentChildren[0]).nextUntil(currentChildren[getCurChildInd()],'',true).addClass('leftShiftElement')
              }
            }
          } else if(getPreParInd() > getCurParInd()){
            // console.log('remove' , getClickedElemType());
            if(getClickedElemLevel() === 'lvl1'){
              // console.log('remove parent');
              $L(previousWrap).prevUntil(currentWrap,'',true).removeClass('leftShiftElement')
              $L(previousParentWrap).prevUntil(currentWrap,'',true).removeClass('leftShiftElement')
              $L(previousWrap).prevUntil(currentWrap,'',true).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              $L(previousParentWrap).prevUntil(currentWrap,'',true).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
            } else {
              // console.log('remove child 1');
              $L(previousWrap).prevUntil(currentParentWrap,'',true).removeClass('leftShiftElement')
              $L(previousWrap).prevUntil(currentParentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              $L(previousParentWrap).prevUntil(currentParentWrap,'',true).removeClass('leftShiftElement')
              if(getCurLastIndex() === getCurChildInd()){
                $L(currentChildren[0]).addClass('leftShiftElement')
              } else {
                $L(currentChildren[getCurLastIndex()]).prevUntil(currentChildren[getCurChildInd()],'',true).removeClass('leftShiftElement')
              }
              $L(currentParentWrap).addClass('leftShiftElement')
            }
            $L(currentWrap).addClass('leftShiftElement')
          } else if(getPreParInd() === getCurParInd()){
            if(getPreChildInd() <= getCurChildInd()){
              // console.log('add child');
              if(getCurChildInd() <= 0){
                $L(currentChildren[0]).addClass('leftShiftElement')
              } else {
                $L(currentChildren[getPreChildInd()]).nextUntil(currentChildren[getCurChildInd()],'',true).addClass('leftShiftElement')
              }
            } else {
              // console.log('remove child');
              $L(previousWrap).prevUntil(currentWrap,'',true).removeClass('leftShiftElement')
              $L(currentWrap).addClass('leftShiftElement')
            }
          }


          /*

          Selection from top to bottom ends

          */


        } else if(getIniParInd() > getCurParInd()){
          /*

          Selection from bottom to top

          */
          // console.log('bottom to top');

          if((getIniParInd() < getPreParInd()) && (getCurParInd() < getIniParInd()) ||
             (getIniChildInd() < getPreChildInd()) && (getCurParInd() < getIniParInd())
            ){
            $L(lB).find('.leftShiftElement').removeClass('leftShiftElement')
            previousElement = initialElement
            previousWrap  = initialWrap
            previousParentWrap  = initialParentWrap
            previousChildren  = initialChildren
          }

          if(getPreParInd() > getCurParInd()){

            // console.log('add bottom to top');
            if(getClickedElemLevel() === 'lvl1'){
              $L(previousWrap).prevUntil(currentWrap,'',true).addClass('leftShiftElement')
              if(getPrevElemType() === 'parent'){
                $L(previousWrap).prevUntil(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              } else {
                $L(previousParentWrap).prevUntil(currentWrap,'',true).addClass('leftShiftElement')
                $L(previousWrap).prevUntil(currentWrap,'',true).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
                $L(previousParentWrap).prevUntil(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              }
              if(getPreChildInd()!==0){
                $L(previousParentWrap).prevUntil(currentWrap,'',true).addClass('leftShiftElement')
                $L(previousParentWrap).prevUntil(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              }
              $L(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              $L(previousParentWrap).addClass('leftShiftElement')

            } else {
              $L(previousParentWrap).addClass('leftShiftElement')
              $L(previousParentWrap).prevUntil(currentParentWrap).addClass('leftShiftElement')
              $L(previousWrap).prevUntil(currentParentWrap).addClass('leftShiftElement')
              $L(previousWrap).prevUntil(currentParentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              if(getCurChildInd() !== 0){
                $L(previousParentWrap).prevUntil(currentParentWrap).addClass('leftShiftElement')
              } else {
                $L(previousParentWrap).addClass('leftShiftElement')
              }
              $L(previousChildren[getPreChildInd()]).prevUntil(previousChildren[0],'',true).addClass('leftShiftElement')
              if(getCurChildInd() === getCurLastIndex()){
                $L(currentChildren[getCurLastIndex()]).addClass('leftShiftElement')
              } else {
                $L(currentChildren[getCurLastIndex()]).prevUntil(currentChildren[getCurChildInd()],'',true).addClass('leftShiftElement')
              }
            }


          } else if(getPreParInd() < getCurParInd()){

            // console.log('remove bottom to top');

            if(getClickedElemLevel() === 'lvl1'){
              $L(previousWrap).nextUntil(currentWrap).removeClass('leftShiftElement')
              $L(previousParentWrap).nextUntil(currentWrap).removeClass('leftShiftElement')
              if(getClickedElemType() === 'parent'){
                $L(previousWrap).nextUntil(currentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
                $L(previousWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
                $L(previousWrap).removeClass('leftShiftElement')
              } else {
                $L(previousWrap).nextUntil(currentWrap,'',true).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              }
              $L(previousWrap).removeClass('leftShiftElement')
            } else {
              if(getPrevElemLevel() === 'lvl2'){
                $L(previousParentWrap).nextUntil(currentParentWrap,'',true).removeClass('leftShiftElement')
                $L(previousParentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              } else {
                $L(previousWrap).nextUntil(currentParentWrap,'',true).removeClass('leftShiftElement')
                $L(previousWrap).nextUntil(currentParentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
                $L(previousWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              }
              if(getCurChildInd()===0){
                $L(currentChildren[0]).removeClass('leftShiftElement')
              } else {
                $L(currentChildren[0]).nextUntil(currentChildren[getCurChildInd()],'',true).removeClass('leftShiftElement')
              }
            }
            $L(currentWrap).addClass('leftShiftElement')

          } else if(getPreParInd() === getCurParInd()){

            // console.log('bottom to top same parent');

            if((getPreChildInd() > getCurChildInd()) || (getClickedElemType() === 'parent')){

              // console.log('add child bottom to top');
              $L(currentChildren[getCurLastIndex()]).prevUntil(currentChildren[getCurChildInd()],'',true).addClass('leftShiftElement')
              if(getPreParInd() === getCurParInd()){
                $L(currentWrap).find('.lyteLeftLvl2Wrap').addClass('leftShiftElement')
              }

            } else {

              // console.log('remove child bottom to top');
              if(getPrevElemType() === 'parent'){
                $L(previousWrap).removeClass('leftShiftElement')
                if(getCurChildInd()!==0){
                  $L(currentChildren[getPreChildInd()]).nextUntil(currentChildren[getCurChildInd()] , '' , true).removeClass('leftShiftElement')
                }
              } else {
                $L(previousWrap).nextUntil(currentWrap,'',true).removeClass('leftShiftElement')
              }

            }
            $L(currentWrap).addClass('leftShiftElement')

          }


          /*

          Selection from bottom to top ends

          */


        } else if(getIniParInd() === getCurParInd()){
          // console.log('same parent');
          /*

          Selection within the same parent and child

          */

          if(getCurChildInd() < getIniChildInd()){
            if((getIniChildInd() < getPreChildInd()) && (getCurChildInd() < getIniChildInd()) ||
               (getIniChildInd() > getCurChildInd()) && (getCurParInd()<getPreParInd())
              ){
              $L(lB).find('.leftShiftElement').removeClass('leftShiftElement')
              previousElement = initialElement
              previousWrap  = initialWrap
              previousParentWrap  = initialParentWrap
              previousChildren  = initialChildren
            }
            // console.log('bottom to top in same parent');

            if(((getPreChildInd() > getCurChildInd()) || (getClickedElemType() === 'parent')) && (getPreParInd() === getCurParInd())){
              // console.log('add bottom to top same parent');
              if(getClickedElemType() === 'parent'){
                $L(currentWrap).addClass('leftShiftElement');
                $L(currentChildren[getPreChildInd()]).prevUntil(currentChildren[0] , '' , true).addClass('leftShiftElement')
              } else {
                $L(currentChildren[getPreChildInd()]).prevUntil(currentChildren[getCurChildInd()] , '' , true).addClass('leftShiftElement')
              }
            } else {
              // console.log('remove bottom to top same parent');
              if(getPreParInd() === getCurParInd()){
                  $L(currentChildren[getPreChildInd()]).nextUntil(currentChildren[getCurChildInd()] , '' , true).removeClass('leftShiftElement')
                  $L(currentParentWrap).removeClass('leftShiftElement')
              } else {
                $L(previousWrap).nextUntil(currentWrap,'',true).removeClass('leftShiftElement')
                $L(previousWrap).nextUntil(currentParentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
                $L(previousParentWrap).nextUntil(currentParentWrap,'',true).removeClass('leftShiftElement')
                if(getPrevElemType() === 'parent'){
                  $L(previousWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
                }
                if(getCurChildInd() === 0){
                  $L(currentChildren[getCurChildInd()]).removeClass('leftShiftElement')
                } else {
                  $L(currentChildren[0]).nextUntil(currentChildren[getCurChildInd()] , '' , true).removeClass('leftShiftElement')
                }
              }
              $L(currentWrap).addClass('leftShiftElement')
            }

          } else {
            // console.log('top to bottom in same parent');

            if((getIniChildInd() > getPreChildInd()) && (getCurChildInd() > getIniChildInd())){
              $L(lB).find('.leftShiftElement').removeClass('leftShiftElement')
              previousElement = initialElement
              previousWrap  = initialWrap
              previousParentWrap  = initialParentWrap
              previousChildren  = initialChildren
            }

            if(((getPreChildInd() < getCurChildInd()) || (getClickedElemType() === 'parent')) && (getPreParInd() === getCurParInd())){

              // console.log('add top to bottom in same parent');

              $L(currentChildren[getPreChildInd()]).nextUntil(currentChildren[getCurChildInd()] , '' , true).addClass('leftShiftElement')

            } else {

              // console.log('remove top to bottom in same parent');

              $L(previousWrap).prevUntil(currentWrap,'',true).removeClass('leftShiftElement')
              $L(previousWrap).prevUntil(currentParentWrap).find('.lyteLeftLvl2Wrap.leftShiftElement').removeClass('leftShiftElement')
              $L(previousParentWrap).prevUntil(currentParentWrap,'',true).removeClass('leftShiftElement')

              if(getPreParInd() === getCurParInd()){
                $L(currentChildren[getPreChildInd()]).prevUntil(currentChildren[getCurChildInd()] , '' , true).removeClass('leftShiftElement')
              } else {
                if(getCurChildInd() === getCurLastIndex()){
                  $L(currentChildren[getCurLastIndex()]).addClass('leftShiftElement')
                } else {
                  $L(currentChildren[getCurLastIndex()]).prevUntil(currentChildren[getCurChildInd()] , '' , true).removeClass('leftShiftElement')
                }
              }


              $L(currentWrap).addClass('leftShiftElement')
            }

          }

          /*

          Selection within the same parent and child ends

          */

        }

        $L(lB).find('.lyteListBoxRequiredParent').removeClass('leftShiftElement')
				$L(lB).find('.leftShiftElement').children('.lyteListBoxLeftElement').addClass('lyteLBLeftActive')

				this.setData('leftShiftSelectIndex' , $L(clickedEle)[0].getAttribute('index'));

      } else if ($L(clickedEle).hasClass('lyteListBoxRightElement') && !(clickedEle === lastActiveRight)) {

        if ($L(lB).find('.lyteLBLeftActive').length > 0) {
          $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
        }

        if (!isCurrentElementDisabled) {

          var lastActiveRightInd
          if (!(lastActiveRight.getAttribute('index').split(" ").length > 1)) {
            lastActiveRightInd = rightEles.indexOf(lastActiveRight)
          }
          lastActiveRight = rightEles[lastActiveRightInd]
          prevWrap = $L(lastActiveRight).closest('.lyteListBoxRightWrap');
          nextPrevCheck = parseInt(clickedEle.getAttribute('index')) < parseInt(lastActiveRight.getAttribute('index'))

          if (nextPrevCheck) {
            $L(previousWrap).prevUntil(prevWrap,"",true).removeClass('rightShiftElement')
            $L(previousWrap).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            if (
              (wrapArray.indexOf(currentWrap[0]) > wrapArray.indexOf(previousWrap[0])) &&
              (wrapArray.indexOf(previousWrap[0]) < wrapArray.indexOf(prevWrap[0]))
            ) {
              $L(currentWrap).prevUntil(previousWrap,"",true).removeClass('rightShiftElement')
              $L(currentWrap).prevUntil(previousWrap,"",true).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            }
            $L(previousWrap).prevUntil(prevWrap,"",true).removeClass('rightShiftElement')
            $L(previousWrap).prevUntil(prevWrap,"",true).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            $L(prevWrap).prevUntil(currentWrap, '.lyteListBoxRightWrap',true).addClass('rightShiftElement')
          } else {
            $L(previousWrap).nextUntil(prevWrap,"",true).removeClass('rightShiftElement')
            $L(previousWrap).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            if (
              (wrapArray.indexOf(currentWrap[0]) < wrapArray.indexOf(previousWrap[0])) &&
              (wrapArray.indexOf(previousWrap[0]) > wrapArray.indexOf(prevWrap[0]))
            ) {
              $L(currentWrap).nextUntil(previousWrap,"",true).removeClass('rightShiftElement')
              $L(currentWrap).nextUntil(previousWrap,"",true).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            }
            $L(previousWrap).nextUntil(prevWrap,"",true).removeClass('rightShiftElement')
            $L(previousWrap).nextUntil(prevWrap,"",true).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            $L(prevWrap).nextUntil(currentWrap, '.lyteListBoxRightWrap',true).addClass('rightShiftElement')
          }

          $L(lB).find('.lyteListBoxRequiredParent').removeClass('rightShiftElement')
          $L(lB).find('.rightShiftElement').children('.lyteListBoxRightElement').addClass('lyteLBRightActive')

          this.setData('rightShiftSelectIndex', $L(clickedEle)[0].getAttribute('index'));

        }
      }


    } else if ($L(clickedEle).hasClass('lyteListBoxLeftElement') || $L(clickedEle).hasClass('lyteListBoxRightElement')) {

      if (event.metaKey || event.ctrlKey) {

        /*

        * CTRL/CMD key down and select elements

        */


        if (this.panelSide(clickedEle) === "left") {
          if ($L(lB).find('.lyteLBRightActive').length > 0) {
            $L(lB).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
          }


          if (!isCurrentElementDisabled) {

            if ($L(clickedEle).hasClass('lyteListBoxLeftElement') && !$L(clickedEle).hasClass('lyteLBLeftActive')) {

              this.setData('leftShiftSelectIndex', '')
              var cwrap = clickedEle.parentElement
              cwrap = $L(cwrap).find('.lyteListBoxLeftWrap');
              if (cwrap.length > 1) {
                $L(cwrap).find('.lyteListBoxLeftElement').addClass('lyteLBLeftActive')
              }

              $L(clickedEle).addClass('lyteLBLeftActive')
              Lyte.arrayUtils(this.getData('selectedIndexLeft'), 'push', leftEles.indexOf(clickedEle))
              this.setData('leftShiftSelectIndex', '')
              $L(clickedEle).data('elementData', this.getData('ltPropLeftData')[leftEles.indexOf(clickedEle)]);

            } else {

              if (wrap.length > 1) {
                $L(wrap).find('.lyteListBoxLeftElement').removeClass('lyteLBLeftActive')
              }
              $L(clickedEle).removeClass('lyteLBLeftActive')
              Lyte.arrayUtils(this.getData('selectedIndexLeft'), 'removeAt', $L(clickedEle).data().selectOrder - 1, 1)
              $L(clickedEle).data()
            }
          }

        } else {
          if ($L(lB).find('.lyteLBLeftActive').length > 0) {
            $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
          }
          if ((!(this.getData('ltPropRightData')[notDisabled].required))) {

            if ($L(clickedEle).hasClass('lyteListBoxRightElement') && !$L(clickedEle).hasClass('lyteLBRightActive')) {

              this.setData('rightShiftSelectIndex', $L(clickedEle)[0].getAttribute('index'));
              var cwrap = $L(clickedEle).closest('.lyteListBoxRightWrap')[0]
              cwrap = $L(cwrap).find('.lyteListBoxRightWrap');
              if (cwrap.length > 1) {
                $L(cwrap).find('.lyteListBoxRightElement').addClass('lyteLBRightActive')
              }

              // $L(clickedEle).closest('.lyteListBoxRightWrap').addClass('rightShiftElement')

              $L(clickedEle).addClass('lyteLBRightActive')
              Lyte.arrayUtils(this.getData('selectedIndexRight'), 'push', rightEles.indexOf(clickedEle))
              this.setData('rightShiftSelectIndex', rightEles.indexOf(clickedEle) - 1)
              $L(clickedEle).data('elementData', this.getData('ltPropRightData')[rightEles.indexOf(clickedEle)]);

            } else {

              if (wrap.length > 1) {
                $L(wrap).find('.lyteListBoxRightElement').removeClass('lyteLBRightActive')
              }

              $L(clickedEle).removeClass('lyteLBRightActive')
              Lyte.arrayUtils(this.getData('selectedIndexRight'), 'removeAt', $L(clickedEle).data().selectOrder - 1, 1)
              $L(clickedEle).data()
            }

          }
        }





      } else {


        /*

        * Normal mouse clicks

        */

        if (this.panelSide(clickedEle) === "left") {
          if ($L(lB).find('.lyteLBRightActive').length > 0) {
            $L(lB).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
          }
          if ($L(lB).find('.leftShiftElement').length > 0) {
            $L(lB).find('.leftShiftElement').removeClass('leftShiftElement')
          }

          if (!isCurrentElementDisabled) {
            $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
            $L(lB).find('.lyteLBLeftMoveElement').removeClass('lyteLBLeftMoveElement')
            this.setData('selectedIndexLeft', [])


            if (!$L(clickedEle).hasClass('lyteLBLeftActive')) {

              this.setData('leftShiftSelectIndex', "");

              if ($L(clickedEle).hasClass('lyteListBoxLeftElement')) {

                if (clickedEle.getAttribute('index').split(" ").length > 1) {

                  $L(clickedEle).addClass('lyteLBLeftActive');
                  $L(clickedEle).addClass('lyteLBLeftMoveElement');

                  Lyte.arrayUtils(this.getData('selectedIndexLeft'), 'push', leftEles.indexOf(clickedEle))

                } else {
                  if (wrap.length > 1) {
                    $L(wrap).find('.lyteListBoxLeftElement').addClass('lyteLBLeftActive')
                  }

                  $L(clickedEle).addClass('lyteLBLeftActive');
                  $L(clickedEle).addClass('lyteLBLeftMoveElement');

                  Lyte.arrayUtils(this.getData('selectedIndexLeft'), 'push', leftEles.indexOf(clickedEle))

                }

              }

            }
          }

        } else {
          if ($L(lB).find('.lyteLBLeftActive').length > 0) {
            $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
          }
          if ($L(lB).find('.rightShiftElement').length > 0) {
            $L(lB).find('.rightShiftElement').removeClass('rightShiftElement')
          }
          if ((!(this.getData('ltPropRightData')[notDisabled].required))) {
            $L(lB).find('.lyteLBRightActive').removeClass('lyteLBRightActive')
            $L(lB).find('.lyteLBRightMoveElement').removeClass('lyteLBRightMoveElement')
            this.setData('selectedIndexRight', [])

            if (!$L(clickedEle).hasClass('lyteLBRightActive')) {

              this.setData('rightShiftSelectIndex', "");

              if ($L(clickedEle).hasClass('lyteListBoxRightElement')) {
                if (clickedEle.getAttribute('index').split(" ").length > 1) {


                  $L(clickedEle).addClass('lyteLBRightActive');
                  $L(clickedEle).addClass('lyteLBRightMoveElement');

                  Lyte.arrayUtils(this.getData('selectedIndexRight'), 'push', rightEles.indexOf(clickedEle))

                } else {

                  if (wrap.length > 1) {
                    $L(wrap).find('.lyteListBoxRightElement').addClass('lyteLBRightActive')
                  }

                  // $L(clickedEle).closest('.lyteListBoxRightWrap').addClass('rightShiftElement')
                  $L(clickedEle).addClass('lyteLBRightActive');
                  $L(clickedEle).addClass('lyteLBRightMoveElement');

                  Lyte.arrayUtils(this.getData('selectedIndexRight'), 'push', rightEles.indexOf(clickedEle))


                }

              }

            }
          }

        }




      }
    }

  },

  panelSide: function(ele) {

    if ($L(ele).hasClass('lyteListBoxLeftElement')) {
      return 'left'
    } else if ($L(ele).hasClass('lyteListBoxRightElement')) {
      return 'right'
    }

  },

  updateInsertIndex: function(th) {
    this.setData('insertAtRightInd', this.getData('insertAtRightInd') + 1)
  },
  reduceInsertIndex: function(th) {
    this.setData('insertAtRightInd', this.getData('insertAtRightInd') - 1)
  },

  getActiveElements: function(activeEles, dataString) {
    var th = this
    var toMoveDatas = []
    var parInd;
    for (var i = 0; i < activeEles.length; i++) {
      var index = activeEles[i].getAttribute('index').split(" ").map(this.indexCallback);
      var elemData;
      if (!$L(activeEles[i]).hasClass('lyteListBoxLeftParentElement')) {
        if (index.length > 1) {
          elemData = th.getData(dataString)[index[0]].childrenList[index[1]]
          if (!parInd) {
            parInd = toMoveDatas.length - 1;
          }
          toMoveDatas.push(elemData)
        } else {
          elemData = th.getData(dataString)[index[0]]
          elemData = Object.assign({}, elemData);
          if (elemData.childrenList) {
            elemData.childrenList = []
          }
          toMoveDatas.push(elemData)
          if (parInd) {
            parInd = undefined
          }
        }
      }
    }
    return toMoveDatas
  },

  sESPF: function(activeEles, toMoveDatas, mainData, dropIndex, allElements) {
    /*
     *  sort elements in same panel function
     */
    var startInd = activeEles[0].getAttribute('index').split(" ").map(this.indexCallback);
    var dropElem = $L(this.$node).find(allElements)[dropIndex]
    for (var i = 0; i < activeEles.length; i++) {

      if ((!($L(activeEles[i]).hasClass('lyteListBoxLeftParentElement'))) && (!($L(activeEles[i]).hasClass('lyteListBoxRightParentElement')))) {
        var ind = activeEles[i].getAttribute('index').split(" ").map(this.indexCallback);
        Lyte.arrayUtils(this.getData(mainData), 'removeAt', ind, 1);
      }
    }
    dropIndex = dropElem.getAttribute('index').split(" ").map(this.indexCallback)[0];
    Lyte.arrayUtils(this.getData(mainData), 'insertAt', dropIndex, toMoveDatas);

  },


  mERFN: function(th) {

    /*

    *  Move Elements Right Function
    *  Used to move either a selected single or more elements to move from left panel to right panel

    */

    if (!th) {
      th = this;
    }
    var lB = th.$node;


    $L(lB).find('.lyteLBLeftActive.lyteLBdragClone').removeClass('lyteLBLeftActive')
    var activeEles = $L(lB).find('.lyteLBLeftActive')

    if ((th.getData('ltPropRightData').length + activeEles.length > th.getData('ltPropMaxCount')) && ((this.getData('ltPropMaxCount') > -1))) {
      $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
      th.executeMethod('onMaxCountReached', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas);
      return
    }

    var value = this.getData('ltPropAssociateParent')

    var parInd;

    var toMoveDatas = th.getActiveElements(activeEles, 'ltPropLeftData');

    th.executeMethod('onBeforeRight', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas);

    toMoveDatas = []
    parInd = undefined

    function getIndex(arr, par) {
      var v = arr.findIndex(function(item) {
        return item[value] == par[value]
      })
      return v
    }


    for (var i = 0; i < activeEles.length; i++) {
      var elementData;
      var elemData;
      var ind = activeEles[i].getAttribute('index').split(" ").map(this.indexCallback);
      var currentData = th.getData('ltPropLeftData')[ind[0]]

      var parentElement = $L(lB).find('.lyteListBoxLeftElement')[ind[0]]

      if ((!$L(activeEles[i]).hasClass('lyteListBoxLeftParentElement')) && (!$L(activeEles[i]).closest('.lyteListBoxLeftWrap').hasClass('lyteLBDisabledElement'))) {
        if ((ind.length > 1)) {
          elementData = th.getData('ltPropLeftData')[ind[0]].childrenList[ind[1]]
          elemData = elementData
          var parentDiv = $L(activeEles[i]).closest('.lyteLBLeftChildWrap')
          var parData = th.getData('ltPropLeftData')[ind[0]]
          if (elementData) {
            Lyte.arrayUtils(th.getData('ltPropRightData'), 'insertAt', th.getData('insertAtRightInd'), elementData);
            var selectedDiv = $L(lB).find('.lyteListBoxRightElement')[th.getData('insertAtRightInd')]
            selectedDiv.setAttribute('setParent', th.getData('ltPropLeftData')[ind[0]][th.getData('ltPropAssociateParent')])
            th.updateInsertIndex();
            Lyte.arrayUtils(th.getData('ltPropLeftData')[ind[0]].childrenList, 'removeAt', ind[1], 1);
            $L(lB).find('.lyteLBLeftActive').removeClass('lyteLBLeftActive')
            if (th.getData('ltPropLeftData')[ind[0]].childrenList.length <= 0) {
              $L(parentDiv).closest('.lyteListBoxLeftWrap').addClass('lyteLBoxDisabledParent')
            } else {
              $L(parentDiv).closest('.lyteListBoxLeftWrap').removeClass('lyteLBoxDisabledParent')
            }
          }
        } else {
          if (!(currentData.childrenList)) {
            elementData = th.getData('ltPropLeftData')[ind]
            Lyte.arrayUtils(th.getData('ltPropRightData'), 'insertAt', th.getData('insertAtRightInd'), elementData);
            th.updateInsertIndex();
            Lyte.arrayUtils(th.getData('ltPropLeftData'), 'removeAt', ind, 1);
            toMoveDatas.push(elementData)
          }
        }
      }
    }

    th.setData('selectedIndexLeft', [])
    th.setData('leftShiftSelectIndex', "")


    if ((th.getData('ltPropRightData').length >= th.getData('ltPropMaxCount')) && (this.getData('ltPropMaxCount') > -1)) {
      th.executeMethod('onMaxCountReached', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas);
      $L(lB).find('.lyteListboxLeftPanel').addClass('lyteLBDisabledElement')
    }


    th.executeMethod('onMoveRight', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas)


    // after

  },


  mELFN: function(th) {


    /*

    *  Move Elements Left Function
    *  Used to move either a selected single or more elements to move from Right panel to left panel

    */

    if (!th) {
      th = this;
    }
    var lB = th.$node;
    $L(lB).find('.lyteLBRightActive.lyteLBdragClone').removeClass('lyteLBRightActive')
    var activeEles = $L(lB).find('.lyteLBRightActive')

    var value = this.getData('ltPropAssociateParent')

    var toMoveDatas = []
    var parInd;

    var toMoveDatas = th.getActiveElements(activeEles, 'ltPropRightData');

    th.executeMethod('onBeforeLeft', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas);

    toMoveDatas = []
    parInd = undefined

    function getIndex(arr, par) {
      var v = arr.findIndex(function(item) {
        return item[value] == par[value]
      })
      return v
    }

    function getI(arr, val) {
      var i = arr.findIndex(function(item) {
        return item[value] == val
      })
      return i;
    }

    for (var i = 0; i < activeEles.length; i++) {
      var elementData;
      var elemData;
      var ind = activeEles[i].getAttribute('index').split(" ").map(this.indexCallback);
      var currentData = th.getData('ltPropRightData')[ind[0]]

      var parentElement = $L(lB).find('.lyteListBoxRightElement')[ind[0]]

      if ($L(activeEles[i])[0].getAttribute('setParent').length > 0) {

        var parI = getI(th.getData('ltPropLeftData'), $L(activeEles[i])[0].getAttribute('setParent'));
        elementData = th.getData('ltPropRightData')[ind]
        Lyte.arrayUtils(th.getData('ltPropLeftData')[parI].childrenList, 'push', elementData);
        Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', ind, 1);
        th.reduceInsertIndex();

      } else {

        elementData = th.getData('ltPropRightData')[ind]
        Lyte.arrayUtils(th.getData('ltPropLeftData'), 'push', elementData);
        Lyte.arrayUtils(th.getData('ltPropRightData'), 'removeAt', ind, 1);
        th.reduceInsertIndex();
        toMoveDatas.push(elementData)

      }

      if ($L(lB).find('.lyteLBoxDisabledParent')) {
        if ($L(lB).find('.lyteLBoxDisabledParent').find('.lyteLBLeftChildWrap').length > 0) {
          $L(lB).find('.lyteLBoxDisabledParent').removeClass('lyteLBoxDisabledParent')
        }
      }

    }

    th.setData('selectedIndexRight', [])
    th.setData('rightShiftSelectIndex', "")

    if (th.getData('ltPropRightData').length < th.getData('ltPropMaxCount')) {
      $L(lB).find('.lyteLBDisabledElement').removeClass('lyteLBDisabledElement')
    }

    th.executeMethod('onMoveLeft', th.getData('ltPropLeftData'), th.getData('ltPropRightData'), toMoveDatas)

    // after

  },
  didDestroy: function() {
    this.setData('selectedIndexLeft', [])
    this.setData('selectedIndexRight', [])
    this.setData('leftShiftSelectIndex', '')
    this.setData('rightShiftSelectIndex', '')
    this.setData('insertAtLeftInd', 0)
    this.setData('insertAtRightInd', 0)
  }
});

/**
 * A menu is a group of options available to perform some reasonable actions in the page
 * @component lyte-menu
 * @version 1.0.0
 * @methods onBeforeOpen,onOpen,onBeforeClose,onClose,onMenuClick,onPositionChanged
 */

Lyte.Component.register("lyte-menu", {
_template:"<template tag-name=\"lyte-menu\"> <lyte-menu-box class=\"{{ltPropWrapperClass}}\" onmousemove=\"{{action('mousemove',event,this)}}\"> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-menu-body id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" tabindex=\"1\"> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"menu\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(menu)}}\"><template case=\"true\"> <lyte-menu-group elemorder=\"{{indexVal}}\"> <template is=\"if\" value=\"{{lyteUiReturnOnlyKey(menu)}}\"><template case=\"true\"> <lyte-menu-header> {{lyteUiReturnOnlyKey(menu)}} </lyte-menu-header> </template></template> <template is=\"for\" items=\"{{lyteUiReturnOnlyValue(menu)}}\" item=\"menu1\" index=\"indexVal1\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(menu1),'==',false)}}\"><template case=\"true\"> <lyte-menu-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{menu1}}\"> <lyte-menu-label>{{menu1}}</lyte-menu-label> </lyte-menu-item> </template><template case=\"false\"> <lyte-menu-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" id=\"{{menu1.id}}\" class=\"{{menu1.class}}\" data-value=\"{{menu1[ltPropSystemValue]}}\"> <lyte-menu-label>{{menu1[ltPropUserValue]}}</lyte-menu-label> <template is=\"if\" value=\"{{menu1[ltPropDescription]}}\"><template case=\"true\"> <lyte-menu-description> {{menu1[ltPropDescription]}}</lyte-menu-description> </template></template> </lyte-menu-item> </template></template></template> </lyte-menu-group> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(menu),'==',false)}}\"><template case=\"true\"> <lyte-menu-item elemorder=\"{{indexVal}}\" data-value=\"{{menu}}\"> <lyte-menu-label>{{menu}}</lyte-menu-label> </lyte-menu-item> </template><template case=\"false\"> <lyte-menu-item elemorder=\"{{indexVal}}\" id=\"{{menu.id}}\" class=\"{{menu.class}}\" data-value=\"{{menu[ltPropSystemValue]}}\"> <lyte-menu-label>{{menu[ltPropUserValue]}}</lyte-menu-label> <template is=\"if\" value=\"{{menu[ltPropDescription]}}\"><template case=\"true\"> <lyte-menu-description> {{menu[ltPropDescription]}}</lyte-menu-description> </template></template> </lyte-menu-item> </template></template></template></template></template> </lyte-menu-body> </template><template case=\"false\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template> </template></template> </lyte-menu-box> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropContent","ltPropId","ltPropClass","ltPropQuery","ltPropEvent","ltPropYield","ltPropUserValue","ltPropSystemValue","ltPropCallout","ltPropPosition","ltPropDescription","ltPropTabIndex","ltPropFreeze","ltPropShow","ltPropWidth","ltPropHeight","ltPropQueryClass","ltPropBoundary","ltPropScope","ltPropPreventInsideClick","ltPropAnimate","ltPropSetCss","ltPropWrapperClass","ltPropWrapperId","ltPropBindToBody","ltPropAria","ltPropAriaAttributes","ltPropOffset","ltPropHeightResetOnScroll","eventListeners","pos","parIndex","lyteUnbound"],
    init: function () {
        var event = this.getData('ltPropEvent');
        var evt = this.checkElementForMenu.bind(this);
        this.setData('eventListeners.event', evt);
        this._close = this.closing.bind(this);
        this._trsend = this.tranEnd.bind(this);
        this._hoverclose = this.hoverClose.bind(this);
        document.addEventListener(/^(mouseenter|mousemove|mouseover|hover)$/.test(event) ? 'mousemove' : event, evt, true);

        if (!document.getElementsByClassName('lytemenufreezelayer')[0] && this.getData('ltPropFreeze')) {
            this.appendFreeze.call(this, 'lytemenufreezelayer left lyteMenuHidden')
            this.appendFreeze.call(this, 'lytemenufreezelayer top lyteMenuHidden')
            this.appendFreeze.call(this, 'lytemenufreezelayer bottom lyteMenuHidden')
            this.appendFreeze.call(this, 'lytemenufreezelayer right lyteMenuHidden')
            var freezeLayer = this.appendFreeze.call(this, 'lytemenufreezelayer nogroup lyteMenuHidden');
            freezeLayer.addEventListener('wheel', this.preventEvent);
            freezeLayer.addEventListener('touchmove', this.preventEvent);
        }
        if (!document.hasOwnProperty('_lyteMenu')) {
            document.documentElement.addEventListener('click', lyteCloseMenu, true);
            document.documentElement.addEventListener('keydown', this.keydownCheck, true);
            document.documentElement.addEventListener('keypress', menukeypress, true);
            window.addEventListener('orientationchange', this.resizeFunc, true);
            window.addEventListener('resize', this.resizeFunc, true);
            document._lyteMenu = {};
            document._lyteMenu.eventFlag = true;
        }
        /**
         * @method beforeRender
         * @version 1.0.1
         */
        this.getMethods('beforeRender') && this.executeMethod('beforeRender', this.$node);
    },

    rtlfunc: function (lft, bcr, ww) {
        if (this._dir) {
            if (bcr) {
                if (lft == 'right') {
                    return ww - bcr.left;
                }
                return ww - bcr.right;
            } else if (lft == 'left') {
                return 'right';
            }
        }
        return bcr ? bcr[lft] : 'left';
    },

    actions: {
        mousemove: function (evt, _this) {
            var node = evt.target
            while (node && node.tagName != "BODY") {
                if (node.tagName == 'LYTE-MENU-ITEM') {
                    break
                }
                node = node.parentNode;
            }
            if (node && node.tagName == 'LYTE-MENU-ITEM') {

                var prev = _this.querySelector('.lyteMenuSelection');
                if (prev == node) {
                    return
                } else if (prev) {
                    prev.classList.remove('lyteMenuSelection')
                    node.classList.add('lyteMenuSelection')
                } else if (!prev) {
                    node.classList.add('lyteMenuSelection')
                }
            }
        }
    },

    arrayFrom: function (nodeList) {
        var arrayList = [];
        for (var i = 0; i < nodeList.length; i++) {
            arrayList.push(nodeList[i]);
        }
        return arrayList.slice();
    },

    appendFreeze: function (className) {
        var freezeLayer = document.createElement('div');
        freezeLayer.setAttribute('class', className);
        return document.body.appendChild(freezeLayer);
    },

    resizeFunc: function (event) {
        if (event && event.type == 'resize' && _lyteUiUtils.isMobile) {
            return;
        }
        clearTimeout(this._resizeTimeout)
        this._resizeTimeout = setTimeout(function () {
            var activeMenu = document.getElementsByTagName('lyte-menu');
            for (var i = 0; i < activeMenu.length; i++) {
                var current = activeMenu[i],
                    comp = current.component;
                if (current.classList.contains('lyteMenuClosed')) {
                    continue;
                }
                if (!comp.hasOwnProperty('parentMenu')) {
                    comp.callScrollFunc(event);
                    if (comp.getData('ltPropFreeze') && !comp.parentMenu) {
                        setTimeout(comp.setZIndex.bind(comp), 100);
                    }
                }
            }
        }.bind(this), event && event.type == "orientationchange" ? 500 : 16)
    },

    keydownCheck: function (event) {
        var keyCode = event.which || event.keyCode;
        if (keyCode == 27) {
            lyteCloseMenu(event, undefined, true);
        } else if (/^(38|40|13|36|35)$/.test(keyCode)) {
            var menus = document.getElementsByTagName('lyte-menu');
            // if( menus.length ) {
            // event.preventDefault()
            for (var i = 0; i < menus.length; i++) {
                if (menus[i].classList.contains('lyteMenuClosed') || menus[i].getAttribute('lyte-rendered') == null) {
                    continue;
                }
                var menu = menus[i].component;
                if (!menu.childMenu) {
                    menu.traverseList.call(menu, event);
                    if (/^(38|40)$/.test(keyCode) || (menu.data.ltPropAria && /^(35|36)$/.test(keyCode))) {
                        event.preventDefault();
                    }
                    break;
                }
            }
            // }
        } else if (/^(37|39)$/.test(keyCode)) {
            var menus = document.getElementsByTagName('lyte-menu');
            for (var i = 0; i < menus.length; i++) {
                if (menus[i].classList.contains('lyteMenuClosed') || menus[i].getAttribute('lyte-rendered') == null) {
                    continue;
                }
                var menu = menus[i].component;
                if (menu.parentMenu && !menu.childMenu && menu.data.ltPropAria) {
                    var exstSel = $L('.lyteMenuSelection', menu.childComp);
                    if (exstSel.length) {
                        if (/right/i.test(menu.data.pos) && keyCode == 37 || /left/i.test(menu.data.pos) && keyCode == 39) {
                            menu.$node.ltProp('show', false);
                        }
                        event.preventDefault();
                    } else {
                        menu.scrIntoView($L('lyte-menu-item:not(.lyteMenuSelection)', menu.childComp).eq(0).addClass('lyteMenuSelection').get(0));
                    }
                    break;
                }
            }
        } else if (keyCode == 32) {
            var menus = document.getElementsByTagName('lyte-menu');
            for (var i = 0; i < menus.length; i++) {
                if (menus[i].classList.contains('lyteMenuClosed') || menus[i].getAttribute('lyte-rendered') == null) {
                    continue;
                }
                var menu = menus[i],
                    box = menu.component.childComp,
                    target = event.target,
                    _this = menu.component;

                if (_this.eligibleForClose(_this, target)) {
                    break;
                }
                if (menu.ltProp('freeze')) {
                    event.preventDefault();
                    break;
                }
            }
        }
    },

    searchFilter: function (val) {
        this._typed = '';
        if (!val) {
            return
        }
        var items = this.childComp.getElementsByTagName('lyte-menu-item'), sel = {};
        for (var i = 0; i < items.length; i++) {
            var txt = items[i].textContent.trim().toLowerCase(), idx = txt.indexOf(val);
            if (idx != -1 && (idx < sel.index || sel.index == undefined)) {
                sel.item = items[i]; sel.index = idx;
            }
        }
        if (sel.item) {
            var prevS = this.childComp.getElementsByClassName('lyteMenuSelection')[0];
            if (sel.item == prevS) {
                return;
            }
            if (prevS) {
                prevS.classList.remove('lyteMenuSelection');
            }
            sel.item.classList.add('lyteMenuSelection');
            this.scrIntoView.call(this, sel.item)
        }
    },

    scrIntoView: function (elem) {
        if (!elem) {
            return;
        }
        $L.fastdom.measure(function () {
            var off = elem.getBoundingClientRect(), scr = this.findscrElem.call(this, elem), hgt = scr.getBoundingClientRect();
            $L.fastdom.mutate(function () {
                if (off.bottom > hgt.bottom) {
                    scr.scrollTop += parseInt(off.bottom - hgt.bottom);
                } else if (off.top < hgt.top) {
                    scr.scrollTop += parseInt(off.top - hgt.top);
                }
            }.bind(this))
        }.bind(this))
    },

    findscrElem: function (el) {
        var nde = el.parentNode;
        while (nde && nde.nodeName != "LYTE-MENU-BODY") {
            var st = window.getComputedStyle(nde).getPropertyValue('overflow-y')
            if (nde.scrollHeight > nde.offsetHeight && (st == 'auto' || st == 'scroll')) {
                break;
            }
            nde = nde.parentNode;
        }
        return nde;
    },

    didDestroy: function () {

        if (this.childComp) {
            var allNodes = this.childComp.getElementsByTagName('lyte-menu-item')
            for (var i = 0; i < allNodes.length; i++) {
                var curValue = allNodes[i].getAttribute('lyte-shortcut')
                if (curValue) {
                    allNodes[i].setAttribute('lyte-shortcut', JSON.stringify({}))
                }
            }
            this.childComp.parentElement && this.childComp.parentElement.removeChild(this.childComp);
            delete this.childComp.parent;
            delete this.childComp; /*delete this.$node.toggle;*/
        }
        var removeEvents = this.getData('eventListeners'), event = this.getData('ltPropEvent');
        if (document.body.querySelectorAll('lyte-menu').length == 0) {
            var freezeLayers = document.body.querySelectorAll('div.lytemenufreezelayer')
            for (var i = 0; i < freezeLayers.length; i++) {
                document.body.removeChild(freezeLayers[i]);
            }
            if (document._lyteMenu) {
                delete document._lyteMenu
                document.documentElement.removeEventListener('keydown', this.keydownCheck, true);
                document.documentElement.removeEventListener('keypress', menukeypress, true)
                document.documentElement.removeEventListener('click', lyteCloseMenu, true);
                window.removeEventListener('resize', this.resizeFunc, true);
                window.removeEventListener('orientationchange', this.resizeFunc, true);
            }
        } else if (this.data.ltPropShow && this.data.ltPropFreeze) {
            document.body.classList.remove('lyteBodyWrapper');
            if (document.menu == this) {
                delete document.menu;
            }
            this.removeFreeze();
        }
        window.removeEventListener('scroll', this.addScrollPos, true);
        var ltPropQuery = this.getData('ltPropQuery'), parIndex = this.getData('parIndex'), nodeList;
        if (ltPropQuery || parIndex != undefined) {
            if (ltPropQuery) {
                nodeList = document.querySelectorAll(ltPropQuery);
            }
            document.removeEventListener(/^(mouseenter|mousemove|mouseover|hover)$/.test(event) ? 'mousemove' : event, removeEvents.event, true);
            if (ltPropQuery) {
                for (var i = 0; i < nodeList.length; i++) {
                    delete nodeList[i].menu;
                }
            }
        }
        clearTimeout(this._typetime)

        if (this.menuBody) {
            delete this.menuBody.parent;
            delete this.menuBody
        }
        if (document.menu == this) {
            delete document.menu;
        }
    },

    closestFind: function (path, query) {
        var parIndex = this.getData('parIndex'),
            elements = this.arrayFrom.call(this, (parIndex != undefined ? (this.$node.parentNode.parentNode.querySelectorAll('lyte-menu-item:nth-of-type(' + ++parIndex + ')')) : document.querySelectorAll(query.trim())));
        for (var i = 0; i < path.length; i++) {
            if (Array.prototype.indexOf.call(elements, path[i]) != -1) {
                return path[i];
            }
        }
        return null;
    },

    isHoverAnimate: function () {
        return this.data.ltPropAnimate && /^(mouseenter|mousemove|mouseover|hover)$/.test(this.data.ltPropEvent);
    },

    checkElementForMenu: function (event) {
        if (!event.menuFlag) {
            var query = this.getData('ltPropQuery');
            var closetElem = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), query);
            if (closetElem != null) {
                var isHover = this.isHoverAnimate();
                if (!isHover) {
                    if (this._evtadded) {
                        if (this.data.ltPropAnimate && parseInt(this.menuBody.style.height) == 0) {
                            this.setData('ltPropShow', false)
                        }
                        return;
                    }
                }
                if (event.type == 'contextmenu') {
                    event.preventDefault();
                    lyteCloseMenu(event, this.$node);
                }
                var isOpen = !this.childComp.classList.contains('lyteMenuHidden');
                if (isOpen && this.$node.element != closetElem) {
                    if (isHover) {
                        if (this._openstart) {
                            this.tranEnd();
                        }
                        this.data.ltPropAnimate = false;
                        if (this._hideStarts) {
                            clearTimeout(this._time3);
                            this.closing(true, event);
                        } else {
                            this.hideMenu(true, event);
                        }
                        this.data.ltPropAnimate = true;
                    } else {
                        // for opening same menu at diff position menu body should be hided and its animation need to be prevented
                        this.childComp.classList.remove('lyteAnimate')
                        this._hideStarts = true
                        this._closest = closetElem, this._event = event
                        var prom = new Promise(function (resolve, reject) {
                            this._promResolve = resolve, this._promReject = reject
                            this.hideMenu.call(this, true, event);
                        }.bind(this))

                        Promise.resolve(prom).then(function () {
                            this.openingMenu(this._closest, this._event)
                            delete this._closest; delete this._event; delete this._promReject; delete this._promResolve;
                        }.bind(this), function () {
                            delete this._closest; delete this._event; delete this._promReject; delete this._promResolve;
                        }.bind(this))
                        return
                    }
                } else if (isOpen && this.$node.element == closetElem) {
                    if (isHover) {
                        if (this._openstart) {
                            return;
                        }
                    } else {
                        return;
                    }
                }
                this.openingMenu(closetElem, event)
            } else if (event.type == "contextmenu") {
                lyteCloseMenu(event, undefined, true);
            }
        }
    },

    openingMenu: function (closetElem, event) {
        if (closetElem.tagName == "LYTE-MENU-ITEM" && event.type == 'click') {
            event.stopPropagation();
        }
        event.menuFlag = true;
        // $L.fastdom.mutate(function(){
        this.$node.element = closetElem;
        closetElem.menu = this.$node;
        if (!this.parentMenu) {
            if (event.type != "contextmenu") {
                this._open_fast = $L.fastdom.mutate(this.$node.toggle.bind(this.$node, event));
            } else {
                this.$node.toggle(event || {});
            }
        }
        // }.bind(this))
    },

    didConnect: function () {

        var menuBox = this.$node.getElementsByTagName('lyte-menu-box')[0];
        this.$node.toggle = function (event, flag) {
            delete this._open_fast;
            if (this.childComp.classList.contains('lyteMenuHidden') || flag) {
                if (['mousedown', 'mouseup'].indexOf(event.type) > -1) {
                    document._lyteMenu.preventClick = false;
                }
                this.openMenu.call(this, event)
            }
            else {
                if (!this.childMenu && event.type.indexOf('mouse') == -1 && !this._hideStarts) {
                    this.hideMenu.call(this, true, event)
                }
            }
        }.bind(this);

        this.$node.setCss = this.setCss.bind(this);

        menuBox.parent = this.$node;
        this.childComp = menuBox;
        menuBox.classList.add('lyteMenuHidden');
        this.$node.classList.add('lyteMenuClosed');
        menuBox.style.width = this.getData('ltPropWidth');

        // Lyte.Component.appendChild(document.body, menuBox);
        if (this.data.ltPropCallout && /^(mouseenter|mousemove|mouseover|hover)$/.test(this.data.ltPropEvent)) {
            this.childComp.classList.add('lyteHoverMenu')
        }
        if (this.getMethods('afterRender')) {
            /**
             * @method afterRender
             * @version 1.0.1
             */
            this.executeMethod('afterRender', this.$node);
        }
        $L.fastdom.measure(function () {
            this._dir = _lyteUiUtils.getRTL();
        }.bind(this))
    },

    bToBody: function () {
        if (this.data.ltPropBindToBody && this.childComp.parentNode != document.body) {
            var menuBody = this.childComp.querySelector('lyte-menu-body');
            menuBody.addEventListener('click', this.optionSelect.bind(this));
            menuBody.parent = this.$node;
            this.menuBody = menuBody;
            var span = document.createElement('span');
            span.setAttribute('class', 'lyteArrow' + (this.data.ltPropCallout ? '' : ' lyteMenuHidden'));
            menuBody.insertBefore(span, menuBody.children[0]);
            this.menuBody.style.height = this.data.ltPropHeight;
            if (this._dir) {
                this.menuBody.classList.add('lyteRTL');
            }
            _lyteUiUtils.appendChild(document.body, this.childComp);
        } else if (!this.data.ltPropBindToBody) {
            this.$node.ltProp('show', false);
            if (this.menuBody) {
                delete this.menuBody.parent;
                delete this.menuBody;
            }
        }
    }.observes('ltPropBindToBody').on('didConnect'),

    calloutObs: function (arg) {
        var arrow = this.childComp.querySelector('span.lyteArrow')
        if (arg.newValue) {
            arrow.classList.remove('lyteMenuHidden')
        } else {
            arrow.classList.add('lyteMenuHidden')
        }
    }.observes('ltPropCallout'),

    data: function () {
        return {
            // user data
            /**
            * @componentProperty {string[] | object[]} ltPropContent
            * @default []
            * @version 1.0.0
            */
            ltPropContent: Lyte.attr('array', { 'default': [] }),
            /**
             * @componentProperty {string} ltPropId=''
             * @version 1.0.0
             */
            ltPropId: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropClass=''
             * @version 1.0.0
             */
            ltPropClass: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropQuery=''
             * @version 1.0.0
             */
            ltPropQuery: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropEvent=click
             * @version 1.0.0
             */
            ltPropEvent: Lyte.attr('string', { 'default': 'click' }),
            /**
             * @componentProperty {boolean} ltPropYield=false
             * @version 1.0.0
             */
            ltPropYield: Lyte.attr('boolean', { 'default': false }),
            /**
             * @componentProperty {string} ltPropUserValue=''
             * @version 1.0.0
             */
            ltPropUserValue: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropSystemValue=''
             * @version 1.0.0
             */
            ltPropSystemValue: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {boolean} ltPropCallout=false
             * @version 1.0.0
             */
            ltPropCallout: Lyte.attr('boolean', { 'default': false }),
            /**
             * @componentProperty {down | up | left | right | upRight | upLeft | downRight | downLeft | downAlignLeft | downAlignRight | upAlignLeft | upAlignRight} ltPropPosition=down
             * @version 1.0.0
             */
            ltPropPosition: Lyte.attr('string', { 'default': 'down' }),
            /**
             * @componentProperty {string} ltPropDescription=''
             * @version 1.0.0
             */
            ltPropDescription: Lyte.attr('string', { 'default': '' }),
            /**
             * @experimental ltPropTabIndex
             */
            ltPropTabIndex: Lyte.attr('number', { 'default': 0 }),
            /**
             * @componentProperty {boolean} ltPropFreeze=true
             * @version 1.0.0
             */
            ltPropFreeze: Lyte.attr('boolean', { 'default': true }),
            /**
             * @componentProperty {boolean} ltPropShow=false
             * @version 1.0.1
             */
            ltPropShow: Lyte.attr('boolean', { 'default': false }),
            /**
             * @componentProperty {string} ltPropWidth=auto
             * @version 1.0.0
             */
            ltPropWidth: Lyte.attr('string', { 'default': 'auto' }),
            /**
             * @componentProperty {string} ltPropHeight=auto
             * @version 1.0.0
             */
            ltPropHeight: Lyte.attr('string', { 'default': 'auto' }),
            /**
             * @componentProperty {string} ltPropQueryClass=lyteMenuSelected
             * @version 1.0.0
             */
            ltPropQueryClass: Lyte.attr('string', { 'default': 'lyteMenuSelected' }),
            /**
             * @componentProperty {object} ltPropBoundary
             * @default {}
             * @version 1.0.0
             */
            ltPropBoundary: Lyte.attr('object', { 'default': {} }),
            /**
             * @componentProperty {string} ltPropScope=''
             * @version 1.0.0
             */
            ltPropScope: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {boolean} ltPropPreventInsideClick=false
             * @version 1.0.0
             */
            ltPropPreventInsideClick: Lyte.attr('boolean', { default: false }),
            /**
             * @componentProperty {boolean} ltPropAnimate=false
             * @version 1.0.3
             */
            ltPropAnimate: Lyte.attr('boolean', { default: false }),
            /**
             * @componentProperty {boolean} ltPropSetCss=true
             * @version 1.0.4
             */
            ltPropSetCss: Lyte.attr('boolean', { default: true }),
            /**
             * @componentProperty {string} ltPropWrapperClass=''
             * @version 1.0.4
             */
            ltPropWrapperClass: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropWrapperId=''
             * @version 1.0.4
             */
            ltPropWrapperId: Lyte.attr('string', { default: "" }),
            /**
             * @componentProperty {boolean} ltPropBindToBody=true
             * @version 2.1.0
             */
            ltPropBindToBody: Lyte.attr('boolean', { default: true }),
            /**
             * @componentProperty {boolean} ltPropAria=false
             * @version 3.1.0
             */
            ltPropAria: Lyte.attr('boolean', { default: false }),
            /**
             * @componentProperty {object} ltPropAriaAttributes
             * @default {"role":"menu"}
             * @version 3.1.0
             */
            ltPropAriaAttributes: Lyte.attr('object', { default: { role: "menu" } }),
            /**
             * @typedef {object} menuOffset
             * @property {number} left
             * @property {number} right
             * @property {number} top
             * @property {number} bottom
             */

            /**
             * @componentProperty {menuOffset} ltPropOffset
             * @default {}
             * @version 2.2.11
             */
            ltPropOffset: Lyte.attr('object', { default: {} }),
            /**
             * @experimental ltPropHeightResetOnScroll
             */
            ltPropHeightResetOnScroll: Lyte.attr('boolean', { default: true }),

            // system data 
            eventListeners: Lyte.attr('object', { 'default': {} }),
            pos: Lyte.attr('string', { default: '' }),
            parIndex: Lyte.attr('number'),
            lyteUnbound: Lyte.attr('boolean', { default: false })
        }
    },

    firePosCallBack: function () {
        if (this.getMethods('onPositionChanged')) {
            this.executeMethod('onPositionChanged', this.getData('pos'), this.$node);
        }
    }.observes('pos'),

    contentChangeObs: function () {
        this.contentChange.call(this);
    }.observes('ltPropContent.[]'),

    contentChange: function () {
        if (!this.childComp.classList.contains('lyteMenuHidden')) {
            this.setCss.call(this);
            this.menuBody.style.removeProperty('height');
        }
    },

    setContextCss: function (evt, position) {
        var element = this.$node.element;
        var menuBody = this.childComp;
        $L.fastdom.measure(function () {
            var evt1 = evt,
                nbr = element.getBoundingClientRect();
            if (!evt) {
                evt = { clientX: nbr.left + nbr.width / 2, clientY: nbr.top + nbr.height / 2 }
            }
            var clientRect = menuBody.getBoundingClientRect(),
                menuBodyBcr = this.menuBody.getBoundingClientRect(),
                menuBodystyle = window.getComputedStyle(this.menuBody),
                padding = (menuBodystyle.boxSizing == 'content-box' ? (parseFloat(menuBodystyle.paddingTop) + parseFloat(menuBodystyle.paddingBottom)) : 0),
                bodyHeight = menuBodyBcr.height - padding,
                innerHeightt = window.innerHeight,
                innerWidtht = window.innerWidth,
                offset = this.data.ltPropOffset || {},
                topoff = offset.top || 0,
                btmoff = offset.bottom || 0,
                lftoff = offset.left || 0,
                rgtoff = offset.right || 0,
                x = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? - 1 : 1),
                y = window.pageYOffset || document.documentElement.scrollTop,
                lT = this.rtlfunc.call(this, 'left'),
                cX = this.__cX != undefined ? (this.__cX + this.rtlfunc('left', nbr, innerWidtht)) : (!this._dir ? evt.clientX : (innerWidtht - evt.clientX)),
                cY = this.__cY != undefined ? (this.__cY + nbr.top) : (evt.clientY);
            // $L.fastdom.mutate(function(){
            if (!position) {
                position = this.data.ltPropPosition;
            }
            switch (position) {
                case 'up': {
                    menuBody.style[lT] = cX + x + 'px';
                    // menuBody.style.top = ( cY - clientRect.height + y ) + 'px';
                    if (cY > innerHeightt - cY) {
                        // if( parseInt( menuBody.style.top ) < y )
                        //     {
                        menuBody.style.top = (cY + y) + 'px';
                        // }
                    } else {
                        // if( ( parseInt( menuBody.style.top ) + clientRect.height) > innerHeightt + y )
                        //     {
                        //         menuBody.style.top = ( cY - clientRect.height + y ) + 'px';
                        //     } 
                        menuBody.style.top = (cY - clientRect.height + y) + 'px';
                    }
                    this.setData('pos', 'up')
                    break;
                }
                default: {
                    menuBody.style[lT] = cX + x + 'px';
                    // menuBody.style.top = cY + y + 'px';
                    if (cY < innerHeightt - cY) {
                        // if( ( parseInt( menuBody.style.top ) + clientRect.height ) > innerHeightt + y ) {
                        //     menuBody.style.top = ( cY - clientRect.height + y ) + 'px';
                        // }
                        menuBody.style.top = cY + y + 'px';
                    } else {
                        // if( parseInt( menuBody.style.top ) < y ) {
                        //     menuBody.style.top = ( cY + y ) + 'px';
                        // }
                        menuBody.style.top = (cY - clientRect.height + y) + 'px';
                    }
                    this.setData('pos', 'down')
                }
            }
            if (clientRect.left < lftoff) {
                menuBody.style[lT] = (cX + lftoff) + 'px';
            }
            else if (this.rtlfunc.call(this, 'right', clientRect, innerWidtht) > (innerWidtht - rgtoff)) {
                menuBody.style[lT] = (cX - clientRect.width) + 'px';
            }
            if (evt1) {
                // if( evt1.type == 'contextmenu' ){
                if (parseFloat(menuBody.style.top) - y + bodyHeight > innerHeightt - btmoff && cY <= innerHeightt) {
                    this.menuBody.style.height = (innerHeightt - btmoff - parseFloat(menuBody.style.top) + y) + 'px';
                    bodyHeight = parseFloat(this.menuBody.style.height);
                }
                if (parseFloat(menuBody.style.top) - y < topoff && cY >= topoff) {
                    this.menuBody.style.height = (parseFloat(menuBody.style.top) - y - topoff + bodyHeight) + 'px';
                    menuBody.style.top = (y + topoff) + 'px';
                    bodyHeight = parseFloat(this.menuBody.style.height);
                }
                this._hgt = bodyHeight;
                // }
                if (this.__cX == undefined) {
                    this.__cX = cX - this.rtlfunc('left', nbr, innerWidtht);
                }
                if (this.__cY == undefined) {
                    this.__cY = cY - nbr.top;
                }
            }
            // }.bind(this))
        }.bind(this))

    },


    openMenu: function (event, flagg) {
        var onBeforeOpen, eventType = this.getData('ltPropEvent'), targetDiv;
        event = event ? event : {}
        if (!flagg) {
            targetDiv = this.targetElem.call(this, event.target);
            if (targetDiv[0]) {
                targetDiv[0].originMenu = targetDiv[1].component
            }
        }
        if (flagg && eventType != 'contextmenu') {
            if (!this.$node.element) {
                var query = this.getData('ltPropQuery');
                this.$node.element = document.body.querySelector(query.trim());
            }
            if (this.$node.element.tagName == 'LYTE-MENU-ITEM') {
                targetDiv = this.targetElem.call(this, this.$node.element);
            }
            else if (!targetDiv) {
                targetDiv = [];
            }
        }
        if (this.getMethods('onBeforeOpen')) {
            onBeforeOpen = this.executeMethod('onBeforeOpen', this.$node, event, this.$node.element);
        }

        if (targetDiv && targetDiv[0] && targetDiv[1].tagName == 'LYTE-MENU') {
            if (!targetDiv[1].ltProp('show')) {
                onBeforeOpen = false;
            }
        }

        if (onBeforeOpen != false && this.$node.element) {
            if (!this.data.ltPropBindToBody) {
                this.$node.ltProp('bindToBody', true);
            }
            //Actual opening process
            // $L.fastdom.measure(function(){
            //     // to set initial position if its scrolled previously

            // }.bind(this))
            // $L.fastdom.mutate(function(){
            // to set initial position if its scrolled previously
            this.childComp.scrollTop = 0;
            this.childComp.classList.remove('lyteMenuHidden', 'lyteAnimate');
            this.$node.classList.remove('lyteMenuClosed');
            this.$node.element && this.$node.element.setAttribute('aria-expanded', 'true');
            this.childComp.style.display = 'block'

            if (this.getData('ltPropHeight')) {
                this.menuBody.style.height = this.getData('ltPropHeight')
            } else {
                this.menuBody.style.removeProperty('height')
            }
            if (targetDiv[0]) {
                if (targetDiv[1].tagName == 'LYTE-MENU') {
                    targetDiv[1].component.childMenu = this
                    this.parentMenu = targetDiv[1].component
                    targetDiv[1].component.childComp.addEventListener('mousemove', this.mouseleave)
                }
            }
            if (!this.parentMenu) {
                this.$node.element.classList.add(this.getData('ltPropQueryClass'))
            }
            if (!this.parentMenu && this.$node.element.tagName != 'LYTE-MENU-ITEM') {
                lyteCloseMenu(event, this.$node)
            }
            if (this.getData('ltPropFreeze') && !this.parentMenu) {
                this.setZIndex.call(this)
            }
            else if (!document.menu) {
                window.addEventListener('scroll', this.addScrollPos, true)
                document.menu = this
            }
            if ((/^(mouseenter|mousemove|mouseover|hover)$/.test(eventType)) && !this.childMenu && !this.parentMenu && !targetDiv[0]) {
                document.addEventListener('mousemove', this._hoverclose);
                // this.$node.element.addEventListener('mousemove', this.preventEvent);
                // this.menuBody.addEventListener('mousemove', this.preventEvent);
            }
            this._openFastdom = $L.fastdom.measure(function () {
                var mbcr = this.menuBody.getBoundingClientRect(),
                    iH = window.innerHeight,
                    yOff = window.pageYOffset || document.documentElement.scrollTop;
                this._dontCall = true;
                this.$node.ltProp('show', true);
                delete this._dontCall; delete this._openFastdom;
                if (this.getData('ltPropEvent') == 'contextmenu') {
                    this.setContextCss.call(this, event);
                }
                else {
                    this.setCss.call(this);
                }
                if (event.type != 'contextmenu') {
                    // this._hgt =  this.heightCheck.call(this, this.menuBody, mbcr, yOff, iH );
                    if (this.getData('ltPropAnimate') && this._hgt != 0) {
                        this._openstart = true;
                        // for animating height height need to set as zero and animate class need to be added
                        this.menuBody.style.height = 0;
                        if (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {
                            this.childComp.style.top = parseInt(this.childComp.style.top) + this._hgt + 'px';
                        }
                        this._time1 = setTimeout(this.animeClassAdd.bind(this), 20)
                    }
                }
                if (this.getMethods('onOpen')) {
                    this.executeMethod('onOpen', this.$node, event, this.$node.element);
                }
            }.bind(this))

        } else {
            this._dontCall = true;
            delete this.$node.element;
            this.setData('ltPropShow', false)
            delete this._dontCall;
            if (this._promReject) {
                this._promReject();
            }
        }
    },

    animeClassAdd: function () {
        this.childComp.classList.add('lyteAnimate');
        this._time2 = setTimeout(this.heightSet.bind(this), 20)
    },

    heightSet: function () {

        var style = window.getComputedStyle(this.menuBody);

        this._transdur = Math.max(400, this.returntran(style.transitionDuration) + this.returntran(style.transitionDelay) + 20);

        // for invert animation
        this._evtadded = true;
        // this.childComp.removeEventListener( 'transitionend', this._trsend )
        this.childComp.addEventListener('transitionend', this._trsend)
        if (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {
            this.childComp.style.top = parseInt(this.childComp.style.top) - this._hgt + 'px';
        }
        // animation start
        this.menuBody.style.height = this._hgt + 'px';
    },

    tranEnd: function (evt) {
        this.childComp.removeEventListener('transitionend', this._trsend)
        this.childComp.classList.remove('lyteAnimate');
        clearTimeout(this._time2);
        clearTimeout(this._time1);
        this.clearFastdom();
        if (this._dont_modify) {
            this.menuBody.style.height = '';
            delete this._dont_modify;
        }
        delete this._openstart;
    },

    clearFastdom: function () {
        $L.fastdom.clear(this._openFastdom);
        $L.fastdom.clear(this._open_fast);
        delete this._open_fast;
        delete this._openFastdom;
    },

    // heightCheck : function(menuBody, bcr, extsYoff, iH ){
    //         if(  !this.data.ltPropSetCss ) {
    //             return
    //         }
    //     // here fastdom is removed for proper on open callback
    //         // menu body properties are required for enable scroll when window size is too small to view full menu body
    //         var clientRect = bcr || menuBody.getBoundingClientRect(), hgt, yoff = extsYoff == undefined ? ( window.pageYOffset || document.documentElement.scrollTop ) : extsYoff,
    //         windowHgt = iH || window.innerHeight;
    //         hgt = clientRect.bottom - clientRect.top;
    //         if(clientRect.bottom > windowHgt)
    //             {
    //                 this.menuBody.style.height = (windowHgt - clientRect.top) + 'px';
    //                 hgt = windowHgt - clientRect.top;
    //             }       
    //         if(clientRect.top < 0)
    //             {
    //                 this.menuBody.style.height = clientRect.bottom + 'px';
    //                 this.childComp.style.top = yoff + 'px';
    //                 hgt = clientRect.bottom;
    //             }   
    //         this._dontCall = true;
    //         this.$node.ltProp('show', true);
    //         delete this._dontCall;
    //         return hgt;
    // },

    composePath: function (event) {
        var arr = [], node = event.target;
        while (node && node.tagName != 'HTML') {
            arr.push(node);
            node = node.parentNode;
        }
        return arr;
    },

    elementsFromPointCal: function (x, y) {
        var arr = [], element = document.elementFromPoint(x, y), prev;
        while (element != document && element != document.documentElement && element != document.body && element.tagName != 'LYTE-MENU-BODY') {
            element._pe = element.style.pointerEvents;
            element.style.pointerEvents = 'none';
            arr.push(element);
            prev = element;
            element = document.elementFromPoint(x, y);
            if (prev == element) {
                break
            }
        }
        for (var i = 0; i < arr.length; i++) {
            arr[i].style.pointerEvents = arr[i]._pe;
            delete arr[i]._pe;
        }
        return arr;
    },

    eligibleForClose: function (_this, target) {
        if (!target) {
            return false;
        }
        if (_this.childComp && _this.childComp.contains(target)) {
            return true;
        }
        if (_this.childMenu) {
            return this.eligibleForClose(_this.childMenu, target);
        }
        return false;
    },

    hoverClose: function (event) {
        if (this.$node) {
            var elements = document.elementsFromPoint ? document.elementsFromPoint(event.clientX, event.clientY) : this.elementsFromPointCal(event.clientX, event.clientY);
            if (elements.indexOf(this.$node.element) == -1 && elements.indexOf(this.childComp) == -1 && !this.eligibleForClose(this, elements[0])) {
                this.hideMenu(true, event);
            }
            // if((document.elementsFromPoint ? document.elementsFromPoint(event.clientX, event.clientY) : this.elementsFromPointCal.call(this, event.clientX, event.clientY)).indexOf(this.$node.element) == -1)
            //     {
            //         this.hideMenu.call(this, true, event);
            //     }
        }
    },

    mouseleave: function (event) {
        var component = this.parent.component, target = component.targetElem.call(component, event.target);
        if (component.childMenu) {
            if (target[1] == component.$node && target[0] != component.childMenu.$node.element && target[0]) {
                this.removeEventListener('mousemove', component.childMenu.mouseleave)
                component.childMenu.hideMenu.call(component.childMenu, true, event)
            }
        }
    },

    hideToggle: function (arg) {
        if (this._dontCall) {
            return;
        }
        if (arg.newValue == false) {
            this.hideMenu(true, {});
        }
        else {
            this.openMenu({}, true);
        }
    }.observes('ltPropShow'),

    hideMenu: function (flag, event, flag2) {
        this.tranEnd();
        var onBeforeClose;
        if (this.childMenu) {
            if (!this.childMenu.childComp.contains(event.target) || flag2) {
                if (!this.childMenu.hideMenu.call(this.childMenu, flag, event, flag2)) {
                    return
                }
            } else {
                return
            }
        }
        if (this.getMethods('onBeforeClose')) {
            onBeforeClose = this.executeMethod('onBeforeClose', this.$node, event);
        }
        if (onBeforeClose != false) {
            this.clearFastdom();
            delete this.__cX; delete this.__cY;
            if (this.parentMenu) {
                delete this.parentMenu.childMenu
                delete this.parentMenu
            }
            else {
                // this.$node.element && this.$node.element.classList.remove(this.getData('ltPropQueryClass'))
                delete document.menu
                window.removeEventListener('scroll', this.addScrollPos, true)
            }
            this._arguments = arguments;
            if (/^(mouseenter|mousemove|mouseover|hover)$/.test(this.data.ltPropEvent) != -1) {
                // this.$node.element.removeEventListener('mousemove', this.preventEvent);
                // this.menuBody.removeEventListener('mousemove', this.preventEvent);
                document.removeEventListener('mousemove', this._hoverclose);
            }
            this._hideStarts = true;
            // $L.fastdom.mutate( function(){
            if (this.menuBody && this.data.ltPropAnimate && this.data.ltPropEvent != 'contextmenu' && this._hgt) {
                this.menuBody.style.height = this._hgt + 'px';
                this.childComp.classList.add('lyteAnimate')// for hide height is set to zero
                // clearTimeout( this.hidetime )
                this._time3 = setTimeout(function () {
                    if (this.menuBody.style.height != '0px') {
                        this.menuBody.style.height = 0;
                        if (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {
                            this.childComp.style.top = parseInt(this.childComp.style.top) + this._hgt + 'px';
                        }
                        this.menuBody.removeEventListener('transitionend', this._close)
                        this.menuBody.addEventListener('transitionend', this._close)
                        this._hidetimeout = setTimeout(this.closing.bind(this, flag, event), this._transdur);
                    } else {
                        this.closing(flag, event);
                    }
                }.bind(this), 20)
            } else {
                delete this._arguments;
                this.closing(flag, event)
            }
            // }.bind(this))
            return true
        } else {
            this._dontCall = true;
            this.setData('ltPropShow', true)
            delete this._dontCall;
            delete this._hideStarts;
            if (this._promReject) {
                this._promReject();
            }
        }
    },

    closing: function () {
        var flag, evt;
        if (this._arguments) {
            flag = this._arguments[0];
            evt = this._arguments[1];
            // height set to its original
            this.menuBody.style.height = this._hgt + 'px';
            delete this._hgt;
            delete this._arguments;
        } else {
            flag = arguments[0];
            evt = arguments[1];
        }
        this.menuBody && this.menuBody.removeEventListener('transitionend', this._close)
        this.childComp.classList.add('lyteMenuHidden')
        delete this._hideStarts;
        this.$node.classList.add('lyteMenuClosed');
        if (this.getData('ltPropFreeze') && !this.parentMenu) {
            this.setZIndex.call(this, flag)
        }
        this._dontCall = true;
        this.$node.ltProp('show', false);
        
        if( this.$node.element ){
            this.$node.element.removeAttribute( 'aria-expanded' );
            this.$node.element.classList.remove( this.getData( 'ltPropQueryClass' ) );
        }
        delete this._dontCall;
        delete this.$node.element; delete this._evtadded;
        this.childComp.classList.remove('lyteAnimate');
        this.childComp.style.left = '';
        this.childComp.style.top = '';
        var selection = this.childComp.querySelector('.lyteMenuSelection')
        if (selection) {
            selection.classList.remove('lyteMenuSelection')
        }
        clearTimeout(this._hidetimeout);
        delete this._hidetimeout;
        $L.fastdom.measure(function () {
            if (this.getMethods('onClose')) {
                this.executeMethod('onClose', this.$node, evt);
            }
            if (this._promResolve) {
                $L.fastdom.mutate(this._promResolve.bind(this))
            }
            this.clearFastdom();
        }.bind(this))
    },

    targetElem: function (nodeName) {
        var currNode;
        nodeName = nodeName.correspondingElement || nodeName;
        while (nodeName && nodeName.tagName != 'LYTE-MENU-BODY' && nodeName.tagName != 'BODY') {
            if (nodeName.tagName == 'LYTE-MENU-ITEM') {
                currNode = nodeName
            }
            nodeName = nodeName.parentNode;
        }
        return [currNode, nodeName ? nodeName.parent : null]
    },

    optionSelect: function (event) {
        var nodeName = this.targetElem.call(this, event.target)[0], flag
        if ((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank') { return false; }
        if (this.getMethods('onMenuClick') && nodeName) {
            var value;
            if (this.getData('ltPropYield')) {
                value = nodeName.getAttribute('data-value')
            }
            else {
                var ltPropContent = this.getData('ltPropContent')
                if (nodeName.hasAttribute('grporder')) {
                    var grp = ltPropContent[parseInt(nodeName.getAttribute('grporder'))]
                    value = grp[Object.keys(grp)[0]][parseInt(nodeName.getAttribute('elemorder'))]
                }
                else {
                    value = ltPropContent[parseInt(nodeName.getAttribute('elemorder'))]
                }
            }
            flag = this.executeMethod('onMenuClick', value, event, this.$node, this.$node.element, { element: nodeName, submenu: !!nodeName.originMenu });
        }
        if (this.childMenu && !flag) {
            event.stopPropagation()
        }
        if (nodeName || (!nodeName && this.getData('ltPropPreventInsideClick'))) {
            lyteCloseMenu(event, undefined, true)
            // this.hideMenu( false, event, true )
        }
    },
    /*
        Calculate left of menu container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
    */
    setLeftExceedForDown: function (element, container, bcr, containerbcr, xscroll, ww) {
        var scrolledLeft = xscroll,
            elementBCR = bcr,
            elementLeft = this.rtlfunc.call(this, 'left', elementBCR, ww),
            elementWidth = elementBCR.width,
            containerBCR = containerbcr,
            containerWidth = containerBCR.width,
            total = scrolledLeft + elementLeft + elementWidth - containerWidth;

        return total
    },
    /*
        Calculate left of menu container when it has to come below/above the select element when it doesn't exceed window.innerWidth
    */
    setLeftNotExceedForDown: function (element, bcr, xscroll, ww) {
        var scrolledLeft = xscroll,
            elementBCR = bcr,
            elementLeft = this.rtlfunc.call(this, 'left', elementBCR, ww),
            total = scrolledLeft + elementLeft;

        return total
    },
    /*
        Calculate top of menu container when it has to come above the select element
    */
    setTopAboveForDown: function (element, container, bcr, containerbcr, yscroll) {
        var scrolledHeight = yscroll,
            elementBCR = bcr,
            elementTop = elementBCR.top,
            containerBCR = containerbcr,
            containerHeight = containerBCR.height,
            total = scrolledHeight + elementTop - containerHeight;

        return total
    },
    /*
        Calculate top of menu container when it has to come below the select element
    */
    setTopBelowForDown: function (element, bcr, yscroll) {
        var scrolledHeight = yscroll,
            elementBCR = bcr,
            elementTop = elementBCR.top,
            elementHeight = elementBCR.height,
            total = scrolledHeight + elementTop + elementHeight;

        return total
    },
    /*
        Calculate left of menu container when it has to come to right of the select element
    */
    setLeftForRight: function (element, bcr, xscroll, ww) {
        var scrolledWidth = xscroll,
            elementBCR = bcr,
            elementLeft = this.rtlfunc.call(this, 'left', elementBCR, ww),
            elementWidth = elementBCR.width,
            total = scrolledWidth + elementLeft + elementWidth;

        return total
    },
    /*
        Calculate right of menu container when it has to come to left of the select element of right menu
    */
    setRightForRight: function (element, container, bcr, elembcr, xscroll, ww) {
        var scrolledWidth = xscroll,
            elementBCR = bcr,
            containerBCR = elembcr,
            elementLeft = this.rtlfunc.call(this, 'left', elementBCR, ww),
            containerWidth = containerBCR.width,
            total = scrolledWidth + elementLeft - containerWidth;

        return total
    },
    /*
        Calculate top of menu container when it has to come to right of menu and there is space below
    */
    setTopForRight: function (element, bcr, yscroll) {
        var scrolledHeight = yscroll,
            elementBCR = bcr,
            elementTop = elementBCR.top,
            total = scrolledHeight + elementTop;

        return total
    },
    /*
        Calculate top of menu container when it has to come to right of menu and there is no space below
    */
    setTopForRightAbove: function (element, container, bcr, elembcr, yscroll) {
        var scrolledHeight = yscroll,
            elementBCR = bcr,
            elementTop = elementBCR.top,
            elementHeight = elementBCR.height,
            containerBCR = elembcr,
            containerHeight = containerBCR.height,
            total = scrolledHeight + elementTop + elementHeight - containerHeight;

        return total
    },
    /**
        Remove wrong arrow and append proper arrow
        @param string correct - the correct class
    */
    setCorrectClass: function (cls) {
        var arrow = this.childComp.querySelector('.lyteArrow'),
            list = arrow.classList, i = 0;
        for (; i < list.length; i++) {
            if (list[i] == 'lyteArrow' || list[i] == cls) {
                continue;
            }
            else {
                arrow.classList.remove(list[i]);
                i--;
            }
        }

        arrow.classList.add(cls);
    },

    /**
     * Set the CSS for your menu
     * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
     * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
     */
    setCss: function (onlyScroll) {
        var link = this.childComp;

        if (!link
            || link.classList.contains('lyteMenuHidden') || !this.getData('ltPropSetCss')
        ) {
            return;
        }

        // Get properties
        var callout = this.getData('ltPropCallout');


        // Get button
        var body = link,
            par = this.$node.element;

        // Get Geometric propotions
        var wwidth, wheight, wleft, wtop, iwdt = window.innerWidth;
        var query = this.getData('ltPropScope'), flag;
        if (query) {
            var temp = { target: par };
            var elemm = this.closestFind.call(this, this.composePath.call(this, temp), query);
            if (elemm) {
                var rec = elemm.getBoundingClientRect();
                wleft = this.rtlfunc.call(this, 'left', rec, iwdt) < 0 ? 0 : this.rtlfunc.call(this, 'left', rec, iwdt);
                wwidth = iwdt > this.rtlfunc.call(this, 'right', rec, iwdt) ? this.rtlfunc.call(this, 'right', rec, iwdt) : iwdt;
                flag = true
            }
        }
        if (!flag) {
            wwidth = iwdt;
            wleft = 0;
        }
        var wheight = window.innerHeight;
        var wtop = 0,
            drop = body.getBoundingClientRect(),
            menuBodyBcr = this.menuBody.getBoundingClientRect(),
            menuBodystyle = window.getComputedStyle(this.menuBody),
            padding = (menuBodystyle.boxSizing == 'content-box' ? (parseFloat(menuBodystyle.paddingTop) + parseFloat(menuBodystyle.borderTopWidth) + parseFloat(menuBodystyle.borderBottomWidth) + parseFloat(menuBodystyle.paddingBottom)) : 0),
            bodyHeight = menuBodyBcr.height - padding,
            x = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? - 1 : 1),
            y = window.pageYOffset || document.documentElement.scrollTop,
            height = body.offsetHeight,
            width = body.offsetWidth,
            arrow = link.querySelector('.lyteArrow'),
            position = this.getData('ltPropPosition'),
            offsets = par.getBoundingClientRect(),
            arrowBcr = arrow ? arrow.getBoundingClientRect() : { width: 0, height: 0 },
            aHeight = arrowBcr.height / 2,
            aWidth = arrowBcr.width / 2,
            offset = this.data.ltPropOffset || {};

        if (offset.left) {
            wleft += offset.left;
        }
        if (offset.top) {
            wtop += offset.top;
        }
        if (offset.right) {
            wwidth -= offset.right;
        }
        if (offset.bottom) {
            wheight -= offset.bottom;
        }

        // Intialize flags
        var downPos,
            rightPos,
            topPos,
            leftPos;

        // temp stores
        var tempStore,
            tempTop,
            tempLeft,
            tempMarginLeft,
            tempMarginTop,
            tempNum,
            tempDenom,
            pos,
            tempPer,
            oL = this.rtlfunc.call(this, 'left', offsets, iwdt),
            lT = this.rtlfunc.call(this, 'left');

        if (arrow) {
            arrow.style.removeProperty('left');
            arrow.style.removeProperty('top');
            arrow.style.removeProperty('bottom');
            arrow.style.removeProperty('right')
        }
        if (position === 'down') {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if (tempTop + height > wheight
                /*&& offsets.top > height */
            ) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            rightPos = true;
            tempLeft = oL;
            if (tempLeft + width > wwidth
                && tempLeft > tempLeft + offsets.width - body.offsetWidth
            ) {
                rightPos = false;

            }
            else if (oL + width <= wwidth) {
                rightPos = true;
            }

            if (offsets.width > width && arrow) {
                arrow.style[lT] = ((width / 2 - 0) / width) * 100 + "%";
            }

            if (downPos) {
                pos = 'down'
                if (callout) {
                    this.setCorrectClass('lyteArrowTop');
                    tempStore = this.setTopBelowForDown(par, offsets, y) + aHeight + 'px';
                }
                else {
                    body.style.top = this.setTopBelowForDown(par, offsets, y) + 'px';
                }

            }
            else {
                pos = 'up';
                if (callout) {
                    this.setCorrectClass('lyteArrowBottom');
                    tempStore = this.setTopAboveForDown(par, body, offsets, drop, y) - aHeight + 'px';
                }
                else {
                    body.style.top = this.setTopAboveForDown(par, body, offsets, drop, y) + 'px';
                }
            }

            if (rightPos) {
                if (callout) {
                    tempNum = Math.max(Math.min(offsets.width, width) / 2 - aWidth, aWidth / 2); // We removed arrow.offsetWidth because it was giving width as 0 px
                    tempDenom = width / 100;
                    tempPer = tempNum / tempDenom;
                    arrow.style[lT] = tempPer + '%';
                }

                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[lT] = this.setLeftNotExceedForDown(par, offsets, x, iwdt) + 'px';
            }
            else {
                if (callout) {
                    tempDenom = width / 100;
                    tempNum = width - (Math.min(offsets.width, width) / 2) - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
                    tempPer = tempNum / tempDenom;
                    arrow.style[lT] = tempPer + '%';
                }

                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[lT] = this.setLeftExceedForDown(par, body, offsets, drop, x, iwdt) + 'px'
            }


        }
        else if (position === 'right') {
            rightPos = true;
            if (oL + offsets.width + width > wwidth
                && oL - drop.width > wleft
            ) {
                rightPos = false;

            }
            else {
                rightPos = true;
            }

            downPos = true;
            if (offsets.top + drop.height > wheight) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }

            if (rightPos) {
                pos = 'right';
                if (callout) {
                    this.setCorrectClass('lyteArrowLeft');
                    tempStore = this.setLeftForRight(par, offsets, x, iwdt) + aWidth + 'px';
                }
                else {
                    body.style[lT] = this.setLeftForRight(par, offsets, x, iwdt) + 'px'
                }
            }
            else {
                pos = 'left';
                if (callout) {
                    this.setCorrectClass('lyteArrowRight');
                    tempStore = (this.setRightForRight(par, body, offsets, drop, x, iwdt) - aWidth) + 'px';
                }
                else {
                    body.style[lT] = this.setRightForRight(par, body, offsets, drop, x, iwdt) + 'px';
                }
            }

            if (downPos) {
                if (callout) {
                    arrow.style.top = Math.max(offsets.height / 2 - aHeight, aHeight / 2) + 'px';
                }

                body.style[lT] = tempStore ? tempStore : body.style[lT];
                body.style.top = this.setTopForRight(par, offsets, y, iwdt) + 'px'
            }
            else {
                if (callout) {
                    arrow.style.bottom = Math.max(offsets.height / 2 - aHeight, aHeight / 2) + 'px';
                }

                body.style[lT] = tempStore ? tempStore : body.style[lT];
                body.style.top = this.setTopForRightAbove(par, body, offsets, drop, y, iwdt) + 'px'
            }
        }
        else if (position === 'up') {
            topPos = true
            if (offsets.top - drop.height < wtop
                /*&& offsets.top + offsets.height + height < wheight */
            ) {
                topPos = (wheight - offsets.top) < (offsets.bottom - wtop)
            }

            rightPos = true
            if (oL + width > wwidth
                && oL > oL + offsets.width - body.offsetWidth
            ) {
                rightPos = false
            }
            else if (oL + width <= wwidth) {
                rightPos = true
            }

            if (offsets.width > width && arrow) {
                arrow.style[lT] = ((width / 2 - 0) / width) * 100 + '%';
            }

            if (topPos) {
                pos = 'up';
                if (callout) {
                    this.setCorrectClass('lyteArrowBottom');
                    tempStore = this.setTopAboveForDown(par, body, offsets, drop, y) - aHeight + 'px';
                }
                else {
                    body.style.top = this.setTopAboveForDown(par, body, offsets, drop, y) + 'px';
                }
            }
            else {
                pos = 'down';
                if (callout) {
                    this.setCorrectClass('lyteArrowTop');
                    tempStore = this.setTopBelowForDown(par, offsets, y) + aHeight + 'px';
                }
                else {
                    body.style.top = this.setTopBelowForDown(par, offsets, y, iwdt) + 'px'
                }
            }
            if (rightPos) {
                if (callout) {
                    tempNum = Math.max(Math.min(offsets.width, width) / 2 - aWidth, aWidth / 2); // We removed arrow.offsetWidth because it was giving width as 0 px
                    tempDenom = width / 100;
                    tempPer = tempNum / tempDenom;
                    arrow.style[lT] = tempPer + '%'
                }

                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[lT] = this.setLeftNotExceedForDown(par, offsets, x, iwdt) + 'px';
            }
            else {
                if (callout) {
                    tempDenom = width / 100;
                    tempNum = width - (Math.min(offsets.width, width) / 2) - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
                    tempPer = tempNum / tempDenom;
                    arrow.style[lT] = tempPer + '%';
                }

                body.style.top = tempStore ? tempStore : body.style.top;
                body.style[lT] = this.setLeftExceedForDown(par, body, offsets, drop, x, iwdt) + 'px';
            }
        }
        else if (position === 'left') {
            leftPos = true;
            if (oL - drop.width < wleft
                && oL + drop.width < wwidth
            ) {
                leftPos = false;
            }
            else {
                leftPos = true;
            }

            downPos = true;
            if (offsets.top + drop.height > wheight) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }

            if (leftPos) {
                pos = 'left';
                if (callout) {
                    this.setCorrectClass('lyteArrowRight');
                    tempStore = (this.setRightForRight(par, body, offsets, drop, x, iwdt) - aWidth) + 'px';
                }
                else {
                    body.style[lT] = this.setRightForRight(par, body, offsets, drop, x, iwdt) + 'px';
                }
            }
            else {
                pos = 'right';
                if (callout) {
                    this.setCorrectClass('lyteArrowLeft');
                    tempStore = (this.setLeftForRight(par, offsets, x, iwdt) + aWidth) + 'px';
                }
                else {
                    body.style[lT] = this.setLeftForRight(par, offsets, x) + 'px';
                }
            }
            if (downPos) {
                if (callout) {
                    arrow.style.top = Math.max(offsets.height / 2 - aHeight, aHeight / 2) + 'px';
                }

                body.style[lT] = tempStore ? tempStore : body.style[lT];
                body.style.top = this.setTopForRight(par, offsets, y) + 'px';
            }
            else {
                if (callout) {
                    arrow.style.bottom = Math.max(offsets.height / 2 - aHeight, aHeight / 2) + 'px';
                }

                body.style[lT] = tempStore ? tempStore : body.style[lT];
                body.style.top = this.setTopForRightAbove(par, body, offsets, drop, y) + 'px';
            }
        } else if (position === 'downLeft') {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if (tempTop + height > wheight /*&& offsets.top > height*/) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            if (!downPos) {
                tempTop = offsets.top - height;
            }
            rightPos = false

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.max(oL + offsets.width / 2 - width, oL - width + 2 * aHeight);
            if (tempLeft < wleft) {
                tempLeft = wleft
                rightPos = true
            } else {
                rightPos = false
            }
            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = (oL + 0.25 * offsets.width - tempLeft) + 'px';
                } else {
                    newArrowLeft = Math.min(width - 0.25 * offsets.width, width - (aHeight * 1.5) - 3) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downLeft';
            } else {
                pos = 'upLeft';
            }

        } else if (position === 'downRight') {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if (tempTop + height > wheight /*&& offsets.top > height*/) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }

            if (!downPos) {
                tempTop = offsets.top - height
            }

            rightPos = true

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.min(oL + offsets.width / 2, oL + offsets.width - 2 * aHeight);
            if (tempLeft + width > wwidth) {
                tempLeft = wwidth - width;
                rightPos = false;
            } else {
                rightPos = true;
            }

            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = Math.max(0.25 * offsets.width, aWidth / 2) + 'px';
                } else {
                    newArrowLeft = (oL + 0.25 * offsets.width - tempLeft) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downRight';
            } else {
                pos = 'upRight';
            }
        } else if (position === 'upLeft') {
            downPos = false;
            tempTop = offsets.top - height;
            if (tempTop < wtop) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            if (downPos) {
                tempTop = offsets.top + offsets.height;
            }
            rightPos = false
            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.max(oL + offsets.width / 2 - width, oL - width + 2 * aHeight);
            if (tempLeft < wleft) {
                tempLeft = wleft
                rightPos = true
            } else {
                rightPos = false
            }
            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = (oL + 0.25 * offsets.width - tempLeft) + 'px';
                } else {
                    newArrowLeft = Math.min(width - 0.25 * offsets.width, width - (aHeight * 1.5) - 3) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downLeft';
            } else {
                pos = 'upLeft';
            }

        } else if (position === 'upRight') {
            downPos = false;
            tempTop = offsets.top - height;
            if (tempTop < wtop) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            if (downPos) {
                tempTop = offsets.top + offsets.height
            }

            rightPos = true

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.min(oL + offsets.width / 2, oL + offsets.width - 2 * aHeight);
            if (tempLeft + width > wwidth) {
                tempLeft = wwidth - width;
                rightPos = false;
            } else {
                rightPos = true;
            }

            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = Math.max(0.25 * offsets.width, aWidth / 2) + 'px';
                } else {
                    newArrowLeft = (oL + 0.25 * offsets.width - tempLeft) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downRight';
            } else {
                pos = 'upRight';
            }
        } else if (position === 'downAlignLeft') {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if (tempTop + height > wheight /*&& offsets.top > height*/) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }

            if (!downPos) {
                tempTop = offsets.top - height
            }

            rightPos = false

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.max(oL + offsets.width - width, oL - width + 2 * aHeight);
            if (tempLeft < wleft) {
                tempLeft = Math.max(Math.min(oL, oL + offsets.width - 2 * aHeight), wleft)
                rightPos = true
            } else {
                tempLeft = Math.min(wwidth - width, tempLeft)
                rightPos = false
            }
            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = (offsets.right - tempLeft) / 2 + 'px';
                } else {
                    newArrowLeft = Math.min((oL - tempLeft + Math.max(width, offsets.width)) / 2, Math.max(width, offsets.width) - (aHeight * 1.5) - 3) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downAlignLeft';
            } else {
                pos = 'upAlignLeft';
            }

        } else if (position === 'downAlignRight') {
            downPos = true;
            tempTop = offsets.top + offsets.height;
            if (tempTop + height > wheight /*&& offsets.top > height*/) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }

            if (!downPos) {
                tempTop = offsets.top - height;
            }

            rightPos = true

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.min(oL, oL + offsets.width - 2 * aHeight);
            if (tempLeft + width > wwidth) {
                tempLeft = Math.min(Math.max(oL + offsets.width - width, oL - width + 2 * aHeight), wwidth - width);
                rightPos = false;
            } else {
                tempLeft = Math.max(tempLeft, 0)
                rightPos = true;
            }

            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = Math.max(0.5 * (Math.min(this.rtlfunc.call(this, 'right', offsets, iwdt) - tempLeft, width) - aWidth), aWidth / 2) + 'px';
                } else {
                    newArrowLeft = (0.5 * (-tempLeft + width + oL)) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downAlignRight';
            } else {
                pos = 'upAlignRight';
            }
        } else if (position === 'upAlignLeft') {
            downPos = false;
            tempTop = offsets.top - height;
            if (tempTop < wtop) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            if (downPos) {
                tempTop = offsets.top + offsets.height;
            }
            rightPos = false
            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.max(oL + offsets.width - width, oL - width + 2 * aHeight);
            if (tempLeft < wleft) {
                tempLeft = Math.max(Math.min(oL, oL + offsets.width - 2 * aHeight), wleft)
                rightPos = true
            } else {
                tempLeft = Math.min(wwidth - width, tempLeft)
                rightPos = false
            }
            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = (offsets.right - tempLeft) / 2 + 'px';
                } else {
                    newArrowLeft = Math.min((oL - tempLeft + Math.max(width, offsets.width)) / 2, Math.max(width, offsets.width) - (aHeight * 1.5) - 3) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downAlignLeft';
            } else {
                pos = 'upAlignLeft';
            }
        } else if (position === 'upAlignRight') {
            downPos = false;
            tempTop = offsets.top - height;
            if (tempTop < wtop) {
                downPos = (wheight - offsets.top) > (offsets.bottom - wtop);
            }
            if (downPos) {
                tempTop = offsets.top + offsets.height;
            }
            rightPos = true

            if (callout) {
                this.setCorrectClass(downPos ? 'lyteArrowTop' : 'lyteArrowBottom');
            }
            tempLeft = Math.min(oL, oL + offsets.width - 2 * aHeight);
            if (tempLeft + width > wwidth) {
                tempLeft = Math.min(Math.max(oL + offsets.width - width, oL - width + 2 * aHeight), wwidth - width);
                rightPos = false;
            } else {
                tempLeft = Math.max(tempLeft, wleft)
                rightPos = true;
            }

            body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

            body.style[lT] = tempLeft + x + 'px';
            if (callout) {
                var newArrowLeft;
                if (rightPos) {
                    newArrowLeft = Math.max(0.5 * (Math.min(this.rtlfunc.call(this, 'right', offsets, iwdt) - tempLeft, width) - aWidth), aWidth / 2) + 'px';
                } else {
                    newArrowLeft = (0.5 * (-tempLeft + width + oL)) + 'px';
                }
                arrow.style[lT] = newArrowLeft;
            }
            if (downPos) {
                pos = 'downAlignRight';
            } else {
                pos = 'upAlignRight';
            }
        }
        if (parseFloat(body.style.top) - y + bodyHeight > wheight && offsets.top <= wheight) {
            this.menuBody.style.height = (wheight - parseFloat(body.style.top) + y - padding) + 'px';
            bodyHeight = parseFloat(this.menuBody.style.height);
            this._dont_modify = true;
        }
        if (parseFloat(body.style.top) - y < wtop && offsets.bottom >= wtop) {
            this.menuBody.style.height = (parseFloat(body.style.top) - y + bodyHeight - wtop) + 'px';
            body.style.top = (wtop + y) + 'px';
            bodyHeight = parseFloat(this.menuBody.style.height);
            this._dont_modify = true;
        }

        this._hgt = bodyHeight;

        if (body.classList.contains('lyteHoverMenu')) {
            $L(body).removeClass("topPlace", "bottomPlace", "rightPlace", "leftPlace");
            if (/up/.test(pos)) {
                body.classList.add('topPlace');
            } else if (/down/.test(pos)) {
                body.classList.add('bottomPlace');
            } else if (/right/.test(pos)) {
                body.classList.add('rightPlace');
            } else if (/left/.test(pos)) {
                body.classList.add('leftPlace');
            }
        }
        if (downPos) {
            $L(this.childComp).removeClass('lyteMenuUp').addClass('lyteMenuDown');
        } else {
            $L(this.childComp).removeClass('lyteMenuDown').addClass('lyteMenuUp');
        }
        this.setData('pos', pos);
    },

    returntran: function (prop) {
        var ret = 0;
        if (/\d+/.test(prop || '')) {
            var match = prop.match(/(\d+)(s|ms){0,}$/);
            ret = parseFloat(prop) * (match[2] == "s" ? 1000 : 1);
        }
        return ret;
    },

    checkForBoundary: function (clientRect, ww) {
        // var clientRect = this.$node.element.getBoundingClientRect(), ww = window.innerWidth;
        var boundary = this.getData('ltPropBoundary');
        if ((boundary.hasOwnProperty('left') ? (this.rtlfunc.call(this, 'left', clientRect, ww) < this.rtlfunc.call(this, 'left', boundary, ww)) : false) || (boundary.hasOwnProperty('right') ? (this.rtlfunc.call(this, 'right', clientRect, ww) > this.rtlfunc.call(this, 'right', boundary, ww)) : false) || (boundary.hasOwnProperty('top') ? (clientRect.top < boundary.top) : false) || (boundary.hasOwnProperty('bottom') ? (clientRect.bottom > boundary.bottom) : false)) {
            this.hideMenu.call(this);
        }
    },

    traverseList: function (event) {
        var kc = event.keyCode || event.which;
        if ((this.childComp && this.childComp.classList.contains('lyteMenuHidden')) || (kc != 13 && kc != 40 && kc != 38 && kc != 36 && kc != 35)) {
            return
        }
        var cursel = this.childComp.querySelector('.lyteMenuSelection')
        if (!cursel || !cursel.offsetParent) {
            if (kc != 35) {
                var elem = this.childComp.querySelector('lyte-menu-item:not(.lyteSearchHidden)')
                if (elem && elem.offsetParent) {
                    elem.classList.add('lyteMenuSelection')
                    return;
                }
            } else {
                $L('lyte-menu-item:not(.lyteSearchHidden)', this.childComp).eq(-1).addClass('lyteMenuSelection');
            }
        }

        var elements = this.childComp.querySelectorAll('lyte-menu-item:not(.lyteSearchHidden)')
        for (var i = 0; i < elements.length; i++) {
            if (!elements[i].offsetParent) {
                continue;
            }
            if (elements[i].classList.contains('lyteMenuSelection')) {
                break;
            }
        }

        if (!elements[i]) {
            return;
        }

        if (kc == 13) {
            elements[i].dispatchEvent(new Event('click', { bubbles: true }))
            event.preventDefault()
        }
        else if (kc == 38 && i != 0) {
            var j = i
            i = i - 1
            for (; i > -1; i--) {
                if (!elements[i].classList.contains('lyteMenuActive') && !elements[i].classList.contains('lyteMenuFiltered') && elements[i].offsetParent) {
                    break;
                }
            }
            if (i != -1) {
                elements[j].classList.remove('lyteMenuSelection')
                elements[i].classList.add('lyteMenuSelection')
                this.scrIntoView.call(this, elements[i])
            }
        }
        else if (kc == 40 && i != elements.length - 1) {
            var j = i
            i = i + 1
            for (; i < elements.length; i++) {
                if (!elements[i].classList.contains('lyteMenuActive') && !elements[i].classList.contains('lyteMenuFiltered') && elements[i].offsetParent) {
                    break;
                }
            }
            if (i != elements.length) {
                elements[j].classList.remove('lyteMenuSelection')
                elements[i].classList.add('lyteMenuSelection')
                this.scrIntoView.call(this, elements[i])
            }
        } else if (kc == 36 && elements.length && this.data.ltPropAria) {
            if (cursel == elements[0]) {
                return;
            }
            cursel.classList.remove('lyteMenuSelection');
            elements[0].classList.add('lyteMenuSelection');
            this.scrIntoView.call(this, elements[0])
        } else if (kc == 35 && elements.length && this.data.ltPropAria) {
            if (cursel == $L(elements).get(-1)) {
                return;
            }
            cursel.classList.remove('lyteMenuSelection');
            $L(elements).get(-1).classList.add('lyteMenuSelection');
            this.scrIntoView.call(this, $L(elements).get(-1));
        }
    },
    setFreeze: function (nodeName) {
        var fz = document.body.querySelectorAll('.lytemenufreezelayer:not(.nogroup)')
        // freeze bound calculation
        $L.fastdom.measure(function () {
            var node = document.body.querySelector('.lytemenufreezelayer.left'), rect = nodeName.getBoundingClientRect(),
                iwdt = window.innerWidth
            $L.fastdom.mutate(function () {
                node.style.height = rect.height + "px"
                node.style.width = Math.max(rect.left, 0) + "px"
                node.style.top = rect.top + "px"
                node = document.body.querySelector('.lytemenufreezelayer.right')
                node.style.height = rect.height + "px"
                node.style.width = Math.max(iwdt - rect.right, 0) + "px"
                node.style.top = rect.top + "px"
                node = document.body.querySelector('.lytemenufreezelayer.top')
                node.style.height = rect.top + "px"
                node = document.body.querySelector('.lytemenufreezelayer.bottom')
                node.style.height = (window.innerHeight - rect.bottom) + "px"
                for (var i = 0; i < fz.length; i++) {
                    fz[i].classList.remove('lyteMenuHidden')
                    fz[i].addEventListener('wheel', this.preventEvent);
                    fz[i].addEventListener('touchmove', this.preventEvent);
                }
            }.bind(this))
        }.bind(this))
    },
    preventEvent: function (event) {
        if (!(event.metaKey || event.shiftKey || event.ctrlKey)) {
            var isTch = event.type == "touchmove";
            if (isTch && event.touches.length != 1) {
                return;
            }
            if (event.type == 'wheel' || isTch) {
                event.stopImmediatePropagation()
            }
            event.preventDefault();
            event.stopPropagation();
        }
    },
    addScrollPos: function (event) {
        if (!document.menu) {
            return
        }
        if (event.target != window && (document.menu.childComp.contains(event.target))) {
            return
        }
        var component = document.menu;
        component.callScrollFunc(event, true);

    },
    removeFreeze: function () {
        if (!document.menu || (this.data.ltPropAnimate && this.data.ltPropFreeze)) {
            var fz = document.body.querySelectorAll('.lytemenufreezelayer')
            for (var i = 0; i < fz.length; i++) {
                fz[i].classList.add('lyteMenuHidden');
                fz[i].removeEventListener('wheel', this.preventEvent);
            }
            document.body.classList.remove('lyteBodyWrapper');
        }
    },
    setZIndex: function (flag) {
        var nodeName = this.$node.element;
        if (nodeName) {
            while (nodeName && nodeName.tagName != 'HTML') {
                if (nodeName.classList.contains('lyteMenuGroup')) {
                    if (!flag) {
                        this.setFreeze.call(this, nodeName)
                        document.body.classList.add('lyteBodyWrapper');
                    }
                    else {
                        this.removeFreeze.call(this)
                    }
                    break
                }
                else {
                    nodeName = nodeName.parentNode;
                }
            }
            if (nodeName && nodeName.tagName == 'HTML' || !nodeName) {
                if (flag && (!document.menu || (document.menu && !document.menu.data.ltPropFreeze))) {
                    this.removeFreeze.call(this)
                }
                else {
                    var freezeLayer = document.body.querySelector('.lytemenufreezelayer.nogroup');
                    freezeLayer.classList.remove('lyteMenuHidden');
                    document.body.classList.add('lyteBodyWrapper');
                }
            }
        }

    },

    ariaObs: function (arg) {
        this.data.ltPropAria && _lyteUiUtils.setAttribute(this.childComp, this.data.ltPropAriaAttributes || {}, arg ? arg.oldValue : {})
    }.observes('ltPropAriaAttributes', 'ltPropAriaAttributes.{}').on('didConnect'),

    callScrollFunc: function (evt, callBoundary) {
        var comp = this,
            menubody = comp.menuBody,
            height = menubody.style.height.indexOf('px') != -1,
            boundaryKeys = Object.keys(this.data.ltPropBoundary || {}).length,
            bcr = callBoundary && boundaryKeys && comp.$node.element ? comp.$node.element.getBoundingClientRect() : undefined,
            ww = callBoundary && boundaryKeys && comp.$node.element ? window.innerWidth : undefined,
            given = comp.$node.ltProp('height'),
            allowreset = this.data.ltPropHeightResetOnScroll,
            isContext = comp.$node.ltProp('event') == 'contextmenu';
        if (height && allowreset) {
            menubody.style.height = given || '';
            callBoundary && boundaryKeys && $L.fastdom.measure(comp.checkForBoundary.bind(comp, bcr, ww));
            $L.fastdom.measure(comp[isContext ? 'setContextCss' : 'setCss'].bind(comp, evt));
        } else {
            comp[isContext ? 'setContextCss' : 'setCss'](evt);
            callBoundary && boundaryKeys && comp.checkForBoundary(bcr, ww);
        }
        if (comp.childMenu) {
            comp.childMenu.callScrollFunc();
        }
    }
});

var lyteCloseMenu = function (event, element, flag) {
    if (document._lyteMenu.preventClick != false || element) {
        if ((event && event.button != 2) || element || flag) {
            var menus = document.body.querySelectorAll('lyte-menu:not(.lyteMenuClosed)[lyte-rendered]');
            for (var i = 0; i < menus.length; i++) {
                if (menus[i] != element && !menus[i].component.childComp.classList.contains('lyteMenuHidden')) {
                    if (flag || (!menus[i].component.childComp.contains(event.target))) {
                        if (!menus[i].component._hideStarts) {
                                                /*var ret =*/ menus[i].component.hideMenu.call(menus[i].component, element ? false : true, event, flag)
                            // if( ret ){
                            //     menus[i].component._hideStarts = true
                            // }
                        }
                    }
                }
            }
        }
    }
    if (event && event.type == 'click') {
        document._lyteMenu.preventClick = true;
    }
};

if (!_lyteUiUtils.registeredCustomElements['lyte-menu-item']) {

    _lyteUiUtils.registeredCustomElements['lyte-menu-item'] = true;

    function menukeypress(evt) {
        var menus = document.querySelectorAll('lyte-menu:not(.lyteMenuClosed)[lyte-rendered]');
        for (var i = 0; i < menus.length; i++) {
            var _this = menus[i].component;
            if (!_this.childMenu) {
                _this._typed = _this._typed || '';
                _this._typed += String.fromCharCode(evt.which || evt.keyCode);
                clearTimeout(_this._typetime);
                _this._typetime = setTimeout(_this.searchFilter.bind(_this, _this._typed.trim().toLowerCase()), 400)
                break;
            }
        }
    }

    /**
     * @customElement lyte-menu-item,
     *                lyte-menu-body,
     *                lyte-menu-description,
     *                lyte-menu-label,
     *                lyte-menu-group,
     *                lyte-menu-header
     */
    Lyte.createCustomElement("lyte-menu-item", {
        static: {
            "observedAttributes": {
                get: function () {
                    return ['lyte-shortcut'];
                }
            }
        },
        "attributeChangedCallback": function (attributeName, oldValue, newValue) {
            if (typeof shortcut == "function") {
                if (!newValue) {
                    return;
                }
                newValue = JSON.parse(newValue);
                var newKey = newValue.key;
                var type = newValue.type;
                var wait = newValue.wait;
                if (!oldValue) {
                    oldValue = {};
                }
                else {
                    oldValue = JSON.parse(oldValue)
                }
                shortcut.push({
                    newKey: newKey,
                    type: type,
                    wait: wait,
                    oldKey: oldValue.key,
                    value: this
                });
            }
        },

        connectedCallback: function () {
            var closestBody = $L(this).closest('lyte-menu-box').get(0);
            if (closestBody && closestBody.parent) {
                var aria = closestBody.parent.ltProp('aria');
                if (aria) {
                    $L(this).attr('role', 'menuitem')
                }
            }
        },

        disconnectedCallback: function () {
            var curValue = this.getAttribute('lyte-shortcut');
            if (curValue) {
                this.setAttribute('lyte-shortcut', JSON.stringify({}));
            }
        }
    });
}

/**
 * @syntax nonYielded
 * <lyte-menu  lt-prop-content='[{"label" : "Open File", "description" : "Ctrl + O"},{"label" : "New File", "description" : "Ctrl + N"},{"label" : "Save File", "description" : "Ctrl + S"}]' lt-prop-user-value = 'label' lt-prop-description = 'description' lt-prop-event="click" ></lyte-menu>
 */

/**
 * @syntax yielded
 * <lyte-menu lt-prop-yield="true"  lt-prop-event='click' >
 *   <template is="registerYield" yield-name="yield">
 *      <lyte-menu-body>
 *          <lyte-menu-item data-value = "1">
 *               <lyte-menu-label >
 *                   New File
 *               </lyte-menu-label>
 *          <lyte-menu-item>
 *          <lyte-menu-item data-value = "2">
 *              <lyte-menu-label >
 *                  Open File
 *              </lyte-menu-label>
 *           </lyte-menu-item>
 *           <lyte-menu-item data-value = "3">
 *              <lyte-menu-label >
 *                  Save File
 *              </lyte-menu-label>
 *           </lyte-menu-item>
 *     </lyte-menu-body>
 *   </template>
 * </lyte-menu>
 */
/**
 * Renders a messagebox
 * @component lyte-messagebox
 * @version 1.0.0
 * @dependencies lyte-wormhole
 * @methods onClose
 */

Lyte.Component.register("lyte-messagebox", {
_template:"<template tag-name=\"lyte-messagebox\"> <template is=\"if\" value=\"{{ltPropShow}}\"> <template case=\"true\"><lyte-wormhole style=\"visibility: hidden\" on-before-append=\"{{method(&quot;beforeWormholeAppend&quot;)}}\" on-append=\"{{method(&quot;afterWormholeAppend&quot;)}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"{{lyteUiMsgBoxConcatClass(ltPropClass,ltPropType,'MessageIcon','lyteMessageBox')}}\"> <template is=\"if\" value=\"{{ltPropType}}\"><template case=\"true\"> <span class=\"lyteMessageBoxSymbol\"></span> </template></template> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <span class=\"lyteMessageBoxContent\"> <lyte-yield yield-name=\"messageboxYield\"></lyte-yield> </span> </template><template case=\"false\"> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropMessage,'')}}\"> <template case=\"false\"><div> <span class=\"lyteMessageBoxContent\">{{ltPropMessage}}</span> </div></template> </template> </template></template> <span class=\"lyteMessageBoxClose\" onclick=\"{{action('closeMessageBox')}}\"></span> </div> </template> </lyte-wormhole></template> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1,1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,5]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropShow","ltPropMessage","ltPropDuration","ltPropOffset","ltPropTransition","ltPropYield","ltPropClass","ltPropCloseManually"],
    init : function() {

    },
    data : function(){
        return {

            /**
             * @componentProperty {success | error | warning | info} ltPropType
             * @version 1.0.0
             * @default success
             */
            "ltPropType":Lyte.attr("string",{"default":"success"}),

            /**
             * @componentProperty {boolean} ltPropShow
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropShow":Lyte.attr("boolean",{"default":false}),

            /**
             * @componentProperty {string} ltPropMessage
             * @version 1.0.0
             */
            "ltPropMessage":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropDuration
             * @version 1.0.0
             * @default 2000
             */
            "ltPropDuration":Lyte.attr("string",{"default":"2000"}),
            /**
             * @typedef {object} offset
             * @property {string} left="center"
             * @property {string} top="center"
             * @property {string} right
             * @property {string} bottom
             */
            /**
             * @componentProperty {offset} ltPropOffset
             * @version 1.0.0
             */
            "ltPropOffset":Lyte.attr("object",{"default":null}),

            /**
             * @typedef {object} transition
             * @property {slideFromTop | fadeIn} animation="fadeIn"
             * @property {string} duration
             */
            /**
             * @componentProperty {transition} ltPropTransition
             * @version 1.0.0
             * @default { "animation" : "fadeIn", "duration" :"0.2s"}
             */
            "ltPropTransition":Lyte.attr("object",{"default":{"animation" : "fadeIn","duration" : "0.2s"}}),

            /**
             * @componentProperty {boolean} ltPropYield
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropYield":Lyte.attr("boolean",{"default" : false}),

            /**
             * @componentProperty {string} ltPropClass
             * @version 1.0.0
             */
            "ltPropClass":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {boolean} ltPropCloseManually
             * @version 3.0.X
             */
            "ltPropCloseManually":Lyte.attr("boolean",{"default": false})
        }
    },
    setDuration : function(){
        var durationVal = this.$node.ltProp("duration");
        if(durationVal != ""){
            this.setData("ltPropDuration",durationVal);
        }
    }.observes('ltPropDuration'),

    computeOffsetImpl : function(){
        var messageEle = this.actualMessageDiv;
        this.fastdomfn1 = $L.fastdom.measure(function(){
            delete this.fastdomfn1;
            var messageElePosition = messageEle.getBoundingClientRect();
            // var offsetObj = this.$node.ltProp('offset');
            var offsetObj = Object.assign({},this.$node.ltProp('offset'));
            //console.log(offsetObj);

            var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

            if(this.$node.ltProp('offset')){
                if(offsetObj.left === "center" || offsetObj.right === "center" || offsetObj.left == undefined || offsetObj.left == ""){
                    var offLeft = (w - messageElePosition.width)/2;
                    if(offLeft < 0){
                        offLeft = 20;
                    }
                    offsetObj.left = offLeft + "px";
                }
                if(offsetObj.top === "center" || offsetObj.bottom === "center"){
                    var offTop = (h - messageElePosition.height)/2;
                    if(offTop < 0){
                        offTop = 20;
                    }
                    offsetObj.top = offTop + "px";
                }
                if(offsetObj.right && offsetObj.right !== "center"){
                    if(offsetObj.right.indexOf("%") > -1){
                        offsetObj.left = w-(messageElePosition.width+(w/parseFloat(offsetObj.right)))+"px";
                    }
                    else{
                        offsetObj.left = w-(messageElePosition.width+parseFloat(offsetObj.right))+"px";
                    }
                }
                if(offsetObj.bottom && offsetObj.bottom !== "center"){
                    if(offsetObj.bottom.indexOf("%") > -1){
                        offsetObj.top = h-(messageElePosition.height+(h/parseFloat(offsetObj.bottom)))+"px";
                    }
                    else{
                        offsetObj.top = h-(messageElePosition.height+parseFloat(offsetObj.bottom))+"px";
                    }
                }
                if(!offsetObj.top){
                    offsetObj.top = 20;
                }
                this.fastdomfn2 = $L.fastdom.mutate(function(){
                    delete this.fastdomfn2;
                    messageEle.style.left = parseFloat(offsetObj.left) + "px";
                    if(this.getData('ltPropTransition').animation != "slideFromTop"){
                        this.actualMessageDiv.style.visibility = "visible";
                        messageEle.style.top = parseFloat(offsetObj.top) + "px";
                    }
                    else{
                        // messageEle.style.transitionDuration = this.getData('ltPropTransition').duration ? this.getData('ltPropTransition').duration : '0.2s';
                        messageEle.style.top = -1 * messageElePosition.height + "px";
                        this.childComp.style.visibility = "visible";
                        this.actualMessageDiv.style.visibility = "visible";
                        messageEle.style.transform = "translate(0px,"+ (parseFloat(offsetObj.top) + messageElePosition.height) +"px)";
                        // this.actualMessageDiv.classList.add('lyteMessageBoxFadeIn');
                    }
                    this.showMessagebox();
                },this);
            }
            else{
                var offsetLeft="",offsetTop="";
                offsetLeft = (document.body.clientWidth - messageElePosition.width)/2;
                this.fastdomfn3 = $L.fastdom.mutate(function(){
                    delete this.fastdomfn3;
                    messageEle.style.left = parseFloat(offsetLeft)+"px";
                    if(this.getData('ltPropTransition').animation != "slideFromTop"){
                        this.actualMessageDiv.style.visibility = "visible";
                        messageEle.style.top = "20px";
                    }
                    else{
                        // messageEle.style.transitionDuration = this.getData('ltPropTransition').duration ? this.getData('ltPropTransition').duration : '0.2s';
                        messageEle.style.top = -1 * messageElePosition.height + "px";
                        this.childComp.style.visibility = "visible";
                        this.actualMessageDiv.style.visibility = "visible";
                        messageEle.style.transform = "translate(0px,"+ (messageElePosition.height + 20) +"px)";
                        // this.actualMessageDiv.classList.add('lyteMessageBoxFadeIn');
                    }
                    this.showMessagebox();
                },this);
            }

        },this);
    },
    closeMessageBoxFn : function(checkWormhole){
        //console.log("Here");
        if(this.timeOutId){
            clearInterval(this.timeOutId);
            this.timeOutId = false;
        }
        if( this.childComp && document.contains( this.childComp ) ){
            this.childComp.remove();
        }
        delete this.actualMessageDiv;
        delete this.childComp;
        if(!checkWormhole && this.getMethods("onClose")){
            this.executeMethod("onClose",this);
        }
    },

    clearFastdom : function(){
        if(this.fastdomfn1){
            $L.fastdom.clear(this.fastdomfn1);
            delete this.fastdomfn1;
        }
        if(this.fastdomfn2){
            $L.fastdom.clear(this.fastdomfn2);
            delete this.fastdomfn2;
        }
        if(this.fastdomfn3){
            $L.fastdom.clear(this.fastdomfn3);
            delete this.fastdomfn3;
        }
    },

	showToggled : function() {
		if(!(this.$node.ltProp("show"))){
            this.closeMessageBoxFn();
        }
    }.observes('ltPropShow').on('didConnect'),

    showMessagebox : function(){
        // start = new Date().getTime();
        var duration = parseInt(this.getData("ltPropDuration"));
        var self = this;
        this.timeOutId = setInterval(function(){
            clearInterval(self.timeOutId);
            //console.log("timeOut");
            // end = new Date().getTime();
            // console.log(end - start);
            if(!self.$node || self.getData('ltPropCloseManually')){
                return;
            }
            if(self.getData('ltPropTransition').animation != "slideFromTop"){
                self.actualMessageDiv.classList.remove('lyteMessageBoxFadeIn');
                self.actualMessageDiv.classList.add('lyteMessageBoxFadeOut');
                setTimeout(function(){
                    if(self.$node){
                        self.setData("ltPropShow",false);
                    }
                },500);
            }
            else{
                self.actualMessageDiv.style.transform = "";
                setTimeout(function(){
                    if(self.$node){
                        self.setData("ltPropShow",false);
                    }
                },500);
            }
            self.timeOutId = false;
        },duration);
    },

    didDestroy : function(){
        this.clearFastdom();
        if(this.timeOutId){
            clearInterval(this.timeOutId);
            if(this.getData('ltPropTransition').animation != "slideFromTop" && this.actualMessageDiv){
        		this.actualMessageDiv.classList.remove('lyteMessageBoxFadeIn');
        		this.actualMessageDiv.classList.add('lyteMessageBoxFadeOut');
	        	this.setData("ltPropShow",false);
        	}
        	else{
        		this.actualMessageDiv.style.transform = "";
	        	this.setData("ltPropShow",false);
        	}
            this.timeOutId = false;
            this.closeMessageBoxFn(true);
        }
    },

    actions : {
        closeMessageBox : function(){
            clearInterval(this.timeOutId);
            this.timeOutId = false;
            var self = this;
            if(self.getData('ltPropTransition').animation != "slideFromTop"){
                self.actualMessageDiv.classList.remove('lyteMessageBoxFadeIn');
                self.actualMessageDiv.classList.add('lyteMessageBoxFadeOut');
                setTimeout(function(){
                    if(self.$node){
                        self.setData("ltPropShow",false);
                    }
                },500);
            }
            else{
                self.actualMessageDiv.style.transform = "";
                setTimeout(function(){
                    if(self.$node){
                        self.setData("ltPropShow",false);
                    }
                },200);
            }
        }
    },

    methods : {
        beforeWormholeAppend : function(arg){
            this.childComp = arg;
            this.actualMessageDiv = this.childComp.querySelector(".lyteMessageBox");
            this.actualMessageDiv.style.position = "fixed";
            // LyteComponent.appendChild(document.body,this.childComp);
        },
        afterWormholeAppend : function(arg){
            if(this.getData('ltPropTransition').animation == "slideFromTop"){
                this.actualMessageDiv.classList.add('lyteMessageBoxSlideFromTop');
                this.computeOffsetImpl();
            }
            else{
                this.computeOffsetImpl();
                this.actualMessageDiv.classList.add('lyteMessageBoxFadeIn');
                // this.childComp.style.visibility = "visible";
            }
        }
    }


});

/**
 * @syntax nonYielded
 * <lyte-messagebox lt-prop-message = "This is a messagebox without yield.">
 * </lyte-messagebox>
 */

 /**
 * @syntax yielded
 * <lyte-messagebox lt-prop-yield = true>
 *     <template is = "registerYield" yield-name = "messageboxYield">
 *         <span> Here is the text. </span>
 *         <a href = "#"> Some link </a>
 *     </template>
 * </lyte-messagebox>
 */

/**
 * This component is used to select one or more ranges between given minimum and maximum values
 * @component lyte-multislider
 * @version 1.0.8
 * @methods beforeRender,afterRender,onBeforeSelect,onSelect,onChange
 */

Lyte.Component.register("lyte-multislider", {
_template:"<template tag-name=\"lyte-multislider\"> <div class=\"lyteSlide{{if(ltPropDisabled,' lyteSliderDisabled','')}}\" onkeydown=\"{{action('keydown',event)}}\" tabindex=\"{{ltPropTabindex}}\" style=\"width: {{ltPropWidth}}; height: {{ltPropHeight}}\"> <div class=\"lyteRangeSlider {{ltPropDirection}}\" onclick=\"{{action('click',event)}}\" style=\"background-color: {{ltPropNonFillColor}}\"> <template is=\"for\" items=\"{{ltPropValue}}\" item=\"item\" index=\"index\"> <div class=\"lyteSliderFill {{ltPropValue[index].class}}\" id=\"{{{{ltPropValue[index].id}}}}\" data-order=\"{{index}}\" style=\"background-color: {{if(ltPropColor[index],ltPropColor[index],ltPropFillColor)}};left: 0; top: 0;right: 0\"></div> <div data-order=\"{{index}}\" class=\"lyteSliderHandler {{ltPropHandler}} lyteHandler{{index}} {{item.class}}\" lt-prop-title=\"{{if(ltPropTooltip,item.value,'')}}\" ontouchstart=\"{{action('mousedown',event,this,index)}}\" onmousedown=\"{{action('mousedown',event,this,index)}}\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-tooltip-style=\"{{ltPropTooltipStyle}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\" role=\"{{lyteUiAttribute('slider',ltPropAria)}}\" tabindex=\"{{lyteUiAttribute(item.tabindex,true)}}\" aria-valuemin=\"{{lyteUiAttribute(item.min,ltPropAria)}}\" aria-valuemax=\"{{lyteUiAttribute(item.max,ltPropAria)}}\" aria-valuenow=\"{{lyteUiAttribute(item.value,ltPropAria)}}\" aria-valuetext=\"{{lyteUiAttribute(concat(item.text,item.value),ltPropAria)}}\" aria-label=\"{{lyteUiAttribute(item.label,ltPropAria)}}\" onfocus=\"{{action('focus',this,event)}}\"></div> </template> <div class=\"lyteSliderFill endFill\" id=\"endFill\" style=\"right: 0;bottom: 0;left: 0;background-color: {{ltPropFillColor}}\"></div> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"lyteMultiSlider\"></lyte-yield> </template><template case=\"false\"> <div class=\"lyteScaleOption {{ltPropHandler}}\"> <template is=\"for\" items=\"{{divLength}}\" index=\"indexVal\"> <span class=\"lyteScaleLine\" style=\"{{item}}\"> <span></span> <span class=\"lyteScalLable\">{{scaleVal[indexVal]}}</span> </span> </template> </div> </template></template> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width: '","ltPropWidth","'; height: '","ltPropHeight"]}}}},{"type":"attr","position":[1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'background-color: '","ltPropNonFillColor"]}}}},{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'background-color: '",{"type":"helper","value":{"name":"if","args":["ltPropColor[index]","ltPropColor[index]","ltPropFillColor"]}},"';left: 0; top: 0;right: 0'"]}}}},{"type":"attr","position":[3]}]},{"type":"attr","position":[1,1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'right: 0;bottom: 0;left: 0;background-color: '","ltPropFillColor"]}}}},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"item"}}},{"type":"text","position":[1,3,0]}]}]}},"default":{}}],
_observedAttributes :["ltPropMin","ltPropMax","ltPropValue","ltPropDirection","ltPropHandler","ltPropWidth","ltPropFillColor","ltPropNonFillColor","ltPropHeight","ltPropContent","ltPropScaleInterval","ltPropDiscrete","ltPropScaleAppend","ltPropScalePrepend","ltPropColor","ltPropTooltipStyle","ltPropTooltipConfig","ltPropTooltip","ltPropDigits","ltPropMinDiff","ltPropYield","ltPropTabindex","ltPropAria","divLength","scaleVal","secArr"],

    init : function(){
        this._dir = _lyteUiUtils.getRTL();
        this._mv = this.mousemove.bind( this );
        this._mp = this.mouseup.bind( this );
        this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node );
    },

    didConnect : function(){
        /**
         * @utility reRender
         * @version 2.2.3
         */
        this.$node.reRender = function(){
            this.initObs.call( this );
            this.dctWrk.call( this );
        }.bind( this )
    },

    dcnt : function(){
        if( this._prevent ){
            return
        }
        clearTimeout( this._time );

        this._time = setTimeout( this.dctWrk.bind( this ), 20 );
    }.observes( 'ltPropValue.[]', 'ltPropValue', 'ltPropDirection', 'ltPropWidth', 'ltPropHeight', 'ltPropMin', 'ltPropMax', 'ltPropContent.[]', 'ltPropContent' ).on( 'didConnect' ),

    didDestroy : function(){
        clearTimeout( this._time ); clearTimeout( this._time2 );
    },

    rtlfunc : function( lft, bcr, ww ) {
        if( this._dir && lft != 'top' && lft != 'clientY' ) {
            if( bcr ) {
                if( lft == 'right' ) {
                    return ww - bcr.left;
                } else if( lft == 'clientX' ) {
                    return ww - bcr.clientX
                }
                return ww - bcr.right;
            } else if( lft == 'left' ) {
                return 'right';
            } 
        }
        return bcr ? bcr[ lft ] : lft;
    },

    hgtObs : function(){
        var data = this.data, dir = data.ltPropDirection == "lyteHorizontal";
        this._prevent = true;
        this.$node.ltProp( 'width',  data.ltPropWidth || ( dir ? '200px' : "30px" ) ),
        this.$node.ltProp( 'height',  data.ltPropHeight || ( dir ? '30px' : "200px" ) );
        delete this._prevent;
    }.on('init'),

    initWrk : function( arg ){
        if( this._prevent ){
            return
        }
        clearTimeout( this._time2 );
        this._time2 = setTimeout( this.initObs.bind( this ), 0, arg )
    }.observes('ltPropContent.[]', 'ltPropContent', 'ltPropDiscrete', 'ltPropScaleInterval', 'ltPropValue.[]', 'ltPropValue' ).on('init'),


    initObs : function( arg ){
        var data = this.data, dir = data.ltPropDirection == "lyteHorizontal", cont = data.ltPropContent, len = cont.length, len1 = len, dis = data.ltPropDiscrete, sI = data.ltPropScaleInterval,
        sclVal = [ ], divLen = [ ], lft = this.rtlfunc( 'left' ), pre = data.ltPropScalePrepend, app = data.ltPropScaleAppend, sec = [], value = data.ltPropValue, yild = data.ltPropYield;
        if( !dir ) {
            lft = "top";
        }
        this._prevent = true;
        if( len ) {
            data.ltPropMax = 100;
            data.ltPropMin = 0;
            data.ltPropScaleInterval = data.ltPropDiscrete = 100 / ( len - 1 )
            len--;
        } else {
            if( dis ) {
                sI = data.ltPropScaleInterval = dis
            } else if( !sI ) {
                sI = data.ltPropScaleInterval = 0.1 * Math.abs( parseFloat( data.ltPropMax ) - parseFloat( data.ltPropMin ) )
            }
            len = Math.abs( parseFloat( data.ltPropMax ) - parseFloat( data.ltPropMin ) ) / data.ltPropScaleInterval;
        }
        if( !yild ) {
            divLen.push( lft + ": 0" );
            sclVal.push( pre + ( len1 ? cont[ 0 ] : data.ltPropMin ) + app )
            for( var i = 1; i < len; i++ ) {
                divLen.push( lft + ":" + ( 100 * i / len ) + "%" )
                sclVal.push( pre + ( len1 ? cont[ i ] : ( data.ltPropMin + sI * i * ( data.ltPropMin > data.ltPropMax ? -1 : 1 ) ) ) + app  )   
            }
            if( len1 ){
                var discrete = data.ltPropDiscrete
                for( var i = 0; i < value.length; i++ ) {
                    var mx = cont.indexOf( value[ i ].max );
                    sec.push( { id : i - 1, value : ( cont.indexOf( value[ i ].value ) ) * discrete, min : Math.max( 0, ( cont.indexOf( value[ i ].min ) ) * discrete ), max : Math.min( 100, ( mx != -1 ? mx : 100 ) * discrete ) } )
                }
            }
            divLen.push( lft + ": 100%" );
            sclVal.push( pre + ( len1 ? cont[ len1 - 1 ] : data.ltPropMax ) + app )
            this.setData( 'divLength', divLen );
            this.setData( 'scaleVal', sclVal );
        }
        this.setData( 'secArr', len1 ? sec : value.slice() )
        delete this._prevent;
    },

    dctWrk : function( sortVal, bcr, handBcr, flag ){
        var data = this.data, val = data.secArr.slice().sort( function( a, b ){
            return a.value < b.value ? -1 : 1;
        } ), frmdc = !!val, sortVal = sortVal || [],
        dir = data.ltPropDirection == "lyteHorizontal", cont = data.ltPropContent, len = cont.length, hp = [], wd = "width",

        lft = this.rtlfunc( 'left' ), bcr = bcr || this.$node.querySelector( '.lyteSlide' ).getBoundingClientRect(), max =  parseFloat( data.ltPropMax ), min = parseFloat( data.ltPropMin ),

        handlers = this.$node.querySelectorAll( '.lyteSliderHandler[ data-order ]' ), hp = [],

        fill = this.$node.querySelectorAll( '.lyteSliderFill' ), prev;


        if( !dir ) {
            wd = "height", lft = "top";
        }
        var ddct = max < min ? bcr[ wd ] : 0
        for( var i = 0; i < val.length; i++ ) {
            var j = data.secArr.indexOf( val[ i ] );
            if( sortVal.length && sortVal.indexOf( j ) == -1 ) {
                hp.push( undefined )
                continue;
            }
            hp.push( { node : handlers[ j ], id : val.indexOf( val[ i ] ) } ); 
            hp[ i ].bcr = handBcr || handlers[ j ].getBoundingClientRect();
            hp[ i ].style = this.getLeft( bcr[ wd ], hp[ i ].bcr[ wd ], val[ i ].value, max, min )
            prev = this.findPrevmin.call( this, j, val[ i ].value );
        }
        for( var i = 0; i < hp.length; i++ ) {
            if( hp[ i ] ) {
                var prev = fill[ hp[ i ].id - 1 ];
                if( ddct ) {
                    hp[ i ].style = ddct - hp[ i ].style - hp[ i ].bcr[ wd ];
                    hp[ i ].node.style[ lft ] = hp[ i ].style + 'px';
                    fill[ hp[ i ].id ].style[ lft ] =  hp[ i ].style + hp[ i ].bcr[ wd ] / 2 + 'px';
                    fill[ hp[ i ].id ].style[ wd ] = Math.max( 0, ( prev ? ( parseFloat( prev.style[ lft ] ) ) : ddct )  - hp[ i ].bcr[ wd ] / 2 - hp[ i ].style ) + 'px';
                    if( hp[ i ].id + 2 == fill.length ) {
                        fill[ hp[ i ].id + 1 ].style[ lft ] = '0';
                        fill[ hp[ i ].id + 1 ].style[ wd ] = Math.max( 0, hp[ i ].style + hp[ i ].bcr[ wd ] / 2 ) + 'px';
                        fill[ hp[ i ].id + 1 ].setAttribute( 'range-max', this.convert( cont, min ) );
                    }
                    if( hp[ i ].id == 0 ){
                        fill[ hp[ i ].id ].setAttribute( 'range-min', this.convert( cont, max ) );
                    }
                } else {
                    hp[ i ].node.style[ lft ] = hp[ i ].style + 'px';
                    fill[ hp[ i ].id + 1 ].style[ lft ] = hp[ i ].style + hp[ i ].bcr[ wd ] / 2 + 'px';
                    fill[ hp[ i ].id ].style[ wd ] = Math.max( 0, hp[ i ].style + hp[ i ].bcr[ wd ] / 2 - ( prev ? parseFloat( prev.style[ lft ] ) + ( parseFloat( prev.style[ wd ] ) ) : 0 ) ) + 'px';
                    if( hp[ i ].id + 2 == fill.length ) {
                        fill[ hp[ i ].id + 1 ].style[ wd ] = Math.abs( ddct - Math.max( bcr[ wd ] - hp[ i ].style - hp[ i ].bcr[ wd ] / 2, 0 ) ) + 'px';
                        fill[ hp[ i ].id + 1 ].setAttribute( 'range-max', this.convert( cont, max ) );
                    }
                    if( hp[ i ].id == 0 ){
                        fill[ hp[ i ].id ].setAttribute( 'range-min', this.convert( cont, min ) );
                    }
                }
                fill[ hp[ i ].id ].setAttribute( 'range-max', this.convert( cont, val[ hp[ i ].id ].value ) );
                fill[ hp[ i ].id + 1 ].setAttribute( 'range-min', this.convert( cont, val[ hp[ i ].id ].value ) );
            }
        }
        !flag && this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );
    },

    setValues : function( wd, style, prev ){
        var hp = {};
        if( prev == undefined ) {
                hp.left = 0;
                hp.width = style + wd;
            } else {
                hp.left =  parseFloat( prev.style )  + wd ;
                hp.width = style - hp.left + wd;
            }
        return hp   
    },

    findPrevmin : function( idd, curr, flag, rest, rest2 ){
        var id, val = this.data.secArr.slice(), sel;
        if( curr != undefined ) {
            for( var i = 0; i < val.length; i++ ) {
                if( [ idd, rest2, rest].indexOf( i ) == -1 ) {
                    if( val[ i ].value <= curr && !flag ){
                        if( sel && val[ i ].value > sel ) {
                            sel = val[ i ].value;
                            id = i;
                        } else if( !sel ) {
                            sel = val[ i ].value;
                            id = i;
                        }
                    } else if( val[ i ].value >= curr && flag ) {
                        if( sel && val[ i ].value < sel ) {
                            sel = val[ i ].value;
                            id = i;
                        } else if( !sel ) {
                            sel = val[ i ].value;
                            id = i;
                        }
                    }
                }
            }
            return [ id, sel ]
        } else {
            val.sort( function( a, b ){
                return a.value < b.value ? -1 : 1;
            } )
            var id = this.data.secArr.indexOf( val[ val.length - 1 ] )
            return [ id, this.data.secArr[ id ].value ]
        }
    },

    findPrevmin1 : function( idd, curr, flag ){
        var id, value = this.data.secArr.slice(), sel;
        for( var i = 0; i < value.length; i++ ){
            if( i != idd ){
                if( flag ){
                    if( curr < value[ i ].value ){
                        if( sel && value[ i ].value < sel ){
                            sel = value[ i ].value; id = i;
                        } else if( !sel ) {
                            sel = value[ i ].value
                            id = i
                        }
                    }
                } else{
                    if( curr > value[ i ].value ){
                        if( sel && value[ i ].value > sel ){
                            sel = value[ i ].value; id = i;
                        } else if( !sel ) {
                            sel = value[ i ].value;
                            id = i
                        }
                    }
                }
            }
        }
        return [ id, sel ];
    },

    getLeft : function( parWid, handWid, value, max, min ){
        var ret = ( value - Math.min( min, max ) ) * parWid / (  Math.max( min, max ) -  Math.min( min, max ) ),
        val = Math.round( Math.min( Math.max( ( ret - 0.5 * handWid ), -0.5 * handWid ), parWid - 0.5 * handWid ) * 100 ) / 100
        return val;
    },

    getValue : function( parWid, curr, max, min, vmin, vmax ){
        var pow =  Math.pow( 10, this.data.ltPropDigits );
        if( max > min ){
            return Math.min( Math.max( vmin || min, Math.round( ( min + ( ( max - min ) * curr / parWid ) ) * pow ) / pow ), vmax||max );
        } else {
            return Math.min( Math.max( vmin || max, Math.round( ( max + ( ( min - max ) * ( parWid - curr ) / parWid ) ) * pow ) / pow ), vmax||min )
        }
    },

    convert : function( con, val ){
        if( con.length ){
            return ( con[ Math.round( val / this.data.ltPropDiscrete ) ] )
        } else {
            var pow =  Math.pow( 10, this.data.ltPropDigits );
            return parseInt( val * pow ) / pow;
        }
    },  

    data : function(){
        return {
            /**
             * @componentProperty {number} ltPropMin=0
             * @version 1.0.8
             */
            ltPropMin : Lyte.attr( 'number', { default : 0 } ),
            /**
             * @componentProperty {number} ltPropMax
             * @version 1.0.8
             */
            ltPropMax : Lyte.attr( 'number', { default : undefined } ),
            /**
             * @componentProperty {object[]} ltPropValue
             * @version 1.0.8
             * @default []
             */
            ltPropValue : Lyte.attr( 'array', { default : [] } ),
            /**
             * @componentProperty {lyteHorizontal | lyteVertical} ltPropDirection=lyteHorizontal
             * @version 1.0.8
             */
            ltPropDirection : Lyte.attr( 'string', { default : "lyteHorizontal" } ),
            /**
             * @componentProperty {lyteArrow | lyteArrowLeft | lyteSquare | lyteCircle} ltPropHandler=lyteArrow
             * @version 1.0.8
             */
            ltPropHandler:Lyte.attr( "string", { default : 'lyteArrow' } ),
            /**
             * @componentProperty {string} ltPropWidth=''
             * @version 1.0.8
             */
            ltPropWidth : Lyte.attr( "string", { default : '' } ),
            /**
             * @componentProperty {colorString} ltPropFillColor=''
             * @version 1.0.8
             */
            ltPropFillColor:Lyte.attr( "string", { default : '' } ),
            /**
             * @componentProperty {colorString} ltPropNonFillColor=''
             * @version 1.0.8
             */
            ltPropNonFillColor:Lyte.attr( "string", { default : '' } ),
            /**
             * @componentProperty {string} ltPropHeight=''
             * @version 1.0.8
             */
            ltPropHeight:Lyte.attr( "string", { default :'' } ),
            /**
             * @componentProperty {string[]} ltPropContent
             * @default []
             * @version 1.0.8
             */
            ltPropContent : Lyte.attr( 'array', { default : [ ] } ),
            /**
             * @componentProperty {number} ltPropScaleInterval
             * @version 1.0.8
             */
            ltPropScaleInterval : Lyte.attr( 'number' ),
            /**
             * @componentProperty {number} ltPropDiscrete
             * @version 1.0.8
             */
            ltPropDiscrete : Lyte.attr( 'number' ),
            /**
             * @componentProperty {string} ltPropScaleAppend=''
             * @version 1.0.8
             */
            ltPropScaleAppend : Lyte.attr( 'string', { default : "" } ),
            /**
             * @componentProperty {string} ltPropScalePrepend=''
             * @version 1.0.8
             */
            ltPropScalePrepend : Lyte.attr( 'string', { default : "" } ),
            /**
             * @componentProperty {string[]} ltPropColor
             * @default []
             * @version 1.0.8
             */
            ltPropColor : Lyte.attr( 'array', { default : [ ] } ),
            /**
             * @componentProperty {string} ltPropTooltipStyle=''
             * @version 1.0.8
             */
            ltPropTooltipStyle : Lyte.attr( 'string', { default : '' } ),

            /**
             * @typedef {object} multisliderConfig
             * @property {number} margin=5
             * @property {left | right | top | bottom | topright | bottomright | topleft | bottomleft} position=top
             * @property {box | callout} appearance=callout
             * @property {number} showdelay=0
             * @property {number} hidedelay=0
             * @property {number} maxdisplaytime=5000
             * @property {boolean} keeptooltip=false
             */

            /**
             * @componentProperty {multisliderConfig} ltPropTooltipConfig
             * @default {}
             * @version 1.0.8
             * @condition ltPropTooltip true
             */
            ltPropTooltipConfig : Lyte.attr( 'object', { default : { margin : 5, position : "top" } } ),
            /**
             * @componentProperty {boolean} ltPropTooltip=false
             * @version 1.0.8
             */
            ltPropTooltip : Lyte.attr( 'boolean', { default : false } ),
            /**
             * @componentProperty {number} ltPropDigits=2
             * @version 1.0.8
             */
            ltPropDigits : Lyte.attr( 'number', { default : 2 } ),
            /**
             * @componentProperty {number} ltPropMinDiff=0
             * @version 1.0.8
             */
            ltPropMinDiff : Lyte.attr( 'number', { default : 0 } ),
            /**
             * @componentProperty {boolean} ltPropYield=false
             * @version 1.0.8
             */
            ltPropYield : Lyte.attr( 'boolean', { default : false } ),
            /**
             * @componentProperty {number} ltPropTabindex=0
             * @version 3.1.0
             */            
            ltPropTabindex : Lyte.attr( 'number', { default : 0 } ),
            /**
             * @componentProperty {boolean} ltPropAria=false
             * @version 3.1.0
             */
            ltPropAria : Lyte.attr( 'boolean', { default : false } ),

            // system data
            divLength : Lyte.attr( 'array', { default : [] } ),
            scaleVal : Lyte.attr( 'array', { default : [] } ),
            secArr : Lyte.attr( 'array', { default : [] } )
        }       
    },

    mousemove : function( evt, inc ){
        var _this = this._sel, bcr = this.$node.querySelector( '.lyteSlide' ).getBoundingClientRect() ,data = this.data, dir = data.ltPropDirection == "lyteHorizontal",
        client = "clientX", lft = this.rtlfunc( 'left' ), wd = "width", nwLft, idx = this._idx, newFill, val = data.secArr, reset = [], oldVal,
        fill = this.$node.querySelectorAll( '.lyteSliderFill' ), old, prev, discrete = data.ltPropDiscrete, con = data.ltPropContent, ww = window.innerWidth,
        max = parseFloat( data.ltPropMax ), min = parseFloat( data.ltPropMin ), prevval = [], nextVal = [], diff = this.data.ltPropMinDiff, ev = evt, isTch = evt.type == "touchmove";
        if( isTch && evt.touches.length != 1 ) {
            return;
        } else if( isTch ) {
            ev = evt.touches[ 0 ];
        }
        if( !dir ) {
            client = "clientY", lft = "top", wd = "height";
        }
        old = parseFloat( _this.style[ lft ] );
        if( isNaN( old ) ){
            this.dctWrk.call( this, [], bcr, this._bcr, true );
            old = parseFloat( _this.style[ lft ] );
        }
        if( /mousemove|touchmove/.test( evt.type ) ){
            inc = parseInt( ( ( this.rtlfunc( client, ev, ww ) - this.rtlfunc( lft == "right" ? 'left' : lft, bcr, ww ) - this._xoff - parseFloat( _this.style[ lft ] ) ) * 100 ) ) / 100;
        } 
        this._prevent = true;
        if( discrete ) {
            var crval = this.getValue( bcr[ wd ], old + inc, max, min  );
            var acc = Math.min( Math.max( Math.round( ( crval ) / discrete ) * discrete, 0 ) );
            if( acc == data.secArr[idx].value && ( ( crval != max && crval != min ) ) || ( crval == data.secArr[idx].value ) ){
                delete this._prevent;
                return
            } else if( crval == max || crval == min ) {
                acc = crval;
            }
            if( !con.length && max < min ){
                inc = this.getLeft( bcr[wd], this._bcr[ wd ], data.secArr[ idx ].value, max, min ) - this.getLeft( bcr[wd], this._bcr[ wd ], acc, max, min )
            } else {
                inc = this.getLeft( bcr[wd], this._bcr[ wd ], acc, max, min ) - old;
            }
        }
        if( con.length ){
            diff = diff * discrete;
        }
        if( !isNaN( diff ) ) {
            prevval = this.findPrevmin1( idx, val[ idx ].value );
            if( prevval[ 0 ] != undefined ) {
                prevval[ 1 ] += diff * 1; 
            } else {
                prevval[ 1 ] = Math.min( max, min );
            }
            nextVal = this.findPrevmin1( idx, val[ idx ].value, true )
            if( nextVal[ 0 ] != undefined ){
                nextVal[ 1 ] -= diff * 1 ;
            } else {
                nextVal[ 1 ] = Math.max( max, min );
            }
            if( ( inc < 0 && val[ idx ].frmMax ) || ( inc > 0 && val[ idx ].frmMin ) ){
                return
            } 
        }
        oldVal = val[ idx ] .value;
        Lyte.objectUtils( val[ idx ], 'add', 'value', this.getValue( bcr[ wd ], old + inc + this._bcr[ wd ] / 2, max, min, Math.max( val[ idx ].min || prevval[ 1 ], prevval[ 1 ] || val[ idx ].min ), Math.min( val[ idx ].max || nextVal[ 1 ], nextVal[ 1 ] || val[ idx ].max ) ) )
        Lyte.Component.set( data.ltPropValue[ idx ] , 'value', this.convert( con, val[ idx ].value ));
        prevval = this.findPrevmin( idx, val[ idx ].value )
        if( diff != undefined ) {
            if( prevval[ 1 ] == val[ idx ].value ) {
                if( inc > 0 && !val[ idx ].frmMax ){
                    val[ idx ].frmMin = true;
                } else if( !val[ idx ].frmMin ) {
                    val[ idx ].frmMax = true;
                }
            } else {
                delete val[ idx ].frmMax; delete val[ idx ].frmMin;
            }
        }
        this.dctWrk.call( this, [], bcr, this._bcr, true);
        delete this._prevent;
        evt.preventDefault();
        if( /mousemove|touchmove/.test( evt.type ) && this.getMethods( 'onChange' ) && oldVal != val[ idx ] .value ){
            this.executeMethod( 'onChange', idx, data.ltPropValue[ idx ], evt, this.$node )
        }

        if( _this.tooltip && _this.tooltip.refresh ){
            _this.tooltip.refresh( { clientX : Math.max( Math.min( evt.clientX, bcr.right ), bcr.left ) }, _this.tooltip.tooltipSpan );
        }
    },

    mouseup : function( evt ) {
        var ret, isTch = evt.type == "touchend";
        document.removeEventListener( isTch ? 'touchmove' : "mousemove", this._mv, true );
        document.removeEventListener( isTch ? 'touchend' : "mouseup", this._mp, true );
        if( this.getMethods( 'onSelect' ) ) {
            ret = this.executeMethod( 'onSelect', this._idx, this.data.ltPropValue[ this._idx ], evt, this.$node );
        }
        delete this._sel; delete this._xoff; delete this._idx;
        delete this._bcr; delete this._prevent;

        if( ret != false && isTch ){
            evt.preventDefault();
        }
    },

    callBack : function( idx, evt ){
        this.getMethods( 'onSelect' ) && this.executeMethod( 'onSelect', idx, this.data.ltPropValue[ idx ], evt, this.$node );
        this.getMethods( 'onChange' ) && this.executeMethod( 'onChange', idx, this.data.ltPropValue[ idx ], evt, this.$node );
    },

    actions : {
        mousedown : function( evt, _this, idx ){
            if( evt.button == 2 ){
                return;
            }
            var ret, isTch = evt.type == "touchstart", ev = evt;
            if( isTch && evt.touches.length != 1 ){
                return
            } else if( isTch ){
                ev = evt.touches[ 0 ];
            }
            if( this.getMethods( 'onBeforeSelect' ) && this.executeMethod( 'onBeforeSelect', _this, evt, idx, this.$node ) == false ){
                return;
            }
            $L.fastdom.mutate( function(){
                var prev = this.$node.querySelector( '.lyteMultiSliderSelected' );
                if( prev && prev != _this ){
                    prev.classList.remove( 'lyteMultiSliderSelected' );
                }
                _this.classList.add( 'lyteMultiSliderSelected' );
            }.bind( this ))
            var bcr = _this.getBoundingClientRect(), data = this.data, dir = data.ltPropDirection == "lyteHorizontal",
            client = "clientX", lft = this.rtlfunc( 'left'), wd = "width", ww = window.innerWidth;
            if( !dir ) {
                client = "clientY", lft = "top", wd = "height";
            }
            this._xoff =this.rtlfunc( client, ev, ww ) - this.rtlfunc( lft == "right" ? 'left' : lft, bcr, ww );
            this._sel = _this; this._idx = idx;
            this._bcr = bcr;
            document.addEventListener( isTch ? 'touchmove' : "mousemove", this._mv, true );
            document.addEventListener( isTch ? 'touchend' : "mouseup", this._mp, true );
            isTch && evt.preventDefault();
        },
        click : function( evt ){
            var target = evt.target, wd = "width", client = "clientX", lft = this.rtlfunc( 'left' ) , data = this.data, isLen = !!data.ltPropContent.length;
            if( target.classList.contains( 'lyteSliderHandler' ) || ! target.classList.contains( 'lyteSliderFill' ) ){
                return
            }
            if( this.data.ltPropDirection != "lyteHorizontal" ){
                wd = "height"; client = "clientY"; lft = "top";
            }
            var bcr = this.$node.querySelector( '.lyteSlide' ).getBoundingClientRect(), hand = this.$node.querySelectorAll( '.lyteSliderHandler' ), appVal, max, min, curr, fact = 1, ww = window.innerWidth;
            if( hand.length ) {
                appVal = this.getValue(  bcr[ wd ], this.rtlfunc( client, evt, ww ) - this.rtlfunc( lft == "right" ? 'left' : lft, bcr, ww ), data.ltPropMax, data.ltPropMin );
                min = this.findPrevmin1( null, appVal );
                max = this.findPrevmin1( null, appVal, true );
                if( ( max[ 1 ] || Math.max( data.ltPropMax, data.ltPropMin ) ) - appVal > appVal - ( min[ 1 ] || Math.min( data.ltPropMax, data.ltPropMin ) ) ) {
                    min[ 0 ] = min[ 0 ] != undefined ? min[ 0 ] : ( min[ 0 ] || max[ 0 ])
                    this._sel = hand[ min[ 0 ] ];
                    this._idx = min[ 0 ];
                } else {
                    max[ 0 ] = max[ 0 ] != undefined ? max[ 0 ] : min[ 0 ];
                    this._sel = hand[ max[ 0 ] ];
                    this._idx = max[ 0 ];
                }
                if( appVal - data.secArr[ this._idx ].value < 0 ) {
                    fact = -1;
                }
                if( !isLen && data.ltPropMin > data.ltPropMax ){
                    fact *= -1;
                }
                this._bcr = this._sel.getBoundingClientRect();
                this.mousemove.call( this, evt, fact * this.getLeft( bcr[ wd ], this._bcr[ wd ] / 2, Math.abs( appVal - data.secArr[ this._idx ].value ) + ( isLen ? 0 : Math.min( data.ltPropMin, data.ltPropMax ) ), data.ltPropMax, data.ltPropMin ) );
                this.callBack.call( this, this._idx, evt );
                $L.fastdom.mutate( function(){
                    var prev = this.$node.querySelector( '.lyteMultiSliderSelected' );
                    if( prev && prev != this._sel ){
                        prev.classList.remove( 'lyteMultiSliderSelected' );
                    }
                    this._sel.classList.add( 'lyteMultiSliderSelected' );
                    delete this._bcr; delete this._idx; delete this._sel;
                }.bind( this ) )
            }   
        },
        keydown : function( evt ){
            var keyCode = evt.keyCode || evt.which;
            if( [ 37, 38, 39, 40, 36, 35 ].indexOf( keyCode ) != -1 ) {
                var active = this.$node.querySelector( '.lyteSliderHandler.lyteMultiSliderSelected' );
                if( active ){
                    var data = this.data, dir = data.ltPropDirection == "lyteHorizontal", wd =  dir ? "width" : "height", fact = 1,isLen = !!data.ltPropContent.length;
                    
                    if( !data.ltPropAria && ( /^(38|40)$/.test( keyCode ) && dir || !dir && /^(39|37)$/.test( keyCode ) ) ){
                        return;
                    }

                    if( /^(38|37)$/.test( keyCode ) ){
                        fact = -1;
                    } else if( /^(39|40)$/.test( keyCode ) ){
                        fact = 1;
                    }
                    this._bcr = active.getBoundingClientRect();
                    this._idx = parseInt( active.getAttribute( 'data-order' ) );
                    this._sel = active;
                    var final,
                    nodeBcrwd = this.$node.querySelector( '.lyteSlide' ).getBoundingClientRect()[ wd ];
                    if( !/^(35|36)$/.test( keyCode ) ){
                        final = data.ltPropScaleInterval + ( isLen ? 0 : Math.min( data.ltPropMin, data.ltPropMax ) );
                    } else if( data.ltPropAria && keyCode == 36 ){
                        final = data[ isLen ? 'secArr' : 'ltPropValue' ][ this._idx ].value - data.ltPropMin;
                        fact = -1;
                    } else if( data.ltPropAria && keyCode == 35 ){
                        final = data.ltPropMax - data[ isLen ? 'secArr' : 'ltPropValue' ][ this._idx ].value;
                    }
                    this.mousemove( evt, fact * ( this.getLeft( nodeBcrwd, this._bcr[ wd ], final, data.ltPropMax, data.ltPropMin ) + this._bcr[ wd ] / 2 ) )
                    this.callBack.call( this, this._idx, evt );
                    delete this._bcr; delete this._idx; delete this._sel;
                    evt.preventDefault( );
                }
            }
        },

        focus : function( _this, evt ){
            var active = this.$node.querySelector( '.lyteSliderHandler.lyteMultiSliderSelected' );
            if( active == _this ){
                return;
            }
            active && active.classList.remove( 'lyteMultiSliderSelected' );
            _this.classList.add( 'lyteMultiSliderSelected' );
        }
    }
});

/**
 * @syntax nonYielded
 * <lyte-multislider lt-prop-max = '100' lt-prop-width='600px' lt-prop-value = '[ { "value" : 30, "min" : 20, "max" : 40 }, { "value" : 50, "min" : 40, "max" : 60 }, { "value" : 80, "min" : 70} ]' lt-prop-color = '[ "red", "green", "yellow" ]' lt-prop-discrete = 10 > </lyte-multislider> 
 */

 /**
  * @syntax yielded
  * <lyte-multislider lt-prop-yield = true lt-prop-max = '100' lt-prop-width='600px' lt-prop-value = '[ { "value" : 30, "class" : "class1" }, { "value" : 50, "class" : "class2"}, { "value" : 80, "class" : "class3" } ]' lt-prop-color = '[ "red", "green", "yellow" ]'> 
  *    <template is = "registerYield" yield-name = "lyteMultiSlider"> 
  *        <div class="lyteScaleOption"> 
  *            <span class="lyteScaleLine" style="left: 0"> 
  *                <span> </span> 
  *                <span class="lyteScalLable"> 0 </span> 
  *            </span>
  *            <span class="lyteScaleLine" style="left: 50%"> 
  *                <span> </span> 
  *                <span class="lyteScalLable">  50</span> 
  *            </span> 
  *            <span class="lyteScaleLine" style="left: 100%"> 
  *                <span> </span> 
  *                <span class="lyteScalLable">  100</span> 
  *            </span> 
  *        </div> 
  *    </template> 
  * </lyte-multislider> 
  */
/**
 * Renders a modal
 * @component lyte-modal
 * @version 1.0.0
 * @dependencies lyte-wormhole
 * @methods onBeforeShow,onShow,onBeforeClose,onClose,onResize
 * @utility alignModal,calculateOffset,trapFocus, reflectTransitionChange
 */

Lyte.Component.register("lyte-modal",{
_template:"<template tag-name=\"lyte-modal\"> <template is=\"if\" value=\"{{expHandlers(ltPropBindToBody,'&amp;&amp;',expHandlers(ltPropReRenderModal,'!'))}}\"><template case=\"true\"> <lyte-wormhole case=\"true\" style=\"{{if(ltPropShowCopy,'visibility:visible','visibility:hidden')}}\" on-before-append=\"{{method(&quot;beforeWormholeAppend&quot;)}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"modalWrapper {{ltPropWrapperClass}}\"> <div class=\"lyteModal\"> <template is=\"if\" value=\"{{ltPropShowCloseButton}}\"> <template case=\"true\"><span class=\"lyteModalClose\" onclick=\"{{action('close')}}\" tabindex=\"0\"></span></template> </template> <lyte-yield yield-name=\"modal\"></lyte-yield> </div> <template is=\"if\" value=\"{{ltPropFreeze}}\"> <template case=\"true\"><lyte-modal-freeze></lyte-modal-freeze></template> </template> </div> </template> </lyte-wormhole> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropShowCopy","'visibility:visible'","'visibility:hidden'"]}}}},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"insertYield","position":[1,1,3]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropFreeze","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropTransition","ltPropOffset","ltPropDimmer","ltPropDraggable","ltPropAllowMultiple","ltPropScrollable","ltPropMaxHeight","ltPropMaxWidth","ltPropWidth","ltPropHeight","ltPropWrapperClass","ltPropBindToBody","ltPropShowCopy","ltPropReRenderModal","ltPropOverlayClose","ltPropAria","ltPropAriaAttributes","ltPropPreventFocus","ltPropSetContentHeight","ltPropCloseDuration","ltPropOverlapModal","ltPropIgnoreInlineDirection","first","resizeCalled","initializedPosition","prevHeight","returnedFalse","prevModalHeight","prevModalWidth","calculateHW","checkAria"],
    data: function(){
        return {
            //config from callee

            /**
             * @componentProperty {boolean} ltPropShow
             * @version 1.0.0
             * @default false
             */
            "ltPropShow":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropFreeze
             * @version 1.0.0
             * @default true
             */
            "ltPropFreeze":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {boolean} ltPropShowCloseButton
             * @version 1.0.0
             * @default true
             */
            "ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {boolean} ltPropCloseOnEscape
             * @version 1.0.0
             * @default true
             */
            "ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),
            /**
             * @typedef {object} transition
             * @property {slideFromTop|slideFromBottom|slideFromLeft|slideFromRight|fadeIn|zoom} animation
             * @property {string} duration
             */
            /**
             * @componentProperty {transition} ltPropTransition
             * @version 1.0.0
             * @default { "animation" :"slideFromTop" , "duration":"0.5s"}
             */
            "ltPropTransition":Lyte.attr("object",{"default":{"animation":"slideFromTop","duration":"0.5"}}),
            /**
             * @typedef {object} offset
             * @property {string} top
             * @property {string} left
             * @property {string} bottom
             * @property {string} right
             */
            /**
             * @componentProperty {offset} ltPropOffset
             * @version 1.0.0
             * @default { "top" :"center", "left" :"center"}
             */
            "ltPropOffset":Lyte.attr("object",{"default":{"top":"center","left":"center"}}),
            /**
             * @typedef {object} dimmer
             * @property {colorstring} color
             * @property {string} opacity
             */
            /**
             * @componentProperty {dimmer} ltPropDimmer
             * @version 1.0.0
             */
            "ltPropDimmer":Lyte.attr("object"), //,{"default":{"color":"black","opacity":"0.4"}}

            /**
             * @componentProperty {boolean} ltPropDraggable
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropDraggable":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropAllowMultiple
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropScrollable
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropScrollable":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {string} ltPropMaxHeight
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropMaxHeight":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropMaxWidth
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropMaxWidth":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropWidth
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropWidth":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropHeight
             * @version 1.0.0
             * @default auto
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropHeight":Lyte.attr("string",{"default":"auto"}),

            /**
             * @componentProperty {string} ltPropWrapperClass
             * @version 1.0.0
             */
            "ltPropWrapperClass":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {boolean} ltPropBindToBody
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropBindToBody":Lyte.attr("boolean",{"default":false}),

            /**
             * @experimental ltPropShowCopy
             */
            "ltPropShowCopy":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropReRenderModal
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropReRenderModal":Lyte.attr("boolean",{"default":false}),

            /**
             * @componentProperty {boolean} ltPropOverlayClose
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropOverlayClose":Lyte.attr("boolean",{"default":false}),

            /**
             * @componentProperty {boolean} ltPropAria
             * @version 3.1.0
             * @default false
             *
             */
            "ltPropAria" : Lyte.attr( 'boolean', { default : false } ),

            /**
             * @componentProperty {object} ltPropAriaAttributes
             * @version 3.1.0
             */
            "ltPropAriaAttributes" : Lyte.attr( 'object', { default : {} } ),

            /**
             * @componentProperty {boolean} ltPropPreventFocus
             * @version 3.3.0
             * @default false
             *
             */
            "ltPropPreventFocus" : Lyte.attr('boolean', { default : false } ),

            /**
             * @componentProperty {boolean} ltPropSetContentHeight
             * @version 3.9.0
             * @default false
             *
             */
            "ltPropSetContentHeight" : Lyte.attr('boolean', { default : false } ),

            /**
             * @componentProperty {number} ltPropCloseDuration
             * @version 3.10.0
             * @default undefined
             */
            "ltPropCloseDuration" : Lyte.attr("number",{"default" : undefined}),

            /**
             * @componentProperty {boolean} ltPropOverlapModal
             * @version 3.19.0
             * @default true
             *
             */
            "ltPropOverlapModal" : Lyte.attr('boolean', { default : true } ),

            /**
             * @componentProperty {boolean} ltPropIgnoreInlineDirection
             * @version 3.19.0
             * @default true
             *
             */
            "ltPropIgnoreInlineDirection" : Lyte.attr('boolean', { default : false } ),

            //local properties
            "first":Lyte.attr("boolean",{"default":true}),
            'resizeCalled' : Lyte.attr("boolean",{"default":false}),
            'initializedPosition' : Lyte.attr("boolean",{"default":false}),
            "prevHeight" : Lyte.attr("number"),
            "returnedFalse" : Lyte.attr("boolean",{"default" : false}),
            "prevModalHeight" : Lyte.attr("number"),
            "prevModalWidth" : Lyte.attr("number"),
            "calculateHW" : Lyte.attr("boolean", {"default":false}),
            "checkAria" : Lyte.attr("number", {"default":0})
        }
    },
    addDragHandler : function(){
        var dragHeader = this.actualModalDiv.querySelector('lyte-modal-header');
        if(dragHeader){
            dragHeader.parentEle = this;
            if(this.$node.ltProp("draggable")){
                dragHeader.addEventListener('mousedown',this.handleMove,true);
                dragHeader.addEventListener('touchstart',this.handleMove,true);
                dragHeader.classList.add('lyteModalHeaderDraggable');
            }
            else{
                dragHeader.removeEventListener('mousedown',this.handleMove,true);
                dragHeader.removeEventListener('touchstart',this.handleMove,true);
                dragHeader.classList.remove('lyteModalHeaderDraggable');
            }
        }
        else{
            console.warn("This modal is not draggable because it has no header");
            this.$node.ltProp("draggable",false);
        }
    },
    handleMove : function(e){
        var drag = e.currentTarget.parentEle.actualModalDiv, mouseOffset;
        LytePopup.node=drag;
        if(e.type == "mousedown"){
            mouseOffset = { x : e.clientX, y : e.clientY};
        }
        if(e.type == "touchstart"){
            mouseOffset = { x : e.touches[0].clientX, y : e.touches[0].clientY};
        }
        if(e.currentTarget.parentEle.getData('ltPropTransition').animation == "fadeIn"){
            LytePopup.xPos=mouseOffset.x-this.getBoundingClientRect().left;
            LytePopup.yPos=mouseOffset.y-this.getBoundingClientRect().top;
        }
        else{
            LytePopup.xPos=mouseOffset.x;
            LytePopup.yPos=mouseOffset.y;
        }
        var elePos = drag.getBoundingClientRect();
        drag.style.transitionDuration = "0s";
        if(e.type = "mousedown"){
            document.body.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);
            document.body.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);
        }
        if(e.type = "touchstart"){
            document.body.addEventListener('touchmove',e.currentTarget.parentEle.handleDrag,true);
            document.body.addEventListener('touchend',e.currentTarget.parentEle.stopDrag,true);
        }

    },
    handleDrag : function(e){
        var drag = LytePopup.node;
        if(!LytePopup.node){
            return;
        }
        var mouseOffset;
        if(e.type == "mousemove"){
            mouseOffset = { x : e.clientX, y : e.clientY};
        }
        if(e.type == "touchmove"){
            mouseOffset = { x : e.touches[0].clientX, y : e.touches[0].clientY};
        }
        if(LytePopup.node.closest('lyte-wormhole')._callee.component.getData('ltPropTransition').animation == "fadeIn"){
            drag.style.left=(mouseOffset.x-LytePopup.xPos)+'px';
            drag.style.top=(mouseOffset.y-LytePopup.yPos)+'px';
        }
        else{
            var matrix = LytePopup.node.closest('lyte-wormhole')._callee.component.transform,
                x = matrix.x+(mouseOffset.x-LytePopup.xPos),
                y = matrix.y+(mouseOffset.y-LytePopup.yPos);
            drag.style.transform = "translate("+x+"px, "+y+"px)";
        }
        window.getSelection().removeAllRanges();
    },
    stopDrag : function(e){
        var targetElem = e.target;
        while(targetElem && targetElem !== document){
            if(targetElem.parentEle){
                if(e.type == "mouseup"){
                    this.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);
                    this.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);
                }
                if(e.type == "touchend"){
                    this.removeEventListener('touchmove',targetElem.parentEle.handleDrag,true);
                    this.removeEventListener('touchend',targetElem.parentEle.stopDrag,true);
                }
                break;
            }
            targetElem = targetElem.parentElement ? targetElem.parentElement : document;
        }
        if(LytePopup.node){
            var comp = LytePopup.node.closest('lyte-wormhole')._callee.component;
            LytePopup.node.style.transitionDuration = comp.getData('ltPropTransition').duration;
            if(comp.getData('ltPropTransition').animation != "fadeIn"){
                var matrix = new WebKitCSSMatrix(window.getComputedStyle(comp.actualModalDiv).transform);
                comp.transform = {'x' : matrix.m41, 'y' : matrix.m42};
            }
            LytePopup.node = null;
        }
    },
    showToggled : function(){

        var event = event || window.event;
        if(this.getData('returnedFalse')){
            this.setData('returnedFalse',false);
            return;
        }
        if(this.$node.ltProp("reRenderModal")){
            if(this.$node.ltProp("show")){
                this.$node.ltProp({"showCopy":false, "show":false});
                LytePopup.closePopup(this);
                this.setData("first",true);
                this.setData('initializedPosition',false);
            }
            this.$node.ltProp("reRenderModal",false);
        }
        if(this.timeOutId){
            // debugger
            delete this.timeOutId;
            this.closeModal();
            LytePopup.closePopup(this);
        }
        if(this.$node.ltProp("show") && !this.$node.ltProp("showCopy")){
            if(_lyteUiUtils.getRTL()){
              if(!this.getData('ltPropIgnoreInlineDirection')){
                if(this.getData('ltPropTransition').animation == "slideFromLeft"){
                    this.getData('ltPropTransition').animation = "slideFromRight";
                }
                else if(this.getData('ltPropTransition').animation == "slideFromRight"){
                    this.getData('ltPropTransition').animation = "slideFromLeft";
                }
                var offset = this.getData('ltPropOffset'),
                    newOffset = {};
                for(key in offset){
                    if(key == "left" && offset[key] != "center"){
                        newOffset.right = offset[key];
                    }
                    else if(key == "right"){
                        newOffset.left = offset[key];
                    }
                    else{
                        newOffset[key] = offset[key];
                    }
                }
                this.setData('ltPropOffset',newOffset);
              }
            }
            if(LytePopup.components.indexOf(this) != -1){
                LytePopup.closePopup(this);
                this.setData("first",true);
                this.setData('initializedPosition',false);
            }
            this.$node.ltProp("bindToBody",true);
            var self = this;
            this.beforeShowId = setTimeout(function(){
                delete self.beforeShowId;
                self.onBeforeShowHandling();
            },0);

        }
        else{
            this.clearFastdomBatch();
            if(this.$node.ltProp("showCopy")){
                var self = this;
                this.beforeCloseId = setTimeout(function(){
                    delete self.beforeCloseId;
                    self.onBeforeCloseHandling(event);
                },0);
            }
            else{
                if(LytePopup.components.indexOf(this) != -1){
                    LytePopup.closePopup(this);
                    this.setData("first",true);
                    this.setData('initializedPosition',false);
                }
            }
        }
    }.observes("ltPropShow","ltPropReRenderModal").on('didConnect'),
    clearFastdomBatch : function(){
        if(this.fastdomfn1){
            $L.fastdom.clear(this.fastdomfn1);
        }
        if(this.fastdomfn2){
            $L.fastdom.clear(this.fastdomfn2);
        }
        if(this.fastdomfn3){
            $L.fastdom.clear(this.fastdomfn3);
        }
        if(this.fastdomfn4){
            $L.fastdom.clear(this.fastdomfn4);
        }
        if(this.fastdomfn5){
            $L.fastdom.clear(this.fastdomfn5);
        }
        if(this.fastdomfn6){
            $L.fastdom.clear(this.fastdomfn6);
        }
        if(this.fastdomfn7){
            $L.fastdom.clear(this.fastdomfn7);
        }
        if(this.fastdomfn8){
            $L.fastdom.clear(this.fastdomfn8);
        }
        if(this.beforeShowId){
            clearTimeout(this.beforeShowId);
        }
    },
    changeBindToBody : function(){
        if(!this.getData('ltPropBindToBody')){
            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this,true);
                delete this.addedFreezeDetails;
            }
            LytePopup.closePopup(this);
            if(this.renderSidewise){
                delete this.renderSidewise;
                delete this.renderProps;
            }
            this.actualModalDiv = null;
            this.childComp = null;
            if(this.getData('ltPropShow') ){
                this.setData({'ltPropShowCopy':false,'ltPropShow':false});
            }
            else if(this.getData('ltPropShowCopy')){
                this.setData('ltPropShowCopy', false);
            }
            this.setData("first",true);
            this.setData('initializedPosition',false);
            this.$node.classList.remove('lyteModalOpened');
            // if(this.$node.ltProp('freeze')){
            //     LytePopup.bodywrapperCount -= 1;
            //     if(LytePopup.bodywrapperCount == 0){
            //         document.body.classList.remove('bodyWrapper');
            //     }
            // }
            LytePopup.checkAndRemoveWrapper();
        }
    }.observes("ltPropBindToBody"),
    addAriaValues : function( arg ) {
        if(this.getData('ltPropAria')){
            var ariaProp = this.getData('ltPropAriaAttributes') || {};
            _lyteUiUtils.setAttribute( this.actualModalDiv, ariaProp, arg ? arg.oldValue : {} );
            var closeIcon = this.actualModalDiv.querySelector('.lyteModalClose');
            if(closeIcon){
                closeIcon.setAttribute('aria-label', Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'close-label') || 'Close icon at top right position');
            }
        }
    }.observes('ltPropAriaAttributes','ltPropAriaAttributes.{}','checkAria'),

    /**
     * The method is going to set height and width of the modal
     *
     */
    updateScrollHandling : function(){    //It sets the height and width of the modal
        if(!this.$node.ltProp("freeze")){
            // this.$node.ltProp("scrollable",true);
            this.setData("calculateHW",true);
        }
        var modalElem = this.actualModalDiv;
        var oldHeight, oldWidth, newHeight, newWidth,
        w =  Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
        contentNode = modalElem.querySelector("lyte-modal-content");
        // contentNode = contentNode ? contentNode : modalElem;
        modalElem.style.maxWidth = "";
        modalElem.style.maxHeight = "";
        modalElem.style.height = this.$node.ltProp("height")?this.$node.ltProp("height"):"auto";
        modalElem.style.width = this.$node.ltProp("width")?( (!(this.getData('ltPropOverlapModal')) && this.$node.ltProp("width").indexOf('%') != -1) ? ((parseFloat(this.$node.ltProp("width"))/100) * w) + "px" : this.$node.ltProp("width") ):"auto";
        // console.log(this.$node.ltProp("width"));
        /*------------------------------ MEASURE STARTS --------------------------*/
        this.fastdomfn2 = $L.fastdom.measure(function() {    //Measures the initial height and width
            delete this.fastdomfn2;
            var modalElemOffset = modalElem.getBoundingClientRect();
            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height
                                we need the modalElements parent element's width and height*/
            var modalParentOff = modalElem.parentElement.getBoundingClientRect();
            var cs = window.getComputedStyle(modalElem);
            var borderDimensionY = ((cs.borderTopWidth ? parseFloat(cs.borderTopWidth) : 0) +
                                     (cs.borderBottomWidth ? parseFloat(cs.borderBottomWidth) : 0));
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (this.getData('ltPropFreeze') ? parseInt(window.getComputedStyle(modalElem.parentElement).top) : 0);
            // console.log(modalElemOffset);
            /*------------------------------ MUTATE STARTS --------------------------*/
            this.fastdomfn3 = $L.fastdom.mutate(function(){    //Checks for the max height and width provided by the user and sets the modal height and width based on that
                delete this.fastdomfn3;
                if(this.$node.ltProp("maxWidth")){
                    // this.$node.ltProp("scrollable",true);
                    // this.setData("calculateHW",true);
                    // oldWidth = modalElemOffset.width /*- borderDimensionX*/;
                    newWidth = this.$node.ltProp("maxWidth").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxWidth"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp("maxWidth"));
                    modalElem.style.maxWidth = newWidth + "px";
                    // if(oldWidth < newWidth){
                    //     modalElem.style.width = oldWidth+"px";
                    //     // newWidth = oldWidth;
                    // }
                    modalElem.style.overflowX = "auto";
                }
                else{
                    newWidth = modalElemOffset.width /*- borderDimensionX*/;
                }

                if(this.$node.ltProp("maxHeight")){
                    this.childComp.querySelector(".modalWrapper").classList.add("scrollable");
                    // this.$node.ltProp("scrollable",true);
                    this.setData("calculateHW",true);
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    var newH = this.$node.ltProp("maxHeight").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxHeight"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp("maxHeight"));
                    // modalElem.style.height = newH + "px";
                    modalElem.style.maxHeight = newH + "px";
                    newHeight = newH - borderDimensionY;
                }
                else{
                    /*  +1 is added here to the oldHeight as offsetHeights are rounded off values. ie. 5.5 => 6.
                        So, if 5.5 + 5.5 = 11. But offsetHeight will give 6 + 6 by rounding off 5.5 which is != 11.
                        So for safety we add extra 1 px to the total height.
                    */
                    oldHeight = modalElem.offsetHeight - borderDimensionY + 1;
                    //If height is provided in px or em then we dont compare if it is greater than window height as it is fixed
                    if(this.$node.ltProp('height') && this.$node.ltProp('height') != "auto"/* && ((this.$node.ltProp('height')).indexOf('px') != -1 || (this.$node.ltProp('height')).indexOf('em') != -1)*/){
                        newHeight = oldHeight;
                        this.setData("calculateHW",true);
                    }
                    else{
                        newHeight = oldHeight > h ? h-40 : oldHeight;
                    }
                    if(this.$node.ltProp("scrollable")){
                        if(!(this.$node.ltProp('height')) || this.$node.ltProp('height') == "auto"){
                            newHeight = h-40;
                        }
                        this.setData("calculateHW",true);
                    }
                    if(contentNode /*this.actualModalDiv.querySelector("lyte-modal-content")*/ && contentNode.offsetHeight /*this.actualModalDiv.querySelector("lyte-modal-content")*/ > oldHeight - ((this.actualModalDiv.querySelector("lyte-modal-header") ? this.actualModalDiv.querySelector("lyte-modal-header").offsetHeight : 0) + (this.actualModalDiv.querySelector("lyte-modal-footer") ? this.actualModalDiv.querySelector("lyte-modal-footer").offsetHeight : 0))){
                        // this.$node.ltProp("scrollable",true);
                        this.setData("calculateHW",true);
                    }
                }
                if(this.getData("calculateHW") && contentNode){
                    var modalheader = this.actualModalDiv.querySelector("lyte-modal-header"), modalFooter = this.actualModalDiv.querySelector("lyte-modal-footer");
                    var modalHOff = null,modalFOff = null;
                    /*------------------------------ MEASURE STARTS --------------------------*/
                    this.fastdomfn4 = $L.fastdom.measure(function(){   //measures the content haeder, content and footer dimensions
                        delete this.fastdomfn4;
                        if(modalheader){
                            modalHOff = modalheader.offsetHeight;
                        }
                        if(modalFooter){
                            modalFOff = modalFooter.offsetHeight;
                        }
                        var diff = 0;
                        var modalHeight = modalElem.getBoundingClientRect().height;
                        // if(this.getData('resizeCalled')){
                        //     //to get the difference between previous height and current height
                        //     if(this.getData('prevHeight') < modalHeight){
                        //         diff = modalHeight - this.getData('prevHeight');
                        //     }
                        //     this.setData('resizeCalled',false);
                        // }
                        this.setData('prevHeight',modalHeight);
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        this.fastdomfn5 = $L.fastdom.mutate(function(){   //Sets the final height and width of the modal
                            delete this.fastdomfn5;
                            var newH = (newHeight - ((modalHOff ? modalHOff : 0)+ (modalFOff ? modalFOff : 0)));
                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) + diff +"px";
                            contentNode.style.overflowY = "auto";
                            if(this.$node.ltProp('height') != "auto" && this.getData('ltPropSetContentHeight')){
                                contentNode.style.height = newH + "px";
                            }
                            // if(this.getData('first')){
                            //     contentNode.style.height = (oldHeight - ((modalHOff ? modalHOff.height : 0)+ (modalFOff ? modalFOff.height : 0))) +"px";
                            // }
                            // modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
                            // this.actualModalDiv.style.maxWidth = newWidth > 0 ? (newWidth +"px"):("70%");
                            modalElem = null;
                            contentNode = null;
                            modalheader = null;
                            modalFooter = null;
                            if(!this.getData('initializedPosition')){
                                this.computeOffsetImpl();
                                this.setData('initializedPosition',true);
                            }
                            else if(this.getData('resizeCalled')){
                                this.computeOffsetImplOnResize();
                                this.setData('resizeCalled',false);
                            }
                        },this);
                        /*------------------------------ MUTATE ENDS --------------------------*/
                    },this);
                    /*------------------------------ MEASURE ENDS --------------------------*/
                }
                else{
                    this.childComp.querySelector(".modalWrapper").classList.remove("scrollable");
                    modalElem = null;
                    contentNode = null;
                    if(!this.getData('initializedPosition')){
                        this.computeOffsetImpl();
                        this.setData('initializedPosition',true);
                    }
                    else if(this.getData('resizeCalled')){
                        this.computeOffsetImplOnResize();
                        this.setData('resizeCalled',false);
                    }
                }

                if (!this.$node.ltProp("freeze")) {
                    this.childComp.querySelector(".modalWrapper").classList.add('noFreeze');
                    if(!this.renderSidewise){
                        this.actualModalDiv.style.position = "fixed";
                    }
                }
                // else{
                //     this.childComp.querySelector(".modalWrapper").style.position = "fixed";
                // }
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/


    },
    scrollHandling : function(){
        if(!this.getData('ltPropShow')){
            return;
        }
        this.updateScrollHandling();
    }.observes("ltPropWidth","ltPropMaxWidth","ltPropHeight","ltPropMaxHeight"),
    callOnShow: function(){
        // if(this.getData('ltPropFreeze')){
        //     this.childComp.querySelector("lyte-modal-freeze").style.transitionDuration = this.getData('ltPropTransition').duration + "s";
        // }
        this.$node.classList.add('lyteModalOpened');
        if(this.getMethods("onShow")){
            this.executeMethod("onShow",this);
        }
    },
    callOnResize : function(){
        if(this.isResponsibleForSidewiseRender()){
            LytePopup.components[LytePopup.components.length - 1].$node.component.updateScrollHandling();
        }
        if(this.getMethods("onResize")){
            this.executeMethod("onResize",this);
        }
    },

    enableTransform : function(val,pos,duration){
        this.$node.ltProp('showCopy',true);
        var self = this;
        setTimeout(function(){
            if(pos == 'x'){
                self.actualModalDiv.style.transform = "translate("+val+"px,0px)";
                self.transform = {'x' : val, 'y' : 0};
            }
            if(pos == 'y'){
                self.actualModalDiv.style.transform = "translate(0px,"+val+"px)";
                self.transform = {'x' : 0, 'y' : val};
            }
        },(duration != undefined ? duration : undefined))

    },

    /**
     * The method is going to redo the left and top computation when the modal is opened and the window is resized
     *
     */
    computeOffsetImplOnResize : function(){
        /*------------------------------ MEASURE STARTS --------------------------*/
         $L.fastdom.measure(function() {
            var modalEle = this.actualModalDiv,
                modalElePosition = modalEle.getBoundingClientRect(),
                parentStyle = window.getComputedStyle(modalEle.parentElement),
                parentTop = parseInt(parentStyle.top), //Takes the modalWrapper's top value and subtracts it from the modals top to nullify the parent's top
                parentLeft = parseInt(parentStyle.left),
                correctedTop = modalEle.offsetTop,
                w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - (this.getData('ltPropFreeze') ? parentLeft : 0),
                h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (this.getData('ltPropFreeze') ? parentTop : 0),
                prevWinH = this.getData('prevWinH'),
                prevWinW = this.getData('prevWinW'),
                transform = this.transform /*new WebKitCSSMatrix(window.getComputedStyle(modalEle).transform)*/,
                newTop = null,
                newLeft = null,
                offsetObj = this.getData('ltPropOffset'),
                heightDiff = this.getData('prevModalHeight') - modalElePosition.height,
                widthDiff = this.getData('prevModalWidth') - modalElePosition.width,
                freezeLayer, wrapperDiv;
            this.calculateForSidewiseRender();
            if(this.renderSidewise){
                this.renderProps.windowWidth = w;
                w = this.getData('ltPropTransition').animation == 'slideFromRight' ? this.renderProps.left : (this.renderProps.windowWidth - this.renderProps.right);
                freezeLayer = this.childComp.querySelector('lyte-modal-freeze');
                wrapperDiv = this.actualModalDiv.parentElement;
            }
            if(this.getData('ltPropTransition').animation === "fadeIn" || this.getData('ltPropTransition').animation === "zoom"){
              prevWinH = modalElePosition.height
              prevWinW = modalElePosition.width
                if(w < prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = ((prevWinW - w) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = modalElePosition.left - (prevWinW - w);
                    }
                    else if(offsetObj.left){
                        newLeft = modalElePosition.left;
                    }
                }
                if(w > prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = ((w - prevWinW) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = modalElePosition.left + (w - prevWinW);
                    }
                    else if(offsetObj.left){
                        newLeft = modalElePosition.left;
                    }
                }
                if(h < prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = (h - modalElePosition.height)/2 /*correctedTop - ((prevWinH - h) / 2)*/;
                    }
                    else if(offsetObj.bottom){
                        newTop = correctedTop - (prevWinH - h);
                    }
                    else if(offsetObj.top){
                        newTop = correctedTop;
                    }
                }
                if(h > prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = (h - modalElePosition.height)/2 /*correctedTop + ((h - prevWinH) / 2)*/;
                    }
                    else if(offsetObj.bottom && offsetObj.bottom != "center"){
                        newTop = correctedTop + (h - prevWinH);
                    }
                    else if(offsetObj.top && offsetObj.top != "center"){
                        newTop = correctedTop;
                    }
                }
                $L.fastdom.mutate(function() {
                    if(newTop){
                        modalEle.style.top = newTop + "px";
                    }
                    if(newLeft){
                        modalEle.style.left = newLeft + "px";
                    }
                    this.callOnResize();
                },this);
            }
            else{
                if(w < prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = transform.x - ((prevWinW - w) / 2) + (widthDiff / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = transform.x - (prevWinW - w) + widthDiff;
                    }
                    else if(offsetObj.left){
                        newLeft = transform.x;
                    }
                    this.transform.x = newLeft;
                }
                if(w > prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = transform.x + ((w - prevWinW) / 2) + (widthDiff / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = transform.x + (w - prevWinW) + widthDiff;
                    }
                    else if(offsetObj.left){
                        newLeft = transform.x;
                    }
                    this.transform.x = newLeft;
                }
                if(h < prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = transform.y - ((prevWinH - h) / 2) + (heightDiff / 2);
                    }
                    else if(offsetObj.bottom){
                        newTop = transform.y - (modalElePosition.bottom - h + parseInt(offsetObj.bottom)) /*(prevWinH - h)*/;
                    }
                    else if(offsetObj.top){
                        newTop = transform.y;
                    }
                    this.transform.y = newTop;
                }
                if(h > prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = transform.y + ((h - prevWinH) / 2) + (heightDiff / 2);
                    }
                    else if(offsetObj.bottom && offsetObj.bottom != "center"){
                        newTop = transform.y + (h - modalElePosition.bottom - parseInt(offsetObj.bottom))/*(h - prevWinH)*/;
                    }
                    else if(offsetObj.top && offsetObj.top != "center"){
                        newTop = transform.y;
                    }
                    // console.log("prev top", this.transform.y);
                    // console.log("new top", newTop);
                    this.transform.y = newTop;
                }
                $L.fastdom.mutate(function() {
                    modalEle.style.transitionDuration = "0s";
                    if(this.getData('ltPropTransition').animation === "slideFromTop" || this.getData('ltPropTransition').animation === "slideFromBottom"){
                        if(w < prevWinW){
                            if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                                modalEle.style.left = modalElePosition.left - ((prevWinW - w) / 2) + (widthDiff/2) + "px";
                            }
                            else if(offsetObj.right){
                                modalEle.style.left = modalElePosition.left - (prevWinW - w) + widthDiff + "px";
                            }
                            else if(offsetObj.left){
                                modalEle.style.left = modalElePosition.left + "px";
                            }
                            // modalEle.style.left = modalElePosition.left - ((prevWinW - w)/2) + "px";
                        }
                        if(w > prevWinW){
                            if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                              modalEle.style.left = modalElePosition.left + ((w - prevWinW) / 2) + (widthDiff/2) + "px";
                            }
                            else if(offsetObj.right){
                                modalEle.style.left = modalElePosition.left + (w - prevWinW) + widthDiff + "px";
                            }
                            else if(offsetObj.left){
                                modalEle.style.left = modalElePosition.left + "px";
                            }
                            // modalEle.style.left = modalElePosition.left + ((w - prevWinW)/2) + "px";
                        }
                        modalEle.style.transform = "translate(0px,"+this.transform.y+"px)";
                    }
                    else if(this.getData('ltPropTransition').animation === "slideFromLeft" || this.getData('ltPropTransition').animation === "slideFromRight"){
                        if(h < prevWinH){
                            if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                                modalEle.style.top = correctedTop - ((prevWinH - h) / 2) + (heightDiff/2) + "px";
                            }
                            else if(offsetObj.bottom){
                                modalEle.style.top = correctedTop - (prevWinH - h) + "px";
                            }
                            else if(offsetObj.top){
                                modalEle.style.top = correctedTop + "px";
                            }
                            // modalEle.style.top = modalElePosition.top - ((prevWinH - h)/2) + "px";
                        }
                        if(h > prevWinH){
                            if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                                modalEle.style.top = correctedTop + ((h - prevWinH) / 2) + (heightDiff/2) + "px";
                            }
                            else if(offsetObj.bottom && offsetObj.bottom != "center"){
                                modalEle.style.top = correctedTop + (h - prevWinH) + "px";
                            }
                            else if(offsetObj.top && offsetObj.top != "center"){
                                modalEle.style.top = correctedTop + "px";
                            }
                            // modalEle.style.top = modalElePosition.top + ((h - prevWinH)/2) + "px";
                        }
                        modalEle.style.transform = "translate("+this.transform.x+"px,0px)";
                        if(this.renderSidewise){
                            if(this.getData('ltPropTransition').animation == 'slideFromRight'){
                                var rightValue = this.renderProps.windowWidth - this.renderProps.left;
                                if(freezeLayer){
                                    freezeLayer.style.right = rightValue + "px";
                                }
                                if(wrapperDiv){
                                    wrapperDiv.style.right = rightValue - 5 + "px";
                                }
                            }
                            if(this.getData('ltPropTransition').animation == 'slideFromLeft'){
                                if(freezeLayer){
                                    freezeLayer.style.left = this.renderProps.right + "px";
                                }
                                if(wrapperDiv){
                                    wrapperDiv.style.left = (this.renderProps.right + 1) + "px";
                                }
                            }
                        }
                    }
                    this.callOnResize();
                    // modalEle.style.transitionDuration = this.$node.ltProp("transition").duration+"s";
                },this);
            }
            this.setData('prevModalHeight',modalElePosition.height);
            this.setData('prevModalWidth',modalElePosition.width);
            this.setData('prevWinH',h);
            this.setData('prevWinW',w);
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        // modalEle = null;
    },

    isResponsibleForSidewiseRender : function(){
        var components = LytePopup.components;
        if(components.length > 1 && components[components.length - 2] === this && components[components.length - 1].renderSidewise){
            return true;
        }
        return false;
    },

    /**
     * The method is going to calculate the left and top value of the modal and perform the animation
     *
     */
    computeOffsetImpl : function(arg, triggeredFromTransChange){     //sets the left and top of the modal based on user provided values
        var _this = this.nodeName && this.nodeName === "LYTE-MODAL" ? this.component : this;
        /*------------------------------ MEASURE STARTS --------------------------*/
         _this.fastdomfn6 = $L.fastdom.measure(function() {
            delete _this.fastdomfn6;
            if(!_this.actualModalDiv){
                return;
            }
            _this.calculateForSidewiseRender();
            var modalEle = _this.actualModalDiv;
            var freezeLayer, wrapperDiv;
            var offsetObj = Lyte.deepCopyObject(_this.$node.ltProp('offset'));
            var modalRect = modalEle.getBoundingClientRect();
            var modalElePosition = {top: modalRect.top,
                                    right: modalRect.right,
                                    bottom: modalRect.bottom,
                                    left: modalRect.left,
                                    width: modalEle.offsetWidth,
                                    height: modalEle.offsetHeight
                                };
            var parentLeft = 0, parentTop = 0;
            if(_this.getData('ltPropFreeze')){
                var parentStyle = window.getComputedStyle(modalEle.parentElement);
                parentLeft = parseInt(parentStyle.left);
                parentTop = parseInt(parentStyle.top);
            }
            var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - parentLeft;
            if(_this.renderSidewise){
                _this.renderProps.windowWidth = w;
                w = _this.getData('ltPropTransition').animation == 'slideFromRight' ? _this.renderProps.left : (_this.renderProps.windowWidth - _this.renderProps.right);
                freezeLayer = _this.childComp.querySelector('lyte-modal-freeze');
                wrapperDiv = _this.actualModalDiv.parentElement;
            }
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - parentTop;
             // $L.fastdom.mutate(() => {
                modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp("transition").duration)+"s";
            // },this);
            _this.setData('prevWinH',h);
            _this.setData('prevWinW',w);
            _this.setData('prevModalHeight',modalElePosition.height);
            _this.setData('prevModalWidth',modalElePosition.width);
            if(offsetObj){
                if(offsetObj.left === "center" || offsetObj.right === "center"){
                    var offLeft = (w - modalElePosition.width)/2;
                    if(offLeft < 0){
                        offLeft = 20;
                    }
                    offsetObj.left = offLeft;
                }
                if(offsetObj.top === "center" || offsetObj.bottom === "center"){
                    var offTop = (h - modalElePosition.height)/2;
                    if(offTop < 0){
                        offTop = 20;
                    }
                    offsetObj.top = offTop;
                }
                if(offsetObj.right && offsetObj.right !== "center"){
                    if(offsetObj.right.indexOf("%") > -1){
                        offsetObj.left = w-(modalElePosition.width+(w/parseFloat(offsetObj.right)));
                    }
                    else{
                        offsetObj.left = w-(modalElePosition.width+parseFloat(offsetObj.right));
                    }
                }
                if(offsetObj.bottom && offsetObj.bottom !== "center"){
                    if(offsetObj.bottom.indexOf("%") > -1){
                        offsetObj.top = h-(modalElePosition.height+(h/parseFloat(offsetObj.bottom)));
                    }
                    else{
                        offsetObj.top = h-(modalElePosition.height+parseFloat(offsetObj.bottom));
                    }
                }
                if(offsetObj.left === "" || offsetObj.left == undefined){
                    _this.data.ltPropOffset.left = "center";
                    offsetObj.left = ((w - modalElePosition.width)/2);
                }
                if(offsetObj.top === "" || offsetObj.top == undefined){
                    _this.data.ltPropOffset.top = "center";
                    offsetObj.top = ((h - modalElePosition.height)/2);
                }
                if(_this.getData('ltPropTransition').originElement){
                    var ele = document.querySelector(_this.getData('ltPropTransition').originElement);
                    if(!ele){
                        Console.error("The originElement provided does not exist. Kindly Check!");
                    }
                    else{
                        var eleOffset = ele.getBoundingClientRect();
                        offsetObj.originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (parseFloat(offsetObj.left) + (modalElePosition.width/2)),
                                                      yDiff : (eleOffset.top + (eleOffset.height/2)) - (parseFloat(offsetObj.top) + (modalElePosition.height/2)) };
                    }
                }
                /*------------------------------ MUTATE STARTS --------------------------*/
                 _this.fastdomfn7 = $L.fastdom.mutate(function() {
                    delete _this.fastdomfn7;
                    if(_this.getData('first')){
                        LytePopup.bindTransitionEnd(_this.actualModalDiv);
                    }
                    if(_this.getData('ltPropTransition').animation == "slideFromTop"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = (-1 * modalElePosition.height) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate(0px,"+(parseInt(offsetObj.top)+modalElePosition.height)+"px)";
                            return;
                        }
                        _this.enableTransform(parseInt(offsetObj.top)+modalElePosition.height,"y",arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromBottom"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = h+1 + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate(0px,"+(-1 * (h - parseInt(offsetObj.top) + 1))+"px)";
                            return;
                        }
                        _this.enableTransform(-1 * (h - parseInt(offsetObj.top) + 1),"y",arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromLeft"){
                        if(_this.renderSidewise){
                            if(freezeLayer){
                                freezeLayer.style.left = _this.renderProps.right + "px";
                            }
                            if(wrapperDiv){
                                wrapperDiv.style.left = _this.renderProps.right + "px";
                            }
                        }
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.left = (-1 * modalElePosition.width) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate("+(parseInt(offsetObj.left)+modalElePosition.width)+"px,0px)";
                            return;
                        }
                        _this.enableTransform(parseInt(offsetObj.left)+modalElePosition.width,'x',arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromRight"){
                        if(_this.renderSidewise){
                            var rightValue = _this.renderProps.windowWidth - _this.renderProps.left;
                            if(freezeLayer){
                                freezeLayer.style.right = rightValue + "px";
                            }
                            if(wrapperDiv){
                                wrapperDiv.style.right = rightValue - 5 + "px";
                            }
                        }
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.left = w + 1 + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate("+(-1 * (w - parseInt(offsetObj.left) + 1))+"px,0px)";
                            return;
                        }
                        _this.enableTransform(-1 * (w - parseInt(offsetObj.left) + 1),'x',arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "fadeIn"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "";
                            return;
                        }
                        _this.$node.ltProp('showCopy',true);
                        // setTimeout(function(){
                            modalEle.style.opacity = 1;
                        // },200);
                    }
                    else if(_this.getData('ltPropTransition').animation == "zoom"){
                        _this.$node.ltProp('showCopy',true);
                        var transform = "scale(0)";
                        if(offsetObj.originElementPos){
                            transform = "translateX( "+ offsetObj.originElementPos.xDiff + "px) translateY( "+ offsetObj.originElementPos.yDiff + "px) scale(0)";
                        }
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.transition = "none";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = offsetObj.originElementPos ? 'translateX(0) translateY(0) scale(1)' : 'scale(1)';
                            setTimeout(function(){
                                modalEle.style.transition = "";
                            },16)
                            return;
                        }
                        modalEle.style.transform = transform;
                        modalEle.style.opacity = 1;
                        setTimeout(function(){
                            modalEle.style.transition = "";
                            modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp("transition").duration)+"s";
                            if(offsetObj.originElementPos){
                                modalEle.style.transform = 'translateX(0) translateY(0) scale(1)';
                            }
                            else{
                                modalEle.style.transform = 'scale(1)';
                            }
                        },50);
                    }
                    if(_this.$node.ltProp("freeze")){
                        document.body.classList.add('bodyWrapper');
                        // LytePopup.bodywrapperCount += 1;
                    }
                    if(_this.getData('first')){
                        // LytePopup.bindTransitionEnd(_this.actualModalDiv);
                        _this.callOnShow();
                        _this.setData("first",false);
                    }
                },_this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }
            else{
                _this.setData('ltPropOffset',{left:"center", top:"center"});
                // _this.data.ltPropOffset.left = "center";
                // _this.data.ltPropOffset.top = "center";
                offsetObj.left = ((w - modalElePosition.width)/2);
                offsetObj.top = ((h - modalElePosition.height)/2);
                if(!_this.$node.ltProp("scrollable")){
                    if(offsetObj.left < 0){
                        offsetObj.left = 20;
                    }
                    if(offsetObj.top < 0){
                        offsetObj.top = 20;
                    }
                }
                if(_this.getData('ltPropTransition').originElement){
                    var ele = document.querySelector(_this.getData('ltPropTransition').originElement);
                    if(!ele){
                        Console.error("The originElement provided does not exist. Kindly Check!");
                    }
                    else{
                        var eleOffset = ele.getBoundingClientRect();
                        offsetObj.originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (offsetObj.left + (modalElePosition.width/2)),
                                                      yDiff : (eleOffset.top + (eleOffset.height/2)) - (offsetObj.top + (modalElePosition.height/2)) };
                    }
                }
                /*------------------------------ MUTATE STARTS --------------------------*/
                _this.fastdomfn8 = $L.fastdom.mutate(function() {
                    delete _this.fastdomfn8;
                    if(_this.getData('first')){
                        LytePopup.bindTransitionEnd(_this.actualModalDiv);
                    }
                    if(_this.getData('ltPropTransition').animation == "slideFromTop"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = (-1 * modalElePosition.height) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate(0px,"+(parseInt(offsetObj.top)+modalElePosition.height)+"px)";
                            return;
                        }
                        _this.enableTransform(parseInt(offsetObj.top)+modalElePosition.height,"y",arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromBottom"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = h+1 + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate(0px,"+(-1 * (h - parseInt(offsetObj.top) + 1))+"px)";
                            return;
                        }
                        _this.enableTransform(-1 * (h - parseInt(offsetObj.top) + 1),"y",arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromLeft"){
                        if(_this.renderSidewise){
                            if(freezeLayer){
                                freezeLayer.style.left = _this.renderProps.right + "px";
                            }
                            if(wrapperDiv){
                                wrapperDiv.style.left = _this.renderProps.right + "px";
                            }
                        }
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.left = (-1 * modalElePosition.width) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate("+(parseInt(offsetObj.left)+modalElePosition.width)+"px,0px)";
                            return;
                        }
                        _this.enableTransform(parseInt(offsetObj.left)+modalElePosition.width,'x',arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromRight"){
                        if(_this.renderSidewise){
                            var rightValue = _this.renderProps.windowWidth - _this.renderProps.left;
                            if(freezeLayer){
                                freezeLayer.style.right = rightValue + "px";
                            }
                            if(wrapperDiv){
                                wrapperDiv.style.right = rightValue - 5 + "px";
                            }
                        }
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.left = w + 1 + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "translate("+(-1 * (w - parseInt(offsetObj.left) + 1))+"px,0px)";
                            return;
                        }
                        _this.enableTransform(-1 * (w - parseInt(offsetObj.left) + 1),'x',arg);
                    }
                    else if(_this.getData('ltPropTransition').animation == "fadeIn"){
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = "";
                            return;
                        }
                        _this.$node.ltProp('showCopy',true);
                        // setTimeout(function(){
                            modalEle.style.opacity = 1;
                        // },200);
                    }
                    else if(_this.getData('ltPropTransition').animation == "zoom"){
                        _this.$node.ltProp('showCopy',true);
                        var transform = "scale(0)";
                        if(offsetObj.originElementPos){
                            transform = "translateX( "+ offsetObj.originElementPos.xDiff + "px) translateY( "+ offsetObj.originElementPos.yDiff + "px) scale(0)";
                        }
                        modalEle.style.left = parseFloat(offsetObj.left) + "px";
                        modalEle.style.top = parseFloat(offsetObj.top) + "px";
                        modalEle.style.transition = "none";
                        if(triggeredFromTransChange){
                            modalEle.style.transform = offsetObj.originElementPos ? 'translateX(0) translateY(0) scale(1)' : 'scale(1)';
                            setTimeout(function(){
                                modalEle.style.transition = "";
                            },16)
                            return;
                        }
                        modalEle.style.transform = transform;
                        modalEle.style.opacity = 1;
                        setTimeout(function(){
                            modalEle.style.transition = "";
                            modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp("transition").duration)+"s";
                            if(offsetObj.originElementPos){
                                modalEle.style.transform = 'translateX(0) translateY(0) scale(1)';
                            }
                            else{
                                modalEle.style.transform = 'scale(1)';
                            }
                        },50);
                    }
                    if(_this.$node.ltProp("freeze")){
                        document.body.classList.add('bodyWrapper');
                        // LytePopup.bodywrapperCount += 1;
                    }
                    if(_this.getData('first')){
                        _this.callOnShow();
                        _this.setData("first",false);
                    }
                },_this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }

        },_this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        // modalEle = null;
    },

    /**
     * The method is going to check if sidewise render will be done and assigns the values that will be used for sidewise rendering of the modal
     *
     */
    calculateForSidewiseRender : function(){
        if(LytePopup.components.length > 1){
            var prevModal;
            if(LytePopup.components[LytePopup.components.length - 2].$node.tagName === "LYTE-MODAL"){
                prevModal = LytePopup.components[LytePopup.components.length - 2];
            }
            if(!this.getData('ltPropOverlapModal') && prevModal && prevModal.getData('ltPropAllowMultiple') && ["slideFromLeft","slideFromRight"].indexOf(this.getData('ltPropTransition').animation) != -1){
                this.renderSidewise = true;
                var prevModalOffset = prevModal.actualModalDiv.getBoundingClientRect();
                this.renderProps = {
                    prevModal : prevModal,
                    left : Math.round(prevModalOffset.left),
                    right : Math.round(prevModalOffset.right),
                    width : Math.round(prevModalOffset.width)
                };
            }
        }
    },

    closeModal : function(){
        var freezeLayer = this.childComp.querySelector('lyte-modal-freeze');
        if(this.renderSidewise){
            if(this.getData('ltPropTransition').animation == "slideFromRight"){
                if(freezeLayer){
                    freezeLayer.style.right = "";
                }
                this.actualModalDiv.parentElement.style.right = "";
            }
            if(this.getData('ltPropTransition').animation == "slideFromLeft"){
                if(freezeLayer){
                    freezeLayer.style.left = "";
                }
                this.actualModalDiv.parentElement.style.left = "";
            }
            delete this.renderSidewise;
            delete this.renderProps;
        }
        if(_lyteUiUtils.getRTL()){
            if(!this.getData('ltPropIgnoreInlineDirection')){
              if(this.getData('ltPropTransition').animation == "slideFromLeft"){
                  this.getData('ltPropTransition').animation = "slideFromRight";
              }
              else if(this.getData('ltPropTransition').animation == "slideFromRight"){
                  this.getData('ltPropTransition').animation = "slideFromLeft";
              }
            var offset = this.getData('ltPropOffset'),
                newOffset = {};
            for(key in offset){
                if(key == "left" && offset[key] != "center"){
                    newOffset.right = offset[key];
                }
                else if(key == "right"){
                    newOffset.left = offset[key];
                }
                else{
                    newOffset[key] = offset[key];
                }
            }
            this.setData('ltPropOffset',newOffset);
          }
        }
        if(this.getData('ltPropTransition').animation == "zoom"){
            this.actualModalDiv.style.opacity = "0";
            this.actualModalDiv.style.transform = "";
        }
        if(!this.$node.ltProp('freeze')){
            this.childComp.querySelector(".modalWrapper").classList.remove('noFreeze');
        }
        this.$node.ltProp({"showCopy":false,"show":false});
        // LytePopup.closePopup(this);

        if(this.$node.ltProp('freeze')){
            // LytePopup.bodywrapperCount -= 1;
            // if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
            //     document.body.classList.remove('bodyWrapper');
            // }
        }
        else{
            this.actualModalDiv.style.position = "";
        }
        this.$node.classList.remove('lyteModalOpened');
        if(this.actualModalDiv){
            this.actualModalDiv.style.transform = "";
        }
        if(this.getMethods("onClose")){
            this.executeMethod("onClose",this);
        }
        LytePopup.checkAndRemoveWrapper();
    },

    onBeforeCloseHandling : function(event){
        var result = true;
        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        if(this.getMethods("onBeforeClose")){
            result = this.executeMethod("onBeforeClose",event,this);
        }
        if(result === undefined || result){
            if(this.actualModalDiv && this.childComp){
                if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                    LytePopup.hideOrShowFreeze("close",this);
                    delete this.addedFreezeDetails;
                }
                var animDur = parseFloat(this.$node.ltProp('transition').duration) * 1000;
                var self = this;
                // console.log("duration",animDur);
                // var t1 = performance.now();
                this.timeOutId = setTimeout(function(){
                    delete self.timeOutId;
                    // var t2 = performance.now();
                    // console.log(t2 -t1);
                    self.closeModal();
                },animDur);
                var modalEle = this.actualModalDiv;
                if(this.getData('ltPropCloseDuration')){
                    modalEle.style.transitionDuration = (this.getData('ltPropCloseDuration') / 1000)+"s";
                }
                else{
                    modalEle.style.transitionDuration = (animDur / 1000)+"s";
                }
                // console.log("transitionDuration", modalEle.style.transitionDuration);
                var modalElemOffset;
                var transform = "scale(0)", transformVal;
                /*------------------------------ MEASURE STARTS --------------------------*/
                $L.fastdom.measure(function(){
                    modalElemOffset = modalEle.getBoundingClientRect();
                    if(this.getData('ltPropTransition').animation == "zoom" && this.getData('ltPropTransition').originElement){
                        var ele = document.querySelector(this.getData('ltPropTransition').originElement);
                        if(!ele){
                            Console.error("The originElement provided does not exist. Kindly Check!");
                        }
                        else{
                            var eleOffset = ele.getBoundingClientRect();
                            var modalElePosition = {top: modalElemOffset.top,
                                                    right: modalElemOffset.right,
                                                    bottom: modalElemOffset.bottom,
                                                    left: modalElemOffset.left,
                                                    width: modalEle.offsetWidth,
                                                    height: modalEle.offsetHeight
                                                };
                            var originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (modalElePosition.left + (modalElePosition.width/2)),
                                                          yDiff : (eleOffset.top + (eleOffset.height/2)) - (modalElePosition.top + (modalElePosition.height/2)) };
                            transform = "translateX( "+ originElementPos.xDiff + "px) translateY( "+ originElementPos.yDiff + "px) scale(0)"
                        }
                    }
                },this);
                /*------------------------------ MEASURE ENDS --------------------------*/
                /*------------------------------ MUTATE STARTS --------------------------*/
                $L.fastdom.mutate(function(){
                    if(this.getData('ltPropTransition').animation == "slideFromTop"){
                        // modalEle.style.transform = "translateY(-100%)";
                        transformVal = -(Math.ceil(modalElemOffset.height) + parseInt(modalEle.style.top) + 10) + "px";
                        modalEle.style.transform = "translateY("+transformVal+")";
                    }
                    else if(this.getData('ltPropTransition').animation == "slideFromBottom"){
                        // modalEle.style.transform = "translateY(100%)";
                        transformVal = (h - parseInt(modalEle.style.top) + 10) + "px";
                        modalEle.style.transform = "translateY("+transformVal+")";
                    }
                    else if(this.getData('ltPropTransition').animation == "slideFromLeft"){
                        // modalEle.style.transform = "translateX(-100%)";
                        transformVal = -(Math.ceil(modalElemOffset.width) + parseInt(modalEle.style.left) + 10) + "px";
                        modalEle.style.transform = "translateX("+transformVal+")";
                    }
                    else if(this.getData('ltPropTransition').animation == "slideFromRight"){
                        // modalEle.style.transform = "translateX(100%)";
                        transformVal = (((this.renderProps && this.renderProps.left) || w ) - parseInt(modalEle.style.left) + 10) + "px";
                        modalEle.style.transform = "translateX("+transformVal+")";
                    }
                    else if(this.getData('ltPropTransition').animation == "fadeIn"){
                        modalEle.style.opacity = 0;
                    }
                    else if(this.getData('ltPropTransition').animation == "zoom"){
                        modalEle.style.transform = transform;
                    }
                    delete this.transform;
                    if(!(this.$node.classList.contains('lyteModalOpened'))){
                        modalEle.style.transform = "";
                    }
                },this);
                $L.fastdom.mutate(function(){
                    modalEle = null;
                });
                /*------------------------------ MUTATE ENDS --------------------------*/

                modalEle.classList.remove('lyteModalFromTop','lyteModalFromBottom','lyteModalFromLeft','lyteModalFromRight','lyteModalFadeIn','lyteZoom');
                if(this.$node.ltProp('freeze') && this.childComp.querySelector("lyte-modal-freeze")){
                    var freezeLayer = this.childComp.querySelector("lyte-modal-freeze");
                    setTimeout(function(){
                        freezeLayer.style.opacity = 0;
                        freezeLayer.style.visibility = "";
                    }.bind(this), 300);
                }
                LytePopup.closePopup(this);
                // LytePopup.bindTransitionEnd(this.actualModalDiv);
                this.setData("first",true);
                this.setData('initializedPosition',false);
                this.setData('calculateHW', false);
            }
            this.$node.alignModal = null;
            this.$node.calculateOffset = null;
            this.$node.reflectTransitionChange = null;
        }
        else{
            this.setData('returnedFalse',true);
            this.$node.ltProp('show',true);
        }
    },
    onBeforeShowHandling : function(){
        var result = true;
        if(this.getMethods("onBeforeShow")){
            result = this.executeMethod("onBeforeShow",this) ;
        }
        if(result === undefined || result){
            this.setData('checkAria', this.getData('checkAria')+1);
            this.addDragHandler();
            this.updateScrollHandling();

            var modalEle = this.actualModalDiv;
            var val = "";
            modalEle.style.transitionDuration = this.$node.ltProp("transition").duration+"s";
            var classVal = "lyteModalFrom";
            var modalStyle = this.actualModalDiv.style;
            var modalElemOffset = this.actualModalDiv.getBoundingClientRect();
            var windowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

            switch(this.$node.ltProp("transition").animation){
                case "slideFromTop":
                    classVal += "Top";
                    break;
                case "slideFromBottom":
                    classVal += "Bottom";
                    break;
                case "slideFromLeft":
                    classVal += "Left";
                    break;
                case "slideFromRight":
                    classVal += "Right";
                    break;
                case "fadeIn":
                    classVal = "lyteModalFadeIn";
                    break;
                case "zoom":
                    classVal = "lyteZoom";
                    break;
            }
            /*------------------------------ MUTATE STARTS --------------------------*/
            this.fastdomfn1 = $L.fastdom.mutate(function(){
                delete this.fastdomfn1;
                this.actualModalDiv.classList.add(classVal);
                this.actualModalDiv.style.opacity = "";
                modalEle = null;
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
            LytePopup.addPopup(this);
            this.calculateForSidewiseRender();
            if(this.$node.ltProp('freeze')){
                var freezeLayer = this.childComp.querySelector("lyte-modal-freeze");
                if(this.renderSidewise){
                    if(this.getData('ltPropTransition').animation == 'slideFromRight'){
                        freezeLayer.style.right = (windowWidth - this.renderProps.left) + "px";
                    }
                    if(this.getData('ltPropTransition').animation == 'slideFromLeft'){
                        freezeLayer.style.left = this.renderProps.right + "px";
                    }

                }
                var freezeStyle = freezeLayer.style;
                // freezeStyle.opacity = this.getData('ltPropDimmer').opacity;
                if(this.getData('ltPropDimmer') && this.getData('ltPropDimmer').color){
                    freezeStyle.background = this.getData('ltPropDimmer').color;
                }
                if(!this.addedFreezeDetails){
                    freezeStyle.opacity = this.getData('ltPropDimmer') && this.getData('ltPropDimmer').opacity ? this.getData('ltPropDimmer').opacity : "";
                }
            }
            this.$node.alignModal = this.computeOffsetImpl.bind(this, 0, true);
            this.$node.calculateOffset = this.updateScrollHandling.bind(this);
            this.$node.reflectTransitionChange = this.reflectTransitionChange.bind(this);
        }
        else{
            this.setData('returnedFalse',true);
            this.$node.ltProp({"showCopy":false,"show":false});
        }
    },

    /**
     * The method is going to change the transition property when the modal is opened with different animation and closed with different animation
     * This util function is required to be triggered by the developer after they change the ltPropTransition value
     * The function can be triggered in onShow inside a setTimeout of 500ms or before the ltPropShow of the modal is set to false
     *
     */
    reflectTransitionChange : function(){
        this.computeOffsetImpl(null, true);
    },
    didDestroy : function(){
        this.$node.classList.remove('lyteModalOpened');
        if(this.timeOutId){
            clearTimeout(this.timeOutId);
            delete this.timeOutId;
        }
        if(this.beforeCloseId){
            clearTimeout(this.beforeCloseId);
            delete this.beforeCloseId;
        }
        if(this.renderSidewise){
            delete this.renderSidewise;
            delete this.renderProps;
        }
        if(this.childComp){
            this.clearFastdomBatch();
            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this);
                delete this.addedFreezeDetails;
            }
            LytePopup.closePopup(this);
            this.childComp.remove();
            delete this.actualModalDiv;
            delete this.childComp;
            // if(this.$node.ltProp('freeze')){
            //     LytePopup.bodywrapperCount -= 1;
            //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
            //         document.body.classList.remove('bodyWrapper');
            //     }
            // }
            LytePopup.checkAndRemoveWrapper();
        }
        // LytePopup.components = [];
    },
    actions: {
        close : function(){
           this.$node.ltProp("show",false);
        }
    },
    methods : {
        beforeWormholeAppend : function(arg){
            if(this.childComp){
                delete this.childComp;
            }
            if(this.actualModalDiv){
                delete this.actualModalDiv;
            }
            this.childComp = arg;
            this.actualModalDiv = this.childComp.querySelector(".lyteModal");
        }
    }
});

if (document.readyState === "complete" || document.readyState === "interactive"){
    addModalEvent();
}
else{
    document.addEventListener("DOMContentLoaded", function(event){
        addModalEvent(event);
    });
}
function addModalEvent(event){
    window.addEventListener('resize',function(event){
        // console.log(Math.max(document.documentElement.clientHeight, window.innerHeight || 0));
        if(LytePopup._lyteModalRTId){
            // console.log(LytePopup._lyteModalRTId);
            clearTimeout(LytePopup._lyteModalRTId);
            LytePopup._lyteModalRTId = false;
        }
        LytePopup._lyteModalRTId = setTimeout(function(){
            for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){
                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-MODAL" && LytePopup.components[i].childComp.style.visibility == "visible" && LytePopup.components[i].childComp.querySelector('.lyteModal')){
                    LytePopup.components[i].$node.component.setData('resizeCalled',true);
                    if((i == LytePopup.components.length - 1) && LytePopup.components[i].renderSidewise){
                        continue;
                    }
                    LytePopup.components[i].$node.component.updateScrollHandling();
                }
            }
            LytePopup._lyteModalRTId = false;
        },100);
    },true);

    document.addEventListener('click',function(event){
        var ele = event.target;
        while(!$L(ele).hasClass('modalWrapper') && ele.tagName != "LYTE-MODAL-FREEZE" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){
            ele = ele.parentElement;
            if(!ele){
                return
            }
        }
        if(ele.tagName == "HTML" || ele.tagName == "LYTE-MODAL-FREEZE"){
            for(var i = LytePopup.components.length -1 ; i>=0; i--){
                if(LytePopup.components[i].$node.tagName == "LYTE-MODAL" && LytePopup.components[i].childComp.style.visibility == "visible"){
                    var modal = LytePopup.components[i].$node;

                    if(modal && modal.component.getData('ltPropOverlayClose')){
                        modal.ltProp('show',false);
                        break;
                    }
                }
            }
        }
        else{
            /*  If ele is having modalWrapper class ie. a modal and it is not the modal that is opened at last which is the current modal element in the page
            this means the click has happened outside the current modal
            so the current modal should be closed */
            if(ele.classList.contains('modalWrapper') && LytePopup.components.length > 1 && LytePopup.components[LytePopup.components.length -1].$node.tagName == "LYTE-MODAL"){
                var modal = LytePopup.components[LytePopup.components.length -1];
                if(!(modal.childComp.contains(ele)) && modal.childComp.style.visibility == "visible" && modal.getData('ltPropOverlayClose')){
                    modal.$node.ltProp('show',false);
                }
            }
        }
    },true);
}
;

if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) { // .length of function is 2
      'use strict';
      if (target == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}

/**
 * @syntax yielded
 * <lyte-modal>
 *     <template is = "registerYield" yield-name = "modal">
 *         <lyte-modal-header> Create Profile </lyte-modal-header>
 *         <lyte-modal-content>
 *             //Some Content
 *         </lyte-modal-content>
 *         <lyte-modal-footer class = "right">
 *             //Some button
 *         </lyte-modal-footer>
 *     </template>
 * </lyte-modal>
 */

/**
 * Lyte number is used to get number input from user
 * @component lyte-number
 * @version 2.2.3
 * @utility focus,blur,click,select
 * @methods beforeRender,afterRender,onValueChange,onBeforePaste,onFocus,onBlur
 */

Lyte.Component.register("lyte-number", {
_template:"<template tag-name=\"lyte-number\"> <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\"> <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label> </template></template> <div class=\"lyteField\"> <input type=\"text\" name=\"{{ltPropName}}\" class=\"{{ltPropClass}}\" id=\"{{ltPropId}}\" placeholder=\"{{ltPropPlaceholder}}\" value=\"{{lbind(ltPropValue)}}\" onkeydown=\"{{action('keydown',event,this)}}\" onpaste=\"{{action('paste',event,this)}}\" oninput=\"{{action('input',event,this)}}\" onfocus=\"{{action('focus',event,this)}}\" onblur=\"{{action('blur',event,this)}}\" onwheel=\"{{action('wheel',event,this)}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\" pattern=\"{{ltPropPattern}}\" autocomplete=\"{{ltPropAutocomplete}}\"> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}}],
_observedAttributes :["ltPropValue","ltPropMaxlength","ltPropName","ltPropClass","ltPropId","ltPropPlaceholder","ltPropIgnoreSymbols","ltPropStep","ltPropInverse","ltPropWheel","ltPropMax","ltPropMin","ltPropAutofocus","ltPropDisabled","ltPropReadonly","ltPropStyle","ltPropInputTitle","ltPropPattern","ltPropUpdateDelay","ltPropLabel","ltPropAutocomplete","ltPropAppearance","ltPropDirection","ltPropValidateOnInput","ltPropAutoUpdate","ltPropDecimal","ltPropIncrement","ltPropAria","ltPropAriaAttributes","ltPropRemoveAtCursor","ltPropFireOnInit","ltPropValidateOnEmpty"],

	didConnect : function(){
		[ 'focus', 'blur', 'click', 'select' ].forEach( function( item ){
	        this.$node[ item ] = function( arg ){
	            this.$node.querySelector( 'input' )[item]( arg );
	        }.bind( this )      
	    }.bind( this ) ) 
		if( this.data.ltPropAutofocus ){
			this.$node.focus();
		}
		this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );
	},

	init : function(){
		this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node );
	},

	didDestroy : function(){
		clearTimeout( this._time );
	},

	data : function(){
		return {
			/**
			 * @componentProperty {string} ltPropValue=''
			 * @version 2.2.3
			 */

			ltPropValue : Lyte.attr( 'string', { default : '' } ),
			/**
			 * @componentProperty {number} ltPropMaxlength
			 * @version 2.2.3
			 */
			ltPropMaxlength : Lyte.attr( 'number', { default : undefined } ),
			/**
			 * @componentProperty {string} ltPropName
			 * @version 2.2.3
			 */
			ltPropName : Lyte.attr( 'string', { default : undefined } ),
			/**
			 * @componentProperty {string} ltPropClass
			 * @version 2.2.3
			 */
			ltPropClass : Lyte.attr( 'string', { default : undefined } ),
			/**
			 * @componentProperty {string} ltPropId
			 * @version 2.2.3
			 */
			ltPropId : Lyte.attr( 'string', { default : undefined } ),
			/**
			 * @componentProperty {string} ltPropPlaceholder=''
			 * @version 2.2.3
			 */
			ltPropPlaceholder:Lyte.attr('string',{default :''}),
			/**
			 * @componentProperty {boolean} ltPropIgnoreSymbols=false
			 * @version 2.2.3
			 */
			ltPropIgnoreSymbols : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {number} ltPropStep=1
			 * @version 2.2.3
			 */
			ltPropStep : Lyte.attr( 'number', { default : 1 } ),
			/**
			 * @componentProperty {boolean} ltPropInverse=false
			 * @version 2.2.3
			 */
			ltPropInverse : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {boolean} ltPropWheel=true
			 * @version 2.2.3
			 */
			ltPropWheel : Lyte.attr( 'boolean', { default : true } ),
			/**
			 * @componentProperty {number} ltPropMax
			 * @version 2.2.3
			 */
			ltPropMax : Lyte.attr( 'number', { default : undefined } ),
			/**
			 * @componentProperty {number} ltPropMin
			 * @version 2.2.3
			 */
			ltPropMin : Lyte.attr( 'number', { default : undefined } ),
			/**
			 * @componentProperty {boolean} ltPropAutofocus=false
			 * @version 2.2.3
			 */
			ltPropAutofocus : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {boolean} ltPropDisabled=false
			 * @version 2.2.3
			 */
			ltPropDisabled : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {boolean} ltPropReadonly=false
			 * @version 2.2.3
			 */
			ltPropReadonly : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {string} ltPropStyle=''
			 * @version 2.2.3
			 */
			ltPropStyle : Lyte.attr( 'string', { default : '' } ),
			/**
			 * @componentProperty {string} ltPropInputTitle=''
			 * @version 2.2.3
			 */
			ltPropInputTitle : Lyte.attr( 'string', { default : undefined } ),
			/**
			 * @componentProperty {string} ltPropPattern='.+'
			 * @version 2.2.3
			 */
			ltPropPattern : Lyte.attr( 'string', { default : '.+' } ),
			/**
			 * @componentProperty {number} ltPropUpdateDelay=250
			 * @version 2.2.3
			 */
			ltPropUpdateDelay : Lyte.attr( 'number', { default : 250 } ),
			/**
			 * @componentProperty {string} ltPropLabel=''
			 * @version 2.2.3
			 */
			ltPropLabel : Lyte.attr( 'string', { default : '' } ),
			/**
			 * @componentProperty {on | off} ltPropAutocomplete=off
			 * @version 2.2.3
			 */
			ltPropAutocomplete : Lyte.attr( 'string', { default : 'off' } ),
			/**
			 * @componentProperty {box | flat} ltPropAppearance=box
			 * @version 2.2.3
			 */
			ltPropAppearance : Lyte.attr( 'string', { default : 'box' } ),
			/**
			 * @componentProperty {vertical | horizontal} ltPropDirection=vertical
			 * @version 2.2.3
			 */
			ltPropDirection : Lyte.attr( 'string', { default : 'vertical' } ),
			/**
			 * @componentProperty {boolean} ltPropValidateOnInput=false
			 * @version 2.2.3
			 */
			ltPropValidateOnInput : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {boolean} ltPropAutoUpdate=true
			 * @version 2.2.3
			 */
			ltPropAutoUpdate : Lyte.attr( 'boolean', { default : true } ),
			/**
			 * @componentProperty {string} ltPropDecimal=.
			 * @version 2.2.8
			 */
			ltPropDecimal : Lyte.attr( 'string', { default : '.' } ),
			/**
			 * @componentProperty {boolean} ltPropIncrement=true
			 * @version 2.2.9
			 */
			ltPropIncrement : Lyte.attr( 'boolean', { default : true } ),

			// aria
			/**
			 * @componentProperty {boolean} ltPropAria=false
			 * @version 3.1.0
			 */
            ltPropAria : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {object} ltPropAriaAttributes
			 * @default {}
			 * @version 3.1.0
			 */            
            ltPropAriaAttributes : Lyte.attr( 'object', { default : {} } ),

            /**
			 * @componentProperty {object} ltPropRemoveAtCursor=false
			 * @version 2.2.15
			 */    
            ltPropRemoveAtCursor : Lyte.attr( 'boolean', { default : false } ),

			//test
			/**
			 * @componentProperty {object} ltPropFireOnInit=false
			 * @version 2.2.3
			 */    
			ltPropFireOnInit : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {object} ltPropValidateOnEmpty=true
			 * @version 2.2.3
			 */    
			ltPropValidateOnEmpty : Lyte.attr( 'boolean', { default : true } )
		}		
	},

	valueObs : function( arg ){
		if( this._init ){
			return;
		}
		var isInit = !arg;
		if( !arg ){
			arg = { newValue : this.data.ltPropValue || '' };
		} else {
			arg.newValue = arg.newValue || "";
		}
		if( this._allowCallback ){
			delete this._allowCallback;
			this.getMethods( 'onValueChange' ) && this.executeMethod( 'onValueChange', arg, this.$node );
			return;
		}
		var newVal = arg.newValue, remove;

		if( isInit && !this.data.ltPropFireOnInit ){
			this._init = true;
		}

		remove = this.validate( newVal );
		if( remove ){
			this._valueUpdate( '' );
			delete this._init;
			return
		}
		newVal = this.maxLenValidation( newVal );
		if( ( this.data.ltPropValidateOnEmpty && !arg.newValue ) || arg.newValue ){
			newVal = this.maxMinCheck( newVal, true );
		}
		if( arg.newValue != newVal ){
			this._valueUpdate( newVal );
		} else if( !this._init ) {
			if( isInit && arg.newValue == newVal ){
				return;
			}
			this.getMethods( 'onValueChange' ) && this.executeMethod( 'onValueChange', arg, this.$node );
		}
		delete this._init;

	}.observes( 'ltPropValue' ).on( 'didConnect' ),

	maxMinOns : function(){
		this._valueUpdate( this.maxMinCheck( this.data.ltPropValue, true ) );
	}.observes( 'ltPropMax', 'ltPropMin' ),

	appearanceObs : function(){
		if( /box/i.test( this.data.ltPropAppearance ) ){
			this.$node.classList.add( 'lyteInputBox' );
			this.$node.classList.remove( 'lyteInput' );
		} else{
			this.$node.classList.remove( 'lyteInputBox' );
			this.$node.classList.add( 'lyteInput' );
		}
	}.observes( 'ltPropAppearance' ).on( 'didConnect' ),

	directionObs : function(){
		if( /vertical/i.test( this.data.ltPropDirection ) ){
			this.$node.classList.add( 'vertical' );
			this.$node.classList.remove( 'horizontal' );
		} else {
			this.$node.classList.remove( 'vertical' );
			this.$node.classList.add( 'horizontal' );
		}
	}.observes( 'ltPropDirection' ).on( 'didConnect' ),

	disAbs : function(){
        this.$node.classList[ this.data.ltPropDisabled ? 'add' : 'remove' ]( 'lyteNumberDisabled' );
    }.observes( 'ltPropDisabled' ).on( 'didConnect' ),

    readAbs : function(){
        this.$node.classList[ this.data.ltPropReadonly ? 'add' : 'remove' ]( 'lyteNumberReadonly' );
    }.observes( 'ltPropReadonly' ).on( 'didConnect' ),

	increment : function( _this, isIncrement ){
		var value = _this.value || '0',
		newVal = ( Number( value ) + this.data.ltPropStep * ( isIncrement ? 1 : -1 ) ).toString();
		if( newVal == Infinity || newVal == -Infinity ){
			return;
		}
		newVal = this.maxLenValidation( newVal );
		newVal = this.maxMinCheck( newVal, true );
		_this.value = newVal;
		_this.selectionEnd = newVal.length;
		_this.selectionStart = newVal.length;
		this.data.ltPropAutoUpdate && this.valueUpdate( _this );
	},

	actions : {
		keydown : function( evt, _this ){
			var keyCode = evt.which || evt.keyCode, prevent,
			start = _this.selectionStart,
			end = _this.selectionEnd,
			inc = this.data.ltPropIncrement;

			if( keyCode == 8 ){
				if( start == end && end == 0 ){
					return;
				}
				this._prevent = true;
			} else if( inc && keyCode == 38 ){
				this.increment( _this, !this.data.ltPropInverse );
				prevent = true;
			} else if( inc && keyCode == 40 ){
				this.increment( _this, this.data.ltPropInverse );
				prevent = true;
			} 
			if( prevent ){
				evt.preventDefault();
			}
		},

		wheel : function( evt, _this ){
			if( this.data.ltPropWheel && this._focused && !this.data.ltPropDisabled && !this.data.ltPropReadonly ){
				if( evt.deltaY > 10 ){
					this.increment( _this, !this.data.ltPropInverse );
				} else if( evt.deltaY < -10 ){
					this.increment( _this, this.data.ltPropInverse );
				}
				evt.preventDefault();
			}
		},

		paste : function( evt, _this ){
			evt.preventDefault();
			var clip = evt.clipboardData || window.clipboardData,
			oldValue = _this.value,
			start = _this.selectionStart,
			end = _this.selectionEnd,
			decimal = this.data.ltPropDecimal,
			pasteText = clip.getData( 'text' ).trim().replace(/^(\'|\")|(\'|\")$/, '').replace( new RegExp('\[\^0-9e\\+\\-\\' + decimal + '\]', 'g' ), '' ),
			newVal = oldValue.slice( 0, start ) + pasteText + oldValue.slice( end ),
			remove = this.validate( newVal );
			if( remove ){
				newVal = this.convertToNo( newVal );
			}
			if( Number( oldValue ) == Infinity || Number( oldValue ) == -Infinity ){
				return;
			}
			if( this.getMethods( 'onBeforePaste' ) ){
				var ret = this.executeMethod( 'onBeforePaste', _this.value, clip.getData( 'text' ), newVal );
				if( ret != undefined ){
					newVal = ret;
					if( ret == false ){
						return;
					}
				} 
			}
			if( Number( oldValue ) == Infinity || Number( oldValue ) == -Infinity ){
				return;
			}
			newVal = this.maxLenValidation( newVal );
			if( newVal || ( !newVal && this.data.ltPropValidateOnEmpty ) ){
				newVal = this.maxMinCheck( newVal, true );
			}
			_this.value = newVal;
			_this.selectionStart = end + pasteText.length;
			_this.selectionEnd = end + pasteText.length;
			this.data.ltPropAutoUpdate && this._valueUpdate( _this.value );
		},

		input : function( evt, _this ){
			var prevent;
			if( this._prevent ){
				delete this._prevent;
				this.data.ltPropAutoUpdate && this.valueUpdate( _this );
				prevent = true;
			}
			var value = _this.value,
			oldValue = value,
			start = _this.selectionStart,
			end = _this.selectionEnd,
			remove = !prevent && this.validate( value ),
			minLenCheck;

			if( remove ){
				if( /insertText/i.test( evt.inputType ) ){
					var newvalueISNo = parseFloat( evt.data );
					if( !isNaN( newvalueISNo ) ){
						newvalueISNo = newvalueISNo.toString(); 
						value = value.slice( 0, end - evt.data.length ) + newvalueISNo + value.slice( end );
						end = end - evt.data.length + 1 + newvalueISNo.length;
					} else {
						value = value.slice( 0, end - evt.data.length ) + value.slice( end );
						end = end - evt.data.length + 1;
					}
				} else {
					value = value.slice( 0, start - 1 ) + value.slice( end );
				}
			} else {
				var nw = this.maxLenValidation( value, start, end );
				if( nw != value ){
					if( this.data.ltPropRemoveAtCursor ){
						minLenCheck = true;
					}
					value = nw;
				}
				nw = this.maxMinCheck( value, this.data.ltPropValidateOnInput );
				if( nw != value ){
					value = nw;
					minLenCheck = false;
				}
			}
			_this.value = value;
			if( remove ){
				_this.selectionStart = Math.min( end - 1, value.length );
				_this.selectionEnd = Math.min( end - 1, value.length )
			} else {
				if( oldValue != value ){
					if( minLenCheck ){
						_this.selectionStart = _this.selectionEnd = start - 1;
					} else {
						_this.selectionStart = _this.selectionEnd = value.length;
					}
				} else {
					_this.selectionStart = Math.min( start, value.length );
					_this.selectionEnd = Math.min( end, value.length );
				}
			}

			this.data.ltPropAutoUpdate && this.valueUpdate( _this );
		},

		focus : function( evt, _this ){
			this._focused = true;
			this.$node.classList.add( 'lyteInputFocus' );
			this.getMethods( 'onFocus' ) && this.executeMethod( 'onFocus', evt, this.$node );
		},

		blur : function( evt, _this ){
			delete this._focused;
			this.$node.classList.remove( 'lyteInputFocus' );
			this._valueUpdate( _this.value, true );
			if( _this.value || ( !_this.value && this.data.ltPropValidateOnEmpty )){
				_this.value = this.maxMinCheck( _this.value, true );
			}			
			this.getMethods( 'onBlur' ) && this.executeMethod( 'onBlur', evt, this.$node );
		}
	},

	valueUpdate : function( _this ){
		_this = _this || this.$node.getElementsByTagName( 'input' )[ 0 ];

		if( this.data.ltPropUpdateDelay == undefined ){
			this._valueUpdate( _this.value );
		} else {
			clearTimeout( this._time );
			this._time = setTimeout( this._valueUpdate.bind( this, _this.value ), this.data.ltPropUpdateDelay );
		}
	},

	_valueUpdate : function( value, force ){
		if( force ){
			var endDotRegex = new RegExp( "\\" + this.data.ltPropDecimal + "$" );
			if( /e$/i.test( value ) ){
				value = value.replace( /e$/, '' );
			}
			if( endDotRegex.test( value ) ){
				value = value.replace( endDotRegex, '' );
			}
		}
		if( value != this.data.ltPropValue ){
			this._allowCallback = true;
			this.$node.ltProp( 'value', value );
		}
	},

	validate : function( value ){
		var numberRegex = /\d+/,
		eRegex = /e/ig,
		plusOrMinus = /(\+|\-)/g,
		decimal = this.data.ltPropDecimal,
		dotRegex = new RegExp("\\" + decimal, 'g'),
		eRegexIndex,
		remove;

		if( eRegex.test( value ) ){
			if( value.match( eRegex ).length > 1 ){
				remove = true;
			} if( /^e/i.test( value ) ){
				remove = true;
			} else {
				eRegexIndex = /e/ig.exec( value ).index;
				value = value.replace( eRegex, '' );
			}
		} 
		if( plusOrMinus.test( value ) ) {
			if( value.match( plusOrMinus ).length > 1 ){
				remove = true;
			} else if( !/^(\+|\-)/g.test( value ) ){
				remove = true;
			} else {
				value = value.replace( plusOrMinus, '' );
			}
		} 
		if( dotRegex.test( value ) ){
			if( value.match( dotRegex ).length > 1 || ( eRegexIndex != undefined && eRegexIndex < value.indexOf( decimal ) ) ){
				remove = true;
			} else if( ( /^(\+|\-)/g.test( value ) && value.indexOf( decimal ) == 1 && eRegexIndex == 2  ) || ( !/^(\+|\-)/g.test( value ) && value.indexOf( decimal ) == 0 && eRegexIndex == 1 ) ){ 
 				remove = true;
			} else {
				value = value.replace( dotRegex, '' );
			}
		}
		if( !remove && value.length ){
			remove = !/^\d+$/.test( value );
		}
		return remove;
	},

	maxLenValidation : function( value, start, end ){
		var maxLen = this.data.ltPropMaxlength,
		length = value.length, dotIndex,
		decimal = this.data.ltPropDecimal,
		removeAt = this.data.ltPropRemoveAtCursor;

		if( maxLen == undefined ){
			return value;
		}
		if( !this.data.ltPropIgnoreSymbols ){
			maxLen = maxLen + ( /^(\+|\-)/.test( value ) ? 1 : 0 );
			if( new RegExp("\\" + decimal ).test( value ) ){
				dotIndex = new RegExp("\\" + decimal, 'g').exec( value ).index;
				maxLen++;
			}
			if( /e/i.test( value ) ){
				var index = /e/i.exec( value ).index,
				power = value.slice( index + 1 ),
				parsedPow = parseInt( power );
				if( power.length ){
					length--;
					//if( dotIndex != undefined ){
						var lenAfterDot = dotIndex != undefined ? value.slice( dotIndex + 1, index ).length : 0;
						if( lenAfterDot <= parsedPow ){
							if( dotIndex != undefined ){
								length--;
								maxLen--;
							}
							length -= lenAfterDot;
						} 
						length -= power.length;
						length += parsedPow;
						if( length > maxLen ){
							if( parsedPow > ( length - maxLen ) ){
								return value.slice( 0, index ) + 'e' + ( parsedPow - ( length - maxLen ) );
							} else {
								if( removeAt && start != undefined && value.length > maxLen ){
									value = value.split( /e/i )[ 0 ];
									value = value.slice( 0, start - 1 ) + value.slice( end );
								} else {
									value = value.split( /e/i )[ 0 ].match( new RegExp('.{0,' + maxLen + '}') )[ 0 ];
								}

							}
						} 
						return value;
					// }
				} else {
					maxLen++;
				}
			} 
		}
		if( removeAt && start != undefined && value.length > maxLen ){
			return value.slice( 0, start - 1 ) + value.slice( end );
		}
		return value.match( new RegExp('.{0,' + maxLen + '}') )[ 0 ];
	},

	maxMinCheck : function( value, allowMin ){
		var initial = value,
		max = this.data.ltPropMax,
		min = this.data.ltPropMin,
		parsedValue = Number( value.replace( new RegExp("\\" + this.data.ltPropDecimal ), '.' ) ),
		maxMinVal = this.getMethods( 'onBeforeMaxMinValidation' )

		if( max == undefined && min == undefined ){
			return value;
		} 
		if( max != undefined ){
			if( max < parsedValue ){
				value = max;
				/**
				 * @method onBeforeMaxMinValidation
				 * @version 2.2.9
				 */				
				var callbackvalue = maxMinVal ? this.executeMethod( 'onBeforeMaxMinValidation', 'max', initial, value, this.$node ) : value;
				value = callbackvalue == undefined ? value : callbackvalue;
			}
		}  
		if( allowMin && min != undefined  ){
			if( min > parsedValue ){
				value = min;
				value = min;
				var callbackvalue = maxMinVal ? this.executeMethod( 'onBeforeMaxMinValidation', 'min', initial, value, this.$node ) : value;
				value = callbackvalue == undefined ? value : callbackvalue;
			} else if( parsedValue == 0 && value == '' ){
				value = Math.max( parsedValue, min );
				var callbackvalue = maxMinVal ? this.executeMethod( 'onBeforeMaxMinValidation', 'min', initial, value, this.$node ) : value;
				value = callbackvalue == undefined ? value : callbackvalue;
			}
		}
		return value.toString().replace( /\./, this.data.ltPropDecimal );	
	},

	removeTwice : function( text, regex ){
		var split = text.split( regex );
		if( split.length > 1 ){
			var pop = split.shift(),
			eVal = regex.exec( text )[ 0 ];
			text = pop + eVal + split.join( '' );
		}

		return text;
	},

	convertToNo : function( newVal ){
		var decimal = this.data.ltPropDecimal,
		dotRegex = new RegExp("\\" + decimal ),
		eRegex = /e/i,
		dotIndex,
		eIndex;

		newVal = this.removeTwice( newVal, dotRegex );
		
		newVal = this.removeTwice( newVal, eRegex );
		newVal = this.removeTwice( newVal, /\+|\-/i );

		if( dotRegex.test( newVal ) && eRegex.test( newVal ) ){
			dotIndex = dotRegex.exec( newVal ).index;
			eIndex = eRegex.exec( newVal ).index;
			if( dotIndex > eIndex || Math.abs( dotIndex - eIndex ) == 1 ){
				newVal = newVal.replace( dotIndex > eIndex ? eRegex : dotRegex, '' );
			}
		}

		if( /^e/i.test( newVal ) ){
			newVal = newVal.replace( /e/i, '' );
		}

		if( /\+|\-/.test( newVal ) && !/^(\+|\-)/.test( newVal ) ) {
			if( ( eIndex != undefined && /\+|\-/.exec( newVal ).index != eIndex + 1 ) || eIndex == undefined ){
				newVal = newVal.replace( /\+|\-/g, '' );
			}
		}

		return newVal;	
	},

     attrObs : function( arg ){
        this.data.ltPropAria && _lyteUiUtils.setAttribute( this.$node.querySelector( 'input' ), this.data.ltPropAriaAttributes || {}, arg ? arg.oldValue : {} )
     }.observes( 'ltPropAriaAttributes', 'ltPropAriaAttributes.{}', 'ltPropType' ).on( 'didConnect' )
});


/**
 * @syntax nonYielded
 * <lyte-number></lyte-number>
 */
/**
 * Render a nav bar
 * @component lyte-nav
 * @version 1.0.0
 * @methods onItemSelected,afterRender
 * @import lyte-menu
 * @ignore-props
 * @dependencies lyte-menu
 */

Lyte.Component.register( 'lyte-nav', {
_template:"<template tag-name=\"lyte-nav\"> <template is=\"if\" value=\"{{expHandlers(ltPropAlignment,'!==','vertical')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropNavYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"nav\" items=\"{{auxArray}}\"></lyte-yield> </template><template case=\"false\"> <template is=\"for\" items=\"{{auxArray}}\" item=\"item\" index=\"index\"> <lyte-nav-item data-value=\"{{item[ltPropSystemValue]}}\" lyte-shortcut=\"{{lyteUiGetValue(item,'shortcut')}}\">{{item[ltPropUserValue]}}</lyte-nav-item> </template> </template></template> <template is=\"if\" value=\"{{expHandlers(ltPropType,'===','collapse')}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(menuContent.length,'>',0),'||',showMenu)}}\"><template case=\"true\"> <span class=\"{{ltPropContainerClass}}\"> <span class=\"{{ltPropMenuIcon}}\"></span> </span> </template></template> <lyte-menu lt-prop=\"{{stringify(ltPropMenu)}}\" on-menu-click=\"{{method('itemSelected')}}\" on-before-open=\"{{method('beforeOpen')}}\" on-open=\"{{method('open')}}\" on-before-close=\"{{method('beforeClose')}}\" on-close=\"{{method('close')}}\" before-render=\"{{method('befRender')}}\" after-render=\"{{method('aftRender')}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <template is=\"if\" value=\"{{ltPropMenuYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"menu\" items=\"{{menuContent}}\"></lyte-yield> </template><template case=\"false\"> <lyte-menu-body class=\"{{ltPropNavMenuClass}}\"> <template is=\"for\" items=\"{{menuContent}}\" item=\"item\" index=\"index\"> <lyte-menu-item data-value=\"{{item[ltPropSystemValue]}}\" lyte-shortcut=\"{{lyteUiGetValue(item,'shortcut')}}\"> <lyte-menu-label> {{item[ltPropUserValue]}} </lyte-menu-label> </lyte-menu-item> </template> </lyte-menu-body> </template></template> </template> </lyte-menu> </template></template> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]}]}},"default":{}},{"type":"attr","position":[3]},{"type":"registerYield","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[3]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropMenu","ltPropNavYield","ltPropMenuYield","ltPropItems","ltPropUserValue","ltPropSystemValue","ltPropMaxWidth","ltPropType","ltPropNavMenuClass","ltPropMenuIcon","ltPropContainerClass","ltPropClick","ltPropAlignment","ltPropArrow","ltPropSelected","menuContent","auxArray","arrowTop","arrowBot","showMenu"],
	init: function() {
		/* Set core properties of menu */
		var dropObj = this.getData( 'ltPropMenu' ),
		query = this.getData( 'ltPropContainerClass' ), that = this;

		$L.fastdom.measure( function() {
			var prev = _lyteUiUtils.nav_innerWidth;

			if( !prev ) {
				_lyteUiUtils.nav_innerWidth = document.documentElement.clientWidth;
			}
		} );	
		
		Lyte.objectUtils( dropObj, 'add', 'yield', true );
		Lyte.objectUtils( dropObj, 'add', 'query', '.' + query );

		this.$node.recalculate = function() {
			that.recalculate();
		}
	},

	didDestroy: function() {
		var allNodes = this.$node.querySelectorAll('lyte-nav-item'), i = 0, curValue;

		for( ; i < allNodes.length; i++ ) {
			curValue = allNodes[ i ].getAttribute( 'lyte-shortcut' );
			if( curValue ) {
				allNodes[ i ].setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );
			}
		}
	},

	// Creating outer div 
	createOuterDiv: function() {
		var div = document.createElement( 'div' ),
		useArrow = this.getData( 'ltPropArrow' );

		div.setAttribute( 'class', 'lyteNavDiv' );

		if( useArrow ) {
			div.style.overflow = window._lyteUiUtils.isMobile ? 'auto' : 'hidden';
		}
		else {
			div.style.overflow = 'auto';
			div.classList.add( 'lyteNavDivFullHeight' );
		}
		
		return div;
	},

	show: function( arrows, outer ) { 
		var useArrow = this.getData( 'ltPropArrow' );

		if( !this.$node ) {
			return ;
		}

		if( useArrow ) {
			this.setData( 'topH', arrows[0].getBoundingClientRect().height );
			this.setData( 'botH', arrows[1].getBoundingClientRect().height );
			this.dispArrow.call( this, arrows, outer );	
		}
		
		if( this.getMethods( 'afterRender' ) ) {
			this.executeMethod( 'afterRender', this );
		}
	},

	/**
	 * Constructs an Aux Array that is used to render the nav
	 * Reveals all items as part of the nav at the start
	 *
	 */

	construct: function() {
		var items = this.getData( 'ltPropItems' ) || [], i = 0,
		user = this.getData( 'ltPropUserValue' ),
		sys = this.getData( 'ltPropSystemValue' ), obj, store = [];

		for( ; i < items.length; i++ ) {
			obj = items[ i ];
			Lyte.arrayUtils( store, 'push', obj );
		}

		this.setData( 'auxArray', store );
	},

	recalculate: function() {
		var sel = this.getCurrentSelected(),
		dv = this.getDataValue( sel ),
		click = this.getData( 'ltPropClick' ), newSel;

		// This removes the clicked element when they haven't specified the selected element but if they have it retains it
		this.construct();

		// Can't use the previous sel variable because it gets destroyed
		newSel = this.$node.querySelector( 'lyte-nav-item[data-value="' + window._lyteUiUtils.escape( dv ) + '"]' );

		if( newSel ) {
			newSel.setAttribute( 'selected', true );
		}
		
		this.collapse();
	},

	/**
	 * Recalculate the layout when new items are pushed in
	 * 
	 */

	itemsOb: function() {
		this.recalculate();
	}.observes( 'ltPropItems' ),


	selObserver: function() {
		this.makeSelection();
	}.observes( 'ltPropSelected' ),

	makeSelection: function() {
		if( this.getData( 'preventSel' ) ) {
			return ;
		}

		this.selectItem();
	},

	selectItem: function() {
		var sel = this.getData( 'ltPropSelected' ), node;

		if( !sel ) {
			this.removeSelected();
		}
		else {
			this.addSelected();
		}
	},

	removeSelected: function() {
		var node = this.$node.querySelector( 'lyte-nav-item[selected="true"]' );

		if( node ) {
			node.removeAttribute( 'selected' );
		}
	},

	addSelected: function() {
		var isSelected = this.setInNav();

		if( !isSelected ) {
			this.setInMenu();
		}
	},

	setInNav: function() {
		var sel = this.getData( 'ltPropSelected' ), node;

		node = this.$node.querySelector( 'lyte-nav-item[data-value="' + window._lyteUiUtils.escape( sel ) + '"]' )

		if( node ) {
			node.setAttribute( 'selected', true );

			return true;
		}

		return false;
	},

	setInMenu: function() {
		var menu = this.$node.querySelector( 'lyte-menu' ),
		sel = this.getData( 'ltPropSelected' ),
		body = menu ? menu.component.childComp : null, node;

		if( body ) {
			node = body.querySelector( 'lyte-menu-item[data-value="' + window._lyteUiUtils.escape( sel ) + '"]' );

			if( node ) {
				this.setData( 'preventCallback', true );
				node.click();
				this.setData( 'preventCallback', false );
			}
		}
	},

	/**
	 * This returns the current selected item by searching the DOM
	 * returns {DOMElement | null}
	 *
	 */

	getCurrentSelected: function() {
		var click = this.getData( 'ltPropClick' );

		return this.$node.querySelector( 'lyte-nav-item.' + click );
	},

	/**
	 * Get the data-value of the current item
	 * @param {DOMElement | null} sel - The selected item
	 * @returns {String} - attribute value
	 *
	 */ 

	getDataValue: function( sel ) {
		if( sel ) {
			return sel.getAttribute( 'data-value' );
		}

		return '';
	},

	/**
	 * Get the width of the current item
	 * @param {DOMElement | null} - The element whose width needs to be found
	 * @returns {Number} - The width of the element
	 *
	 */

	getWidth: function( item ) {
		if( item ) {
			return item.getBoundingClientRect().width;
		}

		return 0;
	},

	/**
	 * This is used to get the width of the menu icon that is rendered
	 * @returns {Number} - The width of the menu icon
	 *
	 */

	getMenuWidth: function() {
		var menu, menuWidth;

		this.setData( 'showMenu', true );
		menu = this.$node.querySelector( '.' + this.getData( 'ltPropContainerClass' ) );
		menuWidth = this.getWidth( menu );
		this.setData( 'showMenu', false );

		return menuWidth;
	},

	/**
	 * Collapse excess width held by the nav-items
	 *
	 */

	calculate: function() {

		if( !this.$node ) {
			return ;
		}

		var items = this.getData( 'auxArray' ),
		store = [], tbr = [], ind,
		rects = this.$node.getBoundingClientRect(),
		percent = parseFloat( this.getData( 'ltPropMaxWidth' ) ) / 100,
		maxWidth = rects.width * percent, i = 0, length = items.length, item,
		sys = this.getData( 'ltPropSystemValue' ),
		totalWidth = 0, sel = this.getCurrentSelected(), 
		dv = this.getDataValue( sel ), selWidth = this.getWidth( sel ),
		menuWidth = this.getMenuWidth();

		totalWidth = totalWidth + selWidth + menuWidth;

		for( ; i < items.length; i++ ) {
			item = items[ i ];

			// We already know the width of the selected item
			if( item[ sys ] === dv ) {
				continue;
			}

			totalWidth += this.getWidth( this.$node.querySelector( 'lyte-nav-item[data-value="' + window._lyteUiUtils.escape( item[ sys ] ) + '"]' ) );

			if( totalWidth > maxWidth ) {
				Lyte.arrayUtils( store, 'push', item );
				tbr.push( i );
			}
		}

		this.setData( 'menuContent', store );

		while( !isNaN( ( ind = tbr.pop() ) ) ) {
			Lyte.arrayUtils( items, 'removeAt', ind, 1 );
		}
	},

	/**
	 * The staging function
	 *
	 */

	collapse: function() {
		$L.fastdom.measure( this.calculate, this );
	},

	didConnect: function() {
		var align = this.getData( 'ltPropAlignment' ), 
		tag = this.$node, useArrow = this.getData( 'ltPropArrow' ),
		isMobile = window._lyteUiUtils.isMobile,
		type, arrows, i, div;

		if( align === 'horizontal' ) {
			type = this.getData( 'ltPropType' );

			if( ( this.getData( 'ltPropItems' ) || [] ).length > 0 ) {
				this.construct();

				if( type === 'collapse' ) {
					this.collapse();
				}

				this.makeSelection();
			}
		}
		else if( align === 'vertical' ) {
			this.buildVerticalNav();

			if( !useArrow ) {
				return ;
			}

			div = tag.querySelector( '.lyteNavDiv' );
			this.addEventsForArrows();
			arrows = this.getArrows();

			var that = this;

			if( isMobile ) {
				this.prev = div.scrollTop;
				div.addEventListener( 'scroll', function( e ) {
					var topHeight, botHeight, total, 
					scrollH = div.scrollHeight,
					scrollT = div.scrollTop,
					height = div.getBoundingClientRect().height,
					prev = that.prev,
					diff = Math.floor( scrollT - prev ),
					stopHandler = that.getData( 'stopHandler' );

					that.prev = scrollT;

					topHeight = arrows[ 0 ].getBoundingClientRect().height;
					botHeight = arrows[ 1 ].getBoundingClientRect().height;

					e.preventDefault();
					if( diff == 0 || stopHandler ) {
						return ;
					}
					else if( diff > 0 ) {
						if( arrows[ 0 ].style.display === 'none' ) {
							arrows[ 0 ].style.display = 'inline-block';
							topHeight = that.getData( 'topH' );
							total = topHeight + botHeight;
							div.style.height = 'calc(100% - ' + total + 'px)';
						}

						if( Math.abs( scrollT + height - scrollH ) <= 5 ) {
							arrows[ 1 ].style.display = 'none';
							div.style.height = 'calc(100% - ' + topHeight + 'px)';
						}
					}
					else {
						// Added the second condition to solve a weird judder issue in mobile
						if( arrows[ 1 ].style.display === 'none' && ( scrollH - ( scrollT + height) ) >= 30 ) {
							arrows[ 1 ].style.display = 'inline-block';
							botHeight = that.getData( 'botH' );

							total = topHeight + botHeight;
							div.style.height = 'calc(100% - ' + total + 'px)';
						}

						if( scrollT <= 0 ) {
							arrows[ 0 ].style.display = 'none';
							div.style.height = 'calc(100% - ' + botHeight + 'px)';
						}
					}
				} );
			}
			else {
				div.addEventListener( 'wheel', function( e ) {
					var topHeight, botHeight, total, 
					deltaY = e.deltaY,
					scrollH = div.scrollHeight, 
					height = div.getBoundingClientRect().height, 
					scrollT = div.scrollTop;

					e.preventDefault();

					if( Math.floor( scrollH ) == Math.floor( height ) ) {
						return ;
					}

					topHeight = arrows[ 0 ].getBoundingClientRect().height;
					botHeight = arrows[ 1 ].getBoundingClientRect().height;

					if ( deltaY < 0 ) {
	    				scrollT = div.scrollTop = div.scrollTop - 6;

	    				if( arrows[ 1 ].style.display === 'none' ) {
	    					arrows[ 1 ].style.display = 'inline-block';
	    					botHeight = that.getData( 'botH' );
	    					total = topHeight + botHeight;
	    					div.style.height = 'calc(100% - ' + total + 'px)';
	    				}

	    				if( scrollT <= 0 ) {
	    					arrows[ 0 ].style.display = "none"
	    					div.style.height = 'calc(100% - ' + botHeight + 'px)';
	    				}
	  				}

	  				if ( deltaY > 0 ) {
	    				scrollT = div.scrollTop = div.scrollTop + 6;

	    				if( arrows[ 0 ].style.display === 'none' ) {
	    					arrows[ 0 ].style.display = 'inline-block';
	    					topHeight = that.getData( 'topH' );
	    					total = topHeight + botHeight;
	    					div.style.height = 'calc(100% - ' + total + 'px)';
	    				}

	    				if( Math.floor( height ) + Math.floor( scrollT ) >= Math.floor( scrollH ) ) {
	    					arrows[ 1 ].style.display = 'none';
	    					div.style.height = 'calc(100% - ' + topHeight + 'px)';
	    				}
	  				}
				} );
			}
		}
	},

	addEventsForArrows: function() {
		var parent = this.$node,
		useArrow = this.getData( 'ltPropArrow' ),
		arrows = this.getArrows(),
		isMobile = window._lyteUiUtils.isMobile;

		if( !useArrow ) {
			return ;
		}

		if( isMobile ) {
			arrows[ 0 ].addEventListener( 'touchstart', this.moveup.bind( this ) );
			arrows[ 1 ].addEventListener( 'touchstart', this.movedown.bind( this ) );
			arrows[ 0 ].addEventListener( 'touchend', this.removeup.bind( this ) );
			arrows[ 1 ].addEventListener( 'touchend', this.removedown.bind( this ) );
			arrows[ 0 ].addEventListener( 'touchcancel', this.removeup.bind( this ) );
			arrows[ 1 ].addEventListener( 'touchcancel', this.removedown.bind( this ) );
		}
		else {
			arrows[ 0 ].addEventListener( 'mouseenter', this.moveup.bind( this ) );
			arrows[ 1 ].addEventListener( 'mouseenter', this.movedown.bind( this ) );	
			arrows[ 0 ].addEventListener( 'mouseleave', this.removeup.bind( this ) );
			arrows[ 1 ].addEventListener( 'mouseleave', this.removedown.bind( this ) );
		}
	},

	buildVerticalNav: function() {
		var outerDiv, arrows, parent = this.$node,
		children = parent.children, length = children.length,
		temp, reset;

		outerDiv = this.createOuterDiv();
		arrows = this.getArrows();

		for( var i = 0; i < length; i++ ) {

			// Safari starts firing when a custom element is connected to a disconnected node
			children[ 0 ].prevent = true;
			temp = children[ 0 ];

			if( children[ 0 ].hasAttribute( 'selected' ) 
				&& children[ 0 ].getAttribute( 'selected' ) !== 'false' 
			) {
				reset = children[ 0 ];
				reset.removeAttribute( 'selected' );
			}

			_lyteUiUtils.appendChild( outerDiv, children[ 0 ] );
			temp.prevent = false;
			temp = null;
		}

		// Ideally we want it to be fired when it is appened to the DOM
		_lyteUiUtils.appendChild( parent, outerDiv );

		if( reset ) {
			reset.setAttribute( 'selected', 'true' );
		}

		reset = null;
		
		this.addArrows();
		arrows = this.getArrows();
		$L.fastdom.measure( this.show.bind( this, arrows, outerDiv ) );
	},

	addArrows: function() {
		var arrows = this.getArrows(),
		useArrow = this.getData( 'ltPropArrow' ),
		parent = this.$node;

		if( !useArrow ) {
			return ;
		}

		if( arrows.length == 0 ) {
			this.addArrow( 'arrow-up' );
			this.addArrow( 'arrow-down' );
		}
		else {
			parent.insertBefore( arrows[ 0 ], parent.children[ 0 ] );
			parent.appendChild( arrows[ 1 ] );
		}
	},

	getArrows: function() {
		var parent = this.$node;

		return parent.querySelectorAll( 'lyte-arrow' );
	},

	removedown: function() {
		this.setData( 'stopHandler', false );
		window.cancelAnimationFrame( this.getData( 'arrowdid' ) )
	},

	removeup: function() {
		this.setData( 'stopHandler', false );
		window.cancelAnimationFrame( this.getData( 'arrowuid' ) );
	},

	down: function( div, ar, bot ) {
		var id,
		scrollT = div.scrollTop, 
		scrollH = div.scrollHeight, 
		height = div.getBoundingClientRect().height;

		this.setData( 'stopHandler', true );

		if( scrollT + height < scrollH ) {
			scrollT = div.scrollTop = div.scrollTop + 3
		}

    	if( Math.floor( height ) + Math.floor( scrollT ) >= scrollH ) {
    		ar[ 1 ].style.display = 'none';
    		div.style.height = 'calc(100% - ' + bot + 'px)';
    	}

    	id = window.requestAnimationFrame( this.down.bind( this, div, ar, bot ) );
		this.setData( 'arrowdid', id );
	},

	up: function( div, ar, top ) {
		var scrollT = div.scrollTop, id;

		this.setData( 'stopHandler', true );

		if( scrollT !== 0 ) {
			scrollT = div.scrollTop = div.scrollTop - 3;
		}

   		if( scrollT <= 0 ) {
   			ar[ 0 ].style.display = 'none';
   			div.style.height = 'calc(100% - ' + top + 'px)';
   		}

		id = window.requestAnimationFrame( this.up.bind( this, div, ar, top ) );
		this.setData( 'arrowuid', id );
	},

	movedown: function( event ) {		
		var top, bot, total,
		tag = this.$node, 
		div = tag.querySelector( '.lyteNavDiv' ), 
		ar = this.getArrows(), 
		height = div.getBoundingClientRect().height, 
		scroll = div.scrollHeight, id;

		ar[ 0 ].style.display = 'inline-block';
		top = this.getData( 'topH' );
		bot = this.getData( 'botH' );
		total = top + bot;
		div.style.height = 'calc(100% - ' + total + 'px)';

		// Call Animation inside a rAF.
		id = window.requestAnimationFrame( this.down.bind( this, div, ar, bot ) );
		this.setData( 'arrowdid', id );	
	},

	moveup: function() {
		var top, bot, total,
		tag = this.$node, 
		div = tag.querySelector( '.lyteNavDiv' ), 
		ar = this.getArrows(), id,
		height = div.getBoundingClientRect().height, 
		scroll = div.scrollHeight;

		ar[ 1 ].style.display = 'inline-block';
		top = this.getData( 'topH' );
		bot = this.getData( 'botH' );
		total = top + bot;
		div.style.height = 'calc(100% - ' + total + 'px)';

		// Call Animation inside a rAF
		id = window.requestAnimationFrame( this.up.bind( this, div, ar, top ) );
		this.setData( 'arrowuid', id );			
	},

	addArrow: function( cls ) {
		var i = document.createElement( 'i' ),
		ar = document.createElement( 'lyte-arrow' ), 
		tag = this.$node;

		i.setAttribute( 'class', cls ); 
		ar.appendChild( i );

		if( cls.indexOf('up') !== - 1 ) {
			tag.insertBefore( ar, tag.children[ 0 ] );
		}
		else {
			tag.appendChild( ar )
		}
	},

	dispArrow: function( arrows, div ) {
		var which = 0, topHeight = 0, botHeight = 0, total = 0;
		
		if( this.getData( 'arrowTop' ) ) {
			topHeight = this.getData( 'topH' );
			which = 1;
		}

		if( this.getData( 'arrowBot' ) ) {
			botHeight = this.getData( 'botH' );
			if( which == 1 ) {
				which = 3
			}
			else {
				which = 2
			}
		}

		switch( which ) {
			case 1:
				div.style.height = 'calc(100% - ' + topHeight + 'px)'
				arrows[ 1 ].style.display = "none"
				break;
			case 2:
				div.style.height = 'calc(100% - ' + botHeight + 'px)'
				arrows[ 0 ].style.display = "none"
				break
			case 3:
				total = topHeight + botHeight
				div.style.height = 'calc(100% - ' + total + 'px)'
				break;
		}
	},

	/**
	 * This recreates an object with just the data-value
	 * @param {string} dv - The data-value of the element with which an object is created
	 * @returns {Object} obj - The lyte-nav info object
	 *
	 */

	recreateFromDv: function( dv ) {
		var sys = this.getData( 'ltPropSystemValue' ), i = 0,
		user = this.getData( 'ltPropUserValue' ), items = this.getData( 'ltPropItems' ) || [];

		for( ; i < items.length; i++ ) {
			if( items[ i ][ sys ] === dv ) {
				return items[ i ];
			}
		}
	},

	/**
	 * Find the index of the item that needs to be swapped out from the menu
	 * @param {String} dv - The data-value of the element
	 * @returns {Number} index - The index of the element in the rendered menu
	 *
	 */

	findInd: function( dv ) {
		var menus = this.getData( 'menuContent' ),
		i = 0, user = this.getData( 'ltPropUserValue' ),
		sys = this.getData( 'ltPropSystemValue' );

		for( ; i < menus.length; i++ ) {
			if( dv == menus[ i ][ sys ] ) {
				return i;
			}
		}
	},

	/**
	 * Set the click class to the item
	 * @param {String} dv - The data-value of the item which needs the click class
	 * 
	 */

	setSelected: function( dv ) {
		// Just set the click class to the item
		var newLast = this.$node.querySelector( 'lyte-nav-item[data-value="' + window._lyteUiUtils.escape( dv ) + '"]' ),
		click = this.getData( 'ltPropClick' );

		// Just a safety
		if( newLast ) {
			newLast.click();
		}
	},

	methods: {
		
		/**
		 * The menu was selected
		 * swap the menu item and the last item of the nav item
		 *
		 */

		itemSelected: function( ) {
			var selObj = arguments[ 4 ],
			click = this.getData( 'ltPropClick' ),
			item = selObj.element, aux = this.getData( 'auxArray' ),
			dv = this.getDataValue( item ), /* need to remove */ rm, ind = this.findInd( dv ),
			menus = this.getData( 'menuContent' ), /* need to remove */pushObj, prevSel,
			auxLength = aux.length, replacedObj, finalObj;

			prevSel = this.$node.querySelector( 'lyte-nav-item.' + click );
			if( prevSel ) {
				prevSel.classList.remove( click );
			}

			finalObj = this.recreateFromDv( dv );
			replacedObj = Lyte.arrayUtils( aux, 'replaceAt', auxLength - 1, finalObj );
			rm = Lyte.arrayUtils( menus, 'removeAt', ind, 1 );
			
			// Lyte.arrayUtils( aux, 'push', pushObj );
			// Lyte.arrayUtils( menus, 'replaceAt', ind, rm );

			Lyte.arrayUtils( menus, 'insertAt', ind, replacedObj );

			this.setSelected( dv );
			
			this.$node.recalculate();

			if( this.getMethods( 'onMenuClick' ) && !this.getData( 'preventCallback' ) ) {
				this.executeMethod( 'onMenuClick' );
			}
		},

		beforeOpen: function() {
			if( this.getMethods( 'onBeforeOpen' ) ) {
				this.executeMethod( 'onBeforeOpen' );
			}
		},

		open: function() {
			if( this.getMethods( 'onOpen' ) ) {
				this.executeMethod( 'onOpen' );
			}
		},

		beforeClose: function() {
			if( this.getMethods( 'onBeforeClose' ) ) {
				this.executeMethod( 'onBeforeClose' );
			}
		},

		close: function() {
			if( this.getMethods( 'onClose' ) ) {
				this.executeMethod( 'onClose' );
			}
		},

		befRender: function() {
			if( this.getData( 'beforeMenuRender' ) ) {
				this.executeMethod( 'beforeMenuRender' )
			}
		},

		aftRender: function() {
			if( this.getData( 'afterMenuRender' ) ) {
				this.executeMethod( 'afterMenuRender' );
			}
		}
	},

	data: function() {
		return {
			/**
			 * @componentProperty {object} ltPropMenu
			 * @default {}
			 * @version 1.0.8
			 * @component lyte-menu
			 */

			'ltPropMenu': Lyte.attr( 'object', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-nav', 'menu', {} ) } ),

			/**
			 * @componentProperty {boolean} ltPropNavYield
			 * @default false
			 * @version 1.0.8
			 * 
			 */

			'ltPropNavYield': Lyte.attr( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {boolean} ltPropMenuYield
			 * @default false
			 * @version 1.0.8
			 * 
			 */

			'ltPropMenuYield': Lyte.attr( 'boolean', { 'default': false } ),


			/**
			 * @componentProperty {array} ltPropItems
			 * @version 1.0.8
			 * @default []
			 */

			'ltPropItems': Lyte.attr( 'array', { 'default': [] } ),

			/**
			 * @componentProperty {string} ltPropUserValue
			 * @version 1.0.8
			 */

			'ltPropUserValue': Lyte.attr( 'string', { 'default': '' } ),

			/**
			 * @componentProperty {string} ltPropSystemValue
			 * @version 1.0.8
			 */

			'ltPropSystemValue': Lyte.attr( 'string', { 'default': '' } ),


			/**
			 * @componentProperty {string} ltPropMaxWidth
			 * @suffix %
			 * @default 90%
			 * @version 1.0.8
			 */
			
			'ltPropMaxWidth': Lyte.attr( 'string', { 'default': '90%' } ),

			/**
			 * @componentProperty {collapse|default} ltPropType
			 * @default default
			 * @version 1.0.8
			 */

			'ltPropType': Lyte.attr( 'string', { 'default': '' } ),

			/**
			 * @componentProperty {string} ltPropNavMenuClass
			 * @default lyteNavMenuClass
			 * @version 1.0.8
			 */

			'ltPropNavMenuClass': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-nav', 'navMenuClass', 'lyteNavMenuClass' ) } ),

			/**
			 * @componentProperty {string} ltPropMenuIcon
			 * @default lyteNavKebabMenu
			 * @version 1.0.8
			 */


			'ltPropMenuIcon': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-nav', 'menuIcon', 'lyteNavKebabMenu' ) } ),

			/**
			 * @componentProperty {string} ltPropContainerClass
			 * @default lyteNavIconContainer
			 * @version 1.0.8
			 */

			'ltPropContainerClass': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-nav', 'containerClass', 'lyteNavIconContainer' ) } ),
			

			/**
			 * @componentProperty {string} ltPropClick
			 * @default lyteNavActive
			 */

			'ltPropClick': Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-nav', 'click', 'lyteNavActive' ) } ),

			/**
			 * @componentProperty {string} ltPropAlignment
			 * @default horizontal
			 * @options horizontal,vertical
			 */

			'ltPropAlignment':Lyte.attr( 'string', { 'default': 'horizontal' } ),

			/**
			 * @componentProperty {boolean} ltPropArrow
			 * @default true
			 * 
			 */

			'ltPropArrow': Lyte.attr( 'boolean', { 'default': true } ),

			'ltPropSelected': Lyte.attr( 'string', { 'default': '' } ),

			
			'menuContent': Lyte.attr( 'array', { 'default': [] } ),
			'auxArray': Lyte.attr( 'array', { 'default': [] } ),
			'arrowTop': Lyte.attr( 'boolean', { 'default': false } ),
			'arrowBot':Lyte.attr( 'boolean', { 'default': false } ),
			'showMenu': Lyte.attr( 'boolean', { 'default': false } )
		}
	}
})

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-nav-item' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-nav-item' ] = true;

	Lyte.createCustomElement( 'lyte-nav-item', {
		connectedCallback: function() {
			if( !this.prevent ) {

				var parent = this, component, align, div = this;

		    	while( 
		    		parent.tagName != 'LYTE-NAV' 
		    		&& parent.tagName != 'HTML' 
		    	) {
		      		parent = parent.parentElement
		    	}

		    	if( parent.tagName == 'HTML' ) {
		    		return ;
		  		}

		    	component = parent.component;
		    	align = component.getData( 'ltPropAlignment' );
		    	if( align === 'vertical' ) {
		        	while( div && !div.classList.contains( 'lyteNavDiv' ) ) {
		          		div = div.parentElement
		        	}
		   	 	}

		   	 	$L.fastdom.measure( function() {
		   	 		var offsetTop, newElemOffset;

		   	 		if( component && !component.$node ) {
		   	 			return ;
		   	 		}

		   	 		if( 
		    			this.hasAttribute( 'selected' ) 
		    			&& this.getAttribute( 'selected' ) 
		    		) {
		        		if( div && align === 'vertical' ) {   
		          			offsetTop = this.offsetTop;
		          			div.scrollTop = offsetTop
		          			if( offsetTop != 0 ) {
		            			component.setData( 'arrowTop', true );
		          			} 
		          			
		          			component.setData( 'arrowBot', false );
		        		}

		    		}
		    		else if( div && align === 'vertical' ) {
		      			newElemOffset = this.offsetTop;
		      			if( newElemOffset + this.getBoundingClientRect().height > div.getBoundingClientRect().height + div.scrollTop ) {
		           			component.setData( 'arrowBot', true )    
		        		}
		    		}
		   	 	}, this )

		    	

		   	 	if( !this._eventRegistered ) {
		   	 		this._eventRegistered = true;
		    		this.addEventListener( 'click', function() {
		      			this.setAttribute( 'selected', true );

		      			if( component.getMethods( 'onItemSelected' ) && !component.getData( 'preventCallback' ) ) {
		          			component.executeMethod( 'onItemSelected', this, component );
		          		}
		    		}.bind( this ) );
		   	 	}
		   	 	
			}
		},

		disconnectedCallback : function(){
			var curValue = this.getAttribute( 'lyte-shortcut' );
			if( curValue ) {
				this.setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );
			}
		},

		static : {
			"observedAttributes" : {
				get : function() {
					return [ 'selected', 'lyte-shortcut' ];
				}
			}
		},

		/**
		 * The attrite changed callback will append classes to the lyte-nav-item
		 * It is fired when an element is appened to the DOM in chrome/opera/ff and when it is appended to any disconnected node in safari
		 *
		 */

		"attributeChangedCallback" : function( attributeName, oldValue, newValue, namespace ) {
			if( !this.prevent ) {
				var parent = this, component, click, prevSelected, val, dv;

				if ( attributeName === 'lyte-shortcut' ) {
		        	if ( typeof shortcut === 'function' ) {
		          		if ( !newValue ) {
		            		return;
		         	 	}
		          		newValue = JSON.parse( newValue );
		          		oldValue = oldValue ? JSON.parse( oldValue ) : {};
		          		shortcut.push( {
		           			newKey: newValue.key,
		            		type: newValue.type,
		            		wait: newValue.wait,
		            		oldKey: oldValue.key,
		            		value: this
		          		} );
		        	}
		      	} 
		      	else if ( attributeName == 'selected' && newValue && newValue !== 'false' ) {
		        	val = this.getAttribute( 'selected' );

		        	while (
		        		parent
		        		&& parent.tagName != 'LYTE-NAV' 
		        		&& parent.tagName != 'HTML' 
		        	) {
		          		parent = parent.parentElement;
		        	}

		        	if ( !parent || parent.tagName == 'HTML' ) {
		          		return;
		        	}

		        	component = parent.component;
		        	click = component.getData('ltPropClick');
		        	prevSelected = parent.querySelector('.' + click);
		        	if ( prevSelected && prevSelected != this ) {
		          		prevSelected.setAttribute( 'selected', '' );
		        	}

		        	if ( val ) {
		          		this.classList.add( click );

		          		dv = this.getAttribute( 'data-value' );

		          		if( dv ) {
		          			component.setData( 'preventSel', true );
		          			component.setData( 'ltPropSelected', dv );
		          			component.setData( 'preventSel', false );
		          		}
		        	}
		      	} 
		      	else if ( attributeName == 'selected' ) {
		        	parent = this;
		        	while ( 
		        		parent
		        		&& parent.tagName != 'LYTE-NAV' 
		        		&& parent.tagName != 'HTML' 
		        	) {
		          		parent = parent.parentElement;
		        	}

		        	if ( !parent || parent.tagName == 'HTML' ) {
		          		return;
		        	}

		        	component = parent.component;
		        	click = component.getData( 'ltPropClick' );
		        	this.classList.remove( click );

		        	if( !component.$node.querySelector( 'lyte-nav-item[selected="true"]' ) ) {
		        		component.setData( 'preventSel', true );
		          		component.setData( 'ltPropSelected', '' );
		          		component.setData( 'preventSel', false );
		        	}
		      	}
			}
		}
	});
}


var _lyteUiNav = {
	resize: function() {
		var navs = document.querySelectorAll( 'lyte-nav' ), 
		length = navs.length, i = 0, nav, comp;

		for( ; i < navs.length; i++ ) {
			nav = navs[ i ];
			comp = nav.component;

			if( comp && comp.getData( 'ltPropType' ) === 'collapse' ) {
				comp.recalculate();
			}
		}
	}
};

window.addEventListener( 'resize', function( event ) {
	var id = _lyteUiUtils.lyteNavId,
	isMobile = _lyteUiUtils.isMobile,
	width = _lyteUiUtils.nav_innerWidth, cur;

	if( isMobile && width ) {
		// Comparing the layout viewport widths to check if the orientation has changed
		cur = document.documentElement.clientWidth;

		if( cur !== width ) {
			_lyteUiUtils.nav_innerWidth = cur;
			_lyteUiNav.resize();
		}
	}
	else if( !isMobile ) {
		window.clearTimeout( id );

		// Debounce
		_lyteUiUtils.lyteNavId = window.setTimeout( function() {
			_lyteUiNav.resize();
		}, 16 /* yikes */ );
	}


} );

/**
 * @syntax nonYielded
 * <lyte-nav lt-prop-items='[ { "name": "Tab 1", "value": "1" }, { "name": "Tab 2", "value": "2" } ]' lt-prop-user-value="name" lt-prop-system-value="value"></lyte-nav>
 *
 */ 


/**
 * Renders a navigator
 * @component lyte-navigator
 * @version  1.0.0
 * @methods onNext,onPrevious,onHome,onEnd,onSelect,beforeRender,afterRender
 */
Lyte.Component.register('lyte-navigator', {
_template:"<template tag-name=\"lyte-navigator\"> <template is=\"if\" value=\"{{expHandlers(ltPropType,'==',&quot;default&quot;)}}\"><template case=\"true\"> <div class=\"lyteNavigator\" onclick=\"{{action('clickEvent',event)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <div class=\"lyteNavigator lyteDoubleBack lyteIconDoubleBack\"></div> <div class=\"lyteNavigator lyteSingleBack lyteIconSingleBack\"></div> <template is=\"if\" value=\"{{expHandlers(ltPropShowOnlyIcon,'!')}}\"><template case=\"true\"> <div class=\"lyteNavigatorMidPoint\">{{startRecord}} <span class=\"lyteNavigatorText\">{{ltPropMiddleText}}</span> {{endRecord}}</div> </template></template> <div class=\"lyteNavigator lyteSingleFront lyteIconSingleFront\"></div> <div class=\"lyteNavigator lyteDoubleFront lyteIconDoubleFront\"></div> </template><template case=\"false\"> <lyte-yield yield-name=\"navigatorYield\" start-record=\"{{startRecord}}\" end-record=\"{{endRecord}}\"></lyte-yield> </template></template> </div> </template></template> <template is=\"if\" value=\"{{expHandlers(ltPropType,'==',&quot;simple&quot;)}}\"><template case=\"true\"> <div class=\"lyteNavigator\" onclick=\"{{action('clickEvent',event)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <div class=\"lytepagination\"> <div class=\"lyteNavArrow lyteDoubleBack hover\"></div> <div class=\"lyteNavArrow lyteSingleBack hover\"> </div> <template is=\"if\" value=\"{{expHandlers(ltPropShowOnlyIcon,'!')}}\"><template case=\"true\"> <div class=\"lytepage\"> <template is=\"for\" items=\"{{paginationRange}}\" item=\"page\" indexval=\"pageno\"> <div data-value=\"{{page}}\" class=\"lytesimple\">{{unescape(page)}}</div> </template> </div> </template></template> <div class=\"lyteNavArrow lyteSingleFront hover\"> </div> <div class=\"lyteNavArrow lyteDoubleFront hover\"></div> </div> </template><template case=\"false\"> <lyte-yield yield-name=\"navigatorYield\" pagination-range=\"{{paginationRange}}\"></lyte-yield> </template></template> </div> </template></template> <template is=\"if\" value=\"{{expHandlers(ltPropType,'==',&quot;border&quot;)}}\"><template case=\"true\"> <div class=\"lyteNavigator\" onclick=\"{{action('clickEvent',event)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <div class=\"lytepagination\"> <div class=\"lyteNavArrowBorder lyteDoubleBack hover lyteborder\"></div> <div class=\"lyteNavArrowBorder lyteSingleBack hover lyteborder\"> </div> <template is=\"if\" value=\"{{expHandlers(ltPropShowOnlyIcon,'!')}}\"><template case=\"true\"> <div class=\"lytepage\"> <template is=\"for\" items=\"{{paginationRange}}\" item=\"page\" indexval=\"pageno\"> <div data-value=\"{{page}}\" class=\"lyteborder\">{{unescape(page)}}</div> </template> </div> </template></template> <div class=\"lyteNavArrowBorder lyteSingleFront hover lyteborder\"> </div> <div class=\"lyteNavArrowBorder lyteDoubleFront hover lyteborder\"></div> </div> </template><template case=\"false\"> <lyte-yield yield-name=\"navigatorYield\" pagination-range=\"{{paginationRange}}\"></lyte-yield> </template></template> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"text","position":[1,2,0]},{"type":"text","position":[1,4]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropPerpage","ltPropValue","ltPropRecords","ltPropMoreRecords","ltPropMiddleText","ltPropType","paginationRange","ltPropSelected","ltPropShowOnlyIcon","ltPropShowText","ltPropYield","ltPropAdjustStart"],
	init : function(){

		if(this.getMethods('beforeRender'))
            {
            	
                this.executeMethod('beforeRender', this.$node);
            }

	},
	didConnect:function(){

		this.buttonDisable.call(this);
		this.checkButton.call(this);
		if(this.getData( "ltPropType")!="default" ) {   
			 var elems=this.$node.querySelectorAll('lyte-nav-arrow');
			 if(this.getData('ltPropShowText')){
			 	this.$node.querySelector('.lytepagination').classList.add('textNavLink');
			 }
			if( elems.length == 4 ){   
        		this.$node.querySelector( '.lyteDoubleBack' ).appendChild(elems[0]);
        		this.$node.querySelector( '.lyteSingleBack' ).appendChild(elems[1]);
        		this.$node.querySelector( '.lyteSingleFront' ).appendChild(elems[2]);
        		this.$node.querySelector( '.lyteDoubleFront' ).appendChild(elems[3]);
        		
        	}
        	if( elems.length == 2 ) {   
        		this.$node.querySelector( '.lyteDoubleBack' ).style.display = "none";
        		this.$node.querySelector( '.lyteSingleBack' ).appendChild(elems[0]);
        		this.$node.querySelector( '.lyteSingleFront' ).appendChild(elems[1]);
        		this.$node.querySelector( '.lyteDoubleFront' ).style.display = "none";
        	}
        }
		if(this.getMethods('afterRender')) {  
			
            this.executeMethod('afterRender', this.$node);
        }
       	$L.fastdom.measure( function(){
			var fg = window.getComputedStyle( this.$node ).getPropertyValue( 'direction' ) == 'rtl';
			$L.fastdom.mutate( function(){
				if( fg ) {
					this.$node.classList.add( 'lyteRTL' )
				}
			}.bind( this ) )
		}.bind( this ) )	
       	
	}, 
	data: function(){
		return {
			/**
             * @componentProperty {number} ltPropPerpage=10
             * @minValue 0
             */
			ltPropPerpage:Lyte.attr("number", {"default": _lyteUiUtils.resolveDefaultValue( 'lyte-navigator', 'perPage', 10 ) }), 
			/**
             * @componentProperty {number} ltPropValue=0
             * @minValue 0
             */
			ltPropValue:Lyte.attr("number", {"default":0}), 
			/** @componentProperty {number} ltPropRecords
            */
			ltPropRecords:Lyte.attr("number", {"default":undefined}),
			/**
             * @componentProperty {boolean} ltPropMoreRecords=false
             * 
             */
			ltPropMoreRecords:Lyte.attr("boolean", {"default":false}),
			/**
             * @componentProperty {string} ltPropMiddleText='to'
             */
			ltPropMiddleText : Lyte.attr('string', {'default' : _lyteUiUtils.resolveDefaultValue( 'lyte-navigator', 'middleText', 'to' ) }),
			/**
             * @componentProperty {default | simple | border} ltPropType='default'
             */
			ltPropType:Lyte.attr("string", {"default":_lyteUiUtils.resolveDefaultValue( 'lyte-navigator', 'type', 'default' ) }),
			paginationRange:Lyte.attr("array",{"default":undefined}),
			/**
             * @componentProperty {number} ltPropSelected=0
             */
			ltPropSelected:Lyte.attr("number",{"default":0}),
			/**
             * @componentProperty {boolean} ltPropShowOnlyIcon=false
             */
			ltPropShowOnlyIcon:Lyte.attr("boolean",{"default":_lyteUiUtils.resolveDefaultValue( 'lyte-navigator', 'showOnlyIcon', false ) }),
			/**
             * @componentProperty {boolean} ltPropShowText=false
             */
			ltPropShowText:Lyte.attr("boolean",{"default":_lyteUiUtils.resolveDefaultValue( 'lyte-navigator', 'showText', false ) }),
			/**
             * @componentProperty {boolean} ltPropYield=false
             */
			ltPropYield:Lyte.attr("boolean",{"default":false}),
			/**
             * @componentProperty {boolean} ltPropAdjustStart=false
             * @version 3.0.0
             */
			ltPropAdjustStart : Lyte.attr( "boolean", { "default" : false } )
		}
	}, 
	buttonDisable:function(){
		if( !this.data.ltPropYield ) {
			var next = this.$node.querySelector('.lyteSingleFront' ).style,
			prev = this.$node.querySelector( '.lyteSingleBack' ).style,
			hme = this.$node.querySelector('.lyteDoubleBack' ).style,
			end = this.$node.querySelector('.lyteDoubleFront' ).style;
			if( next ) {
				
				next.display = this.getMethods('onNext') ? '' : 'none';
			}
			if( prev ) {
				
				prev.display = this.getMethods('onPrevious') ? '' : 'none';
			}
			if( hme ) {
				
				hme.display = this.getMethods('onHome') ? '' : 'none';
			}
	        if( end ) {
	        	
	        	end.display = this.getMethods('onEnd') ? '' : 'none';
	        }
        }     
	}, 
	activeAdd : function(){

		if( this.getData( "ltPropType" ) != 'default' && !this.getData( 'ltPropShowOnlyIcon' ) ){
			var a = this.$node.querySelector( '[data-value="'+ this.getData( 'ltPropSelected' ) +'"]' );
			if( a!=null ){
				a.classList.add( 'lyteActiveAdd' );
			}
		}
	},
	onForward : function( evt ){
		var firstIndex = this.getData( 'ltPropValue' ), perPage = this.getData( 'ltPropPerpage' ), MaxRecords = this.getData( 'ltPropRecords' );
		firstIndex += perPage
		var z = (firstIndex) > MaxRecords ? MaxRecords : firstIndex;
		var actionName = this.getMethods('onNext');
		if(actionName ){
			this.executeMethod( 'onNext', z, this.$node, evt )
		}
	},
	onBackward : function(evt){
		var firstIndex = parseInt(this.getData('ltPropValue')), perPage = parseInt(this.getData('ltPropPerpage'))
		firstIndex -= perPage
		var z = (firstIndex) < 0 ? 0 : firstIndex;
		if( this.getMethods( 'onPrevious' ) ){
			this.executeMethod( 'onPrevious', z, this.$node, evt )
		}
				    
	}, 
	goFirst : function( evt ){
		this.setData( 'ltPropValue', 0, this.$node, evt );
		if( this.getMethods( 'onHome' ) ){
			this.executeMethod('onHome', this.getData('ltPropValue'), this.$node, evt);
			var singleFront = this.$node.querySelector( '.lyteSingleFront' );
			if(singleFront){
			singleFront.classList.remove('lyteDisabled')
			}
		}
		if( this.getData( 'ltPropType' ) != "default" ){
			if( this.getData( 'ltPropSelected' ) >= 1 ){   
				this.setData( 'ltPropSelected',1 );
			}
		this.activeAdd();
		}
	}, 
	goLast : function( evt ){
		var firstIndex = this.getData( 'ltPropValue' ), perPage = this.getData( 'ltPropPerpage' ), MaxRecords = this.getData( 'ltPropRecords' )
		var x = Math.floor( MaxRecords / perPage ) * perPage >= MaxRecords ? MaxRecords - perPage : Math.floor(MaxRecords / perPage) * perPage;
		if( this.getMethods( 'onEnd' ) ){
			this.executeMethod( 'onEnd', x, this.$node, evt );
		}
	},
	onSelect : function( evt ){
		var firstIndex = this.getData( 'ltPropValue' ), perPage = this.getData( 'ltPropPerpage' ), MaxRecords = this.getData( 'ltPropRecords' )
			       		
		firstIndex += perPage
		var x = ( parseInt( evt.target.getAttribute( 'data-value' ) ) * perPage )- perPage >= MaxRecords ? MaxRecords - perPage : ( parseInt( evt.target.getAttribute( 'data-value' ) ) * perPage ) - perPage;
		var actionName = this.getMethods( 'onSelect' );
		if( actionName ){
			this.executeMethod( 'onSelect', x, this.$node, evt )
		}
	},
	pagination : function(){
		var current = this.getData('ltPropSelected'),
        propRecord = this.getData('ltPropRecords'),
        delta = 1,
        left = current - delta,
        right = current + delta + 1,
        range = [],
        rangeWithDots = [],
        l,last;
        last = Math.ceil(propRecord/this.getData('ltPropPerpage'));

        if( last>5){
        	if( current == 1 && current != last ){
        		right+=1;
        	}
        	if(current==last&&current!=1){
        		left-=1;
        	}
	    	for( var i = 1; i < last; i++){
	        	if(i == 1 || i == last || i >= left && i < right){
	            	range.push(i); 
	        	}
	        	else if( i>1 && i<left ){
	        		i=left-1;
	        	}
	        	else if( i >= right && i < last ){
	        		i=last-1;
	        	}
	    }
	    range.push(last);
		for (var i=0;i<range.length;i++){
			var val=range[i];
	        if (l){
	           	if (val - l !== 1){
	               	 	rangeWithDots.push("...");
	            	}
	        	}
		        rangeWithDots.push(val);
		        l = val;
	    	}
	}
    else{
    	for( var i=1; i <= last; i++ ){
    		rangeWithDots.push(i);
    	}	
    }
    	this.setData("paginationRange",rangeWithDots);
    	this.activeAdd();
},
paginationObs:function(){
this.pagination();
}.observes('ltPropSelected','ltPropPerpage','ltPropRecords'),
	
	checkButtonObs : function(){
		this.checkButton.call(this);
	}.observes('ltPropPerpage', 'ltPropValue', 'ltPropRecords', 'ltPropMoreRecords'),

	checkButton:function(){
		var firstIndex = this.getData('ltPropValue'), perPage = this.getData('ltPropPerpage'), MaxRecords = this.getData('ltPropRecords')
		var singleFront =this.$node.querySelector( '.lyteSingleFront' ), singleBack = this.$node.querySelector( '.lyteSingleBack' ), doubleBack = this.$node.querySelector('.lyteDoubleBack' ), doubleFront = this.$node.querySelector( '.lyteDoubleFront' );
	$L.fastdom.mutate( function() {
		if( doubleBack && firstIndex <= 0 ){
			doubleBack.classList.add('lyteDisabled')
		}
		else if( doubleBack ){
			doubleBack.classList.remove('lyteDisabled')
		}
				
		if( singleBack && firstIndex <= 0 ){
			singleBack.classList.add('lyteDisabled')
		}
		else if( singleBack ){
			singleBack.classList.remove('lyteDisabled')
		}	
		if( singleFront && ( firstIndex + perPage >= MaxRecords ) && !this.getData( 'ltPropMoreRecords' ) ){
			singleFront.classList.add('lyteDisabled')
		}
		else if( singleFront ){
			singleFront.classList.remove('lyteDisabled')
		}

		if( doubleFront && ( firstIndex + perPage >= MaxRecords ) ){
					doubleFront.classList.add('lyteDisabled')
		}
		else if( doubleFront ){
			doubleFront.classList.remove('lyteDisabled')
		}
				
		if( this.getData("ltPropType") != "default" &&! this.getMethods('onSelect') && !this.getData('ltPropYield')){
	       	this.$node.querySelector('.lytepage' ).classList.add("lyteDisabled");
	    }
			// if(this.getData('ltPropMoreRecords'))
			// 	{
					this._settingStartEndValue();
					if( this.getData( "ltPropType" ) != "default" ) {
						this.setData( "ltPropSelected", Math.ceil( this.getData( 'startRecord' ) / this.getData( 'ltPropPerpage' ) ) );
						var ele = this.$node.querySelectorAll( '[data-value="..."]' );
						for( var i = 0; i < ele.length; i++ ) {   
							ele[ i ].classList.add( "lyteDisabled" );
							ele[ i ].classList.add( "dots3" );
						}
					}
				// }
			// else
			// 	{	
			// 		this.setData('startRecord', Math.ceil((firstIndex + 1) / perPage))
			// 		this.setData('endRecord', Math.ceil(MaxRecords / perPage))
			// 		this.setData('middleText', 'of')
			// 	}
		}.bind(this))

				
	}, 

	settineStartEndValue : function(){
		this._settingStartEndValue();
	}.on( 'init' ) ,


	_settingStartEndValue : function(){
		var firstIndex = this.getData( 'ltPropValue' ),
		perPage = this.getData( 'ltPropPerpage' ),
		MaxRecords = this.getData( 'ltPropRecords' ),
		startRecord = this.getData( 'startRecord' ),
		endRecord = this.getData( 'endRecord' ),
		newstart = ( firstIndex + 1 ) > MaxRecords ? MaxRecords : ( firstIndex + 1 ),
		newend = ( firstIndex + perPage ) > MaxRecords ? MaxRecords : firstIndex + perPage;

		if( this.getData('ltPropAdjustStart') && this.getData('ltPropType') == 'default' && startRecord && endRecord && (endRecord-startRecord != perPage-1) && endRecord > perPage){
			newend = endRecord ? (endRecord < perPage ? perPage : endRecord ): perPage
			newstart = endRecord ? (endRecord-perPage+1 < 1 ? 1 : endRecord-perPage+1) : 1
			if( this.getMethods( 'onPerpageChange' ) ){
				this.executeMethod( 'onPerpageChange', newstart-1, this.$node)
			}
		}
		startRecord != newstart && this.setData( 'startRecord', newstart );
		endRecord != newend && this.setData( 'endRecord', newend );
	},

	actions : {
			 
			'clickEvent' : function(evt){
				var elm=evt.target;
				if(elm.getAttribute('data-value')){
					if(elm.getAttribute('data-value')!="..."){
						this.onSelect(evt);
					}
					
				}
				else{
					while(elm&&(!elm.className||(elm.className.indexOf("lyteNavigator")==-1&&elm.className.indexOf("lyteDoubleFront")==-1&&elm.className.indexOf("lyteSingleFront")==-1&&elm.className.indexOf("lyteDoubleBack")==-1&&elm.className.indexOf("lyteSingleBack")==-1))){
						elm=elm.parentNode;
					}
					if(elm&&elm.className.indexOf("lyteDoubleFront")!=-1){
						this.goLast(evt);
					}
					else if(elm&&elm.className.indexOf("lyteSingleFront")!=-1){
						this.onForward(evt);
					}
					else if(elm&&elm.className.indexOf("lyteDoubleBack")!=-1){
						this.goFirst(evt);
					}
					else if(elm&&elm.className.indexOf("lyteSingleBack")!=-1){
						this.onBackward(evt)
					}
					else{
						evt.preventDefault();
					}
				}
				
			}	
	}
});

/**
 * @syntax nonYielded 
 *  <lyte-navigator> </lyte-navigator>  
 */

/**
 * @syntax 
 * @attribute ltPropType=simple
 * @attribute ltPropYield=false
 * <lyte-navigator lt-prop-type="simple" > 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 * </lyte-navigator>  
 */

 /**
 * @syntax
 * @attribute ltPropType=border
 * @attribute ltPropYield=false
 * <lyte-navigator lt-prop-type="border" > 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 *	  <lyte-nav-arrow> </lyte-nav-arrow> 
 * </lyte-navigator>  
 */

 /**
 * @syntax 
 * @attribute ltPropType=border 
 * @attribute ltPropYield=true
 *  <lyte-navigator lt-prop-type="border"> 
 *	  <template is = "registerYield" yield-name = "navigatorYield"> 
 *	  	  <div class="lyteDoubleBack"> Home </div> 
 *	  	  <div class="lyteSingleBack"> Prev </div> 
 *	  	  <div> {{startRecord}} to {{endRecord}} </div> 
 *	  	  <div class="lyteSingleFront"> Next </div> 
 *	  	  <div class="lyteDoubleFront"> End </div> 
 *	  </template> 
 *	</lyte-navigator>  
 */

 /**
 * @syntax  
 * @attribute ltPropType=simple 
 * @attribute ltPropYield=true
 * <lyte-navigator lt-prop-type="simple"> 
 *	 <template is = "registerYield" yield-name = "navigatorYield"> 
 *	  	 <div class="lyteDoubleBack"> Home </div> 
 *	  	 <div class="lyteSingleBack"> Prev </div> 
*	  	   <div data-value="1"> 1</div> 
*	  	   <div data-value="10"> 10</div>
 *	  	 <div class="lyteSingleFront"> Next </div> 
 *	  	 <div class="lyteDoubleFront"> End </div> 
 *	 </template> 
 * </lyte-navigator>   
 */

 /**
 * @syntax 
 * @attribute ltPropType=border 
 * @attribute ltPropYield=true
 * <lyte-navigator lt-prop-type="border"> 
 *	 <template is = "registerYield" yield-name = "navigatorYield"> 
 *	  	 <div class="lyteDoubleBack"> Home </div> 
 *	  	 <div class="lyteSingleBack"> Prev </div> 
 *	  		<div data-value="1"> 1</div> 
*	  	   <div data-value="10"> 10</div>
 *	  	 <div class="lyteSingleFront"> Next </div> 
 *	  	 <div class="lyteDoubleFront"> End </div> 
 *	 </template> 
 * </lyte-navigator>   
 */
/**
 * Renders a popover
 * @component lyte-popover
 * @version 1.0.0
 * @dependencies lyte-wormhole
 * @methods onBeforeShow,onShow,onBeforeClose,onClose,onResize,onScroll,onPositionChange
 * @utility alignPopover,calculateOffset,trapFocus
 */

Lyte.Component.register("lyte-popover",{
_template:"<template tag-name=\"lyte-popover\"> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole case=\"true\" style=\"{{if(ltPropShowCopy,'visibility:visible','visibility:hidden')}}\" on-before-append=\"{{method(&quot;beforeWormholeAppend&quot;)}}\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"popoverWrapper {{ltPropWrapperClass}}\"> <div class=\"{{if(ifEquals(ltPropAnimation,'zoom'),'lytePopover lyteZoom','lytePopover')}}\"> <template is=\"if\" value=\"{{ifEquals(ltPropType,&quot;callout&quot;)}}\"><template case=\"true\"> <span id=\"lytePopoverArrow\" class=\"lytePopoverArrowIcon\"></span> </template></template> <template is=\"if\" value=\"{{ltPropShowCloseButton}}\"> <template case=\"true\"><span class=\"lytePopoverClose\" onclick=\"{{action('close')}}\" tabindex=\"0\"></span></template> </template> <lyte-yield yield-name=\"popover\"></lyte-yield> </div> <template is=\"if\" value=\"{{ltPropFreeze}}\"> <template case=\"true\"><lyte-popover-freeze></lyte-popover-freeze></template> </template> </div> </template> </lyte-wormhole> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropShowCopy","'visibility:visible'","'visibility:hidden'"]}}}},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"insertYield","position":[1,1,5]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropType","ltPropFreeze","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropOriginElem","ltPropPosition","ltPropPlacement","ltPropDimmer","ltPropDraggable","ltPropAllowMultiple","ltPropScrollable","ltPropMaxHeight","ltPropMaxWidth","ltPropWidth","ltPropHeight","ltPropWrapperClass","ltPropBoundary","ltPropCloseOnBodyClick","ltPropDuration","ltPropOffset","ltPropBindToBody","ltPropHeaderPadding","ltPropContentPadding","ltPropFooterPadding","ltPropAnimation","ltPropWindowSpacing","ltPropForceScroll","ltPropAutoAlign","ltPropAria","ltPropAriaAttributes","ltPropPreventFocus","ltPropStopClick","ltPropIgnoreBoundary","ltPropMargin","buttons","ltPropShowCopy","visible","timeOutId","classTobeAdded","keys","first","arrowHidden","arrowEle","returnedFalse","transformOrigin","windowSpacing","lyteUnbound","prevOffsetVal","calculateHW","checkAria","prevRect","margin"],

    data: function(){
        return {
            //config from callee
            /**
             * @componentProperty {boolean} ltPropShow
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropShow":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {callout|box} ltPropType
             * @version 1.0.0
             * @default callout
             */
            "ltPropType":Lyte.attr("string",{"default":"callout"}),

            /**
             * @componentProperty {boolean} ltPropFreeze
             * @version 1.0.0
             * @default true
             *
             */
            "ltPropFreeze":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {boolean} ltPropShowCloseButton
             * @version 1.0.0
             * @default true
             *
             */
            "ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {boolean} ltPropCloseOnEscape
             * @version 1.0.0
             * @default true
             *
             */
            "ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),

            /**
             * @componentProperty {string} ltPropOriginElem
             * @version 1.0.0
             */
            "ltPropOriginElem":Lyte.attr("string",{"default":""}),

            /**
             * @experimental ltPropPosition
             */
            "ltPropPosition":Lyte.attr("string",{"default":"bottom"}),

            /**
             * @componentProperty {bottom|bottomLeft|bottomRight|top|topLeft|topRight|left|right} ltPropPlacement
             * @version 1.0.0
             */
            "ltPropPlacement":Lyte.attr("string",{"default":""}),

            /**
             * @typedef {object} dimmer
             * @property {colorstring} color
             * @property {string} opacity
             */
            /**
             * @componentProperty {dimmer} ltPropDimmer
             * @version 1.0.0
             */
            "ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),

            /**
             * @componentProperty {boolean} ltPropDraggable
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropDraggable":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropAllowMultiple
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {boolean} ltPropScrollable
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropScrollable":Lyte.attr("boolean",{"default": false}),

            /**
             * @componentProperty {string} ltPropMaxHeight
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropMaxHeight":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropMaxWidth
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropMaxWidth":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropWidth
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropWidth":Lyte.attr("string",{"default":""}),

            /**
             * @componentProperty {string} ltPropHeight
             * @version 1.0.0
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropHeight":Lyte.attr("string",{"default":"auto"}),

            /**
             * @componentProperty {string} ltPropWrapperClass
             * @version 1.0.0
             */
            "ltPropWrapperClass":Lyte.attr("string",{"default":""}),
            /**
             * @typedef {object} boundary
             * @property {string} left
             * @property {string} right
             * @property {string} top
             * @property {string} bottom
             */
            /**
             * @componentProperty {boundary} ltPropBoundary
             * @version 1.0.0
             * @default {}
             */
            "ltPropBoundary" : Lyte.attr("object",{"default":{}}),

            /**
             * @componentProperty {boolean} ltPropCloseOnBodyClick
             * @version 1.0.0
             * @default true
             *
             */
            "ltPropCloseOnBodyClick" : Lyte.attr("boolean",{"default" : true}),

            /**
             * @componentProperty {number} ltPropDuration
             * @version 1.0.0
             * @default 400
             */
            "ltPropDuration" : Lyte.attr("number",{"default" : 400}),
            /**
             * @typedef {object} popoverOffset
             * @property {string} top
             * @property {string} left
             * @property {string} bottom
             * @property {string} right
             * @property {string} height
             * @property {string} width
             */
            /**
             * @componentProperty {object} ltPropOffset
             * @version 1.0.0
             */
            "ltPropOffset" : Lyte.attr("object",{"default" : {}}),

            /**
             * @componentProperty {boolean} ltPropBindToBody
             * @version 1.0.0
             * @default false
             *
             */
            "ltPropBindToBody" : Lyte.attr("boolean",{"default":false}),

            /**
             * @componentProperty {string} ltPropHeaderPadding
             * @version 1.0.0
             * @default 15px 30px
             */
            "ltPropHeaderPadding":Lyte.attr("string",{"default":"15px 30px"}),

            /**
             * @componentProperty {string} ltPropContentPadding
             * @version 1.0.0
             * @default 15px 30px
             */
            "ltPropContentPadding":Lyte.attr("string",{"default":"15px 30px"}),

            /**
             * @componentProperty {string} ltPropFooterPadding
             * @version 1.0.0
             * @default 15px 30px
             */
            "ltPropFooterPadding":Lyte.attr("string",{"default":"15px 30px"}),

            /**
             * @componentProperty {fade|zoom} ltPropAnimation
             * @version 2.1.0
             * @default fade
             */
            "ltPropAnimation":Lyte.attr("string",{"default":"fade"}), //fade,zoom
            /**
             * @typedef {object} windowspacing
             * @property {number} top
             * @property {number} left
             * @property {number} bottom
             * @property {number} right
             */
            /**
             * @componentProperty {object} ltPropWindowSpacing
             * @version 2.1.1
             * @default { "top" : "30","left" : "30","bottom":"30","right" : "30"}
             */
            "ltPropWindowSpacing":Lyte.attr("object"),

            /**
             * @componentProperty {boolean} ltPropForceScroll
             * @version 2.2.14
             * @default false
             *
             */
            "ltPropForceScroll" : Lyte.attr('boolean', { default : false }),

            /**
             * @componentProperty {boolean} ltPropAutoAlign
             * @version 2.2.15
             * @default false
             *
             */
            "ltPropAutoAlign" : Lyte.attr('boolean', {default : false}),

            /**
             * @componentProperty {boolean} ltPropAria
             * @version 3.1.0
             * @default false
             *
             */
            "ltPropAria" : Lyte.attr( 'boolean', { default : false } ),

            /**
             * @componentProperty {object} ltPropAriaAttributes
             * @version 3.1.0
             */
            "ltPropAriaAttributes" : Lyte.attr( 'object', { default : {} } ),

            /**
             * @componentProperty {boolean} ltPropPreventFocus
             * @version 3.2.0
             * @default false
             *
             */
            "ltPropPreventFocus" : Lyte.attr('boolean', { default : false } ),

            /**
             * @componentProperty {boolean} ltPropStopClick
             * @version 3.13.0
             * @default false
             *
             */
            "ltPropStopClick" : Lyte.attr('boolean', {default : false}),

            "ltPropIgnoreBoundary" : Lyte.attr('boolean' , {default : false}),

            "ltPropMargin" : Lyte.attr('object'),
            //local properties

            "buttons":Lyte.attr("array",{"default":[{"type":"accept","text":"Ok"}]}),
            "ltPropShowCopy":Lyte.attr("boolean",{"default": false}),
            "visible" : Lyte.attr("boolean",{"default" : true}),
            "timeOutId" : Lyte.attr("number"),
            "classTobeAdded" : Lyte.attr("string"),
            "keys" : Lyte.attr("object", {"default" : {37: 1, 38: 1, 39: 1, 40: 1}}),
            "first" : Lyte.attr("boolean",{"default":true}),
            "arrowHidden" : Lyte.attr("boolean", {"default" : false}),
            "arrowEle" : Lyte.attr("object"),
            "returnedFalse" : Lyte.attr("boolean",{"default":false}),
            "transformOrigin" : Lyte.attr("string"),
            "windowSpacing" : Lyte.attr("object"),
            "lyteUnbound": Lyte.attr( 'boolean', { 'default': false } ),
            "prevOffsetVal": Lyte.attr("object"),
            "calculateHW": Lyte.attr("boolean", {'default': false}),
            "checkAria" : Lyte.attr("number", {"default":0}),
            "prevRect" : Lyte.attr("object", {'default' : undefined}),
            "margin" : Lyte.attr("object")
        }
    },

    computeSpacing : function(){
        var windowSpacing = Object.assign({},this.getData('ltPropWindowSpacing'));
        if(!windowSpacing.left){
            windowSpacing.left = 30;
        }
        if(!windowSpacing.right){
            windowSpacing.right = 30;
        }
        if(!windowSpacing.top){
            windowSpacing.top = 30;
        }
        if(!windowSpacing.bottom){
            windowSpacing.bottom = 30;
        }
        this.setData('windowSpacing',Object.assign({},windowSpacing));

        var margin = Object.assign({},this.getData('ltPropMargin'));
        if(!margin.left){
            margin.left = 0;
        }
        if(!margin.right){
            margin.right = 0;
        }
        if(!margin.top){
            margin.top = 0;
        }
        if(!margin.bottom){
            margin.bottom = 0;
        }
        this.setData('margin',Object.assign({},margin));
    }.observes('ltPropWindowSpacing', 'ltPropMargin').on('init'),

    addDragHandler : function(){
        var dragHeader = this.actualModalDiv.querySelector('lyte-popover-header');
        if(dragHeader){
            dragHeader.parentEle = this;
            if(this.$node.ltProp("draggable")){
                dragHeader.addEventListener('mousedown',this.handleMove,true);
                dragHeader.addEventListener('touchstart',this.handleMove,true);
                dragHeader.classList.add('lytePopoverHeaderDraggable');
            }
            else{
                dragHeader.removeEventListener('mousedown',this.handleMove,true);
                dragHeader.removeEventListener('touchstart',this.handleMove,true);
                dragHeader.classList.remove('lytePopoverHeaderDraggable');
            }
        }
        else{
            console.warn("This popover is not draggable because it has no header");
            this.$node.ltProp("draggable",false);
        }
    },
    handleMove : function(e){
        var drag = e.currentTarget.parentEle.actualModalDiv;
        LytePopup.node=drag;
        if(e.type == "mousedown"){
            LytePopup.xPos=e.clientX-this.getBoundingClientRect().left;
            LytePopup.yPos=e.clientY-this.getBoundingClientRect().top;
        }
        else if(e.type == "touchstart"){
            LytePopup.xPos=e.touches[0].clientX-this.getBoundingClientRect().left;
            LytePopup.yPos=e.touches[0].clientY-this.getBoundingClientRect().top;
        }
        var elePos = drag.getBoundingClientRect();
        drag.style.transitionDuration = "0s";
        var arrowEle = drag.parentElement.querySelector("#lytePopoverArrow");
        if(arrowEle){
            this.parentEle.setData('arrowHidden',true);
            this.parentEle.setData('arrowEle',arrowEle);
            arrowEle.style.display = "none";
        }
        if(e.type == "mousedown"){
            document.body.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);
            document.body.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);
        }
        else if(e.type == "touchstart"){
            document.body.addEventListener('touchmove',e.currentTarget.parentEle.handleDrag,true);
            document.body.addEventListener('touchend',e.currentTarget.parentEle.stopDrag,true);
        }
    },
    handleDrag : function(e){
        var drag = LytePopup.node;
        if(e.type == "mousemove"){
            drag.style.left=(e.clientX-drag.offsetParent.getBoundingClientRect().left-LytePopup.xPos)+'px';
            drag.style.top=(e.clientY-drag.offsetParent.getBoundingClientRect().top-LytePopup.yPos)+'px';
        }
        else if(e.type == "touchmove"){
            drag.style.left=(e.touches[0].clientX-drag.offsetParent.getBoundingClientRect().left-LytePopup.xPos)+'px';
            drag.style.top=(e.touches[0].clientY-drag.offsetParent.getBoundingClientRect().top-LytePopup.yPos)+'px';
        }
        window.getSelection().removeAllRanges();
    },
    stopDrag : function(e){
        var targetElem = e.target;
        while(targetElem && targetElem !== document){
            if(targetElem.parentEle){
                if(e.type == "mouseup"){
                    this.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);
                    this.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);
                }
                else if(e.type == "touchend"){
                    this.removeEventListener('touchmove',targetElem.parentEle.handleDrag,true);
                    this.removeEventListener('touchend',targetElem.parentEle.stopDrag,true);
                }
                break;
            }
            targetElem = targetElem.parentElement ? targetElem.parentElement : document;
        }
    },
    showToggled : function(){
        // debugger
        var event = event || window.event;
        if(this.getData('returnedFalse')){
            this.setData('returnedFalse',false);
            return;
        }
        if(this.$node.ltProp("show") && !this.$node.ltProp("showCopy")){
            if(this.tIdBeforeClose){
                clearTimeout(this.tIdBeforeClose);
                delete this.tIdBeforeClose;
            }
            if(this.tIdBeforeShow){
                clearTimeout(this.tIdBeforeShow);
                delete this.tIdBeforeShow;
            }
            if(_lyteUiUtils.getRTL() && this.getData('ltPropPlacement')){
                this.setRTLPosition();
            }
            this.$node.ltProp("bindToBody",true);
            if(this.getData('ltPropDuration') == undefined){
                this.onBeforeShowHandling(event);
            }
            else{
                var self = this;
                this.tIdBeforeShow = setTimeout(function(){
                    delete self.tIdBeforeShow;
                    self.onBeforeShowHandling(event);
                },0);
            }
        }
        else{
            this.clearFastdomBatch();
            if(this.tIdBeforeShow){
                clearTimeout(this.tIdBeforeShow);
                delete this.tIdBeforeShow;
            }
            if(this.tIdBeforeClose){
                clearTimeout(this.tIdBeforeClose);
                delete this.tIdBeforeClose;
            }
            if(this.$node.ltProp("showCopy")){
                // console.log(LytePopup.evt);
                if(this.getData('ltPropDuration') == undefined){
                    this.onBeforeCloseHandling(/*LytePopup.evt || */event);
                    if(!(this.getData('ltPropBindToBody'))){
                        this.removeDOMReferences();
                    }
                }
                else{
                    var self = this;
                    this.tIdBeforeClose = setTimeout(function(){
                        delete self.tIdBeforeClose;
                        self.onBeforeCloseHandling(event);
                    },0);
                }
            }
            else{
                if(!(this.getData('ltPropBindToBody'))){
                    this.removeDOMReferences();
                }
            }
        }
    }.observes("ltPropShow").on('didConnect'),

    setRTLPosition : function(){
        var positions = this.getData('ltPropPlacement').trim().split(" ");
        if(positions.length > 1){
            var newPosition = "";
            for(var i = 0; i < positions.length; i++){
                newPosition += this.getRTLPosition(positions[i]) + " ";
            }
            this.setData('ltPropPlacement',newPosition.trim());
        }
        else{
            this.setData('ltPropPlacement', this.getRTLPosition(positions[0]));
        }
    },

    getRTLPosition : function(position){
        if(position == "bottomLeft"){
            return "bottomRight";
        }
        else if(position == "bottomRight"){
            return "bottomLeft";
        }
        else if(position == "topLeft"){
            return "topRight";
        }
        else if(position == "topRight"){
            return "topLeft";
        }
        else if(position == "left"){
            return "right";
        }
        else if(position == "right"){
            return "left";
        }
        return position;
    },
    clearFastdomBatch : function(){
        if(this.fastdomfn1){
            $L.fastdom.clear(this.fastdomfn1);
            delete this.fastdomfn1;
        }
        if(this.fastdomfn2){
            $L.fastdom.clear(this.fastdomfn2);
            delete this.fastdomfn2;
        }
        if(this.fastdomfn3){
            $L.fastdom.clear(this.fastdomfn3);
            delete this.fastdomfn3;
        }
        if(this.fastdomfn4){
            $L.fastdom.clear(this.fastdomfn4);
            delete this.fastdomfn4;
        }
        if(this.fastdomfn5){
            $L.fastdom.clear(this.fastdomfn5);
            delete this.fastdomfn5;
        }
        if(this.fastdomfn6){
            $L.fastdom.clear(this.fastdomfn6);
            delete this.fastdomfn6;
        }
        if(this.fastdomfn7){
            $L.fastdom.clear(this.fastdomfn7);
            delete this.fastdomfn7;
        }
        if(this.initCompute){
            clearTimeout(this.initCompute);
            delete this.initCompute;
        }
    },
    changeShow : function(){
        if(!this.getData('ltPropBindToBody')){
            this.clearFastdomBatch();
            if(this.tIdBeforeShow){
                clearTimeout(this.tIdBeforeShow);
                delete this.tIdBeforeShow;
            }
            if(this.tIdBeforeClose){
                clearTimeout(this.tIdBeforeClose);
                delete this.tIdBeforeClose;
            }
            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this,true);
                delete this.addedFreezeDetails;
            }
            if(this.getData('ltPropShow')){
                this.setData('ltPropShow',false);
            }
            else{
                this.setData('ltPropShowCopy', false);
                LytePopup.closePopup(this);
                this.setData('visible',false);
                this.removeDOMReferences();
            }
        }
    }.observes("ltPropBindToBody"),

    removeDOMReferences : function(){
        if(this.childComp){
            delete this.childComp;
        }
        if(this.actualModalDiv){
            delete this.actualModalDiv;
        }
    },
    addAriaValues : function( arg ) {
        if(this.getData('ltPropAria')){
            var ariaProp = this.getData('ltPropAriaAttributes') || {};
            _lyteUiUtils.setAttribute( this.actualModalDiv, ariaProp, arg ? arg.oldValue : {} );
            var closeIcon = this.actualModalDiv.querySelector('.lytePopoverClose');
            if(closeIcon){
                closeIcon.setAttribute('aria-label', Lyte.Component.registeredHelpers.lyteUiGetValue(ariaProp,'close-label') || 'Close icon at top right position');
            }
        }
    }.observes('ltPropAriaAttributes','ltPropAriaAttributes.{}','checkAria'),
    callOnResize : function(event){
        if(this.getMethods('onResize')){
            this.executeMethod('onResize',event,this);
        }
        var origElemPosition = this.getData('ltPropOriginElem') ? document.querySelector(this.$node.ltProp('originElem')).getBoundingClientRect() : null;
        if(!!origElemPosition){
            var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            var winW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            if( !(this.getData('ltPropForceScroll')) && ( (origElemPosition.bottom > winH) || (origElemPosition.right > winW) || (origElemPosition.left < 0) || (origElemPosition.top < 0) ) ){
                this.$node.ltProp("show",false);
            }
        }

    },
    callOnScroll: function(event){
        var returnVal;
        if(this.getMethods('onScroll')){
            returnVal = this.executeMethod('onScroll',event,this);
        }
        return (returnVal == undefined ? true : returnVal);
    },

    /**
     * The method is going to set height and width to the popover
     *
     */
    updateScrollHandling : function(event){   //Sets the height and width of the popover

        if(!this.$node.ltProp("freeze") && this.$node.ltProp("forceScroll")){
            this.$node.ltProp("scrollable",true);
        }
        var modalElem = this.actualModalDiv;
        var oldHeight, oldWidth, newHeight, newWidth,
        contentNode = modalElem.querySelector("lyte-popover-content");

        if(this.getData('resize') && this.getData('ltPropAutoAlign') && this.$node.mutobserver){
            this.$node.mutobserver.disconnect();
        }
        // contentNode = contentNode ? contentNode : modalElem;
        modalElem.style.maxWidth = "";
        modalElem.style.maxHeight = "";
        modalElem.style.height = this.$node.ltProp("height")?this.$node.ltProp("height"):"auto";
        modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
        /*------------------------------ MEASURE STARTS --------------------------*/
        this.fastdomfn1 = $L.fastdom.measure(function(){   //Measures the initial height and width based on the content of popover
            delete this.fastdomfn1;
            var modalElemOffset = modalElem.getBoundingClientRect();
            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height
                                we need the modalElements parent element's width and height*/
            var modalParentOff = modalElem.parentElement.getBoundingClientRect();
            /*var totalHeight = ((modalElem.querySelector('lyte-popover-header') ? modalElem.querySelector('lyte-popover-header').getBoundingClientRect().height : 0) +
                                    (modalElem.querySelector('lyte-popover-content') ? modalElem.querySelector('lyte-popover-content').getBoundingClientRect().height : 0) +
                                        (modalElem.querySelector('lyte-popover-footer') ? modalElem.querySelector('lyte-popover-footer').getBoundingClientRect().height : 0))*/
            var cs = window.getComputedStyle(modalElem);
            var borderDimensionY = ((cs.borderTopWidth ? parseFloat(cs.borderTopWidth) : 0) +
                                     (cs.borderBottomWidth ? parseFloat(cs.borderBottomWidth) : 0));
            var windowSpacing = this.getData('windowSpacing');
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (windowSpacing.top + windowSpacing.bottom);
            /*------------------------------ MUTATE STARTS --------------------------*/
            this.fastdomfn2 = $L.fastdom.mutate(function(){  //Measures and sets the height and width based on the user provided max values
                delete this.fastdomfn2;
                // debugger
                if(this.$node.ltProp("maxWidth")){
                    // this.$node.ltProp("scrollable",true);
                    oldWidth = modalElemOffset.width;
                    // modalElem.style.width = this.$node.ltProp("maxWidth");
                    newWidth = this.$node.ltProp("maxWidth").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxWidth"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp("maxWidth"));
                    // if(oldWidth < newWidth){
                    //     modalElem.style.width = oldWidth+"px";
                    //     newWidth = oldWidth;
                    // }
                    modalElem.style.maxWidth = this.$node.ltProp("maxWidth");
                    if(contentNode){
                        contentNode.style.overflowX = "auto";
                    }
                    else{
                        modalElem.style.overflowX = "auto";
                    }

                }
                // else{
                //     newWidth = modalElemOffset.width;
                // }

                if(this.$node.ltProp("maxHeight")/* && totalHeight >= parseInt(this.$node.ltProp("maxHeight"))*/){
                    this.childComp.querySelector(".popoverWrapper").classList.add("scrollable");
                    // this.$node.ltProp("scrollable",true);
                    this.setData("calculateHW",true);
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    var newH = this.$node.ltProp("maxHeight").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxHeight"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp("maxHeight"));
                    modalElem.style.maxHeight = this.$node.ltProp("maxHeight");
                    newHeight = newH - borderDimensionY;
                    if(!contentNode){
                        modalElem.style.overflowY = "auto";
                    }
                }
                else{
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    /*  If height is provided in px or em then we dont compare if it is greater than window height as it is fixed
                        And also we add a maxHeight to the content div so that if the elements inside the content is increased
                        there wont be any issue in popover size as we have a fixed max height for popover.  */
                    if(this.$node.ltProp('height') && ((this.$node.ltProp('height')).indexOf('px') != -1 || (this.$node.ltProp('height')).indexOf('em') != -1)){
                        newHeight = oldHeight;
                        this.setData("calculateHW",true);
                    }
                    else{
                        newHeight = h-20;
                    }
                }

                if(this.getData("calculateHW") && contentNode){
                    var popoverHeader = this.actualModalDiv.querySelector("lyte-popover-header"), popoverFooter = this.actualModalDiv.querySelector("lyte-popover-footer");
                    var popoverHOff = 0,popoverFOff = 0;
                    /*------------------------------ MEASURE STARTS --------------------------*/
                    this.fastdomfn3 = $L.fastdom.measure(function(){    //Measures the heaser and footer dimensions
                        delete this.fastdomfn3;
                        if(popoverHeader){
                            if(this.$node.ltProp("maxWidth")){
                                popoverHeader.style.overflowX = "auto";
                            }
                            popoverHOff = popoverHeader.offsetHeight;
                        }
                        if(popoverFooter){
                            if(this.$node.ltProp("maxWidth")){
                                popoverFooter.style.overflowX = "auto";
                            }
                            popoverFOff = popoverFooter.offsetHeight;
                        }
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        this.fastdomfn4 = $L.fastdom.mutate(function(){   //Sets the final height and width of the popover
                            delete this.fastdomfn4;
                            var newH = (newHeight - (popoverHOff + popoverFOff));
                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) +"px";
                            contentNode.style.overflowY = "auto";
                            // if(this.getData('ltPropHeight')){
                            //     contentNode.style.height = (oldHeight - (popoverHOff + popoverFOff))+"px";
                            // }
                            // else{
                            //     contentNode.style.height = "auto";
                            // }
                            // modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
                            // modalElem.style.maxWidth = newWidth > 0 ? (newWidth +"px"):("70%");

                            /*  Moved the calling of computeOffsetImpl function from here during resize so that
                                the height and width calculation of the popover is completed and then we can position the popover.  */
                            if(this.getData('resize')){
                                // if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){
                                //     this.$node.mutobserver.disconnect();
                                // }
                                this.computeOffsetImpl(event);
                            }

                            /* Checks and adds mutation observer */
                            // this.addMutationObserver();
                            modalElem = null;
                            contentNode = null;
                            popoverHeader = null;
                            popoverFooter = null;
                        },this);
                        /*------------------------------ MUTATE ENDS --------------------------*/
                    },this);
                    /*------------------------------ MEASURE ENDS --------------------------*/
                }
                else{
                    this.childComp.querySelector(".popoverWrapper").classList.remove("scrollable");
                    /*  Moved the calling of computeOffsetImpl function from here during resize so that
                        the height and width calculation of the popover is completed and then we can position the popover.  */
                    if(this.getData('resize')){
                        // if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){
                        //     this.$node.mutobserver.disconnect();
                        // }
                        this.computeOffsetImpl(event);
                    }
                    /* Checks and adds mutation observer */
                    // this.addMutationObserver();
                    modalElem = null;
                    contentNode = null;
                }
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
    },
    scrollHandling : function(){
        if(!this.getData('ltPropShow')){
            return;
        }
        this.updateScrollHandling();
    }.observes("ltPropWidth","ltPropMaxWidth","ltPropHeight","ltPropMaxHeight"),

    // Mutation observer
    addMutationObserver : function(){
        if(this.getData('ltPropAutoAlign')){
            var popover = this.$node,
            targetNode = this.actualModalDiv, reAlign, config;
            this.setData('prevOffsetVal', {
                    height : this.actualModalDiv.offsetHeight,
                    width : this.actualModalDiv.offsetWidth
                });
            popover.mutobserver = new MutationObserver( function( mutations ) {
                if(this.getData('ltPropAutoAlign')){
                    var popoverElem = this.actualModalDiv;
                    var prevOffsetVal = this.getData('prevOffsetVal');
                    var offsetWidth = popoverElem.offsetWidth;
                    var offsetHeight = popoverElem.offsetHeight;
                    for( var i = 0; i < mutations.length; i++ ) {
                        // console.log(mutations[ i ].type + " ====== " + mutations[i].attributeName);
                        if( (mutations[ i ].type === 'attributes'/* && mutations[ i ].attributeName === 'style'*/) || mutations[i].type == 'childList' || mutations[i].type == 'subtree' ) {
                            if(prevOffsetVal.width != offsetWidth || prevOffsetVal.height != offsetHeight){
                                reAlign = true;
                                this.setData('prevOffsetVal', {
                                    height : offsetHeight,
                                    width : offsetWidth
                                })
                                break;
                            }
                        }
                    }
                    if(reAlign){
                        reAlign = false;
                        this.computeOffsetImpl(null, true);
                    }
                }
            }.bind( this ) );

            config = {
                attributes: true,
                childList : true,
                subtree: true
                // attributeFilter: ['style', 'class']
            };

            popover.mutobserver.observe( targetNode, config );
            // Mutation observer ends
        }
    },

    /**
     * The method is going to do left and top computation and add it to the popover when it is opened
     *
     */
    computeOffsetImpl : function(event, reAlign){
        var classTobeAdded = "", offsetLeft="",offsetTop="";
        var modalEle = this.actualModalDiv;
        // modalEle.classList.remove('lytePopoverCenter','lytePopoverBottomCenter','lytePopoverBottomLeft','lytePopoverBottomRight','lytePopoverTopCenter','lytePopoverTopLeft','lytePopoverTopRight','lytePopoverLeft','lytePopoverRight');
        // modalEle.style.left = "";
        // modalEle.style.top = "";
        /*------------------------------ MEASURE STARTS --------------------------*/
        $L.fastdom.measure(function(){
            if(this.$node.ltProp("showCopy")){
                if(this.$node.ltProp('originElem') != "" || !(Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset')))){
                    // debugger
                    var ele = this.$node.ltProp('originElem') ? document.querySelector(this.$node.ltProp('originElem')) : null;
                    if(!ele && Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset'))){
                        console.error("The origin element is either not present or may be removed. Kindly check.")
                        this.setData('ltPropShow',false);
                        return;
                    }
                    var modalElemOffset = modalEle.getBoundingClientRect();
                    var modalElePosition = {top: modalElemOffset.top,
                                            right: modalElemOffset.right,
                                            bottom: modalElemOffset.bottom,
                                            left: modalElemOffset.left,
                                            width: modalEle.offsetWidth,
                                            height: modalEle.offsetHeight
                                           };
                    // var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                    // var yscroll = window.pageYOffset || document.documentElement.scrollTop;
                    var wrapperOffset = modalEle.parentElement.getBoundingClientRect();
                    var windowSpacing = Object.assign({},this.getData('windowSpacing'));
                    var bodyHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - windowSpacing.bottom;
                    var bodyWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - windowSpacing.right;
                    var origElemPosition;
                    if(Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset'))){  //If origin element is present and there is no ltPropOffset
                        var eleOffset = ele.getBoundingClientRect();
                        origElemPosition = {top: eleOffset.top,
                                            right: eleOffset.right,
                                            bottom: eleOffset.bottom,
                                            left: eleOffset.left,
                                            width: eleOffset.width,
                                            height: eleOffset.height
                                          };
                    }
                    else{   //if ltPropOffset has value
                        origElemPosition = {width:parseInt(this.$node.ltProp('offset').width) || 0,
                                            height:parseInt(this.$node.ltProp('offset').height) || 0,
                                            top:parseInt(this.$node.ltProp('offset').top),
                                            left:parseInt(this.$node.ltProp('offset').left),
                                            bottom:(parseInt(this.$node.ltProp('offset').bottom) || parseInt(this.$node.ltProp('offset').top) + (parseInt(this.$node.ltProp('offset').height) || 0)),
                                            right:(parseInt(this.$node.ltProp('offset').right) || parseInt(this.$node.ltProp('offset').left) + (parseInt(this.$node.ltProp('offset').width) || 0))
                                            }
                    }
                    // if(!this.getData('ltPropFreeze')){
                    //     origElemPosition.top = origElemPosition.top + yscroll;
                    //     origElemPosition.left = origElemPosition.left + xscroll;
                    // }

                    var elementPosition = origElemPosition;
                    var offObj = {}, newOffObj = {};
                    var position =  this.$node.ltProp('positionNew');
                    var flag = true;
                    var count = 0,
                    index = 0,
                    props;
                    do{
                        if(this.$node.ltProp('placement')/* && !this.$node.ltProp('freeze')*/){
                            props = this.$node.ltProp('placement').trim().split(" ");
                            if(props.length == 1){
                                flag = true;
                                offObj = this.positionPopover(this.$node.ltProp('placement'),elementPosition,modalElePosition);
                                position = this.$node.ltProp('placement');
                                switch(position){
                                    case 'bottom':
                                    case 'top':
                                        if(offObj.offsetLeft+modalElePosition.width > bodyWidth){
                                            offObj.offsetLeft = Math.max(windowSpacing.left, bodyWidth - modalElePosition.width);
                                        }
                                        if(offObj.offsetLeft < windowSpacing.left){
                                            offObj.offsetLeft = windowSpacing.left;
                                        }
                                        break;
                                    case 'left':
                                    case 'right':
                                        if(offObj.offsetTop+modalElePosition.height > bodyHeight){
                                            offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height)/*origElemPosition.bottom - modalElePosition.height*/;
                                        }
                                        if(offObj.offsetTop < windowSpacing.top){
                                            offObj.offsetTop = windowSpacing.top;
                                        }
                                        break;
                                }
                            }
                            else{
                                if(index < props.length){
                                    position = props[index];
                                    flag = true;
                                    offObj = this.positionPopover(position,elementPosition,modalElePosition);
                                    newOffObj = offObj;
                                    switch(position){
                                        case 'bottom':
                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'bottomLeft':
                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'bottomRight':
                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'top':
                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'topLeft':
                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'topRight':
                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                                index++;
                                                flag = false;
                                                break;
                                            }

                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                                offObj.offsetLeft = elementPosition.left;
                                                flag = true;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                                flag = true;
                                            }
                                            break;
                                        case 'left':
                                            if(newOffObj.offsetTop < windowSpacing.top){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(newOffObj.offsetLeft < windowSpacing.left /*0*/){
                                                index++;
                                                flag = false;
                                                offsetLeft = (elementPosition.left + elementPosition.width)+9;
                                                offsetTop = elementPosition.top;
                                                break;
                                            }
                                            if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){
                                                offObj.offsetTop = elementPosition.top;
                                            }
                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                                offObj.offsetTop = bodyHeight - modalElePosition.height;
                                            }
                                            break;
                                        case 'leftCenter':
                                        case 'leftBottom':
                                            if(newOffObj.offsetTop < windowSpacing.top){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(newOffObj.offsetLeft < windowSpacing.left /*0*/){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            break;
                                        case 'right':
                                            if(newOffObj.offsetTop < windowSpacing.top){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                index++;
                                                flag = false;
                                                offObj.offsetLeft = (elementPosition.left - modalElePosition.width)-9;
                                                offObj.offsetTop = elementPosition.top;
                                                break;
                                            }
                                            if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){
                                                offObj.offsetTop = elementPosition.top;
                                            }
                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                                offObj.offsetTop = bodyHeight - modalElePosition.height;
                                            }
                                        break;
                                        case 'rightCenter':
                                        case 'rightBottom':
                                            if(newOffObj.offsetTop < windowSpacing.top){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                                index++;
                                                flag = false;
                                                break;
                                            }
                                        break;
                                    }
                                }
                                else{
                                    flag = true;
                                }
                            }
                        }
                        else{
                           count++;
                            flag = true;
                            offObj = this.positionPopover(position,elementPosition,modalElePosition);
                            // if(!this.$node.ltProp('freeze')){
                            //     newOffObj.offsetTop = origElemPosition.top/* + origElemPosition.height*/;
                            //     newOffObj.offsetLeft = origElemPosition.left/* + origElemPosition.width*/;
                            // }
                            // else{
                                newOffObj = offObj;
                            // }
                            switch(position){
                                case 'bottom':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'bottomLeft':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'bottomRight':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'top':
                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                        position = (_lyteUiUtils.getRTL() ? "left" : "right");
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'topLeft':
                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                        position = "right";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'topRight':
                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){
                                        position = "left";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == "box" ? 0 : 9);
                                        flag = true;
                                    }
                                    break;
                                case 'left':
                                    if(newOffObj.offsetTop < windowSpacing.top){
                                        position = "bottom";
                                        flag = false;
                                        break;
                                    }
                                    if(newOffObj.offsetLeft < windowSpacing.left /*0*/){
                                        position = "right";
                                        offObj.offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == "box" ? 0 : 9);
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height) /*bodyHeight - modalElePosition.height*/;
                                    }
                                    break;
                                case 'right':
                                    if(newOffObj.offsetTop < windowSpacing.top){
                                        position = "bottom";
                                        flag = false;
                                        break;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        position = "left";
                                        offObj.offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == "box" ? 0 : 9);
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height) /*bodyHeight - modalElePosition.height*/;
                                    }
                                    break;
                            }

                            if(this.getData('ltPropIgnoreBoundary')){
                              flag = true
                            }

                        }

                    }while(!flag && count <= 8)
                    var positions = ["bottom","bottomLeft","bottomRight","top","topLeft","topRight","right","left"];
                    if(this.getData('ltPropForceScroll')){
                        if(position.indexOf("left") != -1 || position.indexOf("right") != -1){
                            if(elementPosition.height <= modalElePosition.height){
                                if(offObj.offsetTop > elementPosition.top){
                                    offObj.offsetTop = elementPosition.top;
                                }
                                else if(offObj.offsetTop+modalElePosition.height < elementPosition.bottom){
                                    offObj.offsetTop = elementPosition.bottom - modalElePosition.height;
                                }
                            }
                            else{
                                if(offObj.offsetTop < elementPosition.top){
                                    offObj.offsetTop = elementPosition.top;
                                }
                                else if(offObj.offsetTop+modalElePosition.height > elementPosition.bottom){
                                    offObj.offsetTop = elementPosition.bottom - modalElePosition.height;
                                }
                            }
                        }
                        else{
                            if(offObj.offsetLeft > elementPosition.left){
                                offObj.offsetLeft = elementPosition.left;
                            }
                            else if(offObj.offsetLeft+modalElePosition.width < elementPosition.right){
                                offObj.offsetLeft = elementPosition.right - modalElePosition.width;
                            }
                        }
                    }
                    offsetLeft = offObj.offsetLeft;
                    offsetTop = offObj.offsetTop;

                    if(this.$node.ltProp('type') === "callout"){
                        if(position.indexOf("bottom") > -1){
                            offObj.classTobeAdded = "lytePopoverArrowTop";
                            offObj.posClass = "lytePopBottomToOrig";
                        }
                        else if(position.indexOf("top") > -1){
                            offObj.classTobeAdded = "lytePopoverArrowBottom";
                            offObj.posClass = "lytePopTopToOrig";
                        }
                        else if(position.indexOf("left") > -1){
                             offObj.classTobeAdded = "lytePopoverArrowRight";
                             offObj.posClass = "lytePopLeftToOrig";
                        }
                        else if(position.indexOf("right") > -1){
                             offObj.classTobeAdded = "lytePopoverArrowLeft";
                             offObj.posClass = "lytePopRightToOrig";
                        }
                        var arrowIcon = modalEle.querySelector("#lytePopoverArrow");
                        arrowIcon.classList.remove("lytePopoverArrowTop","lytePopoverArrowBottom","lytePopoverArrowRight","lytePopoverArrowLeft");
                        arrowIcon.classList.add(offObj.classTobeAdded);
                        var arrowIconOffset;
                        if(!(modalEle.parentElement.classList.contains(offObj.posClass))){
                            modalEle.parentElement.classList.remove("lytePopBottomToOrig","lytePopTopToOrig","lytePopLeftToOrig","lytePopRightToOrig");
                            modalEle.parentElement.classList.add(offObj.posClass);
                        }
                        /*------------------------------ MEASURE STARTS --------------------------*/
                        $L.fastdom.measure(function(){
                            arrowIconOffset = {height : arrowIcon.offsetHeight, width : arrowIcon.offsetWidth};
                        });
                        /*------------------------------ MEASURE ENDS --------------------------*/
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        //Positions the arrowIcon of the popover and the popover too based on origin elem
                        $L.fastdom.mutate(function(){   //If originElem -> height < arrowIcon -> height OR originElem -> width < arrowIcon -> width
                            var diagonal = Math.floor(Math.sqrt((arrowIconOffset.height * arrowIconOffset.height) + (arrowIconOffset.width * arrowIconOffset.width)) - 2) ;
                            if(offObj.classTobeAdded === "lytePopoverArrowTop" || offObj.classTobeAdded === "lytePopoverArrowBottom"){
                                var leftVal = Math.abs(offsetLeft - (elementPosition.left+(elementPosition.width-diagonal)/2));
                                arrowIcon.style.left = leftVal+"px";
                                arrowIcon.style.top = "";
                                if(leftVal < 13 && origElemPosition.width <= (diagonal+22) ){
                                    var diff = 13 - leftVal;
                                    // if(Math.round(origElemPosition.left) == Math.round(offsetLeft)/* && (offsetLeft - diff) >= 0*/){
                                        leftVal += diff;
                                        arrowIcon.style.left = leftVal + "px";
                                        offsetLeft -= diff;
                                    // }
                                }
                                else if(modalElePosition.width - (leftVal + diagonal) < 13 && origElemPosition.width <= (diagonal+22)){
                                    var diff = 13 - (modalElePosition.width - (leftVal + diagonal));
                                    // if(Math.round(origElemPosition.left + origElemPosition.width) == Math.round(modalElePosition.width + offsetLeft)){
                                        leftVal -= diff;
                                        arrowIcon.style.left = leftVal + "px";
                                        offsetLeft += diff;
                                    // }
                                }
                                if(leftVal > (modalElePosition.width - (2 * diagonal))){
                                    leftVal =  (modalElePosition.width - (2 * diagonal));
                                    arrowIcon.style.left = leftVal + "px";
                                }
                                if(offObj.classTobeAdded === "lytePopoverArrowTop"){
                                    this.setData('transformOrigin',Math.round(leftVal)+"px top");
                                }
                                if(offObj.classTobeAdded === "lytePopoverArrowBottom"){
                                    this.setData('transformOrigin',Math.round(leftVal)+"px bottom");
                                }
                            }
                            else{
                                var topVal = Math.abs(offsetTop - (elementPosition.top+(elementPosition.height-diagonal)/2));
                                arrowIcon.style.left = "";
                                arrowIcon.style.top = topVal +"px";
                                if(topVal < 13 && origElemPosition.height <= (diagonal+22) ){
                                    var diff = 13 - topVal;
                                    // if(Math.round(origElemPosition.top) == Math.round(offsetTop)/* && (offsetTop - diff) >= 0*/){
                                        topVal += diff;
                                        arrowIcon.style.top = topVal + "px";
                                        offsetTop -= diff;
                                    // }
                                }
                                else if(modalElePosition.height - (topVal + diagonal) < 13 && origElemPosition.height <= (diagonal+22)){
                                    var diff = 13 - (modalElePosition.height - (topVal + diagonal));
                                    // if(Math.round(origElemPosition.top + origElemPosition.height) == Math.round(modalElePosition.height + offsetTop)){
                                        topVal -= diff;
                                        arrowIcon.style.top = topVal + "px";
                                        offsetTop += diff;
                                    // }
                                }
                                if(offObj.classTobeAdded === "lytePopoverArrowLeft"){
                                    this.setData('transformOrigin',"left "+Math.round(topVal)+"px");
                                }
                                if(offObj.classTobeAdded === "lytePopoverArrowRight"){
                                    this.setData('transformOrigin',"right "+Math.round(topVal)+"px");
                                }
                            }
                        },this);
                        /*------------------------------ MUTATE ENDS --------------------------*/

                    }
                    else{
                        if(position.indexOf("bottom") > -1){
                            offObj.posClass = "lytePopBottomToOrig";
                        }
                        else if(position.indexOf("top") > -1){
                            offObj.posClass = "lytePopTopToOrig";
                        }
                        else if(position === "left"){
                             offObj.posClass = "lytePopLeftToOrig";
                        }
                        else if(position === "right"){
                             offObj.posClass = "lytePopRightToOrig";
                        }
                        if(!(modalEle.parentElement.classList.contains(offObj.posClass))){
                            modalEle.parentElement.classList.remove("lytePopBottomToOrig","lytePopTopToOrig","lytePopLeftToOrig","lytePopRightToOrig");
                            modalEle.parentElement.classList.add(offObj.posClass);
                        }
                        if(offObj.posClass == "lytePopBottomToOrig" || offObj.posClass == "lytePopTopToOrig"){
                            var leftVal = Math.abs(offsetLeft - (elementPosition.left+elementPosition.width/2));
                            if(offObj.posClass == "lytePopBottomToOrig"){
                                this.setData('transformOrigin',Math.round(leftVal)+"px top");
                            }
                            if(offObj.posClass == "lytePopTopToOrig"){
                                this.setData('transformOrigin',Math.round(leftVal)+"px bottom");
                            }
                        }
                        else{
                            var topVal = Math.abs(offsetTop - (elementPosition.top+elementPosition.height/2));
                            if(offObj.posClass === "lytePopRightToOrig"){
                                this.setData('transformOrigin',"left "+Math.round(topVal)+"px");
                            }
                            if(offObj.posClass === "lytePopLeftToOrig"){
                                this.setData('transformOrigin',"right "+Math.round(topVal)+"px");
                            }
                        }

                    }
                    this.setData('classTobeAdded',offObj.classTobeAdded);
                }
                else{
                    console.error("Please provide values for either ltPropOriginElem or ltPropOffset to open the popover at proper position.")
                    this.setData('ltPropShow',false);
                    return;
                }
                this.$node.ltProp('positionNew',position);
                /*------------------------------ MUTATE STARTS --------------------------*/
                $L.fastdom.mutate(function(){
                    offsetLeft -= wrapperOffset.left ? wrapperOffset.left : 0;
                    offsetTop -= wrapperOffset.top ? wrapperOffset.top : 0;
                    modalEle.style.left = offsetLeft+"px";
                    modalEle.style.top = offsetTop+"px";
                    if(this.getData("first")){
                        LytePopup.bindTransitionEnd(this.actualModalDiv);
                        this.callOnShow();
                        this.setOpacityAndVisibility();
                        this.setData("first",false);
                        /* Checks and adds mutation observer */
                        $L.fastdom.mutate(function(){
                            this.addMutationObserver();
                        },this);
                    }
                    else if(this.getData('resize')){
                        this.callOnResize(event);
                        this.setData('resize', false);
                        /* Checks and adds mutation observer */
                        $L.fastdom.mutate(function(){
                            this.addMutationObserver();
                        },this);
                    }
                    else if(reAlign){
                        var prevRect = this.getData('prevRect');
                        if(prevRect && ( (prevRect.left != offsetLeft) || (prevRect.top != offsetTop) ) && this.getMethods('onPositionChange')){
                            this.executeMethod('onPositionChange', this);
                        }
                    }
                    this.setData('prevRect', {left : offsetLeft, top : offsetTop});
                },this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        if(this.$node.ltProp("freeze")){
            document.body.classList.add('bodyWrapper');
            // LytePopup.bodywrapperCount += 1;
        }
    },

    /**
     * The method is going to return the left and top values that can be set to the popover based on the origin element's position
     *
     */
    positionPopover : function(position,elementPosition,modalElePosition){
        var  offsetLeft=0,offsetTop=0,classTobeAdded,margin=this.getData("margin");
        switch(position){
            case 'bottom':
                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;
                offsetTop = elementPosition.top+elementPosition.height+ (this.getData('ltPropType') == "box" ? 0 : 9) + margin.top;
                classTobeAdded = "lytePopoverArrowTop";
                break;
            case 'bottomLeft':
                offsetLeft = elementPosition.left;
                offsetTop = elementPosition.top +elementPosition.height+(this.getData('ltPropType') == "box" ? 0 : 9) + margin.top;
                classTobeAdded = 'lytePopoverArrowTop';
                break;
            case 'bottomRight':
                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;
                offsetTop =  elementPosition.top +elementPosition.height+(this.getData('ltPropType') == "box" ? 0 : 9) + margin.top;
                classTobeAdded = 'lytePopoverArrowTop';
                break;
            case 'top':
                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;
                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == "box" ? 0 : 9)) - margin.bottom;
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'topLeft':
                offsetLeft = elementPosition.left;
                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == "box" ? 0 : 9)) - margin.bottom;
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'topRight':
                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;
                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == "box" ? 0 : 9)) - margin.bottom;
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'left':
                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == "box" ? 0 : 9) + margin.left;
                offsetTop = elementPosition.top;
                classTobeAdded = 'lytePopoverArrowRight';
                break;
            case 'leftCenter':
                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == "box" ? 0 : 9) + margin.left;
                offsetTop = elementPosition.top + (elementPosition.height - modalElePosition.height) / 2;
                classTobeAdded = 'lytePopoverArrowRight';
                break;
            case 'leftBottom':
                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == "box" ? 0 : 9) + margin.left;
                offsetTop = elementPosition.bottom  - modalElePosition.height;
                classTobeAdded = 'lytePopoverArrowRight';
                break;
            case 'right':
                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == "box" ? 0 : 9) - margin.right;
                offsetTop = elementPosition.top;
                classTobeAdded = 'lytePopoverArrowLeft';
                break;
            case 'rightCenter':
                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == "box" ? 0 : 9) - margin.right;
                offsetTop = elementPosition.top + (elementPosition.height - modalElePosition.height) / 2;
                classTobeAdded = 'lytePopoverArrowLeft';
                break;
            case 'rightBottom':
                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == "box" ? 0 : 9) - margin.right;
                offsetTop = elementPosition.bottom - modalElePosition.height;
                classTobeAdded = 'lytePopoverArrowLeft';
                break;
        }
        return {offsetLeft:offsetLeft,offsetTop:offsetTop,classTobeAdded:classTobeAdded};
    },

    callOnShow:function(){
        this.$node.classList.add('lytePopoverOpened');
        if(this.getMethods("onShow")){
            this.executeMethod("onShow",this);
        }
    },
    setOpacityAndVisibility : function(){
        if(this.getData('ltPropAnimation') === "zoom"){
            this.actualModalDiv.style.transition = "none";
            this.actualModalDiv.style.transform = "scale(0)";
            // this.actualModalDiv.style.opacity = "1";
            this.actualModalDiv.classList.add('lytePopoverVisible');
            // this.actualModalDiv.classList.add('lyteZoom');
            var self = this;
            setTimeout(function(){
                self.actualModalDiv.style.transition = "";
                self.actualModalDiv.style.transitionDuration = (parseFloat(self.getData('ltPropDuration'))/1000) + "s";
                LytePopup.makingVisible = true;

                self.actualModalDiv.style.transformOrigin = self.getData('transformOrigin');
                self.actualModalDiv.style.transform = "scale(1)";
            },50);
        }
        else{
            this.actualModalDiv.style.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + "s";
            LytePopup.makingVisible = true;
            // this.actualModalDiv.style.opacity = "1";
            this.actualModalDiv.classList.add('lytePopoverVisible');
        }


        /* ---- Commented for position error ---*/
        /* if(!this.$node.ltProp('freeze') && this.getData('classTobeAdded') && (this.getData('classTobeAdded') == "lytePopoverArrowLeft" || this.getData('classTobeAdded') == "lytePopoverArrowRight")){
            var actualModalDivOffset = this.actualModalDiv.getBoundingClientRect();
            var origElemPosition = document.querySelector(this.getData('ltPropOriginElem')).getBoundingClientRect();
            if(actualModalDivOffset.top != origElemPosition.top){
                this.actualModalDiv.style.top = origElemPosition.top + "px";
            }
        } */
    },

    /*computeOffset : function(){
        this.computeOffsetImpl();
    }.observes("ltPropOriginElem","ltPropPosition","ltPropType","ltPropShowCopy","ltPropOffset"),*/
    onBeforeCloseHandling : function(event){
        var result = true;
        if(this.getMethods("onBeforeClose")){
            result = this.executeMethod("onBeforeClose",event,this);
        }
        if(result === undefined || result){
            delete this.$node.alignPopover;
            delete this.$node.calculateOffset;
            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this);
                delete this.addedFreezeDetails;
            }

            if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){
                this.$node.mutobserver.disconnect();
                delete this.$node.mutobserver;
            }

            if(this.getData('arrowHidden')){
                this.getData('arrowEle').style.display = "";
                this.setData('arrowHidden',false);
                this.setData('arrowEle',null);
            }
            if(_lyteUiUtils.getRTL() && this.getData('ltPropPlacement')){
                this.setRTLPosition();
            }
            if(this.getData('ltPropDuration') == undefined){
                // this.childComp.querySelector(".popoverWrapper").style.position = "";
                this.$node.ltProp({"showCopy":false,"show":false});
                this.$node.classList.remove('lytePopoverOpened');
                if(this.getData('ltPropAnimation') == "zoom"){
                    this.actualModalDiv.style.transform = "scale(0)";
                }
                else{
                    // this.actualModalDiv.style.opacity = 0;
                    this.actualModalDiv.classList.remove('lytePopoverVisible');

                }
                LytePopup.closePopup(this);
                // LytePopup.bindTransitionEnd(this.actualModalDiv);
                this.setData('visible',false);
                if(this.$node.ltProp('freeze') && this.childComp.querySelector("lyte-popover-freeze")){
                    this.childComp.querySelector("lyte-popover-freeze").style.opacity = 0;
                    this.childComp.querySelector("lyte-popover-freeze").style.visibility = "";
                }
                if(!this.$node.ltProp('freeze')){
                    this.childComp.querySelector(".popoverWrapper").classList.remove('noFreeze');
                }
                if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){
                    document.body.classList.remove('lyteStopBodyScrolling');
                }
                if(this.getMethods("onClose")){
                    this.executeMethod("onClose",event,this);
                }
                // if(this.$node.ltProp('freeze')){
                //     LytePopup.bodywrapperCount -= 1;
                //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
                //         document.body.classList.remove('bodyWrapper');
                //     }
                // }
                LytePopup.checkAndRemoveWrapper();
            }
            else{
                var animDur = parseInt(this.getData('ltPropDuration'));
                var self = this;
                this.tIdClose = setTimeout(function(){
                    self.tIdClose = false;
                    if(self.getData('ltPropAnimation') == "zoom"){
                        // self.actualModalDiv.style.opacity = "0";
                        self.actualModalDiv.classList.remove('lytePopoverVisible');
                        self.actualModalDiv.style.transform = "";
                    }

                    self.$node.ltProp({"showCopy":false,"show":false});
                    self.$node.classList.remove('lytePopoverOpened');
                    if(self.getMethods("onClose")){
                        self.executeMethod("onClose",event,self);
                    }
                    // if(self.$node.ltProp('freeze')){
                    //     LytePopup.bodywrapperCount -= 1;
                    //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
                    //         document.body.classList.remove('bodyWrapper');
                    //     }
                    // }
                    LytePopup.checkAndRemoveWrapper();
                    if(!(self.getData('ltPropBindToBody'))){
                        self.removeDOMReferences();
                    }
                },animDur);
                this.actualModalDiv.style.transitionDuration = ((animDur == 0 ? 0 : animDur > 300 ? animDur - 200 : 100) / 1000)+"s";
                if(this.getData('ltPropAnimation') == "zoom"){
                    this.actualModalDiv.style.transform = "scale(0)";
                }
                else{
                    // this.actualModalDiv.style.opacity = 0;
                    this.actualModalDiv.classList.remove('lytePopoverVisible');
                }
                LytePopup.closePopup(this);
                // LytePopup.bindTransitionEnd(this.actualModalDiv);
                this.setData('visible',false);
                this.childComp.classList.add("lytePopoverDispNone");
                if($L(this.childComp).find('.lytePopover')[0]){
                  $L(this.childComp).find('.lytePopover')[0].style.left = ""
                  $L(this.childComp).find('.lytePopover')[0].style.top = ""
                }
                if(this.$node.ltProp('freeze') && this.childComp.querySelector("lyte-popover-freeze")){
                    this.childComp.querySelector("lyte-popover-freeze").style.opacity = 0;
                    this.childComp.querySelector("lyte-popover-freeze").style.visibility = "";
                }
                if(!this.$node.ltProp('freeze')){
                    this.childComp.querySelector(".popoverWrapper").classList.remove('noFreeze');
                }
                if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){
                    document.body.classList.remove('lyteStopBodyScrolling');
                }
            }
        }
        else{
            // if(LytePopup.evt){
            //     delete LytePopup.evt;
            // }
            this.setData('returnedFalse',true);
            if(!this.getData('visible')){
                this.setData('visible',true);
            }
            this.$node.ltProp('show',true);
        }
    },
    onBeforeShowHandling : function(){
        var result = true;
        if(this.getMethods("onBeforeShow")){
            result = this.executeMethod("onBeforeShow",this);
        }
        if(result === undefined || result){
            this.childComp.classList.remove("lytePopoverDispNone");
            this.setData('checkAria', this.getData('checkAria')+1);
            if(this.getData('ltPropDraggable')){
                this.addDragHandler();
            }
            this.updateScrollHandling();
            if(!this.$node.ltProp('freeze')){
                this.childComp.querySelector(".popoverWrapper").classList.add('noFreeze');
            }

            this.$node.ltProp("positionNew",this.$node.ltProp("position"));
            if(this.getData('ltPropDuration') == undefined){
                this.$node.ltProp('showCopy',true);
                this.fastdomfn5 = $L.fastdom.mutate(function(){
                    delete this.fastdomfn5;
                    this.fastdomfn6 = $L.fastdom.measure(function(){
                        delete this.fastdomfn6;
                        this.fastdomfn7 = $L.fastdom.mutate(function(){
                            delete this.fastdomfn7;
                            this.computeOffsetImpl();
                        },this);
                    },this);
                },this);
            }
            else{
                var self = this;
                this.initCompute = setTimeout(function(){
                    delete self.initCompute;
                    /*------------------------------ MUTATE STARTS --------------------------*/
                    self.$node.ltProp('showCopy',true);
                    self.fastdomfn5 = $L.fastdom.mutate(function(){
                        delete self.fastdomfn5;
                        self.fastdomfn6 = $L.fastdom.measure(function(){
                            delete self.fastdomfn6;
                            self.fastdomfn7 = $L.fastdom.mutate(function(){
                                delete self.fastdomfn7;
                                self.computeOffsetImpl();
                            },self);
                        },self);
                    },self);
                    /*------------------------------ MUTATE ENDS --------------------------*/
                },0);
            }
            if(!this.getData("first")){
                this.setData("first",true);
            }
            $L.fastdom.measure(function(){
                var scrollParent = this.$node.ltProp('originElem') ? LytePopup.getScrollParent(document.querySelector(this.$node.ltProp('originElem'))) : null;
                if(!this.getData('ltPropFreeze') && !(scrollParent && scrollParent.isEqualNode(document.body))){
                    document.body.classList.add('lyteStopBodyScrolling');
                }
            },this);
            if(!this.getData('visible')){
                this.setData('visible',true);
            }
            LytePopup.addPopup(this);
            if(this.$node.ltProp('freeze')){
                var freezeStyle = this.childComp.querySelector("lyte-popover-freeze").style;
                // freezeStyle.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + "s";
                // freezeStyle.opacity = this.getData('ltPropDimmer').opacity;
                freezeStyle.background = this.getData('ltPropDimmer').color;
                if(!this.addedFreezeDetails){
                    freezeStyle.opacity = this.getData('ltPropDimmer').opacity;
                }
            }
            this.$node.alignPopover = this.computeOffsetImpl.bind(this);
            this.$node.calculateOffset = this.updateScrollHandling.bind(this);
        }
        else{
            this.$node.ltProp({"showCopy":false,"show":false});
        }
    },
    didDestroy : function(){
        this.$node.classList.remove('lytePopoverOpened');
        if(this.childComp){
            this.clearFastdomBatch();
            if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){
                this.$node.mutobserver.disconnect();
                delete this.$node.mutobserver;
            }
            if(this.tIdBeforeClose){
                clearTimeout(this.tIdBeforeClose);
                this.tIdBeforeClose = false;
            }
            if(this.tIdClose){
                clearTimeout(this.tIdClose);
                this.tIdClose = false;
            }
            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){
                LytePopup.hideOrShowFreeze("close",this);
                delete this.addedFreezeDetails;
            }
            // if(LytePopup.evt){
            //     delete LytePopup.evt;
            // }
            LytePopup.closePopup(this)
            this.childComp.remove();
            // delete this.childComp;
            // delete this.actualModalDiv;
            this.removeDOMReferences();
            // if(this.$node.ltProp('freeze')){
            //     LytePopup.bodywrapperCount -= 1;
            //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){
            //         document.body.classList.remove('bodyWrapper');
            //     }
            // }
            LytePopup.checkAndRemoveWrapper();
            if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){
                document.body.classList.remove('lyteStopBodyScrolling');
            }
        }
    },
    actions: {
        close : function(){
           this.$node.ltProp("show",false);
        }
    },
    methods : {
        beforeWormholeAppend : function(arg){
            this.childComp = arg;

            //Sets the padding style based on user provide padding values
            if(this.$node.parentElement && this.$node.parentElement.tagName == 'LYTE-COLORPICKER'){
                this.$node.parentElement.component.childComp = this.childComp;
            }
            if(this.childComp.querySelector('lyte-popover-header')){
                this.childComp.querySelector('lyte-popover-header').style.padding = this.getData('ltPropHeaderPadding');
            }
            if(this.childComp.querySelector('lyte-popover-content')){
                this.childComp.querySelector('lyte-popover-content').style.padding = this.getData('ltPropContentPadding');
            }
            if(this.childComp.querySelector('lyte-popover-footer')){
                this.childComp.querySelector('lyte-popover-footer').style.padding = this.getData('ltPropFooterPadding');
            }
            this.actualModalDiv = this.childComp.querySelector(".lytePopover");
            if(this.childComp.querySelector('lyte-popover-header') && this.getData('ltPropShowCloseButton')){
                var headerHeight=0, closeHeight= 0;
                $L.fastdom.measure(function(){
                    headerHeight = this.childComp.querySelector('lyte-popover-header').offsetHeight /*this.childComp.querySelector('lyte-popover-header').getBoundingClientRect().height*/;
                    closeHeight = this.childComp.querySelector('.lytePopoverClose').offsetHeight /*this.childComp.querySelector('.lytePopoverClose').getBoundingClientRect().height*/;
                },this);
                $L.fastdom.mutate(function(){
                    this.childComp.querySelector('.lytePopoverClose').style.top = (headerHeight - closeHeight) / 2 + "px";
                },this);
            }
        }
    },
    observeClickEvent : function(){
        LytePopup._stopPropagation = this.getData('ltPropStopClick');
        if(LytePopup._stopPropagation){
            LytePopup._sourceComp = this;
        }
        else{
            if(LytePopup._sourceComp){
                delete LytePopup._sourceComp;
            }
        }
    }.observes('ltPropStopClick')
});



if (document.readyState === "complete" || document.readyState === "interactive"){
    addPopoverEvent();
}
else{
    document.addEventListener("DOMContentLoaded", function(event){
        addPopoverEvent(event);
    });
}

function addPopoverEvent(event){

    document.addEventListener('click',function(event){
        if(LytePopup._stopPropagation){
            LytePopup._sourceComp.setData('ltPropStopClick', false);
            return;
        }
        var ele = event.target;
        while(!$L(ele).hasClass('popoverWrapper') && ele.tagName != "LYTE-POPOVER-FREEZE" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){
            ele = ele.parentElement;
            if(!ele){
                return
            }
        }
        if(ele.tagName == 'HTML' || ele.tagName == "LYTE-POPOVER-FREEZE"){
            for(var i = LytePopup.components.length -1 ; i>=0; i--){
                if(LytePopup.components[i].$node.tagName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible"){
                    // LytePopup.evt = event;
                    var popover = LytePopup.components[i].$node;
                    if(popover && popover.component.getData('visible') && popover.component.getData('ltPropCloseOnBodyClick')){
                        popover.component.setData('visible',false);
                        popover.ltProp('show',false);
                        break;
                    }
                }
            }
        }
        /*  If ele is having popoverWrapper class ie. a popover and it is not the popover that is opened at last which is the current popover element in the page
            this means the click has happened outside the current popover
            so the current popover should be closed */
        else if(ele.classList.contains('popoverWrapper') && LytePopup.components.length > 1 && LytePopup.components[LytePopup.components.length -1].$node.tagName == "LYTE-POPOVER"){
            var comp = LytePopup.components[LytePopup.components.length -1];
            if(!(comp.childComp.contains(ele)) &&comp.getData('visible') && comp.getData('ltPropCloseOnBodyClick')){
                comp.setData('visible',false);
                comp.$node.ltProp('show',false);
            }
        }
    },true);

    //13/01/2020 - Changed document.body.addEventListener => window.addEventListener as scroll was not triggered when the html was having scroll(not the body)
    window.addEventListener('scroll',function(event){    //This is for closing the dropdown when an outside area is clicked(CODE HELP)
       // console.log("called scroll");
       if(LytePopup.makingVisible) {
        LytePopup.makingVisible = false;
        return;
       }
        var wormhole;
        for(var i=LytePopup.components.length-1;i>=0;i--){
            if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible"){
                wormhole = LytePopup.components[i].childComp;
                if(wormhole && wormhole._callee.component.$node.ltProp("scrollable")){
                    if(LytePopup.components[i].callOnScroll(event)){
                        var ele =  wormhole.querySelector('.lytePopover');
                        if(!ele/* || !wormhole._callee.ltProp('originElem')*/){
                            return ;
                        }
                        while(ele.tagName != 'LYTE-WORMHOLE'){
                            ele = ele.parentElement
                        }
                        var curscroll = event.target
                        // if(curscroll.nodeName == "#document"){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)
                        //     return ;
                        // }
                        while(curscroll.tagName != "LYTE-WORMHOLE" && curscroll.tagName != 'HTML' && curscroll.nodeName != "#document"){
                            curscroll = curscroll.parentElement
                        }
                        if(curscroll.tagName == 'LYTE-WORMHOLE' && curscroll.isEqualNode(ele)){
                            return ;
                        }
                        // console.log("didnt return");
                        ele._callee.component.computeOffsetImpl();
                        if(ele._callee.component.getData('ltPropForceScroll')){
                            return;
                        }

                        var par = document.querySelector(ele._callee.ltProp('originElem'));
                        var screl = event.target
                        var pbcr = par.getBoundingClientRect();

                        var boundary = ele._callee.ltProp("boundary");
                        var popoverElem = ele.querySelector('.lytePopover');
                        var windowSpacing = ele._callee.getData('windowSpacing');
                        if(!(Object.keys(boundary).length === 0 && boundary.constructor === Object)){
                            if(boundary.top && popoverElem.getBoundingClientRect().top < parseFloat(boundary.top)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.bottom && popoverElem.getBoundingClientRect().bottom > parseFloat(boundary.bottom)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.left && popoverElem.getBoundingClientRect().left < parseFloat(boundary.left)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.right && popoverElem.getBoundingClientRect().right > parseFloat(boundary.right)){
                                ele._callee.ltProp('show',false);
                            }
                        }
                        // console.log("for moving up",sbcr.top,pbcr.top)
                        // console.log("for moving down",(sbcr.top+sbcr.height),(pbcr.top+pbcr.height))
                        if(screl.contains(par)){
                            var arrowEle = ele.querySelector('#lytePopoverArrow');
                            if(arrowEle && arrowEle.classList.contains('lytePopoverArrowBottom') && ((pbcr.top+(pbcr.height/2)) > window.innerHeight)){
                                ele._callee.ltProp('show',false);
                            }
                            if((arrowEle &&
                                    (arrowEle.classList.contains('lytePopoverArrowLeft') || arrowEle.classList.contains('lytePopoverArrowRight')) &&
                                    ((arrowEle.getBoundingClientRect().bottom >= ele.querySelector('.lytePopover').getBoundingClientRect().bottom) ||
                                        (arrowEle.getBoundingClientRect().top <= ele.querySelector('.lytePopover').getBoundingClientRect().top))
                                )){
                                ele._callee.ltProp('show',false);
                            }
                            if(screl.nodeName == "#document"){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)
                                // console.log("pbcr.top ==> ",pbcr.top,"   pbcr.bottom ==> ",pbcr.bottom);
                                var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                                var winW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                                if(pbcr.top < windowSpacing.top || (pbcr.bottom+3) >= (winH - windowSpacing.bottom)){
                                    ele._callee.ltProp('show',false);
                                }
                                // console.log("pbcr.left ==> ",pbcr.left,"   pbcr.right ==> ",pbcr.right);
                                if(pbcr.left < windowSpacing.left || (pbcr.right+3) >= (winW - windowSpacing.right)){
                                    ele._callee.ltProp('show',false);
                                }
                            }
                            else{
                                var sbcr = screl.getBoundingClientRect();
                                if((sbcr.top + windowSpacing.top) > pbcr.top || (sbcr.top + sbcr.height - windowSpacing.bottom) < (pbcr.top + pbcr.height)){
                                    ele._callee.ltProp('show',false);
                                }
                                if((sbcr.left + windowSpacing.left) > pbcr.left || (sbcr.left + sbcr.width - windowSpacing.right) < (pbcr.left + pbcr.width)){
                                    ele._callee.ltProp('show',false);
                                }
                            }
                        }

                    }
                }
            }
        }


    },true);

    window.addEventListener("resize",function(event){
        if(LytePopup._lytePopoverRTId){
            // console.log(LytePopup._lytePopoverRTId);
            clearTimeout(LytePopup._lytePopoverRTId);
            LytePopup._lytePopoverRTId = false;
        }
        LytePopup._lytePopoverRTId = setTimeout(function(){
            for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){
                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible" && LytePopup.components[i].childComp.querySelector('.lytePopover')){
                    LytePopup.components[i].$node.component.setData('resize', true);
                    LytePopup.components[i].$node.component.updateScrollHandling(event);

                    /*  Commented calling these functions from here and called them from inside updateScrollHandling
                        so that the functions gets called in a synchronised manner and doesnt overlap each other. */

                    // LytePopup.components[i].$node.component.computeOffsetImpl();
                    // LytePopup.components[i].$node.component.callOnResize(event);
                    // var origElemPosition = document.querySelector(LytePopup.components[i].$node.ltProp('originElem')).getBoundingClientRect();
                    // var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                    // if(origElemPosition.bottom + 3 >= winH){
                    //     LytePopup.components[i].$node.ltProp("show",false);
                    // }
                }
            }
            LytePopup._lytePopoverRTId = false;
        },100);
    },true);

};

/**
 * @syntax yielded
 * <lyte-popover>
 *     <template is = "registerYield" yield-name = "popover">
 *         <lyte-popover-header> Create Profile </lyte-popover-header>
 *         <lyte-popover-content>
 *             //Some Content
 *         </lyte-popover-content>
 *         <lyte-popover-footer class = "right">
 *             //Some button
 *         </lyte-popover-footer>
 *     </template>
 * </lyte-popover>
 */

/**
 * Renders a progressbar
 * @component lyte-progressbar
 * @version 1.0.0
 */
Lyte.Component.register('lyte-progressbar', {
_template:"<template tag-name=\"lyte-progressbar\"> <template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'circle')}}\"><template case=\"true\"> <div class=\"lyteProgressBar lyteCircle\" style=\"{{lyteUiConcat('width:',lyteUiSetWH(ltPropRadius),'px; height:',lyteUiSetWH(ltPropRadius),'px;')}}\"> <div class=\"lyteCircleType\"> <svg class=\"svgValueEle\" width=\"{{lyteUiSetWH(ltPropRadius)}}\" height=\"{{lyteUiSetWH(ltPropRadius)}}\"> <circle style=\"{{lyteUiConcat('transition:','stroke-dashoffset ',duration,' ',timingfn,';')}}\" cx=\"{{ltPropRadius}}\" cy=\"{{ltPropRadius}}\" r=\"{{lyteUiSetRadius(ltPropRadius,ltPropStroke)}}\" fill=\"none\" stroke=\"#DCE0E3\" stroke-width=\"{{ltPropStroke}}\"></circle> <circle style=\"{{lyteUiConcat('transition:','stroke-dashoffset ',duration,' ',timingfn,';')}}\" cx=\"{{ltPropRadius}}\" cy=\"{{ltPropRadius}}\" r=\"{{lyteUiSetRadius(ltPropRadius,ltPropStroke)}}\" fill=\"none\" stroke=\"{{ltPropBackground}}\" stroke-width=\"{{ltPropStroke}}\" stroke-dasharray=\"{{lyteUiSetDashArray(ltPropRadius,ltPropStroke)}}\" stroke-dashoffset=\"{{lyteUiSetOffset(ltPropRadius,ltPropStroke,percentage)}}\"></circle> </svg> <template is=\"if\" value=\"{{ltPropShowPercentage}}\"><template case=\"true\"> <svg width=\"{{lyteUiSetWH(ltPropRadius)}}\" height=\"{{lyteUiSetWH(ltPropRadius)}}\" style=\"transform:{{lyteUiTextTransform(ltPropRadius)}}\" viewBox=\"{{lyteUiConcat('0 ','0 ',lyteUiSetWH(ltPropRadius),' ',lyteUiSetWH(ltPropRadius))}}\" fill=\"{{if(ltPropLabelColor,ltPropLabelColor,'#333')}}\"> <text font-size=\"{{if(ltPropFontSize,ltPropFontSize,'1.5rem')}}\" text-anchor=\"middle\" dy=\".2em\" x=\"50%\" y=\"50%\"> {{lyteUiProgressbarLabel(ltPropLabel,percentageDisplay,ltPropPercentage)}} </text> </svg> </template></template> </div> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'stacked')}}\"><template case=\"true\"> <div class=\"{{lyteUiConcat('lyteProgressBar',' lyteHorizontal',' lyteStacked')}} \" style=\"{{lyteUiConcat('width:',ltPropWidth,';height:',ltPropHeight)}}\"> <template is=\"for\" items=\"{{chunks}}\" item=\"item\" index=\"index\"> <span class=\"lyteProgressStatusStack\" style=\"{{lyteUiConcat('width: ','0% ;','transition: ','width ',duration,' ',timingfn,';','background:',lyteUiGetStackValue(ltPropStack,index,'color'),';')}}\"> <template is=\"if\" value=\"{{lyteUiGetStackValue(ltPropStack,index,'animated')}}\"><template case=\"true\"> <span class=\"ltPropProgressAnimated progressMovingObj\"></span> </template></template> <template is=\"if\" value=\"{{ltPropShowPercentage}}\"><template case=\"true\"> <span case=\"true\" class=\"lyteProgressPercentageStack\" style=\"{{lyteUiConcat('line-height:',ltPropHeight,'; font-size: ',if(ltPropFontSize,ltPropFontSize,'12px'),'; color: ',if(lyteUiGetStackValue(ltPropStack,index,'labelColor'),lyteUiGetStackValue(ltPropStack,index,'labelColor'),'#fff'),';')}}\"> {{lyteUiProgressbarLabel(lyteUiGetStackValue(ltPropStack,index,'label'),'')}} </span> </template></template> </span> </template> </div> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'vertical')}}\"><template case=\"true\"> <div class=\"lyteProgressBar lyteVertical\" style=\"{{lyteUiConcat('width:',ltPropWidth,';height:',ltPropHeight)}}\"> <span class=\"{{lyteUiConcat('lyteProgressStatusVertical ',ltPropDirection)}}\" style=\"{{lyteUiConcat('height: ',percentage,'% ;','transition:','height ',duration,' ',timingfn,';','background: ',ltPropBackground,';','display: block')}}\"> <template is=\"if\" value=\"{{ltPropShowPercentage}}\"><template case=\"true\"> <span case=\"true\" class=\"lyteProgressPercentage\" style=\"{{lyteUiConcat('line-height:',ltPropHeight,'; font-size: ',if(ltPropFontSize,ltPropFontSize,'12px'),'; color: ',if(ltPropLabelColor,ltPropLabelColor,'#fff'),';')}}\"> {{lyteUiProgressbarLabel(ltPropLabel,percentageDisplay,ltPropPercentage)}} </span> </template></template> </span> </div> </template><template case=\"false\"> <div class=\"{{lyteUiConcat('lyteProgressBar',' lyteHorizontal',if(ltPropIndeterminate,' lyteIndeterminate',''))}} \" style=\"{{lyteUiConcat('width:',ltPropWidth,';height:',ltPropHeight)}}\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropAnimated,'!'),'&amp;&amp;',ltPropIndeterminate)}}\"><template case=\"true\"> <span class=\"inc\" style=\"{{lyteUiConcat('position: absolute; height: 100%; background: ',ltPropProgressFillColor)}}\"></span> <span class=\"dec\" style=\"{{lyteUiConcat('position: absolute; height: 100%; background: ',ltPropProgressFillColor)}}\"></span> </template><template case=\"false\"> <span class=\"lyteProgressStatus\" style=\"{{lyteUiConcat('width: ',percentage,'% ;','transition: ','width ',duration,' ',timingfn,';','background:',ltPropBackground)}}\"> <template is=\"if\" value=\"{{ltPropAnimated}}\"><template case=\"true\"> <span class=\"ltPropProgressAnimated progressMovingObj\"></span> </template></template> <template is=\"if\" value=\"{{expHandlers(expHandlers(ltPropIndeterminate,'!'),'&amp;&amp;',ltPropShowPercentage)}}\"><template case=\"true\"> <span case=\"true\" class=\"lyteProgressPercentage\" style=\"{{lyteUiConcat('line-height:',ltPropHeight,'; font-size: ',if(ltPropFontSize,ltPropFontSize,'12px'),'; color: ',if(ltPropLabelColor,ltPropLabelColor,'#fff'),';')}}\"> {{lyteUiProgressbarLabel(ltPropLabel,percentageDisplay,ltPropPercentage)}} </span> </template></template> </span> </template></template> </div> </template></template></template></template></template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'",{"type":"helper","value":{"name":"lyteUiSetWH","args":["ltPropRadius"]}},"'px; height:'",{"type":"helper","value":{"name":"lyteUiSetWH","args":["ltPropRadius"]}},"'px;'"]}}}},{"type":"attr","position":[1,1,1]},{"type":"attr","position":[1,1,1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'transition:'","'stroke-dashoffset '","duration","' '","timingfn","';'"]}}}},{"type":"attr","position":[1,1,1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'transition:'","'stroke-dashoffset '","duration","' '","timingfn","';'"]}}}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'transform:'",{"type":"helper","value":{"name":"lyteUiTextTransform","args":["ltPropRadius"]}}]}}}},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","';height:'","ltPropHeight"]}}}},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width: '","'0% ;'","'transition: '","'width '","duration","' '","timingfn","';'","'background:'",{"type":"helper","value":{"name":"lyteUiGetStackValue","args":["ltPropStack","index","'color'"]}},"';'"]}}}},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'line-height:'","ltPropHeight","'; font-size: '",{"type":"helper","value":{"name":"if","args":["ltPropFontSize","ltPropFontSize","'12px'"]}},"'; color: '",{"type":"helper","value":{"name":"if","args":[{"type":"helper","value":{"name":"lyteUiGetStackValue","args":["ltPropStack","index","'labelColor'"]}},{"type":"helper","value":{"name":"lyteUiGetStackValue","args":["ltPropStack","index","'labelColor'"]}},"'#fff'"]}},"';'"]}}}},{"type":"text","position":[1,1]}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","';height:'","ltPropHeight"]}}}},{"type":"attr","position":[1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'height: '","percentage","'% ;'","'transition:'","'height '","duration","' '","timingfn","';'","'background: '","ltPropBackground","';'","'display: block'"]}}}},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'line-height:'","ltPropHeight","'; font-size: '",{"type":"helper","value":{"name":"if","args":["ltPropFontSize","ltPropFontSize","'12px'"]}},"'; color: '",{"type":"helper","value":{"name":"if","args":["ltPropLabelColor","ltPropLabelColor","'#fff'"]}},"';'"]}}}},{"type":"text","position":[1,1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","';height:'","ltPropHeight"]}}}},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'position: absolute; height: 100%; background: '","ltPropProgressFillColor"]}}}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'position: absolute; height: 100%; background: '","ltPropProgressFillColor"]}}}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width: '","percentage","'% ;'","'transition: '","'width '","duration","' '","timingfn","';'","'background:'","ltPropBackground"]}}}},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'line-height:'","ltPropHeight","'; font-size: '",{"type":"helper","value":{"name":"if","args":["ltPropFontSize","ltPropFontSize","'12px'"]}},"'; color: '",{"type":"helper","value":{"name":"if","args":["ltPropLabelColor","ltPropLabelColor","'#fff'"]}},"';'"]}}}},{"type":"text","position":[1,1]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropProgressFillColor","ltPropCompletedFillColor","ltPropWidth","ltPropHeight","ltPropRadius","ltPropStroke","ltPropValueCopy","ltPropAnimated","ltPropShowPercentage","ltPropProgressProperty","ltPropLabel","ltPropFontSize","ltPropLabelColor","ltPropIndeterminate","ltPropStack","ltPropDirection","ltPropPercentage","percentage","duration","timingfn","percentageDisplay","checkIndeterminate","chunks","prevValues"],
	init: function () {
		if (!(this.getData('ltPropWidth'))) {
			this.setData('ltPropWidth', this.getData('ltPropType') == "vertical" ? '20px' : '100%');
		}
		if (!(this.getData('ltPropHeight'))) {
			this.setData('ltPropHeight', this.getData('ltPropType') == "vertical" ? '200px' : '12px');
		}
	},
	didConnect: function () {
		// this.setData('ltPropValueCopy',this.getData('ltPropValue'));
		if (this.getData('ltPropIndeterminate')) {
			this.setData('checkIndeterminate', this.getData('checkIndeterminate') + 1);
		}
		else {
			if (this.getData('ltPropType') == "stacked") {
				this.stackId = [];
			}
			$L.fastdom.mutate(this.setBackground.bind(this));
		}
	},
	setChunks: function () {
		if (this.getData('ltPropType') != "stacked") {
			return;
		}
		var chunks = this.getData('chunks');
		var prop = this.getData('ltPropStack');
		var prevValues = this.getData('prevValues');
		if (chunks.length != prop.length) {
			chunks = [];
			for (var i = 0; i < prop.length; i++) {
				chunks.push(i);
			}
			this.setData('chunks', chunks);
			if (prevValues.length == 0) {
				for (var i = 0; i < prop.length; i++) {
					prevValues.push(0);
				}
			}
			else if (prevValues.length > prop.length) {
				prevValues.splice(prop.length);
			}
			else if (prevValues < prop.length) {
				for (var i = prevValues.length; i < prop.length; i++) {
					prevValues.push(0);
				}
			}
			this.setData('prevValues', prevValues);
		}
	}.observes('ltPropStack.[]').on('init'),
	data: function () {
		return {
			// ltPropValue : Lyte.attr("string",{"default":'0'}),

			/**
						 * @componentProperty {string} ltPropType
						 * @version 1.0.0
						 * @default bar
						 * @options bar,circle,stacked,vertical
						 */
			ltPropType: Lyte.attr("string", { "default": 'bar' }),	//circle,vertical,stacked,bar

			/**
						 * @componentProperty {colorString} ltPropProgressFillColor
						 * @version 1.0.0
						 * @default #42a2eb
						 */
			ltPropProgressFillColor: Lyte.attr("string", { "default": '#42a2eb' }),

			/**
						 * @componentProperty {colorString} ltPropCompletedFillColor
						 * @version 1.0.0
						 * @default #3fbd5f
						 */
			ltPropCompletedFillColor: Lyte.attr("string", { "default": '#3fbd5f' }),

			/**
						 * @componentProperty {string} ltPropWidth
						 * @version 1.0.0
						 * @default 100%
						 * @suffix px,pt,cm,mm,vh,vm,em,%
						 */
			ltPropWidth: Lyte.attr("string"/*,{"default":'100%'}*/),

			/**
						 * @componentProperty {string} ltPropHeight
						 * @version 1.0.0
						 * @default 12px
						 * @suffix px,pt,cm,mm,vh,vm,em
						 */
			ltPropHeight: Lyte.attr("string"/*,{"default":'12px'}*/),

			/**
						 * @componentProperty {string} ltPropRadius
						 * @version 1.0.0
						 * @default 50
						 */
			ltPropRadius: Lyte.attr("string", { "default": '50' }),

			/**
						 * @componentProperty {string} ltPropStroke
						 * @version 1.0.0
						 * @default 5
						 */
			ltPropStroke: Lyte.attr("string", { "default": '5' }),

			/**
						 * @experimental ltPropValueCopy
						 */
			ltPropValueCopy: Lyte.attr("string", { "default": '0' }),

			/**
						 * @componentProperty {boolean} ltPropAnimated
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			ltPropAnimated: Lyte.attr("boolean", { "default": true }),

			/**
						 * @componentProperty {boolean} ltPropShowPercentage
						 * @version 1.0.0
						 * @default true
						 * 
						 */
			ltPropShowPercentage: Lyte.attr("boolean", { "default": true }),
			/**
			 * @typedef {object} progressProperty
			 * @property {string} value
			 * @property {string} duration
			 */
			/**
						 * @componentProperty {object} ltPropProgressProperty
						 * @version 1.0.0
						 * @default {"value":"0","duration" : "0s"}
						 */
			ltPropProgressProperty: Lyte.attr('object', { "default": { "value": "0", "duration": "0s" } }),

			/**
						 * @componentProperty {string} ltPropLabel
						 * @version 1.0.0
						 */
			ltPropLabel: Lyte.attr("string"),

			/**
						 * @componentProperty {string} ltPropFontSize
						 * @version 2.2.8
						 */
			ltPropFontSize: Lyte.attr("string"),

			/**
						 * @componentProperty {colorString} ltPropLabelColor
						 * @version 3.1.0
						 */
			ltPropLabelColor: Lyte.attr("string"),

			/**
						 * @experimental ltPropIndeterminate
						 */
			ltPropIndeterminate: Lyte.attr("boolean", { "default": false }),

			/**
						 * @componentProperty {array} ltPropStack
						 * @version 3.1.0
						 */
			ltPropStack: Lyte.attr("array", { "default": [] }),

			/**
						 * @componentProperty {up|down} ltPropDirection
						 * @version 3.1.0
						 * @default up
						 */
			ltPropDirection: Lyte.attr("string", { "default": "up" }),		//up,down

			/**
						 * @componentProperty {boolean} ltPropPercentage
						 * @version 3.1.0
						 * @default true
						 * 
						 */
			ltPropPercentage: Lyte.attr("boolean", { "default": true }),
			percentage: Lyte.attr('string', { "default": '0' }),
			duration: Lyte.attr('string', { "default": '2s' }),
			timingfn: Lyte.attr('string', { "default": 'linear' }),
			percentageDisplay: Lyte.attr('string', { "default": '0' }),
			checkIndeterminate: Lyte.attr("number", { "default": 0 }),
			chunks: Lyte.attr("array", { "default": [] }),
			prevValues: Lyte.attr("array", { "default": [] })
		}
	},
	didDestroy: function () {
		if (this.sid) {
			window.clearTimeout(this.sid);
			this.sid = false;
		}
		if (this.iId) {
			window.clearInterval(this.iId);
			this.iId = false;
		}
		if (this.stackId) {
			this.stackId.forEach(function (item, index) {
				if (item) {
					window.clearTimeout(this.sid);
					item = false;
				}
			});
		}
	},
	observeIndeterminate: function () {
		if (this.getData('ltPropType') == "bar") {
			if (this.getData('ltPropIndeterminate') && this.getData('ltPropAnimated')) {
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				this.setData('duration', '0s');
				this.setData('percentage', '100');
			}
		}
	}.observes('ltPropIndeterminate', 'checkIndeterminate'),
	percentageChange: function (obj) {
		if (this.getData('ltPropIndeterminate')) {
			return;
		}
		this.setBackground();
	}.observes('ltPropProgressProperty', 'ltPropStack.[]', 'ltPropProgressProperty.value'),
	setBackground: function () {
		// this.setData('ltPropValue',Math.round(this.getData('ltPropValue')));
		// this.setData('ltPropValueCopy',this.getData('ltPropValue'));
		var value = parseFloat(this.getData('ltPropProgressProperty').value);
		var duration = this.getData('ltPropProgressProperty').duration ? this.getData('ltPropProgressProperty').duration : this.getData('duration');
		if (this.getData('ltPropProgressProperty').timingfn) {
			this.setData('timingfn', this.getData('ltPropProgressProperty').timingfn);
		}
		if (this.getData('ltPropType') === 'circle') {
			if (parseInt(value) >= 100) {
				this.setData('duration', duration);
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				this.setData('percentage', '100');
				duration = parseFloat(duration) * 1000;
				var self = this;
				if (this.sid) {
					window.clearTimeout(this.sid);
					this.sid = false;
				}
				this.sid = setTimeout(function () {
					self.sid = false;
					if (!self.node) {
						clearTimeout(self.sid);
						return;
					}
					self.$node.querySelector('.lyteProgressBar').classList.add('lyteProgressCompleted');
					self.setData('ltPropBackground', self.getData('ltPropCompletedFillColor'));
				}, duration);
			}
			else {
				if (this.sid) {
					clearTimeout(this.sid);
					this.sid = false;
				}
				this.$node.querySelector('.lyteProgressBar').classList.remove('lyteProgressCompleted');
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				this.setData('duration', duration);
				this.setData('percentage', value + "");
			}
		}
		else if (this.getData('ltPropType') === 'stacked') {
			// this.setChunks();
			var stacks = this.getData('ltPropStack');
			var bars = this.$node.querySelectorAll('.lyteProgressStatusStack');
			var prevValues = this.getData('prevValues');
			var left = 0;
			this.setData('duration', duration);
			for (var i = 0; i < stacks.length; i++) {
				value = parseFloat(stacks[i].value);
				bars[i].style.width = value + "%";
				if (stacks[i].animated) {
					var animatedSpan = bars[i].querySelector('.ltPropProgressAnimated');
					animatedSpan.classList.add('progressMovingObj');
					animatedSpan.style.transition = 'left ' + duration + ' linear, width ' + duration + ' linear';
					animatedSpan.style.left = left + '%';
					animatedSpan.style.width = value + '%';
				}
				left += value;
				// debugger
				if (stacks[i].label) {
					bars[i].querySelector('.lyteProgressPercentageStack').innerHTML = stacks[i].label;
				}
				else {
					dur = parseFloat(stacks[i].duration || duration);
					if (this.stackId[i]) {
						clearInterval(this.stackId[i]);
						this.stackId[i] = false;
					}
					var p = prevValues[i] || 0,
						self = this,
						curr = { ind: i, value: value, ele: bars[i].querySelector('.lyteProgressPercentageStack'), p: p, stack: stacks[i] };
					if (dur == 0) {
						prevValues[i] = value;
						if (this.getData('ltPropShowPercentage')) {
							curr.ele.textContent = value + (this.getData('ltPropPercentage') ? "%" : "");
						}
					}
					else if (p > value) {
						var diff = p - value;
						curr.margin = ((diff / (dur * 1000)) * 100);
						this.stackId[i] = setInterval(this.changePercentageDisplay, 100, "dec", curr, this);
					}
					else if (p < value) {
						var diff = value - p;
						curr.margin = ((diff / (dur * 1000)) * 100);
						this.stackId[i] = setInterval(this.changePercentageDisplay, 100, "inc", curr, this);
					}
				}
			}
			return;
		}
		else if (this.getData('ltPropType') === 'vertical') {
			if (parseInt(value) >= 100) {
				this.setData('duration', duration);
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				this.setData('percentage', '100');
				// this.$node.querySelector('.lyteProgressStatus').style.width = "100%";
				duration = parseFloat(duration) * 1000;
				var self = this;
				if (this.sid) {
					window.clearTimeout(this.sid);
					this.sid = false;
				}
				this.sid = setTimeout(function () {
					self.sid = false;
					self.$node.querySelector('.lyteProgressBar').classList.add('lyteProgressCompleted');
					self.setData('ltPropBackground', self.getData('ltPropCompletedFillColor'));
					// if(self.getData('ltPropAnimated')){
					// 	self.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.remove('progressMovingObj');	
					// }
				}, duration);
			}
			else {
				if (this.sid) {
					clearTimeout(this.sid);
					this.sid = false;
				}
				this.$node.querySelector('.lyteProgressBar').classList.remove('lyteProgressCompleted');
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				// if(this.getData('ltPropAnimated')){
				// 	this.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.add('progressMovingObj');	
				// }
				// debugger
				this.setData('duration', duration);
				this.setData('percentage', value + "");

				// this.$node.querySelector('.lyteProgressStatus').style.width = value + "%";
			}
		}
		else {
			if (parseInt(value) >= 100) {
				this.setData('duration', duration);
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				this.setData('percentage', '100');
				// this.$node.querySelector('.lyteProgressStatus').style.width = "100%";
				duration = parseFloat(duration) * 1000;
				var self = this;
				if (this.sid) {
					window.clearTimeout(this.sid);
					this.sid = false;
				}
				this.sid = setTimeout(function () {
					self.sid = false;
					self.$node.querySelector('.lyteProgressBar').classList.add('lyteProgressCompleted');
					self.setData('ltPropBackground', self.getData('ltPropCompletedFillColor'));
					if (self.getData('ltPropAnimated')) {
						self.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.remove('progressMovingObj');
					}
				}, duration);
			}
			else {
				if (this.sid) {
					clearTimeout(this.sid);
					this.sid = false;
				}
				this.$node.querySelector('.lyteProgressBar').classList.remove('lyteProgressCompleted');
				this.setData('ltPropBackground', this.getData('ltPropProgressFillColor'));
				if (this.getData('ltPropAnimated')) {
					this.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.add('progressMovingObj');
				}
				// debugger
				this.setData('duration', duration);
				this.setData('percentage', value + "");

				// this.$node.querySelector('.lyteProgressStatus').style.width = value + "%";
			}
		}
		if (this.iId) {
			clearInterval(this.iId);
			this.iId = false;
		}
		var p = parseFloat(this.getData('percentageDisplay')),
			self = this;
		if (parseInt(this.getData('duration')) == 0) {
			this.setData('percentageDisplay', value + "");
		}
		else if (p > value) {
			var diff = p - value;
			var margin = ((diff / (parseInt(this.getData('duration')) * 1000)) * 100);
			this.iId = setInterval(function () {
				p -= margin;
				if (!self.$node) {
					clearInterval(self.iId);
					self.iId = false;
					return;
				}
				self.setData('percentageDisplay', Math.max(parseFloat(p.toFixed(2)), value) + "");
				if (parseFloat(p) == value) {
					clearInterval(self.iId);
					self.iId = false;
				}
			}, 100)
		}
		else if (p < value) {
			var diff = value - p;
			var margin = ((diff / (parseInt(this.getData('duration')) * 1000)) * 100);
			this.iId = setInterval(function () {
				p += margin;
				if (!self.$node) {
					clearInterval(self.iId);
					self.iId = false;
					return;
				}
				self.setData('percentageDisplay', Math.min(parseFloat(p.toFixed(2)), value) + "");
				if (parseFloat(p) >= value) {
					clearInterval(self.iId);
					self.iId = false;
				}
			}, 100)
		}

	},
	changePercentageDisplay: function (cond, chunk, comp) {
		if (cond == "inc") {
			chunk.p += chunk.margin;
		}
		else {
			chunk.p -= chunk.margin
		}
		if (!comp.$node) {
			clearInterval(comp.stackId[chunk.ind]);
			comp.stackId[chunk.ind] = false;
			return;
		}
		var pd = cond == "inc" ? Math.min(parseFloat(chunk.p.toFixed(2)), chunk.value) : Math.max(parseFloat(chunk.p.toFixed(2)), chunk.value);
		if (comp.getData('ltPropShowPercentage')) {
			chunk.ele.textContent = pd + (comp.getData('ltPropPercentage') ? "%" : "");
		}
		if ((cond == "inc" && parseFloat(pd) >= chunk.value) || (cond == "dec" && parseFloat(pd) == chunk.value)) {
			clearInterval(comp.stackId[chunk.ind]);
			Lyte.arrayUtils(comp.getData('prevValues'), 'replaceAt', chunk.ind, chunk.value);
			comp.stackId[chunk.ind] = false;
		}
	},
	setCircleStroke: function (circle, val) {
		var per = circle.getAttribute('stroke-dasharray') * (1 - parseInt(val) / 100);
		circle.setAttribute('stroke-dashoffset', per);
	},
	actions: {

	}
});

/**
 * @syntax nonYielded 
 * @attribute ltPropType=circle
 * <lyte-progressbar lt-prop = '{"type":"circle","progressProperty" : {"value" : "20", "duration" : "2s"}}'>
 * </lyte-progressbar>
 */

/**
* @syntax nonYielded 
* @attribute ltPropType=bar
* <lyte-progressbar lt-prop = '{"progressProperty" : {"value": "25.89", "duration" : "2s"}}'>
* </lyte-progressbar>
*/
/**
 * Renders a radiobutton
 * @component lyte-radiobutton
 * @version 1.0.0
 * @utility focus,blur,click
 * @methods onBeforeChecked,onBeforeUnchecked,onChecked,onUnchecked,onChanged
 */

Lyte.Component.register( 'lyte-radiobutton', {
_template:"<template tag-name=\"lyte-radiobutton\"> <template is=\"switch\" value=\"{{ltPropType}}\"><template case=\"default\"></template><template case=\"primary\"></template><template case=\"secondary\"> <label class=\"{{radioclass}}\" onmouseup=\"{{action('mup',event)}}\"> <input onkeypress=\"{{action('preventPropagation',event)}}\" type=\"radio\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" class=\"lyteHide\" onclick=\"{{action('valueChanged',event)}}\" disabled=\"{{ltPropDisabled}}\" checked=\"{{ltPropChecked}}\"> <span class=\"{{ltPropClass}}\"> <span class=\"lyteRadioCheck\"> </span> </span> <span class=\"{{ltPropLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </label> </template><template case=\"switch\"> <label class=\"\" onmouseup=\"{{action('mup',event)}}\"> <input onkeypress=\"{{action('preventPropagation',event)}}\" type=\"radio\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide on-off-sw\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('valueChanged',event)}}\"> <span class=\"{{ltPropClass}}\"> <span class=\"on-btn\"></span> </span> <span class=\"{{ltPropLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </label> </template><template case=\"slider\"> <label class=\"lyteRadioSliderLabel\" onmouseup=\"{{action('mup',event)}}\"> <input onkeypress=\"{{action('preventPropagation',event)}}\" type=\"radio\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('valueChanged',event)}}\"> <span class=\"{{ltPropClass}}\"> <span class=\"{{ltPropLabelClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> {{ltPropLabel}} </template></template> </span> </span> </label> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"default":{"dynamicNodes":[],"additional":{"next":"primary"}},"primary":{"dynamicNodes":[],"additional":{"next":"secondary"}},"secondary":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"attr","position":[1,5,1]},{"type":"if","position":[1,5,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]},"switch":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"attr","position":[1,5,1]},{"type":"if","position":[1,5,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]},"slider":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"attr","position":[1,3,1,1]},{"type":"if","position":[1,3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropName","ltPropDisabled","ltPropChecked","ltPropLabel","ltPropValue","ltPropFireOnInit","ltPropLabelClass","ltPropClass","ltPropYield","ltPropAriaRadio","ltPropFocus","lyteUnbound"],
	data: function() {
		return {

			/**
			 * @componentProperty {default|primary|secondary|switch|slider} ltPropType
			 * @default default
			 */

			'ltPropType': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton', 'type', 'default' )
			} ),

			/**
			 * @componentProperty {string} ltPropName
			 */

			'ltPropName': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {boolean} ltPropDisabled
			 * @default false
			 * 
			 */

			'ltPropDisabled': Lyte.attr( 'boolean', { 
				'default': false
			} ),

			/**
			 * @componentProperty {boolean} ltPropChecked
			 * @default false
			 * 
			 */

			'ltPropChecked': Lyte.attr( 'boolean', { 
				'default': false
			} ),

			/**
			 * @componentProperty {string} ltPropLabel
			 */


			'ltPropLabel': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {string} ltPropValue
			 */
			'ltPropValue': Lyte.attr( 'string', { 
				'default': undefined
			} ),

			/**
			 * @componentProperty {boolean} ltPropFireOnInit
			 * @default false
			 * 
			 */

			'ltPropFireOnInit': Lyte.attr( 'boolean', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton', 'fireOnInit', false )
			} ),

			/**
			 * @componentProperty {string} ltPropLabelClass
			 */
			'ltPropLabelClass': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton', 'labelClass', '' ) 
			} ),

			/**
			 * @componentProperty {string} ltPropClass
			 */

			'ltPropClass': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton', 'class', '' )
			} ),

			/**
			 * @componentProperty {boolean} ltPropYield
			 * @version 2.2.8
			 * @default false
			 * 
			 */

			'ltPropYield': Lyte.attr( 'boolean', {
				'default': false
			} ), 
			'ltPropAriaRadio': Lyte.attr( 'object', {
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton', 'ariaRadio', {} )
			} ),
			'ltPropFocus': Lyte.attr( 'boolean', {
				'default': false
			} ),

			'lyteUnbound': Lyte.attr( 'boolean', {
				'default': false
			} )
		}
	},

	ariaObserver: function( change ) {
		var oldAria = change.oldValue,
		newAria = change.newValue;

		this.addAriaValues( oldAria, newAria );
	}.observes( 'ltPropAriaRadio' ),

	didDestroy: function() {
		delete this.$node.focus;
		delete this.$node.blur;
		delete this.$node.click;
	},

	changeStyle: function() {
		this.changeStyleFunction()
	}.observes( 'ltPropType' ),

	changeStyleFunction: function() {

		var type = this.getData( 'ltPropType' ), 
		checked = this.getData('ltPropChecked'),
		cls = this.getData( 'ltPropClass' ), 
		labelCls = this.getData( 'ltPropLabelClass' );

		if( 
			type.indexOf( 'slider' ) === -1 
			&& type.indexOf( 'switch' ) === -1 
			&& type.indexOf( 'default' ) === -1 
			&& type.indexOf( 'primary' ) === -1 
			&& type.indexOf( 'secondary' ) === -1 
		) {
			this.setData( 'ltPropType', 'default' );
		}

		if( type.indexOf( 'default' ) !== -1 ) {
			this.setData( 'radioclass', 'lyteRadioBtn lyteDefault' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' ) 
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'primary' ) !== -1 ) {
			this.setData( 'radioclass', 'lyteRadioBtn lytePrimary' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' )
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'secondary' ) !== -1 ) {
			this.setData( 'radioclass', 'lyteRadioBtn lyteSecondary' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' )
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'switch' ) !== -1 ) {
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioSwitch' )	
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )	
		}
		else if( type.indexOf('slider') !== -1 ) {
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioSlider' )	
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioSliderText' )	
		}
	},

	reduceOpacity: function() {
		if( this.getData( 'ltPropDisabled' ) ) {
			this.$node.classList.add( 'lyteRadioDisabled' );
		}
		else {
			this.$node.classList.remove( 'lyteRadioDisabled' );
		}
	},

	disabledChange: function() {
		this.reduceOpacity();
	}.observes( 'ltPropDisabled' ),

	init: function() {
		this.changeStyleFunction();
	},

	didConnect: function() {
		var that = this, newAria = this.getData( 'ltPropAriaRadio' );

		this.reduceOpacity();

		this.$node.click = function() {
			var ev = new Event( 'click', {
				bubbles: true,
				cancelable: true
			} ),
			node = that.$node,
			checked = node.ltProp( 'checked' ),
			disabled = node.ltProp( 'disabled' );

			if( disabled ) {
				return ;
			}

			node.component.clickFn = true;

			if( !checked ) {
				if( node._fR ) {
					// Just calling resetValues here to make things less complicated
					node.component.resetValues();
					node.component.checkFR( node );
				}
				else {
					node.ltProp( 'checked', true );
				}
			}

			node.component.clickFn = false;

			node.dispatchEvent( ev );
		}

		this.$node.focus = function() {
			var node = that.$node,
			input = node.querySelector( 'input' ),
			disabled = node.ltProp( 'disabled' );

			if( disabled ) {
				return ;
			}

			input.focus();
		}

		this.$node.blur = function() {
			var node = that.$node,
			input = node.querySelector( 'input' ),
			disabled = node.ltProp( 'disabled' );

			if( disabled ) {
				return ;
			}

			input.blur();
		}

		this.callMethodsOnInit( true );
		this.addAriaValues( {}, newAria );
	},

	addAriaValues: function( oldAria, newAria ) {
		var radio = this.getRadioWidget();

		_lyteUiUtils.setAttribute( radio, newAria, oldAria );
	},

	getRadioWidget: function() {
		return this.$node.querySelector( 'input' );
	},

	check: function( inp, comp ) {
		if( this.getMethods( 'onChecked' ) ) {
			this.executeMethod( 'onChecked', inp, comp, this.eventType() );
		}
	},

	uncheck: function( inp, comp ) {
		if( this.getMethods( 'onUnchecked' ) ) {
			this.executeMethod( 'onUnchecked', inp, comp, this.eventType() );
		}
	},

	beforeCheck: function( inp, comp ) {
		if( this.getMethods( 'onBeforeChecked' ) ) {
			return this.executeMethod( 'onBeforeChecked', inp, comp, this.eventType() );
		}
	},

	beforeUncheck: function( inp, comp ) {
		if( this.getMethods( 'onBeforeUnchecked' ) ) {
			return this.executeMethod( 'onBeforeUnchecked', inp, comp, this.eventType() );
		}
	},

	onchanged: function( inp, comp ) {
		if( this.getMethods( 'onChanged' ) ) {
			this.executeMethod( 'onChanged', inp, comp, this.eventType() );
		}
	},

	checkCurrentRadio: function() {
		this.eveType = 'key';
		this.setData( 'ltPropChecked', true );
		this.eveType = '';
	},

	checkNextRadio: function() {
		var radios = this.extractAllRadios(),
		nextRadioIndex = this.getCheckableRadio( radios, 1 );

		if( nextRadioIndex !== -1 ) {
			radios[ nextRadioIndex ].component.eveType = 'key';
			radios[ nextRadioIndex ].ltProp( 'checked', true );
			radios[ nextRadioIndex ].component.eveType = '';
		}
	},

	checkPreviousRadio: function() {
		var radios = this.extractAllRadios(),
		previousRadioIndex = this.getCheckableRadio( radios, -1 );

		if( previousRadioIndex !== -1 ) {
			radios[ previousRadioIndex ].component.eveType = 'key';
			radios[ previousRadioIndex ].ltProp( 'checked', true );
			radios[ previousRadioIndex ].component.eveType = '';
		}
	},

	getCheckableRadio: function( radios, indexChange ) {
		var currentRadioIndex = this.getIndex( radios ),
		totalRadios = radios.length,
		index = currentRadioIndex;

		for( var i = 0; i < totalRadios; i++ ) {
			index = index + indexChange;

			if( index < 0 ) {
				index = totalRadios - 1;
			}
			else if( index === totalRadios ) {
				index = 0;
			}

			if( !radios[ index ].ltProp( 'disabled' ) || index === currentRadioIndex ) {
				return index;
			}
		}

		return -1;
	},

	extractAllRadios: function() {
		var name = this.getData( 'ltPropName' ), i = 0, radio,
		inp = document.querySelectorAll( 'input[type="radio"][name="' + name + '"]' ),
		result = [];

		for( ; i < inp.length; i++ ) {
			radio = inp[ i ];

			while( radio.tagName !== 'LYTE-RADIOBUTTON' 
					&& radio.tagName !== 'HTML' 
			) {
				radio = radio.parentElement;
			}

			if( radio.tagName === 'LYTE-RADIOBUTTON' ) {
				result.push( radio );
			}
		}

		return result;
	},

	getIndex: function( result ) {
		return result.indexOf( this.$node );
	},

	extractRadios: function() {
		var name = this.getData( 'ltPropName' ), i = 0, tag,
		inp = document.querySelectorAll( 'input[type="radio"][name="' + name + '"]' );

		for( ; i < inp.length; i++ ) {
			tag = inp[ i ];

			while( tag.tagName !== 'LYTE-RADIOBUTTON' 
					&& tag.tagName !== 'HTML' 
			) {
				tag = tag.parentElement;
			}

			if( tag.tagName === 'LYTE-RADIOBUTTON'
				&& tag.ltProp( 'checked' ) 
				&& tag != this.$node
			) {
				return tag;
			}
		}
	},

	changeChecks: function( change ) {
		var radio = this.extractRadios(), 
		inp = radio && radio.querySelector( 'input' ),
		comp = radio && radio.component,
		cur = this.$node.querySelector( 'input' ),
		ret_uncheck, ret_check;

		// A checked radiobutton is checked
		// This check probably never executes because 
		// observers never fire when oldValue and newValue are the same. Its just a safety check
		if( change.newValue && change.oldValue ) {
			return ;
		}

		// A radiobutton that is different from the currently checked radiobutton is checked
		else if( change.newValue ) {
			this.setData( 'prevent', true );
			this.setData( 'ltPropChecked', false );

			// Unchecking the previously checked radiobutton and calling before uncheck callbacks
			if( radio ) {
				ret_uncheck = this.beforeUncheck( cur, this );
			}

			if( ret_uncheck === false ) {
				this.revertState( radio, this.$node );

				return ;	
			}

			ret_check = this.beforeCheck( cur, this );

			if( ret_check === false ) {
				this.revertState( radio, this.$node );

				return ;
			}

			// calling the uncheck callback of the previously checked radiobutton 
			if( radio ) {
				comp.setData( 'prevent', true );
                radio.ltProp( 'checked', false );
                comp.setData( 'prevent', false );
				this.uncheck( cur, this );
			}

			this.setData( 'ltPropChecked', true );
			this.setData( 'prevent', false );

			this.check( cur, this );
			this.onchanged( cur, this );
		}

		// A radiobutton is unchecked but it was not previously unchecked
		else if( !change.newValue && change.oldValue ) {
			this.setData( 'prevent', true );
			this.setData( 'ltPropChecked', true );

			ret_uncheck = this.beforeUncheck( cur, this );
			
			if( ret_uncheck === false ) {
				this.revertState( this.$node, {} );

				return ;
			}

			this.setData( 'ltPropChecked', false );
			this.uncheck( cur, this );
			this.onchanged( cur, this );
			this.setData( 'prevent', false );
		}
 
	},

	change: function( change ) {

		var name = this.getData( 'ltPropName' ),
		input = document.querySelector( 'input[type="radio"][name="' + name + '"]:checked' );

		if( !this.getData( 'onChange' ) ) {
			this.changeChecks( change );
		}
		else {
			if( !change.newValue ) {
				this.uncheck( input, this.getData( 'second' ) );
			}
			else {
				this.check( input, this );
			}
		}	
	},

	resetValues: function() {
		var name = this.getData( 'ltPropName' ),
		radios = document.querySelectorAll( 'input[type="radio"][name="' + name + '"]' ),
		i = 0, len = radios.length, comp;

		for( ; i < len; i++ ) {
			comp = radios[ i ].parentElement.parentElement.component;
			comp.setData( 'prev', undefined );
			comp.setData( 'node', undefined )
		}

	},

	valueChanged: function( change ) {
		this.fireCallbacks( change );	
	}.observes( 'ltPropChecked' ),

	fireCallbacks: function( change ) {
		var prev = change.oldValue,
		cur = change.newValue;

		if( prev && !cur ) {
			this.resetValues();
		}

		if( this.getData( 'prevent' ) ) {
			return ;
		}

		if( cur ) {
			this.$node.focus();
		}

		this.change( change );
	},

	focusRadioButton: function() {
		var shouldFocus = this.getData( 'ltPropFocus' );

		if( shouldFocus ) {
			this.$node.focus();
		}

		this.data.ltPropFocus = false;
	}.observes( 'ltPropFocus' ).on( 'didConnect' ),

	// Returns undefined when node is undefined
	
	getParentRadio: function( node ) {
		while( node 
			&& node.tagName !== 'LYTE-RADIOBUTTON' ) {
			node = node.parentElement;
		}

		return node;
	},

	revertState: function( uncheckedRadio, checkedRadio ) {
		var uncheckedRadioComp = ( uncheckedRadio || {} ).component,
		checkedRadioComp = ( checkedRadio || {} ).component;

		if( uncheckedRadioComp ) {
			uncheckedRadioComp.setData( 'prevent', true );
			uncheckedRadioComp.setData( 'ltPropChecked', true );
			uncheckedRadio.querySelector( 'input' ).checked = true;
			uncheckedRadioComp.setData( 'prevent', false );
		}

		if( checkedRadioComp ) {
			checkedRadioComp.setData( 'prevent', true );
			checkedRadioComp.setData( 'ltPropChecked', false );
			checkedRadio.querySelector( 'input' ).checked = false;
			checkedRadioComp.setData( 'prevent', false );
		}
		
	},

	callMethodsOnInit: function() {
		var foi = this.getData( 'ltPropFireOnInit' ), 
		checked = this.getData( 'ltPropChecked' );

		if(	!foi ) {
			return ;
		}

		if( checked ) {
			var element = this.$node.querySelector( 'input' ),
			value = element.getAttribute( 'value' );

			this.beforeCheck( element, this );
			this.check( element, this );
			this.onchanged( element, this );
		}
	},

	checkFR: function( node ) {

		node.component.setData( 'ltPropChecked', true );
		node.querySelector( 'input' ).checked = true;

		node.component.fireCallbacks( {
			oldValue: false,
			newValue: true
		} );
	},

	uncheckFR: function( node ) {

		node.component.setData( 'ltPropChecked', false );
		node.querySelector( 'input' ).checked = false;

		node.component.fireCallbacks( {
			oldValue: true,
			newValue: false
		} );
	},

	eventType: function() {
		var isClicked = this.clicked || this.clickFn,
		key = this.eveType;

		if( isClicked ) {
			return 'click';
		}

		return key ? key : 'script';
	},

	actions: {
		preventPropagation: function() {
			if( event.keyCode === 32 ) {
				this.preventClick = true;
			}
		},

		mup: function( event ) {
			var name = this.getData( 'ltPropName' ), 
			checkedNode = document.querySelector( 'input[type="radio"][name="' + name + '"]:checked' ), ret_check, ret_uncheck;

			this.setData( 'shouldCallUnChecked', false );
			if( checkedNode ) {
				this.setData( 'prev', checkedNode.getAttribute( 'value' ) );
				this.setData( 'node', checkedNode );
				this.setData( 'shouldCallUnChecked', true );
			} 

			var element = this.$node.querySelector( 'input' ), checked = element.checked;

			if( element.disabled ) {
				return ;
			}

			if( !checked ) {
				this.clicked = true;

				if( this.getData( 'shouldCallUnChecked' ) ) {
					ret_uncheck = this.beforeUncheck( element, this );

					if( ret_uncheck === false ) {
						this.setData( 'revertState', true );
						this.clicked = false;
						return ;
					}
				}

				ret_check = this.beforeCheck( element, this );

				if( ret_check === false ) {
					this.setData( 'revertState', true );
					this.clicked = false;
					return ;
				}
			}
		},

		valueChanged: function( event ) {
			var ele = event.target, 
			val = ele.getAttribute( 'value' ), 
			prev = this.getData( 'prev' ), 
			node = this.getData( 'node' ),
			revert = this.getData( 'revertState' ),
			uncheckedRadio = this.getParentRadio( node ),
			checkedRadio = this.$node,
			comp = node && node.parentElement.parentElement.component,
			parent = ele.parentElement.parentElement;

			event.stopPropagation();

			if( this.preventClick ) {
				this.preventClick = false;
				return ;
			}

			if( val === prev ) {
				return ;
			}

			if( revert ) {
				this.revertState( uncheckedRadio, checkedRadio );
				this.setData( 'node', undefined );

				// Just a safety
				this.clicked = false;

				return ;
			}

			if( node ) {
				while( node.tagName !== 'LYTE-RADIOBUTTON' ) {
					node = node.parentElement;
				}

				comp.setData( 'onChange', true );

				// We are using a variable called second so that we can pass the current radiobutton's this to the callback.
				// We won't get the current radiobutton's this in a different radiobutton's observer - we are setting ltPropChecked to false below.
				comp.setData( 'second', this );

				if( node._fR ) {
					this.uncheckFR( node );
				}
				else {
					node.ltProp( 'checked', false );
				}
				
				comp.setData( 'second', undefined );

				comp.setData( 'onChange', false );
			}

			node = this.getData( 'node' );
			if( node ) {
				this.setData( 'node', undefined );
			}

			this.setData( 'onChange', true );

			if( this.$node._fR ) {
				this.checkFR( this.$node );
			}
			else {
				this.setData( 'ltPropChecked', true );
			}
			
			this.setData( 'onChange', false );
			this.onchanged( ele, this );	
			this.clicked = false;
		}
	}
} );

document.addEventListener( 'keydown', function( event ) {
	var keyCode = event.keyCode, node, checked, comp;

	if( keyCode === 37 
		|| keyCode === 38 
		|| keyCode === 39 
		|| keyCode === 40
		|| keyCode === 32 
	) {

		node = document.activeElement;

		if( node.tagName !== 'INPUT' ) {
			return ;
		}

		while( node.tagName !== 'LYTE-RADIOBUTTON' 
			&& node.tagName !== 'HTML' 
		) {
			node = node.parentElement;
		}

		if( node.tagName === 'LYTE-RADIOBUTTON' ) {
			comp = node.component;
			event.preventDefault();

			switch( keyCode ) {
				case 37:
				case 38:
					comp.checkPreviousRadio();
					break;
				case 39:
				case 40:
					comp.checkNextRadio();
					break;
				case 32:
					comp.checkCurrentRadio();
					break;
			}
		}
	}
} );

/**
 * @syntax nonYielded
 * <lyte-radiobutton lt-prop-value="1" lt-prop-label="check me" lt-prop-name="group-1"></lyte-radiobutton>
 */

 /**
  * @syntax yielded
  * <lyte-radiobutton lt-prop-value="1" lt-prop-name="group-1" lt-prop-yield="true">
  *     <template is="registerYield" yield-name="yield">
  *         check me
  *     </template>
  * </lyte-radiobutton>
  */
 

/**
 * Renders a radiobutton group
 * @component lyte-radiobutton-group
 * @version 3.22.0
 * @methods onBeforeChecked,onBeforeUnchecked,onChecked,onUnchecked,onChanged
 */
Lyte.Component.register("lyte-radiobutton-group", {
_template:"<template tag-name=\"lyte-radiobutton-group\"> <div class=\"{{concat('lyteRadioBtnGroup',lyteUiCapitalizeName(ltPropAlignment))}}\"> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"index\"> <lyte-radiobutton lt-prop-label=\"{{item[ltPropUserValue]}}\" lt-prop-value=\"{{item[ltPropSystemValue]}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-fire-on-init=\"{{ltPropFireOnInit}}\" lt-prop-label-class=\"{{ltPropLabelClass}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-checked=\"{{unbound(if(ifEquals(item[ltPropSystemValue],ltPropSelected[ltPropSystemValue]),true))}}\" lt-prop-aria-radio=\"{{ltPropAriaAttributes[index]}}\" lt-prop-yield=\"{{ltPropYield}}\" on-before-unchecked=\"{{method('rdbBeforeUnchecked')}}\" on-unchecked=\"{{method('rdbUnchecked')}}\" on-changed=\"{{method('rdbChanged')}}\" on-before-checked=\"{{method('rdbBeforeChecked')}}\" on-checked=\"{{method('rdbChecked')}}\" index=\"{{concat('',index)}}\" data-value=\"{{item[ltPropSystemValue]}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-yield yield-name=\"yield\" lt-item=\"{{item}}\"></lyte-yield> </template> </template></template> </lyte-radiobutton> </template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}],
_observedAttributes :["ltPropType","ltPropName","ltPropAlignment","ltPropOptions","ltPropSelected","ltPropLabelClass","ltPropClass","ltPropFireOnInit","ltPropUserValue","ltPropSystemValue","ltPropDisabledList","ltPropFocus","ltPropAriaAttributes","ltPropYield","prevSelectedValue","preventFocusSet","selThroScript"],
	data : function(){
		return {
			/**
			 * @componentProperty {default|primary|secondary|switch|slider} ltPropType
			 * @default default
			 */
			ltPropType : Lyte.attr("string",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton-group', 'type', 'default' )
			}),
			/**
			 * @componentProperty {string} ltPropName
			 */
			ltPropName : Lyte.attr("string",{"default":undefined}),
			/** 
			 * @componentProperty {Horizontal | Vertical} ltPropAlignment=horizontal
			 */
			ltPropAlignment : Lyte.attr("string",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton-group', 'alignment', "horizontal" )
			}),
			/**
			 * @componentProperty {array} ltPropOptions
			 * @default []
			 */

			ltPropOptions : Lyte.attr("array",{"default":[]}),
			/** 
			 * @componentProperty {string} ltPropSelected=""
			 */
			ltPropSelected : Lyte.attr("object",{"default":{}}),
			/** 
			 * @componentProperty {string} ltPropLabelClass=""
			 */
			ltPropLabelClass : Lyte.attr("string",{
				"default":  _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton-group', 'labelClass', "" )
			}),
			/** 
			 * @componentProperty {string} ltPropClass=""
			 */
			ltPropClass: Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton-group', 'class', "" )
			}),
			/** 
			 * @componentProperty {boolean} ltPropFireOnInit=false
			 */
			ltPropFireOnInit : Lyte.attr("boolean",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-radiobutton-group', 'fireOnInit', false )
			}),
			/**
			 * @componentProperty {string} ltPropUserValue=name
			 */
			ltPropUserValue : Lyte.attr("string",{"default":"name"}),
			/**
			 * @componentProperty {string} ltPropSystemValue=value
			 */
			ltPropSystemValue : Lyte.attr("string",{"default":"value"}),
			/**
			 * @componentProperty {array} ltPropDisabledList
			 * @default []
			 */
			ltPropDisabledList : Lyte.attr("array",{"default":[]}),
			/** 
			 * @componentProperty {boolean} ltPropFocus=false
			 */
			ltPropFocus : Lyte.attr("boolean",{"default":false}),
			/** 
			 * @componentProperty {array} ltPropAriaAttributes
			 * @default []
			 */
			ltPropAriaAttributes : Lyte.attr("array",{"default":[]}),
			/** 
			 * @componentProperty {boolean} ltPropYield=false
			 */
			ltPropYield : Lyte.attr("boolean",{"default":false}),

			prevSelectedValue : Lyte.attr("object",{"default":{}}),//used to store previous selected value
			preventFocusSet : Lyte.attr("boolean",{"default":false}),
			selThroScript : Lyte.attr("boolean",{"default":false})
			//selThroScript is used to prevent the recursive while setting the ltPropSelected through script.
		}		
	},
	getAllRadiobuttons : function(){
		//return this.$node.querySelectorAll("lyte-radiobutton");
		return $L("lyte-radiobutton",this.$node);
	},
	makeRadiobuttonFocus : function(){//need to be tested
		var radiobuttons = this.getAllRadiobuttons();
		for(var iterator=0;iterator<radiobuttons.length;iterator++){
			var radiobutton = radiobuttons[iterator];
			if(!radiobutton.ltProp("disabled")){
				radiobutton.focus();
				break;
			}
		}
	},
	updateDisabledValue :  function(array,value){
		if(array){
			var comp = this;
			array.forEach(function(item){
				var radiobutton = comp.getRadiobutton(item);
				if(radiobutton){
					radiobutton.ltProp("disabled",value);
				}
			});
		}
	},
	radiobuttonStateChange : function(radiobutton,value){
		this.setData("selThroScript",true);
		radiobutton.ltProp("checked",value);
		this.setData("selThroScript",false);
	},
	didConnect : function(){
		this.updateDisabledValue(this.getData("ltPropDisabledList"),true);
	},
	isNotEmpty : function(object){
		var systemValue = this.getData("ltPropSystemValue");
		if(object && object[systemValue] !=  undefined){
			return true;
		}
		return false;
	},
	getRadiobutton : function(radioButtonvalue){
		var systemValue = this.getData("ltPropSystemValue");
		if(this.isNotEmpty(radioButtonvalue)){
			return $L('[data-value="'+radioButtonvalue[systemValue]+'"]',this.$node)[0];
		} 
	},
	selectedChanges : function(oldValue,newValue){
		var radiobutton =  this.getRadiobutton(newValue);
		this.setPreviousValue(oldValue);
		if(radiobutton){
			this.radiobuttonStateChange(radiobutton,true);
		}
		else if(!this.isNotEmpty(newValue)){
			var oldRadiobutton = this.getRadiobutton(oldValue);
			if(oldRadiobutton){
				this.radiobuttonStateChange(oldRadiobutton,false);
			}
			this.setPreviousValue(newValue);
			/* if the newValue is empty then we also making prevSelectedValue as empty 
			because if they again select radiobutton by click, there prevSelectedValue will be different.
			basically we are reseting the prevSelectedValue.
			*/
		}
	},
	selectedObserver : function(changes){
		if(this.getData("selThroScript")){
			return;
		}
		this.selectedChanges(changes.oldValue,changes.newValue);
	}.observes("ltPropSelected"),
	disabledValueObserver : function(changes){// need to be tested
		this.updateDisabledValue(changes.oldValue,false);
		this.updateDisabledValue(changes.newValue,true);
	}.observes('ltPropDisabledList'),
	focusObserver : function(){
		var focus = this.getData("ltPropFocus");
		if(focus){
			this.makeRadiobuttonFocus();
		}
		this.setData("ltPropFocus",false);
	}.observes("ltPropFocus").on('didConnect'),
	getPreviousValue : function(bypass){
		if(this.getData("selThroScript") || !bypass){
			/* Here if the selThroScript is true then the prevSelectedValue is setted 
			through selectedObserver so we can use current prevSelectedValue
			if bypass is true, the prevSelectedValue is not yet set and 
			considering the ltPropSelcted as previous value.
			In all cases,if the selThroScript is true then the value is setted and
			we can get the currentValues of prevSelectedValue and ltPropSelected respectively.
			*/
			return this.getData("prevSelectedValue");
		}
		return this.getSelectedValue();
	},
	setPreviousValue : function(value){
		if(value){
			this.setData("prevSelectedValue",value);
		}
		else if(!this.getData("selThroScript")){
			//Here if selThroScript is false, we setting current ltPropSelected as prevSelectedValue.
			//This will be done before updating the current selected value.
			this.setData("prevSelectedValue",this.getSelectedValue());
		}
	},
	getSelectedValue : function(radiobutton){
		if(this.getData("selThroScript") || !radiobutton){
			return this.getData("ltPropSelected");
		}
		return this.getCurrentSelectedValue(radiobutton);
	},
	setSelectedValue : function(radiobutton){
		if(!this.getData("selThroScript")){
			var oldValue = this.getData("ltPropSelected");
			var newValue = this.getCurrentSelectedValue(radiobutton);
			if(!oldValue || oldValue.value != newValue.value){
				//Above check is used to prevent the from setting the value in ltPropOnInit
				this.setData("selThroScript",true);
				this.setData("ltPropSelected",this.getCurrentSelectedValue(radiobutton));
				this.setData("selThroScript",false);
			}
		}
	},
	getCurrentSelectedValue : function(radiobutton){
		var options = this.getData("ltPropOptions");
		var index  = radiobutton.getAttribute("index");
		return options[index];
	},
	rollbackSelectedValue : function(){
		if(this.getData("selThroScript")){
			this.setData("ltPropSelected",this.getPreviousValue());
		}
	},
	methods : {
		rdbBeforeUnchecked : function(input,component){
			var previousValue = this.getPreviousValue(true);
			var prevRadiobutton = this.getRadiobutton(previousValue);
			if(this.getMethods('onBeforeUnchecked')){
				if(this.executeMethod('onBeforeUnchecked', this, previousValue, prevRadiobutton) === false){
					this.rollbackSelectedValue();
					return false;
				}
			}
		},
		rdbUnchecked : function(input,component){
			this.setPreviousValue();
			var previousValue = this.getPreviousValue();
			var prevRadiobutton = this.getRadiobutton(previousValue);
			if(this.getMethods('onUnchecked')){
				this.executeMethod('onUnchecked', this, previousValue, prevRadiobutton);
			}
		},
		rdbBeforeChecked : function(input,component){
			if(this.getMethods('onBeforeChecked')){
			 	if(this.executeMethod('onBeforeChecked', this, this.getSelectedValue(component.$node), component.$node) === false){
					this.rollbackSelectedValue();
					return false;
				}
			}
		},
		rdbChecked : function(input,component){
			var radiobutton = component.$node;
			this.setSelectedValue(radiobutton);
			if(this.getMethods('onChecked')){
				this.executeMethod('onChecked', this, this.getSelectedValue(), radiobutton);
			}
		},
		rdbChanged : function(input,component){
			var prevSelectedValue = this.getPreviousValue(),
			curSelectedValue =  this.getSelectedValue(),
			prevRadiobutton = this.getRadiobutton(prevSelectedValue),
			curRadioButton =  this.getRadiobutton(curSelectedValue);
			if(this.getMethods('onChanged')){
				this.executeMethod('onChanged', this, prevSelectedValue, curSelectedValue, prevRadiobutton, curRadioButton);
			}
		}
	}
});
//TODO: window._lyteUiUtils.escape() check.
/**
 * This component is used to search and filter elements from existing rendered DOM
 * @copmponent lyte-search
 * @version 1.0.0
 * @methods onValueChange,onFocus,onBlur,onBeforeSearch,onSearch
 * @utility setValue
 * @dependency lyte-input
 *  /components/lyte-input.js
 *  /theme/compiledCSS/default/ltr/lyte-ui-input.css
 * @import lyte-input
 * @ignoreMethods
 * @ignoreUtils revertToSelected,revertToToday
 * @ignoreProperties ltPropRows,ltPropCols,ltPropTextAreaResize,ltPropMax,ltPropMin,ltPropStep,ltPropTimeFormat,ltPropHourInterval,ltPropDefaultTime,ltPropMinuteInterval,ltPropDropdown,ltPropShowInterval,ltPropStartTime,ltPropEndTime,ltPropFillRows,ltPropNumberOfRows,ltPropMinDate,ltPropMaxDate,ltPropStartWeekDay,ltPropMonthHeaderFormat,ltPropYear,ltPropFormat,ltPropStartDate,ltPropEndDate,ltPropCurrentDate,ltPropBindToBody,ltPropCalendarClass,ltPropHeaderType,ltPropDropdownDisabled,ltPropDropdownShow,ltPropDropdownCallout,ltPropDropdownFreeze,ltPropDropdownId,ltPropDropdownClass,ltPropPosition,ltPropBoundary,ltPropWheel,ltPropYield,ltPropAnimate,ltPropPreventSelection,ltPropPreventKeys
 */

Lyte.Component.register("lyte-search",{
_template:"<template tag-name=\"lyte-search\"> <lyte-input lt-prop-auto-update=\"{{ltPropAutoUpdate}}\" lt-prop-tab-index=\"{{ltPropTabIndex}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-wrapper-style=\"{{ltPropWrapperStyle}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-autocomplete=\"{{ltPropAutocomplete}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-placeholder=\"{{ltPropPlaceholder}}\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-height=\"{{ltPropHeight}}\" onkeyup=\"{{action('keyup',event,this)}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-value=\"{{lbind(ltPropValue)}}\" onkeypress=\"{{action('keypress',event,this)}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-direction=\"{{ltPropDirection}}\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-readonly=\"{{ltPropReadonly}}\" on-value-change=\"{{method('valuechange')}}\" on-focus=\"{{method('focus')}}\" on-blur=\"{{method('blurEvent')}}\" lt-prop-input-title=\"{{ltPropInputTitle}}\" lt-prop-pattern=\"{{ltPropPattern}}\" lt-prop-maxlength=\"{{ltPropMaxlength}}\" oninput=\"{{action('input',event)}}\" lt-prop-close-icon=\"{{ltPropCloseIcon}}\" is-search=\"true\" lt-prop-update-delay=\"{{ltPropUpdateDelay}}\" lt-prop-aria=\"{{ltPropAria}}\" lt-prop-aria-attributes=\"{{ltPropAriaAttributes}}\" lt-prop-focus=\"{{lbind(ltPropFocus)}}\"></lyte-input> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropAutocomplete","ltPropPlaceholder","ltPropAutofocus","ltPropDisabled","ltPropStyle","ltPropMaxlength","ltPropReadonly","ltPropId","ltPropClass","ltPropType","ltPropName","ltPropWidth","ltPropHeight","ltPropValue","ltPropAppearance","ltPropDirection","ltPropQuerySelector","ltPropMinLength","ltPropMethod","ltPropWrapperStyle","ltPropTabIndex","ltPropAjaxRequest","ltPropAutoUpdate","ltPropPattern","ltPropInputTitle","ltPropCloseIcon","ltPropUpdateDelay","ltPropSearchDelay","ltPropCaseSensitive","ltPropComponent","ltPropTrim","ltPropFocus","ltPropDiacritic","ltPropMaintainState","ltPropPreventEmptyKeys","ltPropMultipleSearch","ltPropIgnoreChildren","ltPropAria","ltPropAriaAttributes","timeout","ltPropCheckFromParent"],

   init : function(){
       /**
        * @method beforeRender
        * @version 1.0.1
        */
        this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node );
    },
    didConnect : function(){
        this.$node.setValue = function( value, evt ) {
            this.$node.ltProp( 'value', value );
            this.pressFunc( value || '', evt || {} );
            clearTimeout( this.data.timeout )
            clearTimeout( this._iptime );
            delete this._minlengthfail;
        }.bind( this );
       /**
        * @method afterRender
        * @version 1.0.1
        */
        this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );

        [ 'focus', 'blur', 'click', 'select' ].forEach( function( item ){
            this.$node[ item ] = function( arg ){
                this.$node.querySelector( 'lyte-input' )[ item ]( arg );
            }.bind( this )
        }.bind( this ) )

         $L.fastdom.measure( function(){
            var fg = _lyteUiUtils.getRTL();
            if( fg ) {
               $L.fastdom.mutate( function(){
                  this.$node.classList.add( 'lyteRTL' )
               }.bind( this ) )
            }
          }.bind( this ) );

         var comp =  this.data.ltPropComponent, query = this.data.ltPropQuerySelector;
         if( comp == "accordion" ) {
              query.related  = "lyte-accordion-item";
         } else if( comp == "tree" ){
            query.related = ".lyteTreeBodyDiv lyte-yield:not(.noChildClass) lyte-tree-icon";
         }
    },

    didDestroy : function(){
        clearTimeout( this.data.timeout )
        clearTimeout( this._iptime );
        delete this.$node.setValue;
        delete this.$node.focus;  delete this.$node.blur;  delete this.$node.click;  delete this.$node.select;
    },

     data : function (){
      //user data
            return {
               ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
               ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
               ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
               ltPropDisabled : Lyte.attr("boolean",{"default" : false}),
               ltPropStyle : Lyte.attr("string",{"default" : ''}),
               ltPropMaxlength : Lyte.attr("number",{"default" : 25}),
               ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
               ltPropId : Lyte.attr("string",{"default" : 'inputId'}),
               ltPropClass : Lyte.attr("string",{"default" : ''}),
               ltPropType : Lyte.attr("string",{"default" : 'search'}),
               ltPropName : Lyte.attr("string",{"default" : ''}),
               ltPropWidth : Lyte.attr("string",{"default" : '100%'}),
               ltPropHeight  : Lyte.attr("string",{"default" : ''}),
               ltPropValue : Lyte.attr("string",{"default" : ''}),
               ltPropAppearance : Lyte.attr("string",{"default" : 'flat'}),
               ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
               /**
                * @typedef {object} searchQuery
                * @property {string} scope
                * @property {string} search
                * @property {string} target
                */

               /**
                * @componentProperty {searchQuery} ltPropQuerySelector
                * @version 1.0.0
                * @default {}
                */
               ltPropQuerySelector : Lyte.attr("object",{"default" : {}}),
               /**
                * @componentProperty {number} ltPropMinLength=1
                * @version 1.0.0
                */
               ltPropMinLength : Lyte.attr('number',{'default' : 1}),
               /**
                * @componentProperty {startsWith | endsWith | contains} ltPropMethod=contains
                * @version 1.0.0
                */
               ltPropMethod : Lyte.attr('string',{'default' : 'contains'}),
               ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
               ltPropTabIndex : Lyte.attr('string',{default : '0'}),
               /**
                * @experimental ltPropAjaxRequest
                */
               ltPropAjaxRequest : Lyte.attr("object",{"default":{}}),
               ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),
               ltPropPattern : Lyte.attr('string', { default : '.+'}),
               ltPropInputTitle : Lyte.attr('string', { default : '' }),
               ltPropCloseIcon : Lyte.attr( 'boolean', { default : false } ),
               ltPropUpdateDelay : Lyte.attr( 'number', { default : 250 } ),
               ltPropSearchDelay : Lyte.attr( 'number', { default : 100 } ),
               /**
                * @componentProperty {boolean} ltPropCaseSensitive=false
                * @version 2.2.10
                */
               ltPropCaseSensitive : Lyte.attr( 'boolean', { default : false } ),
               /**
                * @componentProperty {string} ltPropComponent
                * @version 2.0.0
                */
               ltPropComponent : Lyte.attr( 'string', { default : undefined } ),
               /**
                * @componentProperty {boolean} ltPropTrim=false
                * @version 2.2.6
                */
               ltPropTrim : Lyte.attr( 'boolean', { default : false } ),
               ltPropFocus : Lyte.attr( 'boolean', { default : false } ),

               /**
                * @componentProperty {boolean} ltPropDiacritic=false
                * @version 3.12.0
                */

               ltPropDiacritic : Lyte.attr( 'boolean', { default : false } ),

               /**
                * @componentProperty {boolean} ltPropMaintainState=true
                * @version 3.16.3
                */

               ltPropMaintainState : Lyte.attr( 'boolean', { default : true } ),

               /**
                * @componentProperty {boolean} ltPropPreventEmptyType=false
                * @version 3.19.3
                */

               ltPropPreventEmptyKeys : Lyte.attr( 'boolean', { default : false } ),

              /**
                * @componentProperty {boolean} ltPropMultipleSearch=false
                * @version 3.25.0
                */

               ltPropMultipleSearch : Lyte.attr( 'boolean', { default : false } ),

               /**
                * @componentProperty {boolean} ltPropIgnoreChildren=false
                * @version 3.27.0
                */

                ltPropIgnoreChildren : Lyte.attr( 'boolean', { default : false } ),

               // aria
               ltPropAria : Lyte.attr( 'boolean', { default : false } ),
               ltPropAriaAttributes : Lyte.attr( 'object', { default : {} } ),

               //system data
               timeout : Lyte.attr("number",{"default" : undefined}),
               ltPropCheckFromParent : Lyte.attr("boolean",{"default" : false})

             }
         },

      methods : {
         blurEvent : function(arg1){
           this.getMethods( 'onBlur' ) && this.executeMethod( 'onBlur', arg1, this.$node );
        },

        focus :function( arg1 ){
            this.getMethods( 'onFocus' ) && this.executeMethod( 'onFocus', arg1, this.$node );
        },

        valuechange : function( arg1 ){
            this.getMethods( 'onValueChange' ) && this.executeMethod( 'onValueChange', arg1, this.$node );
        }
      },

// Function for finding textContents when data were not properly given for DOM search
      searchList : function( nodeName ){
              var searchList=[];
              var target=[],
              query=this.getData('ltPropQuerySelector')
              if(typeof query =="string")
                  {
                      query=JSON.parse(query);
                  }
              for(var i=0;i<nodeName.childElementCount;i++)
                {
                  var _children = nodeName.children[ i ];

                  while( _children.childElementCount)
                     {
                        var returnedVal=this.searchList.call(this, _children);
                        searchList=searchList.concat(returnedVal[0]);
                        target=target.concat(returnedVal[1]);
                        break;
                     }
                  if(! _children.childElementCount)
                      {
                        var valueToPush = _children.textContent;
                        if( this.data.ltPropDiacritic ){
                          valueToPush = _lyteUiUtils.convert_diacritics( valueToPush );
                        }
                        searchList.push( valueToPush );
                        if(query.target)
                          {
                            var scope = this.getScope( typeof query.scope == 'string' ? document.body.querySelector( query.scope.trim() ) : query.scope ),
                            targetList= scope.querySelectorAll( query.target ),
                            node= _children;
                            while(node != scope)
                              {
                                var flag=false;
                                for(var j=0;j<targetList.length;j++)
                                  {
                                      if(node==targetList[j])
                                         {
                                            target.push(node);
                                            flag=true;
                                            break;
                                         }
                                  }
                                if(flag)
                                    {
                                        break;
                                    }
                                 else
                                   {
                                      node=node.parentElement;
                                   }
                              }
                          }
                        else
                          {
                            target.push( _children );
                          }
                    }
                }
              return [searchList,target];
         },

     actions : {
        "on-ip-clear" : function( evt ){
              this.$node.setValue( '', { type : 'clear' } );
              /**
               * @method onClear
               * @version 2.2.9
               */
              this.getMethods( 'onClear' ) && this.executeMethod( 'onClear', this.$node );
          },
         "keypress":function( event ){
               var keyCode = event.keyCode
               if(!( keyCode >= 37 && keyCode <= 40 ) && keyCode != 13 ) {
                  event.stopPropagation()
                }
            },
        //filtering process  checks
        "keyup":function( event, lyteInput ){
              var keyCode = event.which || event.keyCode,
              prevent = this.data.ltPropPreventEmptyKeys;

              if( [ 37,13,38,39,40,27 ].indexOf( keyCode ) > -1 ) {
                return
              }

              clearTimeout( this._iptime );

              if( prevent ){
                 if( this._iptime == void 0 ){
                      return;
                 }
                 delete this._iptime;
              }

              clearTimeout( this.data.timeout )

              var val = event.target.value,
              minLength = this.data.ltPropMinLength,
              isPassed = val.length >= minLength;

              if( isPassed ){
                 delete this._minlengthfail;
              } else {
                  if( prevent && this._minlengthfail ){
                     return;
                  }
                  this._minlengthfail = true;
                  if( /^8|91|17|46$/i.test( keyCode ) ){
                    isPassed = true;
                  }
              }

              if( isPassed ){
                    var dly = this.data.ltPropSearchDelay
                      if( dly != undefined ) {
                          this.timeout = setTimeout( this.pressFunc.bind( this ), dly, val, event )
                       } else {
                         this.pressFunc.call(this, val, event )
                       }
                }
            },
        'input' :  function( evt ) {
              var delay = this.data.ltPropSearchDelay,
              minLength = this.data.ltPropMinLength,
              value = evt.target.value;
              clearTimeout( this._iptime );

              if( value.length >= minLength ){
                if( delay == undefined ){
                   this.pressFunc( value, event );
                } else {
                   // this._iptime = setTimeout( this.pressFunc.bind( this ), 250, value, evt );

                   this._iptime = setTimeout( function(){
                        delete this._iptime;
                        this.pressFunc( value, evt );
                   }.bind( this ), 250 );
                }
              }
          }
        },

        fNcase : function( str ){
            if( !this.data.ltPropCaseSensitive ){
              str = str.toLowerCase();
            }
            if( this.data.ltPropTrim ){
              str = str.trim();
            }
            return str;
        },

         multi_search : function( value, evt ){
           var data = this.data,
           query = data.ltPropQuerySelector,
           scope = $L( query.scope ),
           search = Array.from( scope.find( query.search ) ),
           dia = data.ltPropDiacritic,
           visible = [],
           hidden = [],
           _this = this;

           search.forEach( function( item ){
               var target = $L( item ).closest( query.target, scope ).get( 0 ),
               txt_value = _this.fNcase( item.textContent );

               if( dia ){
                  txt_value = _lyteUiUtils.convert_diacritics( txt_value );
               }

               if( !value || _this.switchfn( data.ltPropMethod, value, txt_value ) ){
                  visible.push( target );
               } else {
                  hidden.push( target );
               }
           });

           if( this.getMethods( 'onSearch' ) && this.executeMethod( 'onSearch', visible, this.$node, evt, value, hidden ) == false ){
              return;
           }

           this.common_hide( visible, hidden, evt );
        },

        common_hide : function( visible, hidden, evt ){
          function fn( arr, cls ){
              arr.forEach( function( item ){
                  $L( item )[ cls ]( 'lyteSearchHidden' );
              });
           }

           fn( hidden, 'addClass' );
           fn( visible, 'removeClass' );

           if( evt != "ignore" ){
              this.getMethods( 'onAfterSearch' ) && this.executeMethod( 'onAfterSearch', visible, evt, this.$node );
            }
        },

        check_label : function( visible, hidden, related, label, target_visible, target_hidden, evt, value ){
          var visible_groups = [],
          hidden_groups = [],
          cb = 'onSearch',
          fn 

          Array.from( related ).forEach( function( item ){
              var label_dom = item.querySelector( label );
              if( label_dom ){
                  var is_visible = visible.indexOf( label_dom ) + 1;

                  if( is_visible ){
                      var len = hidden.length;

                      for( var i = 0; i < len; i++ ){
                          var cur = hidden[ i ];
                          if( item.contains( cur ) ){
                            visible.push( cur );
                            target_visible.push( target_hidden[ i ] );
                            target_hidden.splice( i, 1 );
                            hidden.splice( i--, 1 );
                            len--;
                          }
                      }

                      visible_groups.push( item );
                  } else {
                     var len = visible.length;

                     for( var i = 0; i < len; i++ ){
                        var cur = visible[ i ];
                        if( item.contains( cur ) ){
                            visible.push( label_dom );
                            var index = hidden.indexOf( label_dom );
                            hidden.splice( index, 1 );
                            target_visible.push( target_hidden[ index ] );
                            target_hidden.splice( index, 1 );
                            break;
                        }
                     }

                     if( i == len ){
                        hidden_groups.push( item );
                     } else{
                        visible_groups.push( item );
                     }
                  }

              }
          });

          if( this.getMethods( cb ) && this.executeMethod( cb, visible, this.$node, evt, value, hidden ) == false ){
               return;
          }

          this.common_hide( visible_groups, hidden_groups, "ignore" );
          this.common_hide( visible, hidden, evt );

        },

        filteringArray : function(searchList, targetList, val, searchComp, evt, related, label ){
            var method = this.getData('ltPropMethod'), visibleList = [], hiddenList = [],
            target_visible = [],
            target_hidden = [];

            val = this.fNcase( val );
            if( val.length )
                {

                  var __len = searchList.length;

                  for( var i = 0; i < __len; i++ ){
                      var current = searchComp[ i ],
                      current_target = targetList[ i ];

                      if( this.switchfn( method, val, this.fNcase( searchList[ i ].trim() ) ) ){
                          visibleList.push( current );
                          target_visible.push( current_target );
                      } else {
                          hiddenList.push( current );
                          target_hidden.push( current_target );
                      }
                  }
                }
             else
                {
                   visibleList = Array.apply( Array, searchComp );
                   target_visible = Array.from( targetList );
                }

                if( label ){
                    return this.check_label( visibleList, hiddenList, related, label, target_visible, target_hidden, evt, val );
                }

              if( this.getMethods( 'onSearch' ) && this.executeMethod( 'onSearch', visibleList, this.$node, evt && evt.type == 'clear'? {} : evt, val, hiddenList ) == false ){
                 return;
              }
             if( this.data.ltPropSearchDelay == undefined ) {
                this.hideProcess( searchList, targetList, method, val, related, evt, hiddenList, visibleList );
             } else {
                $L.fastdom.mutate( this.hideProcess.bind( this, searchList, targetList, method, val, related, evt, hiddenList, visibleList ) )
             }
        },

        switchfn : function( method, val, str ){
          var check;
          switch( method )
            {
              case 'contains' : {
                  check = str.indexOf( val ) >= 0
                  break;
               }
               case 'startsWith' : {
                    check = str.indexOf( val ) == 0;
                    break;
               }
               case 'endsWith' : {
                    var ind = str.lastIndexOf( val );
                    if( ind != -1 ){
                      check = ( ind  + val.length ) == str.length;
                    }
                    break;
               }
            }
            return check;
        },

        hideProcess : function( searchList, targetList, method, val, related, evt, hiddenList, visibleList ){
            var query = this.data.ltPropQuerySelector, val = this.fNcase( val );
            for( var i = 0; i < searchList.length; i++ ) {
               this.additionalHand( targetList[ i ],  this.switchfn( method, val, this.fNcase( searchList[i].trim() ) ) );
            }

           for( var i = 0; i < related.length; i++ ) {
              if( this.data.ltPropComponent == "accordion" && related[ i ]._state == undefined ){
                 if( !related[ i ].querySelector( 'lyte-accordion-body' ) ){
                    if( !val ){
                      related[ i ].classList.remove( 'lyteSearchHidden' );
                    } else{
                      related[ i ].classList.add( 'lyteSearchHidden' );
                    }
                    continue;
                 }
                 related[ i ]._state = related[ i ].classList.contains( 'lyteAccordionActive' );
              } else if( this.data.ltPropComponent == "tree" ){
                if( related[ i ]._state == undefined ){
                   related[ i ]._state = related[ i ].classList.contains( 'lyteIconOpened' );
                }
                continue;
              }
              if( related[ i ].querySelectorAll( query.target || query.search ).length == related[ i ].querySelectorAll( '.lyteSearchHidden' ).length ) {
                  related[ i ].classList.add( 'lyteSearchHidden' );
              } else {
                  related[ i ].classList.remove( 'lyteSearchHidden' );
              }
           }

           var component = this.data.ltPropComponent;

           if( component ){
              var map = {
               accordion : "accfilter",
               tree : 'treefilter',
               duallistbox : "listboxfilter"
             };

             if( map[ component ] ){
                $L.fastdom.measure( this[ map[ component ] ].bind( this, visibleList, hiddenList, val, evt && evt.type == 'clear' ) );
              }
           }

           if( this.getMethods( 'onAfterSearch' ) ){
              this.executeMethod( 'onAfterSearch', visibleList, evt, this.$node );
           }
         },

        listboxfilter : function( vis, hid, value, clear ){
          var query = this.data.ltPropQuerySelector,
          scope = $L( this.getScope( query.scope ) ),
          _length = vis.length,
          toOpen = [];


          for( var i = 0; i < _length; i++ ){
             var parent = $L( vis[ i ] ).closest( '.lyteListBoxLeftWrap' ).parent().closest( '.lyteListBoxLeftWrap', scope );

             if( parent.length ){
                if( parent.hasClass( 'lyteSearchHidden' ) ){
                    var search = parent.find( query.search ).get( 0 ),
                    index = hid.indexOf( search );
                    if( index != -1 ){
                       vis.push( search );
                       hid.splice( index, 1 );
                       _length++;
                       parent.removeClass( 'lyteSearchHidden' );
                    }
                }

                var open_index = toOpen.indexOf( parent.get( 0 ) );
                 if( open_index == -1 ){
                    toOpen.push( parent.get( 0 ) );
                 }
             }
          }

          toOpen.forEach( function( item ){
              var jobj = $L( item );
              if( jobj.children( '.lyteListboxParentElementClose' ).length ){
                 jobj.find( 'lyte-lb-collapse' ).get( 0 ).click();
              }
          })
        },

        accfilter : function( vis, hid, value, clear ){
            var scope = $L( this.getScope( this.data.ltPropQuerySelector.scope ) );
            for( var i = 0; i < vis.length; i++ ){
              var close1 = $L( vis[ i ] ).closest( 'lyte-accordion-item', scope )
              for( var j = 0; j < hid.length; j++ ){
                 var close2 = $L( hid[ j ] ).closest( 'lyte-accordion-item', scope )
                 if( close1[ 0 ] == close2[ 0 ] ){
                    Lyte.arrayUtils( hid, 'removeAt', j );
                    j--; continue;
                 }
              }
              if( vis[ i + 1 ] ) {
                 var close2 = $L( vis[ i + 1 ] ).closest( 'lyte-accordion-item', scope );
                 if( close1[ 0 ] == close2[ 0 ] ){
                    Lyte.arrayUtils( vis, 'removeAt', i + 1 );
                    i--;
                 }
              }
            }
            // scope[ 0 ].component.getAllHeights();
            $L.fastdom.mutate( function(){
                for( var i = 0; i < vis.length; i++ ){
                   var isclose = false, close = $L( vis[ i ] ).closest( 'lyte-accordion-item' );
                   isclose = !close.hasClass( 'lyteAccordionActive' );
                   if( !value && this.data.ltPropMaintainState ){
                     if( close[ 0 ]._scope != undefined ){
                        isclose = !isclose && !close[ 0 ]._scope;
                     } else{
                       isclose = !isclose
                     }
                   }
                   if( isclose ){
                      close.click();
                   }
                }

                for( var j = 0; j < hid.length; j++ ){
                    var close = $L( hid[ j ] ).closest( 'lyte-accordion-item' )
                    if( clear ){
                      !close[ 0 ]._state && close.hasClass( 'lyteAccordionActive' ) && close.click();
                    } else {
                       close.hasClass( 'lyteAccordionActive' ) && close.click();
                    }
                }
            })
        },

        treeinremove : function( arr ){
            for( var i = 0; i < arr.length; i++ ){
              if( arr[ i + 1 ] ){
                 var cur =  this.closest( arr[ i ], '.lyteTreeBodyDiv' )[ 0 ], next = this.closest( arr[ i + 1 ], '.lyteTreeBodyDiv' )[ 0 ];
                 if( cur.contains( next ) ){
                    Lyte.arrayUtils( arr, 'removeAt', i + 1 );
                 } else if(next.contains( cur ) ){
                    Lyte.arrayUtils( arr, 'removeAt', i );
                    i--;
                 }
              }
          }
        },

        closest : function( dom, query ){
           if( dom.closest ){
              return $L( dom.closest( query ) );
           }
           return $L( dom ).closest( query );
        },

        treefilter : function( visible, hidden, value, clear ){
            var data = this.data,
            scope = $L( this.getScope( data.ltPropQuerySelector.scope ) ).get( 0 ),
            vis_len = visible.length,
            hid_len = hidden.length,
            query = '.lyteTreeBodyDiv',
            hidden_class = "lyteSearchHidden";

            for( var i = 0; i < vis_len; i++ ){
                var cur = this.closest( visible[ i ], query ),
                _dom = cur.get( 0 );

                for( var j = 0; j < hid_len; j++ ){
                    var cur_close = this.closest( hidden[ j ], query ),
                    hid_dom = cur_close.get( 0 );

                    if( _dom.contains( hid_dom ) || hid_dom.contains( _dom ) ){
                       if( data.ltPropIgnoreChildren ){
                          cur_close.removeClass( hidden_class );
                       } else {
                          cur_close.addClass( hidden_class );
                       }
                       hidden.splice( j, 1 );
                       j--;
                       hid_len--;
                    }
                }
            }

            for( var i = 0; i < vis_len; i++ ){
                var cur = visible[ i ];
                this.removeClse( cur, scope );
                if( value ){
                    scope.ltProp( 'stateAttr', this.closest( cur, 'lyte-tree-body' ).attr( 'data-value' ) );
                }

                delete cur.__search_ignore;
            }

            if( value ){
                hidden.forEach( function( item ){
                    this.closest( item, query ).addClass( hidden_class );
                }.bind( this ));
            } else {
                this.hiderecurse( $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope ), clear );
            }

            this.last_tree_element( visible, hidden, scope );
        },

        last_tree_element : function( visible, hidden, scope ){

          var class_name = 'lyteTreeBodyDivLastVisibleElem',
          query = 'lyteTreeBodyDiv',
          search_class = "lyteSearchHidden",
          fn = function( item ){
             var elem = $L( item ).closest( '.' + query, scope ),
             fn_name = "addClass";

             if( elem.length ){

                 if( elem.hasClass( search_class ) ){
                    fn_name = "removeClass";
                 } else {
                    if( elem.next( '.' + query + ":not(." + search_class + ")" ).length ){
                        fn_name = "removeClass";
                    }
                 }

                 elem[ fn_name ]( class_name );
                 fn( elem.parent() );
             }
          };

          visible.concat( hidden ).forEach( fn );
        },

        removeClse : function( target, scope ){
           // var scope = $L( this.data.ltPropQuerySelector.scope );
            var el = $L( target ).closest( '.lyteSearchHidden', scope );
            if( el.length ){
               el.removeClass( 'lyteSearchHidden' );
               this.removeClse( target, scope );
            }
        },

        hiderecurse : function( elem, flag ){
          // this.treeinremove( elem );
           for( var i = elem.length - 1; i >= 0; i-- ) {
              var icon = elem.eq( i ),
              hasClass = icon.hasClass( 'lyteIconOpened' );

              if( flag && icon[ 0 ]._state != undefined ){
                if( ( icon[ 0 ]._state && !hasClass ) || ( !icon[ 0 ]._state && hasClass ) ){
                   setTimeout( icon.click.bind( icon ) , 20 );
                }
              } else if( hasClass ){
                  setTimeout( icon.click.bind( icon ) , 20 );
              }
              delete icon[ 0 ]._state;
           }
        },

        additionalHand : function( target, check ){
            var comp = this.data.ltPropComponent;
            if( check ){
                  if( comp == 'dropdown' ){
                    var clo = $L( target ).closest( 'lyte-drop-box' )[ 0 ]
                    if( clo ) {
                      clo.classList.contains( 'lyteDropdownHidden' ) && ( clo.origindd ? clo.origindd.toggle() : $L( clo ).closest( 'lyte-dropdown' ).get( 0 ).toggle() )
                    }
                  }
                 target.classList.remove( 'lyteSearchHidden' );
            } else if( comp != "tree" ) {
               if( target.classList.contains( 'lyteSearchHidden' ) ){
                  return;
                }
               target.classList.add( 'lyteSearchHidden' );
            }
        },

        pressFunc : function ( val, evt ){
             if( this.getMethods( 'onBeforeSearch' ) && this.executeMethod( 'onBeforeSearch', evt, this ) == false ){
                return
              }

             if( this.data.ltPropMultipleSearch ){
               this.multi_search( val, evt );
               return
             } 

             var content = [], searchList = [], target = [], query = this.data.ltPropQuerySelector, related,
             dia = this.data.ltPropDiacritic;
             var scope = typeof query.scope == 'string' ? document.body.querySelector( query.scope.trim() ) : query.scope;
             scope = this.getScope( scope );
             if( query.search ) {
               searchList = scope.querySelectorAll( query.search.trim() )
             }
             target = query.target ? scope.querySelectorAll( query.target.trim() ) : searchList
             if( !query.search ) {
                   var returnedVal = this.searchList.call( this, scope );
                    content = returnedVal[ 0 ];
                    target = returnedVal[ 1 ];
                    searchList = target.slice();
             } else {
                for( var j = 0; j < searchList.length; j++ ) {
                    var valueToPush = searchList[ j ].textContent;

                    if( dia ){
                       valueToPush = _lyteUiUtils.convert_diacritics( valueToPush );
                    }

                    content[ j ] = valueToPush;
                }
             }

            if( dia ){
              val = _lyteUiUtils.convert_diacritics( val );
            }

            related =  query.related && ( query.search || query.target ) ? related = scope.querySelectorAll( query.related ) : [];
            this.filteringArray.call(this, content, target, val, searchList, evt, related, query.label )
            this._prevVal = val;
        },

        getScope : function( scope ){
             scope = this.getMethods( 'dynamicScope' ) ? this.executeMethod( 'dynamicScope', this.$node ) : scope;
             if( this.data.ltPropCheckFromParent ){
                scope = this.$node.parentNode;
             }
             return scope;
        }
  });
/**
 * @syntax nonYielded
 * <lyte-search></lyte-search>
 */

/**
 * This component is used to select a value from a range of values
 * @component lyte-slider
 * @version 1.0.0
 * @methods beforeRender,afterRender,onSelect,onChange
 */

Lyte.Component.register('lyte-slider',{
_template:"<template tag-name=\"lyte-slider\"> <div class=\"lyteSlide {{if(ltPropDisabled,'lyteSliderDisabled','')}}\"> <div class=\"lyteRangeSlider {{ltPropDirection}}\" onclick=\"{{action('click',event)}}\" tabindex=\"0\" onkeydown=\"{{action('keydown',event)}}\"> <div class=\"lyteSliderFill\"></div> <div class=\"lyteSliderHandler {{ltPropHandler}} lyteHandler1\" lt-prop-title=\"{{if(expHandlers(ltPropTooltip,'&amp;&amp;',true),if(ltPropRangeHandler,ltPropMinValue,ltPropValue),'')}}\" tabindex=\"0\" onmousedown=\"{{action('mousedown',event,this)}}\" ontouchstart=\"{{action('mousedown',event,this)}}\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-tooltip-style=\"{{ltPropTooltipStyle}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\" style=\"border-color: {{ltPropFillColor}}\"></div> <template is=\"if\" value=\"{{ltPropRangeHandler}}\"><template case=\"true\"> <div class=\"lyteSliderHandler {{ltPropHandler}} lyteHandler2\" tabindex=\"0\" onmousedown=\"{{action('mousedown',event,this)}}\" ontouchstart=\"{{action('mousedown',event,this)}}\" lt-prop-title=\"{{if(ltPropTooltip,ltPropMaxValue,'')}}\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-tooltip-style=\"{{ltPropTooltipStyle}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\" style=\"border-color: {{ltPropFillColor}}\"></div> </template></template><template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template><template case=\"false\"> <div class=\"lyteScaleOption {{ltPropHandler}}\"> <template is=\"for\" items=\"{{divLength}}\" index=\"indexVal\"> <span class=\"lyteScaleLine\" style=\"{{item}}\"> <span></span> <span class=\"lyteScalLable\">{{scaleVal[indexVal]}}</span> </span> </template> </div> </template></template> </div> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'border-color: '","ltPropFillColor"]}}}},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'border-color: '","ltPropFillColor"]}}}}]}},"default":{}},{"type":"attr","position":[1,1,6]},{"type":"if","position":[1,1,6],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"item"}}},{"type":"text","position":[1,3,0]}]}]}},"default":{}}],
_observedAttributes :["divLength","scaleVal","ltPropMin","ltPropMax","ltPropScaleInterval","ltPropStep","ltPropHandler","ltPropDirection","ltPropWidth","ltPropFillColor","ltPropNonFillColor","ltPropHeight","ltPropValue","ltPropDiscrete","ltPropContent","ltPropRangeHandler","ltPropMinValue","ltPropMaxValue","ltPropDisabled","ltPropSelectedValue1","ltPropSelectedValue2","ltPropYield","ltPropTooltipStyle","ltPropTooltip","ltPropScaleUnit","ltPropTooltipClass","ltPropTooltipConfig","ltPropMinDiff","ltPropDigits","preventObs"],
        init:function(){
            this._dir = _lyteUiUtils.getRTL();
            var config = this.getData( 'ltPropTooltipConfig' ), dir = this.getData('ltPropDirection'), style = this.getData('ltPropTooltipStyle');
            if( !config ) {
                this._config = true;
                this.data.ltPropTooltipConfig = { position : ( dir == 'lyteHorizontal' ? 'top' : 'right' ), showdelay : 500, margin : 10 }
            }

            if( !style ) {
                this._style = true;
                if( this.data.ltPropFillColor ) {
                    this.data.ltPropTooltipStyle = "background-color : " + this.data.ltPropFillColor + ";";
                }
            }

            if( [ undefined, '', null ].indexOf( this.getData( 'ltPropScaleInterval' ) ) != -1 ) {
                this.setData('preventObs', true);
                var newScale;
                if( this.getData( 'ltPropHandler' ).indexOf( 'Arrow' ) != -1 ) {
                    if( this.getData('ltPropContent').length == 0 ) {
                        newScale = 0.1 * ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) )
                    }
                } 
                if( this.getData('ltPropContent').length ) {
                    newScale = 'true';
                }
                if( newScale ) {
                    this.setData( 'ltPropScaleInterval', newScale.toString() )
                }
                this.setData('preventObs', false);
            }
            if(this.getMethods('beforeRender'))
                {
                   /**
                    * @method beforeRender
                    * @version 1.0.1
                    */
                    this.executeMethod('beforeRender', this.$node);
                }
        },

        rtlfunc : function( lft, bcr, ww ) {
            if( this._dir && lft != 'top' && lft != 'clientY' ) {
                if( bcr ) {
                    if( lft == 'right' ) {
                        return ww - bcr.left;
                    } else if( lft == 'clientX' ) {
                        return ww - bcr.clientX
                    } else if( lft == 'offsetLeft' ) {
                        return bcr.offsetParent.offsetWidth - bcr.offsetLeft - bcr.offsetWidth;
                    }
                    return ww - bcr.right;
                } else if( lft == 'left' ) {
                    return 'right';
                } 
            }
            return bcr ? bcr[ lft ] : lft;
        },

        heightSetObs : function(){
            this.heightSet.call(this, arguments[0])
        }.observes('ltPropWidth','ltPropHeight'),

        heightSet : function (){
            var width = this.getData('ltPropWidth'), height = this.getData('ltPropHeight')
            if(this.getData('ltPropDirection').indexOf('Horizontal')!=-1)
                    {
                        if(!width) {
                                this.setData('ltPropWidth','200px')
                                width = '200px';
                            }
                        if(!height) {
                                this.setData('ltPropHeight','30px')
                                height = '30px';
                            }
                    }
            else
                {
                    if(!width){
                            this.setData('ltPropWidth','30px')
                            width = '30px'
                        }
                    if(!height){
                            this.setData('ltPropHeight','200px')
                            height = '200px';
                        }
                }
            this.$node.style.width = width;
            this.$node.style.height = height;
            if(arguments.length){
                this.didConnectWrk.call(this)   
            }
        },

        initialWorkObs : function(){
            if(this.getData('preventObs')){
                return;
            }
            this.setData('preventObs', true);
            this.initialWork.call(this, arguments[ 0 ]);
            this.setData('preventObs', false);
        }.observes('ltPropContent','ltPropMax','ltPropMin', 'ltPropScaleInterval','ltPropDiscrete','ltPropStep','ltPropValue', 'ltPropScaleUnit').on('init'),

        initialWork : function (arg){
            var ltPropContent = this.getData('ltPropContent').slice(), direction = this.getData('ltPropDirection'), discrete = this.getData( 'ltPropDiscrete' ), rangeHandler = this.getData( 'ltPropRangeHandler' );
            if( !ltPropContent.length )
                {
                    var min = parseFloat( this.getData( 'ltPropMin' ) ), max = parseFloat( this.getData( 'ltPropMax' ) )
                    if( !rangeHandler ) {
                        var value = parseFloat( this.getData( 'ltPropValue' ) );
                        if( value < min || isNaN( value ))
                            {   
                                this.setData('ltPropValue', min.toString());
                            }
                        else if( value > max)
                            {
                                this.setData('ltPropValue', max.toString());
                            }
                        this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));
                    } else {
                        var minVal = parseFloat( this.getData( 'ltPropMinValue' ) ), maxVal = parseFloat( this.getData( 'ltPropMaxValue' ) );
                        if( isNaN( minVal ) || minVal < min || minVal >= max ) {
                            this.setData( 'ltPropMinValue', min.toString() );
                        }
                        if( isNaN( maxVal ) || maxVal > max || maxVal <= min) {
                            this.setData( 'ltPropMaxValue', max.toString() );
                        }
                        this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
                        this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
                    }   
                    if( discrete ) {
                        var minDiscrete = 0.1 * ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) );
                        discrete = parseFloat( discrete );
                        discrete = Math.max( isNaN( discrete ) ? 0 : discrete, minDiscrete ).toString();
                        this.setData( 'ltPropDiscrete', discrete);
                        this.setData( 'ltPropStep', discrete );
                        this.setData( 'ltPropScaleInterval', discrete );                    
                    }
                }
            else if(ltPropContent.length)
                {
                    this.setData('ltPropMax','100');
                    this.setData('ltPropStep',this.getData('ltPropScaleInterval'))
                    if( this.getData( 'ltPropScaleInterval' ) || ( arg && arg.item == 'ltPropContent' ) ) {
                        this.setData('ltPropScaleInterval', '' + parseFloat( 100 / ( ltPropContent.length - 1 ) ) + '')
                    }
                    this.setData('ltPropDiscrete',this.getData('ltPropScaleInterval'))
                    if( !rangeHandler ) {
                        if(!this.getData('ltPropValue'))
                            {
                                this.setData('ltPropValue',this.getData('ltPropContent')[0])
                                this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));  
                            }   
                    } else {
                        var minVal = this.getData( 'ltPropMinValue' ), maxVal = this.getData( 'ltPropMaxValue' );
                        if( !minVal || ltPropContent.indexOf( minVal ) == -1 || ( ltPropContent.indexOf( minVal ) > ltPropContent.indexOf( maxVal ) ) ) {
                             this.setData( 'ltPropMinValue', ltPropContent[ 0 ] );
                        } 
                        if( !maxVal || ltPropContent.indexOf( maxVal ) == -1 || ( ltPropContent.indexOf( minVal ) > ltPropContent.indexOf( maxVal ) ) ) {
                             this.setData( 'ltPropMaxValue', ltPropContent[ ltPropContent.length - 1 ] );
                        } 
                        this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
                        this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
                    }   
                }   
            var array = []
            var scale = []
            if(!this.getData('ltPropYield'))    
                {
                    var dirFlag = direction.indexOf('Horizontal') != -1 ? true : false, left = "top:", scaleint = parseFloat( this.getData( 'ltPropScaleInterval' ) );
                    if(dirFlag){
                        left =  this.rtlfunc.call( this, 'left' ) + ":"
                    }
                    if( scaleint && !isNaN( scaleint ) )
                        {
    
                            var temp = parseFloat(this.getData('ltPropMin')), scaleText = this.getData( 'ltPropScaleUnit' );
                            for(var i=0;temp<=parseFloat(this.getData('ltPropMax'));i++)
                                {
                                    array.push(left + (((temp-parseFloat(this.getData('ltPropMin')))/(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin'))))*100)+'%');
                                    if(this.getData('ltPropContent').length)
                                        {
                                            scale.push(ltPropContent[i] + scaleText)
                                        }
                                    else    
                                        {
                                            scale.push(temp + scaleText);
                                        }   
                                    temp+=parseFloat(scaleint);
                                }
                            var maxVal = ltPropContent.length ? ltPropContent[ltPropContent.length-1] : this.getData('ltPropMax');
                            if(scale[scale.length-1]!=maxVal)
                                {
                                    array.push(left + (100) + '%');
                                    if(ltPropContent.length)
                                        {
                                            scale.push(ltPropContent[ltPropContent.length - 1] + scaleText)
                                        }
                                    else    
                                        {
                                            scale.push(this.getData('ltPropMax') + scaleText);  
                                        }
                                }   
                        }
                    else
                        {
                            array.push( left + 0 + '%');
                            array.push( left + 100 + '%');
                            scale=this.MaxMinSet.call(this);
                            this.setData('scaleVal',scale);         
                        }
            }
            this.setData('scaleVal', scale);
            this.setData('divLength', array);   
        },

        colorSetObs : function(arg){
            this.colorSet.call(this, arg);
        }.observes('ltPropFillColor','ltPropNonFillColor').on( 'didConnect' ),

        colorSet : function (arg) {
            if((!arg && this.data.ltPropFillColor) || (arg && arg.item == "ltPropFillColor"))
                {
                    this.$node.querySelector( 'div.lyteSliderFill' ).style.backgroundColor=this.data.ltPropFillColor;
                }
            if((!arg && this.data.ltPropNonFillColor) || (arg && arg.item == "ltPropNonFillColor"))
                {
                    this.$node.querySelector( 'div.lyteRangeSlider' ).style.backgroundColor= this.data.ltPropNonFillColor;
                }
        },

        didConnectWrkObs : function(){
            if(this.getData('preventObs')){
                return;
            }
            this.setData('preventObs', true);
            this.didConnectWrk.apply(this, arguments);
            this.setData('preventObs', false);
        }.observes('ltPropScaleInterval','ltPropValue','ltPropMin','ltPropMax','ltPropMinValue','ltPropMaxValue','ltPropContent','ltPropHandler','ltPropRangeHandler'),

        didConnectWrk : function () {
            var lyterangeFlag,handlers,nodeName,lyteRangeSlider= this.$node.querySelector( 'div.lyteRangeSlider' ), lyteSlide= this.$node.querySelector( 'div.lyteSlide' );
            var handlers = this.$node.querySelectorAll( 'div.lyteSliderHandler' ), rangeHandler = this.getData('ltPropRangeHandler'), direction = this.getData('ltPropDirection');
            var thisClientRect = this.$node.getBoundingClientRect(), handlersClientRect = handlers[0].getBoundingClientRect(), offParent = this.$node.offsetParent, objj = {};
            var width = "width", handlerWidth = "handlerWidth", left = this.rtlfunc.call( this, 'left' ), left1, left2, actWidth = {}, offsetWidth = 'offsetWidth', node;
            if( direction.indexOf('Horizontal') == -1) {
                width = "height"; handlerWidth = "handlerHeight", left = "top", offsetWidth = 'offsetHeight';
            }
            if( offParent == null ) {
                objj.width = parseFloat(this.getData('ltPropWidth'));
                objj.height = parseFloat(this.getData('ltPropHeight'));
                objj.handlerWidth = objj.handlerHeight = 12;
            } else {
                objj.width = thisClientRect.width;
                objj.height = thisClientRect.height;
                objj.handlerWidth = handlersClientRect.width;
                objj.handlerHeight = handlersClientRect.height;
            }
              var lyteSliderFill= this.$node.querySelector( 'div.lyteSliderFill' );
              if(this.getData('ltPropContent').length)
                    {
                        var index1,index2,index = this.data.ltPropContent.indexOf( this.data.ltPropValue );
                        node= this.$node.querySelectorAll( 'div.lyteSliderHandler' );
                        index = index > -1 ? index : 0 ;
                        if(rangeHandler)
                            {
                                index1 = this.getData( 'ltPropContent' ).indexOf( this.getData( 'ltPropMinValue' ) );
                                index1 = index1 != -1 ? index1 : 0;
                                index2 = this.getData( 'ltPropContent' ).indexOf( this.getData( 'ltPropMaxValue' ) );
                                index2 = index2 != -1 ? index2 : this.getData( 'ltPropContent' ).length - 1;
                            }
                        if(rangeHandler)
                            {
                                left1 = this.rangeInitialSet.call(this, offsetWidth, index1)
                                left2 = this.rangeInitialSet.call(this, offsetWidth, index2)
                                actWidth = this.rangeSliderFill(left1, left2, objj[handlerWidth])
                            }
                        else    
                            {
                                left1 = this.rangeInitialSet.call(this, offsetWidth, index)
                                actWidth.width =  index / ( this.getData( 'ltPropContent' ).length - 1 ) * objj[ width ] ;
                            }   
                    }
                else if(!rangeHandler)
                    {
                        left1 = this.initialValueSet.call(this, objj[width], objj[handlerWidth] , parseFloat(this.getData('ltPropValue')))
                        actWidth.width = ( ( parseFloat( this.getData( 'ltPropValue' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) * objj[width] );
                    }
                else
                    {
                        left1 = this.initialValueSet.call(this, objj[width], objj[handlerWidth], parseFloat( this.getData( 'ltPropMinValue' ) ) )
                        left2 = this.initialValueSet.call(this, objj[width], objj[handlerWidth], parseFloat( this.getData( 'ltPropMaxValue' ) ) )
                        actWidth = this.rangeSliderFill(left1, left2, objj[handlerWidth])
                    }
            handlers[ 0 ].style[ left ] = left1 + 'px';
            lyteSliderFill.style[ width ] = actWidth.width + 'px';
            if( handlers[ 1 ] ) {
                handlers[ 1 ].style[ left ] = left2 + 'px';
                lyteSliderFill.style[ left ] = actWidth.left + 'px';
            }       
        },  

        directionObsObs : function(){
            this.directionObs.call(this);
        }.observes('ltPropDirection'),

        directionObs : function(){
            if(this.getData('preventObs')){
                return;
            }
            $L.fastdom.mutate(function(){
                var lyteSliderHandler = this.$node.querySelector( '.lyteSliderHandler' );
                lyteSliderHandler.style.removeProperty( this.rtlfunc.call( this, 'left' ) );
                lyteSliderHandler.style.removeProperty('top');
                var lyteSliderFill = this.$node.querySelector( '.lyteSliderFill' );
                lyteSliderFill.style.removeProperty('width');
                lyteSliderFill.style.removeProperty('height');
                this.setData('preventObs', true);
                this.heightSet.call(this);
                // this.initialWork.call(this);
                $L.fastdom.measure( function() {
                    this.didConnectWrk.call(this);
                    this.setData('preventObs', false);
                }.bind( this ))
            }.bind(this))
        },

        MaxMinSet:function(){
                var scale=[], scaleText = this.getData( 'ltPropScaleUnit' );
                if(this.getData('ltPropContent').length)
                    {
                        scale.push(this.getData('ltPropContent')[0] + scaleText);
                        scale.push(this.getData('ltPropContent')[this.getData('ltPropContent').length-1] + scaleText)
                    }
                else    
                    {
                        scale.push(this.getData('ltPropMin') + scaleText);
                        scale.push(this.getData('ltPropMax') + scaleText);
                    }
                return scale;   
        },
        selectedVal:function(clientRect, nodeClientRect,ltPropHeight,node,left){
            var selectedVal, lyteSlide = this.$node.querySelector( 'div.lyteSlide' );
            var slideClientRect = clientRect[ltPropHeight];
            if(node)
                {
                    selectedVal = (((parseFloat(node.style[ left ]) + nodeClientRect[ltPropHeight]/2)/slideClientRect)*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin'))).toFixed( this.data.ltPropDigits );
                }
            else    
                {
                    selectedVal = (( parseFloat( this.$node.querySelector( 'div.lyteSliderFill' ).style[ ltPropHeight ] ) / slideClientRect)*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin'))).toFixed( this.data.ltPropDigits );
                }
            if(this.getData('ltPropContent').length)
                {
                    var numb = parseFloat(selectedVal)/parseFloat(this.getData('ltPropScaleInterval'));
                    if(selectedVal>100)
                        {
                            selectedVal=this.getData('ltPropContent')[this.getData('ltPropContent').length - 1];
                        }
                    else
                        {
                            selectedVal=this.getData('ltPropContent')[parseInt(parseFloat(numb).toFixed(0))];
                        }
                }
            return selectedVal; 
        },
        onSelect:function(flag){
            if(this.getMethods('onChange')||this.getMethods('onSelect'))
                {
                    if(!this.getData('ltPropRangeHandler'))
                        {
                            if(this.getMethods('onChange')) 
                                {
                                    this.executeMethod('onChange',this.getData('ltPropSelectedValue1'), this.$node) 
                                }
                            if(this.getMethods('onSelect') && flag) 
                                {
                                    this.executeMethod('onSelect',this.getData('ltPropSelectedValue1'), this.$node) 
                                }
                        }
                    else
                        {
                            if(this.getMethods('onChange')) 
                                {
                                    this.executeMethod('onChange', this.getData('ltPropSelectedValue1'), this.getData('ltPropSelectedValue2'), this.$node); 
                                }
                            if(this.getMethods('onSelect') && flag) 
                                {
                                    this.executeMethod('onSelect', this.getData('ltPropSelectedValue1'), this.getData('ltPropSelectedValue2'), this.$node); 
                                }
                        }
                }           
            },
        scroll:function(widthVal,offWidth){
                var discrete=parseFloat(this.getData('ltPropDiscrete'));
                var flag=false,flag1=false,flag2=false;
                if(widthVal>=parseFloat(this.getData('ltPropMax'))-(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))%discrete)
                    {
                        discrete=(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))%discrete;
                        flag1=true;
                        flag=true;
                    }
                else if(widthVal-parseFloat(this.getData('ltPropDiscrete'))/2<(parseFloat(this.getData('ltPropMin'))))
                    {
                        flag=true;
                        flag2=true;
                    }
                if(flag)                                    
                    {
                        if(widthVal>parseFloat(this.getData('ltPropMax'))-discrete/2)
                            {
                                if(flag1)
                                    {
                                        widthVal=parseFloat(this.getData('ltPropMax'))
                                    }
                                else
                                    {
                                        widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete+discrete;
                                    }
                            }
                        else
                            {
                                discrete=parseFloat(this.getData('ltPropDiscrete'))
                                if(flag2)
                                    {
                                        widthVal=parseFloat(this.getData('ltPropMin'))
                                    }
                                else
                                    {
                                        widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete;
                                    }
                            }
                    }
                else
                    {
                        if((widthVal-parseFloat(this.getData('ltPropMin')))%discrete>=parseFloat(this.getData('ltPropDiscrete'))/2)
                            {
                                widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete+discrete;
                            }
                        else
                            {
                                widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete;
                            }
                    }       
                return ((widthVal-parseFloat(this.getData('ltPropMin')))/(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))*offWidth);
        },  
        ScrollCheck:function(node,left1,width1,clientX1,offsetWidth1,ltPropWidth1,offsetLeft1,event){
            var isTch = event.type == "touchmove", evt = event; 
            if( isTch && event.touches.length != 1 ) {
                return
            } else if( isTch ) {
                evt = event.touches[ 0 ];
            }
            var step, flag = true, lyteHandler2, lyteHandler1, lyteRangeSlider, lyteSlide = this.$node.querySelector( 'div.lyteSlide'  ), handler1Client, handler2Client;
            var rangeHandler = this.getData( 'ltPropRangeHandler' ), sliderFill = this.$node.querySelector( 'div.lyteSliderFill' ), wwidth = window.innerWidth,
            evtt = this.rtlfunc.call( this, clientX1, evt, wwidth ), h1left, h2left, width, left;
            if( !rangeHandler )
                {   
                    width = evtt - this.rtlfunc.call( this, left1, sliderFill.getBoundingClientRect(), wwidth );
                }
            else
                {
                    lyteHandler2 = this.$node.querySelector( 'div.lyteHandler2' ),lyteHandler1= this.$node.querySelector( 'div.lyteHandler1' ), lyteRangeSlider= this.$node.querySelector( 'div.lyteRangeSlider' );
                    handler1Client = lyteHandler1.getBoundingClientRect(), handler2Client = lyteHandler2.getBoundingClientRect();
                    h2left = this.rtlfunc.call( this, left1, handler2Client, wwidth ); h1left = this.rtlfunc.call( this, left1, handler1Client, wwidth )
                    if(( h2left - h1left ) <= 0)    
                        {
                            if(this._elem)
                                {
                                    if( this._elem.classList.contains( 'lyteHandler1' ) )
                                        {
                                            if( evtt < ( h1left + handler1Client[ width1 ] ) && ( h2left - h1left ) == 0 )
                                                {
                                                    flag = true;
                                                }
                                            else
                                                {   
                                                    if(event.type == 'mousemove' || isTch )
                                                        {
                                                          flag = false
                                                        }
                                                }   
                                        }
                                    else if(this._elem.classList.contains('lyteHandler2'))
                                        {
                                            if( evtt > ( h2left ) && ( h2left - h1left ) == 0 )
                                                {   
                                                    flag=true;
                                                }
                                            else
                                                {
                                                    if(event.type=='mousemove' || isTch )
                                                        {
                                                            flag=false
                                                        }
                                                }   
                                        }
                                }       
                            else
                                {
                                    if(event.type=='mousemove' || isTch )
                                        {
                                            flag=false
                                        }
                                }   
                        }   
                    else
                        {
                            step = this.getData('ltPropDiscrete') ? parseFloat( this.getData( 'ltPropDiscrete' ) ) : 0;
                        }    
                width = evtt - this.rtlfunc.call( this, left1, lyteRangeSlider.getBoundingClientRect(), wwidth );   
                }
            if( this.getData( 'ltPropContent' ).length && event.type == 'click' )
                {
                    if( rangeHandler )
                        {
                            if( parseInt( h2left - h1left ) < 1 / ( this.getData( 'ltPropContent' ).length - 1 ) * this.$node[ ltPropWidth1 ] && evtt < ( h2left + handler2Client[ width1 ]) && evtt > ( h1left + handler1Client[ width1 ] ) )
                                {
                                    flag = false
                                }
                        }
                }       
            var discrete=parseFloat(this.getData('ltPropDiscrete')), lyteSliderHandler= this.$node.querySelector( 'div.lyteSliderHandler' );
            var nodeClientRect = node.getBoundingClientRect(), slideClientRect = lyteSlide.getBoundingClientRect();
            if(this.getData('ltPropDiscrete'))
                {   
                    var widthVal=((width/slideClientRect[width1])*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin')));
                    width=this.scroll.call(this,widthVal, slideClientRect[width1]);     
                }
                width=width < slideClientRect[width1] ? width : slideClientRect[width1];
                width=width>0?width:0;  
                left=(width-nodeClientRect[width1]/2);
                left=left>(slideClientRect[width1] -lyteSliderHandler[offsetWidth1]/2) ? slideClientRect[width1] - lyteSliderHandler[offsetWidth1]/2:left;
                left=left>-nodeClientRect[width1]/2?left:-nodeClientRect[width1]/2;
                if( rangeHandler )
                    {
                        if(node.classList.contains('lyteHandler1'))
                            {   
                                if( this.rtlfunc.call( this, offsetLeft1, lyteHandler2 ) < left )
                                    {
                                        flag=false
                                    }
                            }
                        else
                            {
                                if( this.rtlfunc.call( this, offsetLeft1, lyteHandler1 ) > left )
                                    {
                                        flag=false
                                    }
                            }   
                    }
                    // selected node need to be focused for keyboard events
                    node.focus()
                    if(flag)
                        {
                            left1 = this.rtlfunc.call( this, left1 );
                            if( !rangeHandler )
                                {
                                    sliderFill.style[width1]=width+'px';
                                }
                            else
                                {
                                    var leftx, lefty;
                                    if(node.classList.contains( 'lyteHandler1' )) {
                                        lefty = parseInt( lyteHandler2.style[ left1 ] )
                                        var co = this.minMaxCheck( slideClientRect, handler1Client, width1 )
                                        left = Math.min( Math.max( left, co[ 0 ] ), lefty - co[ 1 ] );
                                        leftx = left;
                                    } else {
                                        leftx = parseInt( lyteHandler1.style[ left1 ] )
                                        var co = this.minMaxCheck( slideClientRect, handler1Client, width1, true );
                                        left = Math.max( Math.min( left, co[ 0 ] ), leftx + co[ 1 ]);
                                        lefty = left;
                                    }
                                    var acWid = this.rangeSliderFill.call(this, leftx, lefty, handler1Client [ width1 ]);
                                    sliderFill.style[ left1 ] = acWid.left + 'px';
                                    sliderFill.style[ width1 ] = acWid.width + 'px';

                                }
                            node.style[ left1 ] = left + 'px';  
                        }
                    $L.fastdom.measure(function(){  
                        this.selectedValFind.call(this, slideClientRect, nodeClientRect)    
                    }.bind(this));
            event.stopPropagation();
            event.preventDefault();

            if( event && /mousemove|touchmove/i.test( event.type ) && node.tooltip && node.tooltip.refresh ){
                node.tooltip.refresh( { clientX : Math.max( Math.min( event.clientX, slideClientRect.right ), slideClientRect.left ) }, node.tooltip.tooltipSpan );
            }



        },

        minMaxCheck : function( slideClientRect, handler1Client, width1, flag ){
            var diffVal = this.getData( 'ltPropMinDiff' ) || 0, left1, conv = diffVal * slideClientRect[ width1 ] / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) );
            if( !flag ) {
                left1 = conv - ( handler1Client[ width1 ] / 2 )
            } else {
                left1 = slideClientRect[ width1 ] - conv - ( handler1Client[ width1 ] / 2 )
            }
            return [ left1, conv ]
        },

        selectedValFind : function(clientRect, nodeClientRect){
                this.setData('preventObs', true)
                if(!this.getData('ltPropRangeHandler'))
                    {
                        if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
                            {
                                this.setData('ltPropValue',this.selectedVal.call(this, clientRect, nodeClientRect,'height').toString());
                            }
                        else
                            {
                                this.setData('ltPropValue',this.selectedVal.call(this, clientRect, nodeClientRect,'width').toString());
                            }
                        this.setData('ltPropSelectedValue1',this.getData('ltPropValue'));   
                    }
                else
                    {
                        if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
                            {
                                this.setData('ltPropMinValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'height', this.$node.querySelector( 'div.lyteHandler1' ), 'top').toString());
                                this.setData('ltPropMaxValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'height', this.$node.querySelector( 'div.lyteHandler2' ),'top').toString());
                            }
                        else
                            {
                                var lt = this.rtlfunc.call( this, 'left' );
                                this.setData('ltPropMinValue', this.selectedVal.call(this, clientRect, nodeClientRect, 'width', this.$node.querySelector( 'div.lyteHandler1' ), lt ).toString());
                                this.setData('ltPropMaxValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'width', this.$node.querySelector( 'div.lyteHandler2' ), lt ).toString());
                            }
                        this.setData('ltPropSelectedValue1',this.getData('ltPropMinValue'));
                        this.setData('ltPropSelectedValue2',this.getData('ltPropMaxValue'));    
                    }   
                this.setData('preventObs', false)
            // }.bind(this))
        },

        initialValueSet : function(width, handlerWidth, value){
            var max = parseFloat( this.getData( 'ltPropMax' ) ), min = parseFloat( this.getData( 'ltPropMin' ) );
            return ( ( ( value - min ) / ( max - min ) * ( width ) ) - ( handlerWidth ) / 2 )
        },
        rangeSliderFill:function(left1, left2, handlerWidth){
            return {width : left2 - left1, left : left1 + handlerWidth / 2 }
        },
        keyCheck:function(event, node,width1,left1,offsetWidth,ltPropWidth){
            // while keydown action
            left1 = this.rtlfunc.call( this, left1 );
            var flag=true, lyteSliderFill = this.$node.querySelector( 'div.lyteSliderFill' ), wwidth = window.innerWidth;
            var nodeClientRect = node.getBoundingClientRect(), left, actWidth = {}, rangeHandler = this.getData('ltPropRangeHandler');
            var thisRect = this.$node.getBoundingClientRect(), fact = 1, handlers = this.$node.querySelectorAll( 'div.lyteSliderHandler' );
            var direction = this.getData('ltPropDirection').indexOf('Horizontal') != -1;
            var step = parseFloat(this.getData('ltPropStep'));
            if( !step ) {
                step = parseFloat( this.getData( 'ltPropMax' ) ) * .1;
            }
            if( this._dir ) {
                if( event.keyCode == 39 && direction ) {
                    fact = -1;
                }
            } else {
                if( event.keyCode == 37 && direction || event.keyCode == 38 && !direction ) {
                    fact = -1
                }
            }

            left = parseFloat( node.style[ left1 ] ) + ( step / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) * thisRect[ width1 ] * fact );
            left  = Math.min( Math.max( -nodeClientRect[ width1 ] / 2, left), thisRect[ width1 ] -nodeClientRect[ width1 ] / 2 )
            if( !rangeHandler ) {
                actWidth.width  =  left + nodeClientRect[ width1 ] / 2 ;
            } else {
                var leftx, lefty;
                if(node == handlers[0]){
                    lefty = parseInt( handlers[ 1 ].style[ left1 ] )
                    var co = this.minMaxCheck( thisRect, nodeClientRect, width1 )
                    left = Math.min( Math.max( left, co[ 0 ] ), lefty - co[ 1 ] );
                    leftx = left;
                } else {
                    leftx = parseInt( handlers[ 0 ].style[ left1 ] )
                    var co = this.minMaxCheck( thisRect, nodeClientRect, width1, true );
                    left = Math.max( Math.min( left, co[ 0 ] ), leftx + co[ 1 ]);
                    lefty = left;
                }
                if( leftx > lefty ) {
                    var currLeft = parseInt( handlers[ 0 ].style[ left1 ] );
                    if( currLeft == lefty ) {
                        return
                    } else {
                        if( event.keyCode == 37 || event.keyCode == 38 ) {
                            lefty = left = leftx;
                        } else if( event.keyCode == 39 || event.keyCode == 40 ) {
                            leftx = left = lefty;
                        }
                    }
                }
                actWidth = this.rangeSliderFill.call(this, leftx, lefty, nodeClientRect[width1]);
            }
            node.style[ left1 ] = left + 'px';
            lyteSliderFill.style[ width1 ] = actWidth.width + 'px';
            if(rangeHandler) {
                lyteSliderFill.style[ left1 ] = actWidth.left + 'px';
            }
            $L.fastdom.measure(function(){
                this.selectedValFind.call(this, thisRect, nodeClientRect)
            }.bind(this))
        },
        mousemove : function(event){
            this._mousemoved = true;
            if(!this._flag ) {
                this._flag = true;
            }
            var left, width, clientX, offsetWidth, offsetWidth, ltPropWidth, offsetLeft;
            if( this.getData( 'ltPropDirection' ).indexOf( 'Horizontal' ) != -1 )
                {
                    left = 'left', width = 'width', clientX = 'clientX', offsetWidth = 'offsetWidth', offsetWidth = 'offsetWidth', ltPropWidth = 'ltPropWidth', offsetLeft = 'offsetLeft';
                }
            else
                {
                    left = 'top', width = 'height', clientX = 'clientY', offsetWidth = 'offsetHeight', offsetWidth = 'offsetHeight', ltPropWidth = 'ltPropHeight', offsetLeft = 'offsetTop';
                }
                this.ScrollCheck.call( this, this._elem, left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                $L.fastdom.measure(function(){
                    if( this.getMethods( 'onChange' ) ) {
                        this.onSelect.call( this ); 
                    }
            }.bind(this))           
        },
        eventListener:function(event, elem){
            var isTch = event.type == "touchstart", evt = isTch ? event.touches[ 0 ] : event, wwidth = window.innerWidth, height, xPos = this.rtlfunc.call( this, 'clientX', evt, wwidth ), lyteRangeSlider = this.$node.querySelector( 'div.lyteRangeSlider' );
            var clientRect = lyteRangeSlider.getBoundingClientRect()
            if( xPos > this.rtlfunc.call( this, 'left', 'clientRect', wwidth ) ) {
                    var width = xPos - this.rtlfunc.call( this, 'left', 'clientRect', wwidth ) - parseFloat( clientRect.width - parseFloat( clientRect.width / 2 ) );
                    if( width > 0 ) {
                            event.preventDefault();
                        }
                }
            else {
                    event.preventDefault();
                }
            var yPos = evt.clientY;
            if( yPos >= clientRect.top ) {
                    height = yPos - clientRect.top - parseFloat( clientRect.height - parseFloat( clientRect.height / 2 ) );
                    if( height > 0 ) {
                        event.preventDefault();
                    }
                }
            else {
                    event.preventDefault();
                }
            this._mousemove = this.mousemove.bind(this);
            this._mouseup = this.mouseup.bind(this);
            this._elem = elem;  
            document.addEventListener( isTch ? "touchmove" : 'mousemove', this._mousemove,true);
            document.addEventListener( isTch ? "touchend" : 'mouseup', this._mouseup, true);
        }, 
        rangeInitialSet:function(offsetWidth,index){
            return ( index / ( this.getData( 'ltPropContent' ).length - 1 ) * this.$node[ offsetWidth ] - this.$node.querySelector( 'div.lyteSliderHandler' )[ offsetWidth ] / 2 );
        },
        didConnect:function(){            
            this.directionObs.call(this)
            this.valueSelected.call(this);
            $L.fastdom.mutate(function(){
                if(this.getMethods('afterRender')){
                   /**
                    * @method afterRender
                    * @version 1.0.1
                    */
                    this.executeMethod('afterRender', this.$node);
                }
            }.bind(this))   
        },
        valueSelected : function(){
            if(this.getData('ltPropRangeHandler'))
                {
                    this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
                    this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
                }
            else
                {
                    this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));
                }   
        },
        mouseup : function(event){
            var handler= this.$node.querySelector( 'div.lyteRangeSlider' ), isTch = event.type == "touchend";
            document.removeEventListener( isTch ? "touchmove" : 'mousemove', this._mousemove,true);
            document.removeEventListener( isTch ? "touchend" : 'mouseup', this._mouseup, true);
            delete this._mousemove; delete this._mouseup;
            delete this._elem;
            if( this.$node.contains( event.correspondingElement || event.target ) ) {
                this._prevclick = true;
            }
            if( this._mousemoved ){
                $L.fastdom.measure( this.onSelect.bind( this, true ) ); 
            }
            delete this._mousemoved;
        },

        data:function(){
            return {
                divLength:Lyte.attr("array",{"default":[]}),
                scaleVal:Lyte.attr("array",{"default":[]}),
                /**
                 * @componentProperty {string} ltPropMin=0
                 * @version 1.0.0
                 */
                ltPropMin:Lyte.attr("string",{"default":'0'}),
                /**
                 * @componentProperty {string} ltPropMax=''
                 * @version 1.0.0
                 */
                ltPropMax:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropScaleInterval=''
                 * @version 1.0.0
                 */
                ltPropScaleInterval:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropStep=''
                 * @version 1.0.0
                 */
                ltPropStep:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {lyteArrow | lyteArrowLeft | lyteCircle | lyteSquare} ltPropHandler=lyteArrow
                 * @version 1.0.0
                 */
                ltPropHandler:Lyte.attr("string",{"default":'lyteArrow'}),
                /**
                 * @componentProperty {lyteHorizontal | lyteVertical} ltPropDirection=lyteHorizontal
                 * @version 1.0.0
                 */
                ltPropDirection:Lyte.attr("string",{"default":'lyteHorizontal'}),
                /**
                 * @componentProperty {string} ltPropWidth=''
                 * @version 1.0.0
                 */
                ltPropWidth:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {colorString} ltPropFillColor=''
                 * @version 1.0.0
                 */
                ltPropFillColor:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {colorString} ltPropNonFillColor=''
                 * @version 1.0.0
                 */
                ltPropNonFillColor:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropHeight=''
                 * @version 1.0.0
                 */
                ltPropHeight:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropValue=''
                 * @version 1.0.0
                 */
                ltPropValue:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropDiscrete=''
                 * @version 1.0.0
                 */
                ltPropDiscrete:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string[]} ltPropContent
                 * @default []
                 * @version 1.0.0
                 */
                ltPropContent:Lyte.attr("array",{"default":[]}),
                /**
                 * @componentProperty {string} ltPropRangeHandler=false
                 * @version 1.0.0
                 */
                ltPropRangeHandler:Lyte.attr("boolean",{"default": false}),
                /**
                 * @componentProperty {string} ltPropMinValue=''
                 * @version 1.0.0
                 */
                ltPropMinValue:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropMaxValue=''
                 * @version 1.0.0
                 */
                ltPropMaxValue:Lyte.attr("string",{"default":''}),
                /**
                 * @componentProperty {string} ltPropDisabled=false
                 * @version 1.0.0
                 */
                ltPropDisabled:Lyte.attr("boolean",{"default": false}),
                /**
                 * @componentProperty {string} ltPropSelectedValue1=''
                 * @version 1.0.0
                 */
                ltPropSelectedValue1 : Lyte.attr('string', {default : ''}),
                /**
                 * @componentProperty {string} ltPropSelectedValue2=''
                 * @version 1.0.0
                 */
                ltPropSelectedValue2 : Lyte.attr('string', {default : ''}),
                /**
                 * @componentProperty {string} ltPropYield=false
                 * @version 1.0.0
                 */
                ltPropYield : Lyte.attr('boolean', {default : false}),
                /**
                 * @componentProperty {string} ltPropTooltipStyle=''
                 * @version 1.0.2
                 */
                ltPropTooltipStyle : Lyte.attr('string', { default : ''}),
                /**
                 * @componentProperty {string} ltPropTooltip=''
                 * @version 1.0.2
                 */
                ltPropTooltip : Lyte.attr( 'boolean', { default : true}),
                /**
                 * @componentProperty {string} ltPropScaleUnit=''
                 * @version 1.0.2
                 */
                ltPropScaleUnit : Lyte.attr( 'string' , { default : '' } ),
                /**
                 * @componentProperty {string} ltPropTooltipClass=''
                 * @version 1.0.2
                 */
                ltPropTooltipClass : Lyte.attr('string', { default : ''}),
                
                /**
                 * @typedef {object} sliderConfig
                 * @property {number} margin=5
                 * @property {left | right | top | bottom | topright | bottomright | topleft | bottomleft} position=top
                 * @property {box | callout} appearance=callout
                 * @property {number} showdelay=0
                 * @property {number} hidedelay=0
                 * @property {number} maxdisplaytime=5000
                 * @property {boolean} keeptooltip=false
                 */

                /**
                 * @componentProperty {sliderConfig} ltPropTooltipConfig
                 * @default {}
                 * @version 1.0.2
                 */
                ltPropTooltipConfig : Lyte.attr('object'),
                /**
                 * @componentProperty {number} ltPropMinDiff=0
                 * @version 1.0.2
                 */
                ltPropMinDiff : Lyte.attr( 'number', { default : 0 } ),
                /**
                 * @componentProperty {number} ltPropDigits=2
                 * @version 1.0.8
                 */
                ltPropDigits : Lyte.attr( 'number', { default : 2 } ),

                //system data
                preventObs : Lyte.attr('boolean', { default : false})
            }
        },
        actions:{
            "click":function(event){
                    if( this._prevclick ){      
                        delete this._prevclick;     
                        return;     
                    }
                    var left = 'left', width = "width", clientX = 'clientX', offsetWidth = 'offsetWidth', ltPropWidth = 'ltPropWidth', offsetLeft = 'offsetLeft', wwidth = window.innerWidth;
                    if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
                        {
                            left = 'top', width = "height", clientX = 'clientY', offsetWidth = 'offsetHeight', ltPropWidth = 'ltPropHeight', offsetLeft = 'offsetTop'
                        }
                    if(!this.getData('ltPropRangeHandler'))
                        {
                            this.ScrollCheck.call(this, this.$node.querySelector( 'div.lyteSliderHandler' ), left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                        }
                    else
                        {
                            var YPos= this.rtlfunc.call( this, clientX, event, wwidth );
                            var node1= this.$node.querySelector( 'div.lyteHandler1' )
                            var node2= this.$node.querySelector( 'div.lyteHandler2' )
                            var node1client = node1.getBoundingClientRect(), node2client = node2.getBoundingClientRect();
                            if( Math.abs( this.rtlfunc.call( this, left, node1client, wwidth ) - this.rtlfunc.call( this, left, node2client, wwidth ) ) > 0 )
                                {
                                    if(this.rtlfunc.call( this, left, node1client, wwidth ) + node1client[ width ] + Math.abs(this.rtlfunc.call( this, left, node1client, wwidth ) - this.rtlfunc.call( this, left, node2client, wwidth ) ) / 2 < YPos )
                                        {
                                            this.ScrollCheck.call(this,node2,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                                        }
                                    else if(this.rtlfunc.call( this, left, node1client, wwidth ) + node1client[ width ] + Math.abs(this.rtlfunc.call( this, left, node1client, wwidth ) - this.rtlfunc.call( this, left, node2client, wwidth ) ) / 2 != YPos )
                                        {
                                            this.ScrollCheck.call(this,node1,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                                        }   
                                }
                            else if( this.rtlfunc.call( this, left, node1client, wwidth ) == this.rtlfunc.call( this, left, node2client, wwidth ) )     
                                {   
                                    if( YPos < this.rtlfunc.call( this, left, node1client, wwidth ) )   
                                        {
                                            this.ScrollCheck.call(this,node1,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                                        }
                                    else
                                        {
                                            this.ScrollCheck.call(this,node2,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
                                        }   
                                }
                        }
                    $L.fastdom.measure(function(){
                        this.onSelect.call(this, true); 
                    }.bind(this))
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    event.preventDefault();
            },

            keydown : function( evt ){
                var keycode = evt.keyCode || evt.which,
                data = this.data,
                is_hori = /horizontal/i.test( data.ltPropDirection ),
                discrete = data.ltPropDiscrete;

                if( !/^37|38|39|40$/.test( keycode ) || ( /^37|39$/.test( keycode ) && !is_hori ) || ( /^38|40$/.test( keycode ) && is_hori ) ){
                    return;
                }

                if( discrete ){
                    this.setData( 'ltPropStep', discrete );
                }

                var node = evt.target,
                width = 'width',
                left = 'left',
                offsetWidth = 'offsetWidth',
                ltPropWidth = 'ltPropWidth';

                if( !is_hori ){
                    width = 'height';
                    left = 'top';
                    offsetWidth = "offsetHeight";
                    ltPropWidth = 'ltPropHeight';
                }

                if( !data.ltPropRangeHandler ){
                    node = this.$node.querySelector( 'div.lyteSliderHandler' );
                }
                this.keyCheck( evt, node, width, left, offsetWidth, ltPropWidth );

                $L.fastdom.mutate( this.onSelect.bind( this, true ) );
                evt.stopPropagation();
                evt.stopImmediatePropagation();
                evt.preventDefault();
            },

            "mousedown" : function( evt , elem) {
                if( evt.button == 2 ){
                    return;
                }
                this.eventListener.call(this, evt, elem)
            }
        }
    });

/**
 * @syntax nonYielded
 * <lyte-slider lt-prop-min="0" lt-prop-max="100" lt-prop-discrete="15" lt-prop-value="45" lt-prop-direction="lyteHorizontal" lt-prop-handler="lyteArrow" ></lyte-slider>
 */

 /**
  * @syntax yielded
  * <lyte-slider lt-prop-max = '100' lt-prop-width='600px' lt-prop-value = '50' lt-prop-discrete = '20' lt-prop-yield = true> 
  *    <template is = "registerYield" yield-name = "yield"> 
  *        <div class="lyteScaleOption"> 
  *            <span class="lyteScaleLine" style="left:0%"> 
  *                <span></span> 
  *                <span class="lyteScaleLabel">0</span> 
  *            </span> 
  *            <span class="lyteScaleLine" style="left:50%"> 
  *                <span></span> 
  *                <span class="lyteScaleLabel">50</span> 
  *            </span> 
  *            <span class="lyteScaleLine" style="left:100%"> 
  *                <span></span> 
  *                <span class="lyteScaleLabel">100</span> 
  *            </span> 
  *        </div> 
  *    </template> 
  *  </lyte-slider> 
  */

/**
 * Step indicates the stage or phase of a work within a navigational hierarchy and automatically adds separators between them
 * @component lyte-step
 * @version 1.0.0
 * @methods onClick
 * @utility next,previous,goto
 */

Lyte.Component.register('lyte-step', {
_template:"<template tag-name=\"lyte-step\"> <div onclick=\"{{action('divClick',event,this)}}\"> <template is=\"if\" value=\"{{expHandlers(ltPropType,'!=',&quot;advanced&quot;)}}\"><template case=\"true\"><template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-step-structure class=\"{{ltPropClass}}\" onclick=\"{{action('divClick',event,this)}}\"> <template is=\"for\" items=\"{{ltPropData}}\" item=\"array\" index=\"indexVal\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(array),'==',false)}}\"><template case=\"true\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStepBullet')}}\"><template case=\"true\"> <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-step-body> {{array}} </lyte-step-body> <lyte-step-head>{{indexVal}}</lyte-step-head> </lyte-step-item> </template><template case=\"false\"> <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-step-body> {{array}} </lyte-step-body> </lyte-step-item> </template></template></template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStepBullet')}}\"><template case=\"true\"> <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-step-body> {{array[ltPropLabel]}} </lyte-step-body> <lyte-step-head>{{array[ltPropOption]}}</lyte-step-head> </lyte-step-item> </template><template case=\"false\"> <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick',event,this,array)}}\"> <lyte-step-body> {{array[ltPropLabel]}} </lyte-step-body> </lyte-step-item> </template></template></template></template></template> </lyte-step-structure> </template><template case=\"false\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template></template><template case=\"false\"> <lyte-yield class=\"lyteStepAdvanced\" yield-name=\"yield\" lt-prop-content=\"{{dummyContent}}\"></lyte-yield> </template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropClass","ltPropData","ltPropSelected","ltPropSkip","ltPropActiveClass","ltPropCompletedClass","ltPropWarningClass","ltPropKeepMarked","ltPropYield","ltPropLabel","ltPropOption","ltPropType","ltPropOffset","ltPropIndex","ltPropDataType","ltPropAria","ltPropAriaValue","dummyContent","widthArr","divWidth","forwardWidth","backwardWidth"],
    init: function () {
        /**
         * @method beforeRender
         * @version 1.0.1
         */
        this.getMethods('beforeRender') && this.executeMethod('beforeRender', this.$node)
    },

    didDestroy: function () {
        delete this.$node.next; delete this.$node.previous; delete this.$node.goto;
        delete this._finalCallback; delete this._transEnd;
        clearTimeout(this._animetime);
    },

    didConnect: function () {
        var type = this.getData('ltPropType') == "advanced";
        this.$node.next = function (state) {
            this.$node.goto(this.data.ltPropSelected + 1, state, true)
        }.bind(this);
        this.$node.previous = function (state) {
            this.$node.goto(this.data.ltPropSelected - 1, state, true)
        }.bind(this);

        if (!type) {
            this.$node.goto = function (number, state, flag) {
                if (this.component.getData('ltPropSkip') || flag) {
                    var elements = this.querySelectorAll('lyte-step-item'), ltPropSelected = this.component.getData('ltPropSelected'), ltPropWarningClass = this.component.getData('ltPropWarningClass');
                    var selectedElement = elements[ltPropSelected], ltPropCompletedClass = this.component.getData('ltPropCompletedClass'), ltPropActiveClass = this.component.getData('ltPropActiveClass')
                    if (number >= -1 && elements.length) {
                        if (state == 'incomplete') {
                            selectedElement.classList.add(ltPropWarningClass)
                        }
                        else {
                            selectedElement.classList.add(ltPropCompletedClass)
                        }
                        selectedElement.classList.remove(ltPropActiveClass)
                        if (number == elements.length) {
                            number--;
                        }
                        else if (number == -1) {
                            number++;
                        }
                        elements[number].classList.add(ltPropActiveClass);
                        if (number == ltPropSelected) {
                            selectedElement.classList.remove(ltPropWarningClass);
                            selectedElement.classList.remove(ltPropCompletedClass);
                        }
                        else {
                            this.component.setData('ltPropSelected', number);
                        }
                    }
                }
            }
        } else {
            this.$node.goto = function (number, state, flag) {
                if (this.getData('ltPropSkip') || flag) {
                    this.moveTo(number, state, this.getData('ltPropSelected'));
                }
            }.bind(this);

            this.$node.refreshStep = this._measureWidth.bind(this, this.constructForward);
        }
        $L.fastdom.measure(function () {
            var fg = _lyteUiUtils.getRTL();
            $L.fastdom.mutate(function () {
                if (fg) {
                    this.$node.classList.add('lyteRTL')
                }
                this.breadcrumbClass.call(this);
            }.bind(this))
        }.bind(this))
        if (type) {
            if (this.getMethods('afterRender')) {
                this._finalCallback = this.executeMethod.bind(this, this.$node);
            }
        } else {
            /**
             * @method afterRender
             * @version 1.0.1
             */
            this.getMethods('afterRender') && this.executeMethod('afterRender', this.$node);
        }

        this._transEnd = this.transfade.bind(this);
    },

    selectedElementFindObs: function (arg) {
        if (this.getData('ltPropType') != "advanced") {
            $L.fastdom.mutate(this.selectedElementFind.bind(this));
        } else if (arg && !this._preventselect) {
            this.$node.goto(arg.newValue, '', true);
            var index = this.getData('ltPropIndex');

            if (arg.newValue < index || arg.newValue > index + this.getData('dummyContent').length) {
                this._enableAnimate = true;
                this.setData('ltPropIndex', arg.newValue);
            }

        }
    }.observes('ltPropSelected').on('didConnect'),

    selectedElementFind: function () {
        var ltPropSelected = parseInt(this.getData('ltPropSelected')), ltPropActiveClass = this.getData('ltPropActiveClass'), elements = $L('lyte-step-item', this.$node), ltPropComplete = this.getData('ltPropCompletedClass'), ltPropWarningClass = this.getData('ltPropWarningClass');
        if (elements.length) {
            var length = this.getData('ltPropKeepMarked') ? ltPropSelected : (elements.length - 1);
            for (var j = 0; j < elements.length; j++) {
                elements.eq(j).removeClass(ltPropActiveClass);
                this.data.ltPropAria && elements.eq(j).find('a').removeAttribute('aria-current');
            }
            elements.eq(ltPropSelected).addClass(ltPropActiveClass).removeClass(ltPropWarningClass, ltPropComplete);

            this.data.ltPropAria && elements.eq(ltPropSelected).find('a').attr('aria-current', this.data.ltPropAriaValue);

            for (var i = 0; i <= length; i++) {
                if (i < ltPropSelected) {
                    if (!elements.eq(i).hasClass(ltPropWarningClass)) {
                        elements[i].classList.add(ltPropComplete)
                    }
                } else if (i > ltPropSelected) {
                    elements.eq(i).removeClass(ltPropWarningClass, ltPropComplete);
                }
            }
        }
    },

    ArrayContentChangeObs: function () {
        this.ArrayContentChange.call(this);
    }.observes('ltPropData.[]', 'ltPropData'),

    ArrayContentChange: function () {
        if (this.getData('ltPropSelected') == undefined) {
            this.setData('ltPropSelected', 0)
        }
        else {
            this.selectedElementFind.call(this);
        }
    },

    breadcrumbClassObs: function () {
        this.breadcrumbClass.call(this);
    }.observes('ltPropClass'),

    breadcrumbClass: function () {
        if (this.getData('ltPropType') != "advanced") {
            if (this.data.ltPropYield && this.data.ltPropClass) {
                this.$node.querySelector('lyte-step-structure').classList.add(this.data.ltPropClass)
            }
        }
    },
    data: function () {
        return {
            //  user data
            /**
             * @componentProperty {lyteStepSlash | lyteStepArrow | lyteStepBullet | lyteStepFlat | lyteStepPlain} ltPropClass=lyteStepSlash
             * @version 1.0.0
             */
            ltPropClass: Lyte.attr("string", { "default": 'lyteStepSlash' }),
            /**
             * @componentProperty {string[] | object[]} ltPropData
             * @default []
             * @version 1.0.0
             */
            ltPropData: Lyte.attr("array", { "default": [] }),
            /**
             * @componentProperty {number} ltPropSelected=0
             * @version 1.0.0
             */
            ltPropSelected: Lyte.attr("number", { "default": 0 }),
            /**
             * @componentProperty {boolean} ltPropSkip=true
             * @version 1.0.0
             */
            ltPropSkip: Lyte.attr("boolean", { "default": true }),
            /**
             * @componentProperty {string} ltPropActiveClass=lyteActive
             * @version 1.0.0
             */
            ltPropActiveClass: Lyte.attr("string", { "default": 'lyteActive' }),
            /**
             * @componentProperty {string} ltPropCompletedClass=lyteCompleted
             * @version 1.0.0
             */
            ltPropCompletedClass: Lyte.attr("string", { "default": 'lyteCompleted' }),
            /**
             * @componentProperty {string} ltPropWarningClass=lyteWarning
             * @version 1.0.0
             */
            ltPropWarningClass: Lyte.attr("string", { "default": 'lyteWarning' }),
            /**
             * @componentProperty {boolean} ltPropKeepMarked=false
             * @version 1.0.0
             */
            ltPropKeepMarked: Lyte.attr("boolean", { "default": false }),
            /**
             * @componentProperty {boolean} ltPropYield=false
             * @version 1.0.0
             */
            ltPropYield: Lyte.attr("boolean", { "default": false }),
            /**
             * @componentProperty {string} ltPropLabel=''
             * @version 1.0.0
             */
            ltPropLabel: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {string} ltPropOption=''
             * @version 1.0.0
             */
            ltPropOption: Lyte.attr('string', { 'default': '' }),

            /**
             * @componentProperty {default | advanced} ltPropType
             * @version 2.2.6
             */
            ltPropType: Lyte.attr('string', { default: undefined }),
            /**
             * @componentProperty {number} ltPropOffset=0
             * @version 2.2.6
             */
            ltPropOffset: Lyte.attr('number', { default: 0 }),
            /**
             * @componentProperty {number} ltPropIndex=0
             * @version 2.2.6
             */
            ltPropIndex: Lyte.attr('number', { default: 0 }),
            /**
             * @experimental ltPropDataType
             */
            ltPropDataType: Lyte.attr('array', { default: [] }),

            // aria
            /**
             * @componentProperty {boolean} ltPropAria=false
             * @version 3.1.0
             */
            ltPropAria: Lyte.attr('boolean', { default: false }),
            /**
             * @componentProperty {string} ltPropAriaValue=step
             * @version 3.1.0
             */
            ltPropAriaValue: Lyte.attr('string', { default: 'step' }),

            // system data

            dummyContent: Lyte.attr('array', { default: [] }),
            widthArr: Lyte.attr('array', { default: [] }),
            divWidth: Lyte.attr('number', { default: 0 }),
            forwardWidth: Lyte.attr('number', { default: 0 }),
            backwardWidth: Lyte.attr('number', { default: 0 })
        }
    },
    actions: {
        'onclick': function (event, Component, data) {
            if ((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank') { return false; }
            if (this.getMethods('onClick')) {
                this.executeMethod('onClick', Component, this.$node, event, data);
                event.stopPropagation();
            }
        },
        divClick: function (event, div) {
            if (this.getData('ltPropType') != 'advanced') {
                if ((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank') { return false; }
                if (this.getMethods('onClick') && this.getData('ltPropYield')) {
                    var node = event.target.correspondingElement || event.target;
                    while (node && node != div) {
                        if (node.tagName == 'LYTE-STEP-ITEM') {
                            this.executeMethod('onClick', node, this.$node, event, node.getAttribute('data-value'))
                            break;
                        } else {
                            node = node.parentNode;
                        }
                    }
                }
            } else {
                if (this._transstart) {
                    return;
                }
                var close = $L(event.target).closest('lyte-step-forward');
                if (close.length) {
                    /**
                     * @method onBeforeNavigate
                     * @condition ltPropType advanced
                     * @version 2.2.6
                     */
                    if (this.getMethods('onBeforeNavigate') && this.executeMethod('onBeforeNavigate', 'forward', this.getData('ltPropIndex'), this.$node) == false) {
                        return;
                    }
                    this._enableAnimate = true;
                    this.setData('ltPropIndex', Math.max(0, this.getData('ltPropIndex') + this.getData('dummyContent').length));

                    if (this.getMethods('onNavigate')) {
                        /**
                         * @method onNavigate
                         * @condition ltPropType advanced
                         * @version 2.2.6
                         */
                        this._finalCallback = this.executeMethod.bind(this, 'onNavigate', 'forward', this.getData('ltPropIndex'), this.$node);
                    }
                } else {
                    close = $L(event.target).closest('lyte-step-backward');
                    if (close.length) {
                        if (this.getMethods('onBeforeNavigate') && this.executeMethod('onBeforeNavigate', 'backward', this.getData('ltPropIndex'), this.$node) == false) {
                            return;
                        }
                        this._transstart = true;
                        this._transendback = this.constructBackward;
                        $L('lyte-step-structure', this.$node).on('transitionend', this._transEnd).addClass('lyteStepFade');
                        this.timeout();
                        if (this.getMethods('onNavigate')) {
                            this._finalCallback = this.executeMethod.bind(this, 'onNavigate', 'backward', this.getData('ltPropIndex'), this.$node);
                        }
                    } else {
                        if ((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank') {
                            return false;
                        }
                        close = $L(event.target).closest('lyte-step-item');
                        if (close.length) {
                            this.getMethods('onClick') && this.executeMethod('onClick', close.get(0), this.$node, event, close.attr('data-value'));
                        }
                    }
                }
            }
        }
    },

    forwardAdd: function (min, width, divWidth, consWid, newArr, data) {
        for (var i = min; i < width.length; i++) {

            if (consWid + width[i] > divWidth) {
                i--;
                break;
            }
            consWid += width[i];
            newArr.push(data[i]);
        }
        return { consWid: consWid, i: i };
    },

    backwardAdd: function (min, width, divWidth, consWid, newArr, data) {
        for (var i = min - 1; i >= 0; i--) {
            if (consWid + width[i] > divWidth) {
                break;
            }
            consWid += width[i];
            newArr.unshift(data[i]);
            min = i;
        }
        return { consWid: consWid, min: min };
    },

    constructBackward: function (forward, backward) {
        forward = forward || $L('lyte-step-forward').get(0);
        backward = backward || $L('lyte-step-backward').get(0);

        var data = this.getData('ltPropData'),
            min = Math.min(data.length, this.getData('ltPropIndex') + this.getData('ltPropOffset')),
            consWid = 0,
            newArr = [],
            width = this.getData('widthArr'),
            forwardWidth = this.getData('forwardWidth'),
            backwardWidth = this.getData('backwardWidth'),
            divWidth = this.getData('divWidth');

        consWid += backwardWidth;

        var ret = this.backwardAdd(min, width, divWidth, consWid, newArr, data);
        consWid = ret.consWid;
        min = ret.min;
        if (min == 0) {
            consWid -= backwardWidth;
            if (backward) {
                backward.classList.add('lyteStepHidden');
            }
        }

        if (consWid < divWidth) {
            var ret = this.forwardAdd((min + newArr.length), width, divWidth, consWid, newArr, data);
            consWid = ret.consWid;
        }
        if (min + newArr.length < data.length) {
            if (forward) {
                forward.classList.remove('lyteStepHidden');
            }
            consWid += forwardWidth;
            // var i = min;
            while (consWid > divWidth && newArr.length) {
                consWid -= width[min + newArr.length];
                // min++;
                newArr.pop();
                // newArr.shift();
            }
        }
        this._prevent = true;
        this.setData('ltPropIndex', min);
        delete this._prevent;
        this._arr = newArr;
        this.transend();
    },

    transend: function () {
        this.setData('dummyContent', this._arr);
        delete this._arr;
        if (this._finalCallback) {
            this._finalCallback();
            delete this._finalCallback;
        }
        this.moveTo(this.getData('ltPropSelected'), '', this.getData('ltPropSelected'), this.getData('ltPropIndex') + this.getData('dummyContent').length == this.getData('ltPropData').length);
        $L('.lyteStepFade', this.$node).removeClass('lyteStepFade')
    },

    constructForward: function (forward, backward) {
        forward = forward || $L('lyte-step-forward').get(0);
        backward = backward || $L('lyte-step-backward').get(0);
        var min = Math.max(0, this.getData('ltPropIndex') - this.getData('ltPropOffset')),
            consWid = 0,
            newArr = [],
            width = this.getData('widthArr'),
            forwardWidth = this.getData('forwardWidth'),
            backwardWidth = this.getData('backwardWidth'),
            divWidth = this.getData('divWidth'),
            data = this.getData('ltPropData');

        if (min != 0) {
            consWid += backwardWidth;
            if (backward) {
                backward.classList.remove('lyteStepHidden');
            }
        } else {
            if (backward) {
                backward.classList.add('lyteStepHidden');
            }
        }

        var ret = this.forwardAdd(min, width, divWidth, consWid, newArr, data),
            i = ret.i;

        consWid = ret.consWid;
        if (i < width.length) {
            while (consWid + forwardWidth > divWidth && i) {
                consWid -= width[i];
                i--;
                newArr.pop();
            }
            if (forward) {
                forward.classList.remove('lyteStepHidden');
            }
        } else {
            if (forward) {
                forward.classList.add('lyteStepHidden')
            }
            if (consWid < divWidth) {
                ret = this.backwardAdd(min, width, divWidth, consWid, newArr, data);
                consWid = ret.consWid;
                min = ret.min;
            }
            if (min == 0 && this.getData('ltPropIndex')) {
                consWid -= backwardWidth;
                consWid = this.forwardAdd(min + newArr.length, width, divWidth, consWid, newArr, data);
            }
        }
        this._prevent = true;
        this.setData('ltPropIndex', min);
        delete this._prevent;

        this._arr = newArr;
        this.transend();
    },

    measureWidth: function () {
        if (this.getData('ltPropType') == "advanced") {
            this._measureWidth(this.constructForward);
        }
    }.on('didConnect'),

    indexObs: function (arg) {
        if (this._prevent) {
            return;
        }
        if (this._enableAnimate) {
            this._transstart = true;
            delete this._enableAnimate;
            this.timeout();
            $L('lyte-step-structure', this.$node).on('transitionend', this._transEnd).addClass('lyteStepFade');
        } else {
            this._measureWidth(this.constructForward);
        }
    }.observes('ltPropIndex', 'ltPropData', 'ltPropData.[]'),

    _measureWidth: function (callback) {
        if (this.getData('ltPropType') == "advanced") {
            var width = [], data = this.getData('ltPropData');
            this.setData('dummyContent', data);

            var forward = $L('lyte-step-forward').get(0),
                backward = $L('lyte-step-backward').get(0);

            if (forward) {
                forward.classList.remove('lyteStepHidden');
            }

            if (backward) {
                backward.classList.remove('lyteStepHidden');
            }

            $L.fastdom.measure(function () {
                var items = $L('lyte-step-item', this.$node);

                for (var i = 0; i < items.length; i++) {
                    var style = window.getComputedStyle(items.get(i));
                    width[i] = items.get(i).getBoundingClientRect().width + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
                }
                var divWidth = this.$node.querySelector('lyte-step-structure').getBoundingClientRect().width,
                    forwardWidth = 0,
                    backwardWidth = 0;

                if (forward) {
                    forwardWidth = forward.getBoundingClientRect().width;
                    var compsty = getComputedStyle(forward);
                    forwardWidth += (parseFloat(compsty.marginRight) + parseFloat(compsty.marginLeft));
                }

                if (backward) {
                    backwardWidth = backward.getBoundingClientRect().width;
                    var compsty = getComputedStyle(backward);
                    backwardWidth += (parseFloat(compsty.marginRight) + parseFloat(compsty.marginLeft));
                }

                this.setData({
                    divWidth: divWidth,
                    widthArr: width,
                    forwardWidth: forwardWidth,
                    backwardWidth: backwardWidth
                })
                $L.fastdom.mutate(callback.bind(this, forward, backward));
            }.bind(this))
        }
    },

    moveTo: function (number, state, selected, addClass) {
        this._preventselect = true;
        var data = this.getData('ltPropData'),
            dummyContent = this.getData('dummyContent'),
            index = this.getData('ltPropIndex'),
            array = this.getData('ltPropDataType'),
            items = $L('lyte-step-item', this.$node),
            active = this.getData('ltPropActiveClass'),
            completed = this.getData('ltPropCompletedClass'),
            incomplete = this.getData('ltPropWarningClass'),
            keep = this.getData('ltPropKeepMarked');

        addClass && items.eq(-1).addClass('lyteStepLast');

        number = Math.min(Math.max(0, number || 0), data.length - 1);

        if (selected == undefined) {
            for (var i = 0; i < data.length; i++) {
                if (array[i] == 'active') {
                    selected = i;
                }
            }
            if (selected == undefined) {
                this.setData('ltPropSelected', 0);
                selected = 0;
            }
        }

        for (var i = 0; i < data.length; i++) {
            var arrOp = array[i] == undefined ? 'insertAt' : 'replaceAt',
                state2Push;

            if (number != selected && number > selected && i >= selected && i < number) {
                state2Push = state == "incomplete" ? 'incomplete' : 'completed';
            } else {
                if (i == number) {
                    state2Push = "active";
                } else if (i > number) {
                    state2Push = keep ? array[i] || '' : "";
                } else {
                    if (i > selected) {
                        state2Push = state == "incomplete" ? 'incomplete' : 'completed';
                    } else {
                        state2Push = (array[i] == "active" ? "completed" : array[i]) || 'completed';
                    }
                }
            }

            Lyte.arrayUtils(array, arrOp, i, state2Push);
            if (i >= index) {
                if (array[i] == 'active') {
                    items.eq(i - index).removeClass(completed, incomplete).addClass(active);
                } else if (array[i] == "incomplete") {
                    items.eq(i - index).removeClass(completed, active).addClass(incomplete);
                } else if (array[i] == "completed") {
                    items.eq(i - index).removeClass(active, incomplete).addClass(completed);
                } else {
                    items.eq(i - index).removeClass(completed, active, incomplete);
                }
                if (this.data.ltPropAria) {
                    array[i] == 'active' ? items.eq(i - index).find('a').attr('aria-current', this.data.ltPropAriaValue) : items.eq(i - index).find('a').removeAttr('aria-current')
                }
            }
        }
        this.setData('ltPropSelected', number);
        delete this._preventselect;
    },

    transfade: function () {
        clearTimeout(this._animetime);
        delete this._animetime;
        delete this._transstart;
        this._measureWidth(this._transendback || this.constructForward);
        delete this._transendback;
        $L('.lyteStepFade', this.$node).off('transitionend');
    },

    returntran: function (prop) {
        var ret = 0;
        if (/(.+)(s|ms)$/.test(prop)) {
            var match = prop.match(/(.+)(s|ms)$/);
            ret = parseFloat(match[1]) * (match[2] == "s" ? 1000 : 1);
        }
        return ret;
    },

    timeout: function () {
        var elem = $L('lyte-step-structure', this.$node).get(0),
            style = window.getComputedStyle(elem);
        this._animetime = setTimeout(this._transEnd, 10 + this.returntran(style.transitionDuration) + this.returntran(style.transitionDelay));
    }
});

function stepResize (evt) {
    clearTimeout(window._stepresize);
    window._stepresize = setTimeout(function () {
        delete window._stepresize;
        var steps = document.getElementsByTagName('lyte-step');
        for (var i = 0; i < steps.length; i++) {
            var comp = steps[i].component;
            comp.data.ltPropType == 'advanced' && comp._measureWidth(comp.constructForward);
        }
    }, 0)
}

window.addEventListener('resize', stepResize, true);
window.addEventListener('orientationchange', stepResize, true);

/**
 * @syntax nonYielded
 * <lyte-step lt-prop-data='["Home","Menu",{"name": "Leads"},{"name": "Contacts"},{"name": "Services"}]' lt-prop-label="name"></lyte-step>
 */

/**
 * @syntax yielded
 * <lyte-step lt-prop-yield="true">
 *      <template is="registerYield" yield-name="yield">
 *          <lyte-step-structure>
 *              <lyte-step-item>
 *                  <lyte-step-body>
 *                      Home
 *                  </lyte-step-body>
 *              </lyte-step-item>
 *              <lyte-step-item>
 *                  <lyte-step-body>
 *                      Menu
 *                  </lyte-step-body>
 *              </lyte-step-item>
 *              <lyte-step-item>
 *                  <lyte-step-body>
 *                      Edit
 *                  </lyte-step-body>
 *              </lyte-step-item>
 *              <lyte-step-item>
 *                  <lyte-step-body>
 *                      Save
 *                  </lyte-step-body>
 *              </lyte-step-item>
 *          </lyte-step-structure>
 *      </template>
 *  </lyte-step>
 */

/**
 * @syntax
 * @attribute ltPropYield=true
 * @attribute ltPropClass=lyteStepBullet
 * <lyte-step lt-prop-yield ="true" lt-prop-class = "lyteStepBullet">
 *   <template is="registerYield" yield-name="yield">
 *       <lyte-step-structure>
 *           <lyte-step-item>
 *               <lyte-step-body>Home</lyte-step-body>
 *               <lyte-step-head>1</lyte-step-head>
 *           </lyte-step-item>
 *           <lyte-step-item>
 *               <lyte-step-body>Menu</lyte-step-body>
 *               <lyte-step-head>2</lyte-step-head>
 *           </lyte-step-item>
 *           <lyte-step-item>
 *           <lyte-step-body>Edit</lyte-step-body>
 *               <lyte-step-head>3</lyte-step-head>
 *           </lyte-step-item>
 *           <lyte-step-item>
 *               <lyte-step-body>Save</lyte-step-body>
 *               <lyte-step-head>4</lyte-step-head>
 *           </lyte-step-item>
 *       </lyte-step-structure>
 *   </template>
 *  </lyte-step>
 */

/**
 * @syntax 
 * @attribute ltPropYield=true
 * @attribute ltPropType=advanced
 * <lyte-step lt-prop-class = "lyteStepFlat" lt-prop-type = "advanced">
 *  <template is="registerYield" yield-name="yield">
 *      <lyte-step-structure>
 *          <lyte-step-backward>  backward</lyte-step-backward>
 *               <lyte-step-item data-value = 1>
 *                   <lyte-step-body>
 *                       home
 *                   </lyte-step-body>
 *               </lyte-step-item>
 *              <lyte-step-item data-value = 2>
 *                   <lyte-step-body>
 *                       new
 *                   </lyte-step-body>
 *               </lyte-step-item>
 *              <lyte-step-forward >forward</lyte-step-forward>
 *          </lyte-step-structure>
 *      </template>
 *  </lyte-step>
 */
Lyte.Component.register( 'lyte-svg', {
_template:"<template tag-name=\"lyte-svg\"> <svg class=\"{{ltPropClass}}\" viewBox=\"{{ltPropViewBox}}\"> <use id=\"{{ltPropId}}\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"{{lyteUiSetURL(ltPropPath,flag)}}\"></use> </svg> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]}],
_observedAttributes :["ltPropViewBox","ltPropClass","ltPropPath","ltPropId","flag"],
	data: function() {
		return {
			ltPropViewBox: Lyte.attr( 'string', { 'default': '' } ),
			ltPropClass: Lyte.attr( 'string', { 'default': '' } ),
			ltPropPath: Lyte.attr( 'string' ),
			ltPropId: Lyte.attr( 'string', { 'default': '' } ),
			flag: Lyte.attr( 'boolean', { default: false } )
		}		
	},

	didConnect: function() {
		this.setData( 'flag', true );
	}
} );
/**
 * Renders a resizeable rows and columns
 * @component lyte-splitter
 * @version 2.2.0
 * @methods onResizeEnd
 */


Lyte.Component.register("lyte-splitter", {
_template:"<template tag-name=\"lyte-splitter\"> <lyte-yield yield-name=\"splitter\"></lyte-yield> </template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropResize","ltPropCollapsible","columnElementCount","rowElementCount"],
	data : function(){
		return {

			/**
			 * @componentProperty {boolean} ltPropResize
			 * @default true
			 *
			 */

			ltPropResize : Lyte.attr('boolean' , {
				default : true
			}),

			/**
			 * @componentProperty {boolean} ltPropCollapsible
			 * @default true
			 *
			 */

			ltPropCollapsible : Lyte.attr('boolean' , {
				default : true
			}),
			columnElementCount : Lyte.attr('number' , {
				default : 0
			}),
			rowElementCount : Lyte.attr('number' , {
				default : 0
			})
		}
	}
});

/**
 * @customElement lyte-row-splitter
 */

if(!_lyteUiUtils.registeredCustomElements['lyte-row-splitter']){

	_lyteUiUtils.registeredCustomElements['lyte-row-splitter'] = true

		Lyte.createCustomElement('lyte-row-splitter',{
			constructor : function(){},
			static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
		});

	}

	/**
	 * @customElement lyte-column-splitter
	 */

	if(!_lyteUiUtils.registeredCustomElements['lyte-column-splitter']){

		_lyteUiUtils.registeredCustomElements['lyte-column-splitter'] = true

			Lyte.createCustomElement('lyte-column-splitter',{
				constructor : function(){},
				static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
			});

		}

		/**
		 * @customElement lyte-row-element
		 */

		if(!_lyteUiUtils.registeredCustomElements['lyte-row-element']){

			_lyteUiUtils.registeredCustomElements['lyte-row-element'] = true

			Lyte.createCustomElement('lyte-row-element',{
				constructor : function(){
					var splitterComponent = $L(this).closest('lyte-splitter').get(0);
					var splitterRow = $L(this).closest('lyte-row-splitter').get(0);

					var currentParent = this.parentElement;
					var lyteRowElements = currentParent.querySelectorAll('lyte-row-element');
					var lastRowElement = currentParent.children[currentParent.children.length-1];

					// var lyteRowElementsAr = Object.values(lyteRowElements);
					var lyteRowElementsAr = Object.keys(lyteRowElements).map(function(e) {
						return lyteRowElements[e]
					})

					var currentIndex = lyteRowElementsAr.indexOf(this);

					var rowElements = $L(splitterRow).find('lyte-row-element');

					if((!(lastRowElement == this))&&(this.getAttribute('lt-prop-resize')!=="false")){
						if(lyteRowElementsAr[currentIndex+1]){
							if(lyteRowElementsAr[currentIndex+1].getAttribute('lt-prop-resize')!=="false"){
								var rowHandle  = document.createElement("LYTE-ROW-HANDLE");
								currentParent.insertBefore(rowHandle, this.nextSibling);
							}
						}
					}
					if(lastRowElement == this){
						var remainingWidthPercent = 0;
						var filteredRowElements = $L(splitterRow).children( 'lyte-row-element' ).filter( function( index, item ) {

							if( item.hasAttribute('lt-prop-size') ) {
								var ltSize = item.getAttribute('lt-prop-size')
								var sizeValue = parseInt(item.getAttribute('lt-prop-size').match(/\d+/g));
								if(ltSize.indexOf('%') !== -1){
									item.style.flexBasis = ltSize;
									remainingWidthPercent = remainingWidthPercent + sizeValue;
									return false;
								}
							}
							return true;
						})
						var handleCount = $L(this).parent().children('lyte-row-handle').length;
						var elementCount = filteredRowElements.length;

						var rowSplitterSpace = (currentParent.getBoundingClientRect().height - (handleCount*8));
						var remainingWidth = rowSplitterSpace - ((remainingWidthPercent/100) * rowSplitterSpace);
						var percent = remainingWidth/elementCount;
						var flexBasis = ((percent / (rowSplitterSpace)) * 100)+"%";
						filteredRowElements.css('flexBasis' , flexBasis)
					}
				},
				static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
			})

		}


		/**
		 * @customElement lyte-column-element
		 */



		if(!_lyteUiUtils.registeredCustomElements['lyte-column-element']){

			_lyteUiUtils.registeredCustomElements['lyte-column-element'] = true

		Lyte.createCustomElement('lyte-column-element',{
			constructor : function(){
				var splitterComponent = $L(this).closest('lyte-splitter').get(0);
				var splitterColumn = $L(this).closest('lyte-column-splitter').get(0);

				var currentParent = this.parentElement;
				var lyteColumnElements = currentParent.querySelectorAll('lyte-column-element');
				var lastColumnElement = currentParent.children[currentParent.children.length-1];

				// var lyteColumnElementsAr = Object.values(lyteColumnElements);
				var lyteColumnElementsAr = Object.keys(lyteColumnElements).map(function(e) {
					return lyteColumnElements[e]
				})

				var currentIndex = lyteColumnElementsAr.indexOf(this);

				// var columnElements = $L(splitterColumn).find('lyte-column-element');
				var columnElements = $L(this).parent().children('lyte-column-element');

				if((!(lastColumnElement == this))&&(this.getAttribute('lt-prop-resize')!=="false")){

					if(lyteColumnElementsAr[currentIndex+1]){
						if(lyteColumnElementsAr[currentIndex+1].getAttribute('lt-prop-resize')!=="false"){
							var columnHandle  = document.createElement("LYTE-COLUMN-HANDLE");
							currentParent.insertBefore(columnHandle, this.nextSibling);
						}
					}
				}
				if(lastColumnElement == this){
					var remainingWidthPercent = 0;
					var filteredColumnElements = $L(splitterColumn).children( 'lyte-column-element' ).filter( function( index, item ) {

						if( item.hasAttribute('lt-prop-size') ) {
							var ltSize = item.getAttribute('lt-prop-size')
							var sizeValue = parseInt(item.getAttribute('lt-prop-size').match(/\d+/g));
							if(ltSize.indexOf('%') !== -1){
								item.style.flexBasis = ltSize;
								remainingWidthPercent = remainingWidthPercent + sizeValue;
								return false;
							}
						}
						return true;
					})
					var handleCount = $L(this).parent().children('lyte-column-handle').length;
					var elementCount = filteredColumnElements.length;
					var columnSplitterSpace = (currentParent.getBoundingClientRect().width - (handleCount*8));
					var remainingWidth = columnSplitterSpace - ((remainingWidthPercent/100) * columnSplitterSpace);
					var percent = remainingWidth/elementCount;
					var flexBasis = ((percent / (columnSplitterSpace)) * 100)+"%";
					filteredColumnElements.css('flexBasis' , flexBasis)

				}
			},
			static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
		})

}

/**
 * @customElement lyte-row-handle
 */



if(!_lyteUiUtils.registeredCustomElements['lyte-row-handle']){

	_lyteUiUtils.registeredCustomElements['lyte-row-handle'] = true


		Lyte.createCustomElement('lyte-row-handle',{
			connectedCallback : function(){
				var columnHandleIcon = document.createElement('DIV');
				columnHandleIcon.setAttribute('class' , 'rowHandleIcon');
				this.appendChild(columnHandleIcon);
			},
			constructor : function(){

				var lyteRowRe = this;
				var currentParent,currentIndex,prevSplitterRow,nextSplitterRow,currentIndex;
				var oldClientY;
				var prevSplitterRowBasis;
				var nextSplitterRowBasis;
				var splitterComponent;
				var prevEleMinSize = 0;
				var nextEleMinSize = 0;
				lyteRowRe.addEventListener('mousedown' , resizeFun);
				function resizeFun(event){
					// lyteRowRe.style.background = "red";
					lyteRowRe.classList.add('splitResizing');
					splitterComponent = $L(this).closest('lyte-splitter').get(0);
					splitterComponentRow = $L(this).closest('lyte-row-splitter').get(0);
					currentParent = lyteRowRe.parentElement;
					// childArray = Object.values(currentParent.children);
					childArray = Object.keys(currentParent.children).map(function(e){
						return currentParent.children[e]
					})
					currentIndex = childArray.indexOf(lyteRowRe);
					prevSplitterRow = childArray[currentIndex-1];
					nextSplitterRow = childArray[currentIndex+1];
					oldClientY = event.clientY;
					$L(this).parent().children('lyte-row-element').css('flexGrow',0);
					if(!getComputedStyle(prevSplitterRow).flexBasis){
						prevSplitterRow.style.flexBasis = (((100/currentParent.querySelectorAll('lyte-row-element').length)-1)/2) + "%";
					}
					if((!getComputedStyle(nextSplitterRow).flexBasis)||(getComputedStyle(nextSplitterRow).flexBasis === "auto")){
						nextSplitterRow.style.flexBasis = (((100/currentParent.querySelectorAll('lyte-row-element').length))/($L('lyte-row-element').length - 2)) + "%";
					}
					prevSplitterRow.style.flexGrow = nextSplitterRow.style.flexGrow = 0;
					oldClientY = event.clientY;
					prevSplitterRowBasis = parseFloat(getComputedStyle(prevSplitterRow).flexBasis);
					nextSplitterRowBasis = parseFloat(getComputedStyle(nextSplitterRow).flexBasis);
					if(prevSplitterRow.hasAttribute('lt-prop-min-size')){
						prevEleMinSize = parseFloat(prevSplitterRow.getAttribute('lt-prop-min-size'));
					}
					if(nextSplitterRow.hasAttribute('lt-prop-min-size')){
						nextEleMinSize = parseFloat(nextSplitterRow.getAttribute('lt-prop-min-size'));
					}
					splitterComponent.addEventListener('mousemove' , adjustFun);
					splitterComponent.addEventListener('mouseup' , removeFun);
				}
				function adjustFun(event){
					var clientYchange = oldClientY - event.clientY;
					var availableSpace = (currentParent.getBoundingClientRect().height - ($L(lyteRowRe).parent().children('lyte-row-handle').length * 8));
					var percentDiff = ((clientYchange / availableSpace)*100);

					if(((prevSplitterRowBasis - percentDiff) >= prevEleMinSize) && ((nextSplitterRowBasis + percentDiff) >= nextEleMinSize)){
						prevSplitterRow.style.flexBasis = (prevSplitterRowBasis - percentDiff) + "%";
						prevSplitterRow.setAttribute('lt-prop-size' , ((prevSplitterRowBasis - percentDiff) + "%"));
						nextSplitterRow.style.flexBasis = (nextSplitterRowBasis + percentDiff) + "%";
						nextSplitterRow.setAttribute('lt-prop-size' , ((nextSplitterRowBasis + percentDiff) + "%"))
					} else {
						if(((prevSplitterRowBasis - percentDiff) < (prevEleMinSize+1))){
							nextSplitterRow.style.flexBasis = ((prevSplitterRowBasis + nextSplitterRowBasis)-prevEleMinSize) + "%";
							nextSplitterRow.setAttribute('lt-prop-size' , (((prevSplitterRowBasis + nextSplitterRowBasis)-prevEleMinSize) + "%"))
							prevSplitterRow.style.flexBasis = prevEleMinSize + "%";
							prevSplitterRow.setAttribute('lt-prop-size' , (prevEleMinSize+"%"))
						} else if(((nextSplitterRowBasis + percentDiff) < (nextEleMinSize+1))){
							prevSplitterRow.style.flexBasis = ((prevSplitterRowBasis + nextSplitterRowBasis)-nextEleMinSize) + "%";
							prevSplitterRow.setAttribute('lt-prop-size' , (((prevSplitterRowBasis + nextSplitterRowBasis)-nextEleMinSize) + "%"));
							nextSplitterRow.style.flexBasis = nextEleMinSize + "%";
							nextSplitterRow.setAttribute('lt-prop-size' , (nextEleMinSize+"%"));
						}
					}
				}
				function removeFun(){
					// lyteRowRe.style.background = "#ddd";
					lyteRowRe.classList.remove('splitResizing');
					splitterComponent.removeEventListener('mousemove' , adjustFun);
					splitterComponent.removeEventListener('mouseup' , removeFun);

					var prevId = prevSplitterRow.getAttribute('lt-prop-splitter-id');
					var nextId = nextSplitterRow.getAttribute('lt-prop-splitter-id');

					var returnData = {};
					returnData[prevId] = {
						'element' : prevSplitterRow,
						'size' : prevSplitterRow.getAttribute('lt-prop-size')
					}
					returnData[nextId] = {
						'element' : nextSplitterRow,
						'size' : nextSplitterRow.getAttribute('lt-prop-size')
					}

					if(splitterComponent.getMethods('onResizeEnd')){
						splitterComponent.component.executeMethod('onResizeEnd' , returnData);
					}

				}

			},
			static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
		})

	}

	/**
	 * @customElement lyte-column-handle
	 */


	if(!_lyteUiUtils.registeredCustomElements['lyte-column-handle']){

		_lyteUiUtils.registeredCustomElements['lyte-column-handle'] = true


		Lyte.createCustomElement('lyte-column-handle',{
			connectedCallback : function(){
				var columnHandleIcon = document.createElement('DIV');
				columnHandleIcon.setAttribute('class' , 'columnHandleIcon');
				this.appendChild(columnHandleIcon);
			},
			constructor : function(){

				var lyteColRe = this;
				var currentParent,currentIndex,prevSplitterCol,nextSplitterCol,currentIndex;
				var oldClientX;
				var prevSplitterColBasis;
				var nextSplitterColBasis;
				var splitterComponent;
				var prevEleMinSize = 0;
				var nextEleMinSize = 0;
				var prevFlexValues = {};
				var nextFlexValues = {};

				lyteColRe.addEventListener('mousedown' , resizeFun);
				function resizeFun(event){
					// lyteColRe.style.background = "black";
					// lyteColRe.children[0].style.background = "white";

					lyteColRe.classList.add('splitResizing');


					splitterComponent = $L(lyteColRe).closest('lyte-splitter').get(0);
					splitterComponentCol = $L(lyteColRe).closest('lyte-column-splitter').get(0);
					currentParent = lyteColRe.parentElement;
					childArray = Object.keys(currentParent.children).map(function(e){
						return currentParent.children[e]
					})
					currentIndex = childArray.indexOf(lyteColRe);
					prevSplitterCol = childArray[currentIndex-1];
					nextSplitterCol = childArray[currentIndex+1];
					oldClientX = event.clientX;
					$L(this).parent().children('lyte-column-element').css('flexGrow',0);
					if(!getComputedStyle(prevSplitterCol).flexBasis){
						prevSplitterCol.style.flexBasis = (((100/currentParent.querySelectorAll('lyte-column-element').length)-1)/2) + "%";
					}
					if((!getComputedStyle(nextSplitterCol).flexBasis)||(getComputedStyle(nextSplitterCol).flexBasis === "auto")){
						nextSplitterCol.style.flexBasis = (((100/currentParent.querySelectorAll('lyte-column-element').length))/($L('lyte-column-element').length - 2)) + "%";
					}
					prevSplitterCol.style.flexGrow = nextSplitterCol.style.flexGrow = 0;
					oldClientX = event.clientX;
					prevSplitterColBasis = parseFloat(getComputedStyle(prevSplitterCol).flexBasis);
					nextSplitterColBasis = parseFloat(getComputedStyle(nextSplitterCol).flexBasis);
					if(prevSplitterCol.hasAttribute('lt-prop-min-size')){
						prevEleMinSize = parseFloat(prevSplitterCol.getAttribute('lt-prop-min-size'));
					}
					if(nextSplitterCol.hasAttribute('lt-prop-min-size')){
						nextEleMinSize = parseFloat(nextSplitterCol.getAttribute('lt-prop-min-size'));
					}
					if(!$L(prevSplitterCol).data('flexValues')){
						prevFlexValues = {
							"value" : getComputedStyle(prevSplitterCol).flexBasis
						}
					}
					if(!$L(nextSplitterCol).data('flexValues')){
						nextFlexValues = {
							"value" : getComputedStyle(nextSplitterCol).flexBasis
						}
					}

					$L(prevSplitterCol).data('flexValues' , prevFlexValues);
					$L(nextSplitterCol).data('flexValues' , nextFlexValues);
					// console.log(prevSplitterCol , nextSplitterCol);


					splitterComponent.addEventListener('mousemove' , adjustFun);
					splitterComponent.addEventListener('mouseup' , removeFun);
				}
				function adjustFun(event){
					var clientXchange = oldClientX - event.clientX;
					var availableSpace = (currentParent.getBoundingClientRect().width - ($L(lyteColRe).parent().children('lyte-column-handle').length * 8));
					var percentDiff = ((clientXchange / availableSpace)*100);

					if(((prevSplitterColBasis - percentDiff) >= prevEleMinSize) && ((nextSplitterColBasis + percentDiff) >= nextEleMinSize)){
						prevSplitterCol.style.flexBasis = (prevSplitterColBasis - percentDiff) + "%";
						prevSplitterCol.setAttribute('lt-prop-size' , ((prevSplitterColBasis - percentDiff) + "%"));
						nextSplitterCol.style.flexBasis = (nextSplitterColBasis + percentDiff) + "%";
						nextSplitterCol.setAttribute('lt-prop-size' , ((nextSplitterColBasis + percentDiff) + "%"))
						prevFlexValues.value = (prevSplitterColBasis - percentDiff);
						nextFlexValues.value = (nextSplitterColBasis + percentDiff);
						$L(prevSplitterCol).data('flexValues' , prevFlexValues)
						$L(nextSplitterCol).data('flexValues' , nextFlexValues)
					} else {
						if(((prevSplitterColBasis - percentDiff) < (prevEleMinSize+1))){
							nextSplitterCol.style.flexBasis = ((prevSplitterColBasis + nextSplitterColBasis)-prevEleMinSize) + "%";
							nextSplitterCol.setAttribute('lt-prop-size' , (((prevSplitterColBasis + nextSplitterColBasis)-prevEleMinSize) + "%"))
							prevSplitterCol.style.flexBasis = prevEleMinSize+"%";
							prevSplitterCol.setAttribute('lt-prop-size' , (prevEleMinSize+"%"))
						} else if(((nextSplitterColBasis + percentDiff) < (nextEleMinSize+1))){
							prevSplitterCol.style.flexBasis = ((prevSplitterColBasis + nextSplitterColBasis)-nextEleMinSize) + "%";
							prevSplitterCol.setAttribute('lt-prop-size' , (((prevSplitterColBasis + nextSplitterColBasis)-nextEleMinSize) + "%"));
							nextSplitterCol.style.flexBasis = nextEleMinSize+"%";
							nextSplitterCol.setAttribute('lt-prop-size' , (nextEleMinSize+"%"));
						}
					}
				}
				function removeFun(){

					lyteColRe.classList.remove('splitResizing');
					// lyteColRe.style.background = "#ddd";
					// lyteColRe.children[0].style.background = "black";
					splitterComponent.removeEventListener('mousemove' , adjustFun);
					splitterComponent.removeEventListener('mouseup' , removeFun);

					var prevId = prevSplitterCol.getAttribute('lt-prop-splitter-id');
					var nextId = nextSplitterCol.getAttribute('lt-prop-splitter-id');

					var returnData = {};
					returnData[prevId] = {
						'element' : prevSplitterCol,
						'size' : prevSplitterCol.getAttribute('lt-prop-size')
					}
					returnData[nextId] = {
						'element' : nextSplitterCol,
						'size' : nextSplitterCol.getAttribute('lt-prop-size')
					}

					if(splitterComponent.getMethods('onResizeEnd')){
						splitterComponent.component.executeMethod('onResizeEnd' , returnData);
					}
				}
			},
			static: {
            observedAttributes: {
                get: function() {
                    return []
                }
            }
        }
		})

	}


	/**
	 * @syntax yielded
	 *	 <lyte-splitter>
	 *	     <template is="registerYield" yield-name="splitter">
	 *	       <lyte-column-splitter>
	 *	         <lyte-column-element>
	 *	           <lyte-row-splitter>
	 *	             <lyte-row-element>
	 *	               <lyte-column-splitter>
	 *	                 <lyte-column-element>C1</lyte-column-element>
	 *	               </lyte-column-splitter>
	 *	             </lyte-row-element>
	 *	             <lyte-row-element>R2</lyte-row-element>
	 *	             <lyte-row-element>
	 *	               <lyte-column-splitter>
	 *	                 <lyte-column-element>
	 *	                   <lyte-row-splitter>
	 *	                     <lyte-row-element>R1</lyte-row-element>
	 *	                   </lyte-row-splitter>
	 *	                 </lyte-column-element>
	 *	                 <lyte-column-element>C2</lyte-column-element>
	 *	               </lyte-column-splitter>
	 *	             </lyte-row-element>
	 *	           </lyte-row-splitter>
	 *	         </lyte-column-element>
	 *	         <lyte-column-element>
	 *	           <lyte-column-splitter>
	 *	             <lyte-column-element>
	 *	               <lyte-row-splitter>
	 *	                 <lyte-row-element>
	 *	                   <lyte-column-splitter>
	 *	                     <lyte-column-element>C1</lyte-column-element>
	 *	                   </lyte-column-splitter>
	 *	                 </lyte-row-element>
	 *	                 <lyte-row-element>R2</lyte-row-element>
	 *	               </lyte-row-splitter>
	 *	             </lyte-column-element>
	 *	             <lyte-column-element>C2</lyte-column-element>
	 *	             <lyte-column-element>
	 *	               <lyte-row-splitter>
	 *	                 <lyte-row-element>R1</lyte-row-element>
	 *	               </lyte-row-splitter>
	 *	             </lyte-column-element>
	 *	           </lyte-column-splitter>
	 *	         </lyte-column-element>
	 *	       </lyte-column-splitter>
	 *	     </template>
	 *	   </lyte-splitter>
	 */

// Issues to fix

// Combined width of fixed column should not exceed width of lyte-table 

/**
 * Lyte-table is a component used to display data in rows and columns
 * @component lyte-table
 * @dependency lyte-scrollbar.js
 *  /plugins/lyte-scrollbar.js
 * @version 1.0.0
 */

Lyte.Component.register('lyte-table', {
_template:"<template tag-name=\"lyte-table\"> <div class=\"lyteTableScroll\"> <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\"> <lyte-table-structure id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\"> <template is=\"if\" value=\"{{ltPropHeaderLabelKey}}\"><template case=\"true\"> <lyte-colgroup> <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-col></lyte-col> </template> </lyte-colgroup> <lyte-thead> <lyte-tr> <template is=\"if\" value=\"{{ltPropHeader.length}}\"><template case=\"true\"><template is=\"for\" items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\"> <lyte-th id=\"{{list.id}}\" class=\"{{list.class}}\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\"> {{unescape(list[ltPropHeaderLabelKey])}} </lyte-th> </template></template></template> </lyte-tr> </lyte-thead> </template></template> <lyte-tbody> <template is=\"if\" value=\"{{ltPropInfiniteScroll}}\"><template case=\"true\"> <template is=\"for\" items=\"{{ltPropData}}\" item=\"list\" index=\"indexVal\"> <lyte-tr id=\"{{list.body.id}}\" class=\"{{list.body.class}}\"> <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\"> <lyte-td> <div style=\"height: {{ltPropCellHeight}}\"> {{unescape(lyteUiGetValue(list.body,header[ltPropBodyLabelKey]))}} </div> </lyte-td> </template> </lyte-tr> </template> </template><template case=\"false\"> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"> <lyte-tr id=\"{{list.id}}\" class=\"{{list.class}}\"> <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\"> <lyte-td>{{unescape(lyteUiGetValue(list,header[ltPropBodyLabelKey]))}}</lyte-td> </template> </lyte-tr> </template> </template></template> </lyte-tbody> <template is=\"if\" value=\"{{expHandlers(ltPropResize.vertical,'||',ltPropResize.horizontal)}}\"><template case=\"true\"> <lyte-table-resize onmousedown=\"{{action('tableResize',event,this)}}\"></lyte-table-resize> <template is=\"if\" value=\"{{ltPropResize.vertical}}\"><template case=\"true\"> <lyte-table-vertical-resize onmousedown=\"{{action('tableResize',event,this)}}\"></lyte-table-vertical-resize> </template></template><template is=\"if\" value=\"{{ltPropResize.horizontal}}\"><template case=\"true\"> <lyte-table-horizontal-resize onmousedown=\"{{action('tableResize',event,this)}}\"></lyte-table-horizontal-resize> </template></template></template></template> </lyte-table-structure> </template><template case=\"false\"><template is=\"if\" value=\"{{ltPropInfiniteScroll}}\"><template case=\"true\"> <lyte-yield yield-name=\"yield\" lt-prop-data=\"{{ltPropData}}\"></lyte-yield> </template><template case=\"false\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template></template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"if","position":[3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"for","position":[0],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'height: '","ltPropCellHeight"]}}}},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[4]},{"type":"if","position":[4],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropContent","ltPropHeader","ltPropId","ltPropClass","ltPropBorder","ltPropHeaderLabelKey","ltPropBodyLabelKey","ltPropWidth","ltPropHeight","ltPropResize","ltPropFixedColumnClass","ltPropYield","ltPropScroll","ltPropColumnSortable","ltPropScrollbarOption","ltPropDualResize","ltPropData","ltPropInfiniteScroll","ltPropCellHeight","ltPropContentLength","ltPropPreventScrollbar","lyteUnbound","columns","nonFixedColumn","minWidth1","minWidth2","secondaryData","boundary","rowHeights"],
    init: function () {
        var uA = navigator.userAgent;
        this._dir = _lyteUiUtils.getRTL();
        this.isIE11Lyte = /rv:11/ig.test(uA);
        this.isEdgeLyte = /Edge/ig.test(uA);
        this._browser = this.isIE11Lyte || this.isEdgeLyte || uA.match('Safari');
        if (this.getMethods('beforeRender')) {
            /**
             * @method beforeRender
             * @version 1.0.1
             */
            this.executeMethod('beforeRender', this.$node);
        }
        /**
         * @utility scrollTable
         * @version 1.0.4
         */
        this.$node.scrollTable = function (x, y) {
            if (!this.scrollDiv) {
                this.scrollDiv = this.$node.querySelector('div.lyteTableScroll')
            }
            if (x != undefined) {
                this.scrollDiv.scrollTop = y;
            }
            if (y != undefined) {
                this.scrollDiv.scrollLeft = x;
            }
            var evt = new Event('scroll', { bubbles: true });
            evt._byFunc = true;
            this.scrollDiv.dispatchEvent(evt);
        }.bind(this)
        if (!document._tableResize) {
            document._tableResize = true;
            window.addEventListener('resize', resizeTable, true);
            window.addEventListener('orientationchange', resizeTable, true)
        }
        /**
         * @utility toggleRows
         * @version 1.0.3
         */
        this.$node.toggleRows = function (val) {
            $L.fastdom.mutate(function () {
                var preventRows = this.$node.querySelectorAll('lyte-tbody lyte-tr.lytePreventInfiniteScroll');
                for (var i = 0; i < preventRows.length; i++) {
                    if (val) {
                        preventRows[i].classList.remove('lyteHidden')
                    } else {
                        preventRows[i].classList.add('lyteHidden')
                    }
                }
            }.bind(this))
        }.bind(this)
    },

    rtlfunc: function (lft, bcr, ww) {
        if (this._dir && lft != 'top' && lft != 'clientY') {
            if (bcr) {
                if (lft == 'right') {
                    return ww - bcr.left;
                } else if (lft == 'clientX') {
                    return ww - bcr.clientX;
                }
                return ww - bcr.right;
            } else if (lft == 'left') {
                return 'right';
            } else if (lft == "right") {
                return "left";
            }
        }
        return bcr ? bcr[lft] : lft;
    },

    didDestroy: function () {
        if (document.body.querySelectorAll('lyte-table[lyte-rendered]').length == 0 && document._tableResize) {
            window.removeEventListener('resize', resizeTable, true)
            window.removeEventListener('orientationchange', resizeTable, true);
            delete document._tableResize
        }
        !this.data.ltPropPreventScrollbar && this.scrollDiv && $L(this.scrollDiv).removeScroll();
        delete this.scrollDiv; delete this._dummy; delete this._dummy1; delete this.resizeComponent; delete this.targetElem;
        delete this.$node.setValue; delete this.$node.scrollTable;
    },

    initProcess1: function (arg) {
        if (this._prevent) {
            return
        }
        if (this.data.ltPropInfiniteScroll) {
            var table = this.$node.querySelector('lyte-table-structure'),
                ltPropContent = this.data.ltPropContent || [], len = Math.min(this.data.ltPropContentLength || ltPropContent.length, ltPropContent.length),
                ltPropData = [];
            if (ltPropContent.length == 0 && !arg) {
                return;
            }
            if (table) {
                table.style.height = 'auto';
            }
            for (var i = 0; i < len; i++) {
                ltPropData[i] = { body: ltPropContent[i], checked: false, index: i }
            }
            this.setData('ltPropData', ltPropData)
            if (arg && this._dummy) {
                this._dummy.style.height = 0;
                this._dummy.style.transform = "translateY(0px)";
            }

            if (arg && this._dummy1) {
                this._dummy1.style.transform = "translateY(0px)";
            }
            delete this._stopScroll;
            if (arg && this.scrollDiv) {
                this.scrollDiv.scrollTop = 0;
                this.scrollDiv.scrollLeft = 0;
            }
            this._top = 0;
            this._bottom = Math.max(len - 1, 0)
            this._boundary = { top: 0, bottom: len - 1 }
        }
    }.observes('ltPropContent.[]').on('init'),


    didConnect: function () {
        var ltPropInfiniteScroll = this.data.ltPropInfiniteScroll, secData = this.data.secondaryData,
            ltPropResize = this.data.ltPropResize;
        if (this.data.ltPropYield && (ltPropResize.vertical || ltPropResize.horizontal)) {
            this.resizeComponentAppend.call(this);
        }
        try {
            var scrollDiv = this.$node.querySelector('div.lyteTableScroll');
            // scrollDiv._overlay = scrollDiv.getElementsByTagName( 'lyte-overlaydiv' )[ 0 ];
            this.scrollDiv = scrollDiv;
            scrollDiv.comp = this;
            scrollDiv._infiniteScroll = ltPropInfiniteScroll;
            if (!this.data.ltPropPreventScrollbar) {
                $L(scrollDiv).scroll(this.data.ltPropScrollbarOption);
                var scrollbar = this.$node.querySelector('.lyteScrollContainer.lyteScrollContainerY');
                var header = this.$node.querySelector('lyte-th'), hgt;
                $L.fastdom.measure(function () {
                    var fg = this._dir;
                    // while applying scroll plugin vertical scrollbar needs some offset for enabling the virtual of only body part is scrolling. If it is zero we have to set height of the header as offset
                    if (header && scrollbar && scrollbar.offsetTop == 0) {
                        hgt = header.getBoundingClientRect().height;
                        $L.fastdom.mutate(function () {
                            scrollbar.style.top = hgt + 'px';
                            if (fg) {
                                this.$node.classList.add('lyteRTL')
                            }
                        }.bind(this))
                    }
                    $L.fastdom.mutate(function () {
                        this.data.ltPropDualResize && this.$node.classList.add('lyteDualResize')
                        if (this.getMethods('afterRender')) {
                            this.executeMethod('afterRender', this.$node);
                        }
                    }.bind(this))
                }.bind(this))
            } else {
                if (this.getMethods('afterRender')) {
                    /**
                     * @method afterRender
                     * @version 1.0.1
                     */
                    this.executeMethod('afterRender', this.$node);
                }
            }
        } catch (err) {
        }
        if (ltPropInfiniteScroll) {
            this.$node.classList.add('infinitescroll')
            /**
             * @utility setValue
             * @version 1.0.2
             */
            this.$node.setValue = function (ret) {
                if (this._stopScroll) {
                    this.appendAddData1.call(this, ret)
                }
            }.bind(this)

            /**
             * @utility removeRow
             * @version 2.2.17
             */

            this.$node.removeRow = function (row) {
                this.removeRow(row);
            }.bind(this);

            /**
             * @utility scrollToRecord
             * @version 2.2.19
             */

            this.$node.scrollToRecord = this.scrollToRecord.bind(this);

            /**
             * @utility insertRow
             * @version 2.2.19
             */

            this.$node.insertRow = this.insertRow.bind(this);
        }
    },

    // width calculation for positioning
    columnWidth: function (fixedColumn, i, j) {
        var width = 0;
        if (!j) {
            j = 0
        }
        for (; j < i; j++) {
            width += fixedColumn[j].property.width;
        }
        return width;
    },

    heightCalc: function (rows, upper, hgtLimit) {
        var hgt = 0, j = upper;
        for (; j > 0; j--) {
            hgt += rows[j];
            if (hgtLimit < hgt) {
                break;
            }
        }
        return [hgt, j];
    },

    topElem: function (elem) {
        if (this.isIE11Lyte || this.isEdgeLyte) {
            var ret = elem.querySelector('lyte-td');
            if (ret) {
                return ret.getBoundingClientRect()
            }
            return {}

        } else {
            return elem.getBoundingClientRect()
        }
    },

    cellSet: function (elem, value) {
        if (this.isIE11Lyte || this.isEdgeLyte) {
            var cells = elem.querySelectorAll('lyte-td');
            if (!value && cells.length) {
                return cells[0].style.transform
            }
            for (var i = 0; i < cells.length; i++) {
                cells[i].style.transform = value;
            }
        } else {
            if (!value) {
                return elem.style.transform
            }
            elem.style.transform = value
        }
    },

    scrollTable: function (event, obj) {
        // fastdom has been removed here due to delay causes error in calculation of data in ie edge safari
        var b = event.yScroll, ltPropData = this.getData('ltPropData'), ltPropContent = this.getData('ltPropContent'), scrollDiv = this.scrollDiv, divClientRect = obj.tbodyClient, tableClient = obj.$nodeClient, table = this.$node.querySelector('lyte-table-structure');
        var head = this.$node.querySelector('lyte-th'), neglected = obj.neglected, compNeg = obj.compNeg;
        head = head ? (head.property ? head.property.height : head.getBoundingClientRect().height) : 0;
        var topElem = obj.topElem, top1 = obj.topElemClient;

        if (table.style.height.indexOf('px') == -1) {
            table.style.height = divClientRect.height + 'px';
            this._rowHgt = parseInt(top1.height * 10) / 10;
            this._step = parseInt((divClientRect.height - this._rowHgt * neglected.length) * 10) / 10;
        }
        if (!this._dummy) {

            this.createDummy( obj.tbody );
        }
        if (b == undefined && !scrollDiv.classList.contains('eventBinded')) {
            var prevScroll = parseFloat(this._dummy.style.transform.match(/[\d|.]+/ig)[0]),
                currScroll = scrollDiv.scrollTop
            if (currScroll > prevScroll) {
                b = 1
            } else {
                b = -1
            }
        }
        if (b > 0) {
            if (parseFloat(tableClient.top + head) >= parseFloat(top1.bottom)) {
                if (this._boundary.bottom <= ltPropContent.length - 2) {
                    var diff = Math.max(parseInt((tableClient.top + head - top1.bottom) / this._rowHgt), 1);
                    if (this._boundary.bottom + diff > ltPropContent.length - 1) {
                        diff = ltPropContent.length - 1 - this._boundary.bottom
                    }
                    for (var i = 0; i < diff; i++) {
                        this._boundary.bottom += 1;
                        if (i >= diff - ltPropData.length) {
                            Lyte.Component.set(ltPropData[this._top], { body: ltPropContent[this._boundary.bottom], index: this._boundary.bottom })
                            topElem.dataOrder = this._boundary.bottom;
                        }
                        this._boundary.top = this._boundary.bottom - ltPropData.length + 1;
                        if (this.cellSet(topElem)) {
                            this.regex(topElem)
                        } else {
                            this.cellSet(topElem, "translateY(" + (this._step) + 'px)')
                        }
                        this._dummy.style.transform = 'translateY(' + (parseFloat(this._dummy.style.transform.match(/[\d|.]+/ig)[0]) + this._rowHgt) + 'px)'
                        this._dummy.style.height = Math.max(parseFloat(this._dummy.style.height) - this._rowHgt, 0) + 'px';
                        if (this._browser) {
                            this._dummy1.style.transform = 'translateY(' + (parseFloat(this._dummy1.style.transform.match(/[\d|.]+/ig)[0]) + this._rowHgt) + 'px)'
                        }
                        this._bottom = this._top;
                        this._top = (this._top + 1) % ltPropData.length;
                        if (this._boundary.bottom >= ltPropContent.length) {
                            this._boundary.bottom = ltPropContent.length - 1;
                            this._top = (this._top + 1) % ltPropData.length;
                            break
                        }
                        topElem = this.nthoftype.call(this, obj.tbody, this._top + compNeg.length, true)
                    }
                } else {
                    this.scrollEndMethod1();
                }
            }

        } else if (b < 0) {
            var bottmElem = obj.bottmElem, bottom = obj.bottmElemClient;
            if (tableClient.bottom <= bottom.top) {
                var mat = this.cellSet(bottmElem).match(/[\d|.]+/ig);
                if (!mat || (mat && mat[0] == '0')) {
                    return
                }
                var diff = parseInt(Math.max(parseFloat((bottom.top - tableClient.bottom) / this._rowHgt), 0)),
                    minDiff = Math.max(diff - 1 - this._boundary.top, 0)
                for (var i = diff - 1; i >= 0 && diff != 0; i--) {
                    if (this._boundary.top == 0) {
                        break;
                    }
                    this._boundary.top -= 1;
                    if (i <= ltPropData.length - 1 + minDiff) {
                        Lyte.Component.set(ltPropData[this._bottom], { body: ltPropContent[this._boundary.top], index: this._boundary.top })
                        bottmElem.dataOrder = this._boundary.top;
                    }
                    this._boundary.bottom = this._boundary.top + ltPropData.length - 1;
                    if (this.cellSet(bottmElem)) {
                        this.regex(bottmElem, true)
                    }
                    this._dummy.style.height = (parseFloat(this._dummy.style.height) + this._rowHgt) + 'px';
                    this._dummy.style.transform = 'translateY(' + (parseFloat(this._dummy.style.transform.match(/[\d|.]+/ig)[0]) - this._rowHgt) + 'px)'
                    if (this._browser) {
                        this._dummy1.style.transform = 'translateY(' + (parseFloat(this._dummy1.style.transform.match(/[\d|.]+/ig)[0]) - this._rowHgt) + 'px)'
                    }
                    this._top = this._bottom;
                    this._bottom = (ltPropData.length + this._bottom - 1) % ltPropData.length;
                    if (this._boundary.top == -1) {
                        this._boundary.top = 0;
                        this._boundary.bottom = this._boundary.top + ltPropData.length - 1;
                        break
                    }
                    bottmElem = this.nthoftype.call(this, obj.tbody, this._bottom + compNeg.length, true)
                }
            }
        }
    },

    createDummy : function( tbody ){
        var dummy = document.createElement('lyte-tr');
        dummy.classList.add('dummy');
        tbody.appendChild(dummy)
        dummy.setAttribute('style', 'transform:translateY(0px);height:0px')
        this._dummy = dummy;
        if (this._browser) {
            var dummy1 = document.createElement('div');
            dummy1.classList.add('dummy');
            this.scrollDiv.appendChild(dummy1)
            dummy1.setAttribute('style', 'transform:translateY(0px);height:5px')
            this._dummy1 = dummy1;
        }
    }, 

    regex: function (elem, flag) {
        if (this.isIE11Lyte || this.isEdgeLyte) {
            var cells = elem.querySelectorAll('lyte-td');
            for (var i = 0; i < cells.length; i++) {
                this.regex1(cells[i], flag)
            }
        } else {
            this.regex1(elem, flag)
        }
    },

    regex1: function (elem, flag) {
        if (flag) {
            elem.style.transform = elem.style.transform.replace(/[\d|.]+/ig, function () { return Math.max(parseFloat(arguments[0]) - this._step, 0).toFixed(3) }.bind(this))
        } else {
            elem.style.transform = elem.style.transform.replace(/[\d|.]+/ig, function () { return (parseFloat(arguments[0]) + this._step).toFixed(3) }.bind(this))
        }
    },

    scrollEndMethod1: function () {
        if (this._stopScroll) {
            return
        }
        this._stopScroll = true;
        if (this.getMethods('scrollEnd')) {
            /**
             * @method scrollEnd
             * @version 1.0.0
             */
            this.appendAddData1(this.executeMethod('scrollEnd'))
        }
    },

    appendAddData1: function (ret) {
        if (ret) {
            if (ret.then) {
                Promise.resolve(ret).then(function (arg) {
                    if (arg) {
                        this.apd1.call(this, arg);
                    }
                }.bind(this), function () {
                    console.log( 'error at scroll end promise' );
                }.bind(this));
            } else {
                this.apd1.call(this, ret)
            }
        }
    },

    apd1: function (ret) {
        var ltPropContent = this.data.ltPropContent, ltPropData = this.data.ltPropData
        this._prevent = true
        if (ret.constructor == Array) {
            Lyte.arrayUtils(ltPropContent, 'concat', ret);
        }
        else if (ret.constructor == Object) {
            Lyte.arrayUtils(ltPropContent, 'push', ret);
        }
        delete this._prevent;
        delete this._stopScroll;
    },

    nthoftype: function (tbody, index, fg) {
        var arr = [],
            rows = tbody.getElementsByTagName('lyte-tr');
        if (fg) {
            return rows[index];
        }
        for (var i = 0; i < rows.length; i++) {
            if (!rows[i].classList.contains('dummy')) {
                arr.push(rows[i].querySelectorAll('lyte-td')[index])
            }
        }
        return arr;
    },

    scroll: function (event) {
        // cant use fastdom because of jerk in ie edge safari browser
        var component = this.comp,
            // headerList =component.$node.querySelectorAll( 'lyte-th' ),
            // scrollleft and top are required for process like fixing columns and infinite scroll. If scroll is dispatched by plugin event object contains these properties or it is calculated
            obj = this._wheelObj || { bcr: {} };

        this._scrollLeft = obj.scrollLeft != undefined ? obj.scrollLeft : this.scrollLeft;
        this._scrollTop = obj.scrollTop != undefined ? obj.scrollTop : this.scrollTop;
        var direction = this._direction;
        component.scrollCheck.call(this, event, obj);
        if (this._scrollLeft == 0 && direction != 'rtl' && component.getData('ltPropInfiniteScroll')) {
            var ary = component.getData('columns');
            Lyte.arrayUtils(ary, 'remove', 0, ary.length);
            var fixedd = this.querySelectorAll('.lyteTableFixed')
            if (fixedd.length) {
                for (var i = 0; i < fixedd.length; i++) {
                    fixedd[i].style.left = '0px';
                    fixedd[i].classList.remove('lyteTableFixed');
                }
            }
        }
        if (component.data.ltPropInfiniteScroll) {
            component.scrollTable.call(component, event, obj)
        }
        delete this._scrollLeft; delete this._scrollTop;
    },

    // fixed column checks and removals
    scrollCheck: function (event, obj) {
        var table = this.getElementsByTagName('lyte-table-structure')[0], scrollDiv = this,
            scrollTop = this._scrollTop, scrollLeft = this._scrollLeft,
            scrollDir = this.parentElement.component.getData('ltPropScroll'),
            component = this.parentElement.component,
            direction = this._direction,
            tbody = table.getElementsByTagName('lyte-tbody')[0],
            thead = this.getElementsByTagName('lyte-thead')[0],
            ths = [],
            headerList = [],
            fixedColumn = [];

        if (thead) {
            ths = thead.getElementsByTagName('lyte-th');
        }

        if ((scrollTop != this.prevScollTop || event._byFunc) && scrollDir.vertical) {
            var colsNos = ths;
            if (colsNos.length) {
                for (var i = 0; i < colsNos.length; i++) {
                    colsNos[i].classList.add('tableRowFixed')
                    // colsNos[i].style.top = (scrollTop) + 'px';
                    component.transform(true, colsNos[i], scrollTop)
                }
                if (!scrollTop) {
                    for (var i = 0; i < colsNos.length; i++) {
                        colsNos[i].classList.remove('tableRowFixed');
                    }
                }
            }
        }
        // for horizontal scroll    
        if ((scrollLeft != this.prevScollLeft || event._byFunc) && scrollDir.horizontal) {
            var columns = component.data.columns, head = [];
            if (thead) {
                var headRows = Array.apply(Array, thead.getElementsByTagName('lyte-tr')),
                    headRowCopy = Array.apply(Array, thead.getElementsByClassName('lyteRowCopy'));
                head = headRows.concat(headRowCopy);
            }

            var ltPropFixedColumnClass = component.data.ltPropFixedColumnClass || '';
            if (head.length) {
                headerList = head[0].getElementsByTagName('lyte-th');
                for (var n = 0; n < headerList.length; n++) {
                    headerList[n].classList.contains('lyteFixedColumn') && fixedColumn.push(headerList[n]);
                }
            }
            // fastdom removed due to jerk in ie edge chrome browser
            for (var i = columns.length; i < fixedColumn.length; i++) {
                if (((fixedColumn[i].property.right + component.columnWidth.call(component, fixedColumn, i) > (obj.scrollDivClient.right)) && direction == 'rtl') || ((fixedColumn[i].property.left < (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, i))) && direction != 'rtl')) {
                    var width = fixedColumn[i].property.width
                    var order = fixedColumn[i].order
                    if (order + 1 < headerList.length) {
                        !fixedColumn[i].classList.contains('lyteTableFixed') && fixedColumn[i].classList.add('lyteTableFixed')
                        columns.push(fixedColumn[i])
                        for (var zz = 1; zz < head.length; zz++) {
                            var colex = head[zz].getElementsByTagName('lyte-th')[order];
                            colex && !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed')
                        }
                        var colls = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')' )*/
                        for (var k = 0; k < colls.length; k++) {
                            !colls[k].classList.contains('lyteTableFixed') && colls[k].classList.add('lyteTableFixed')
                            if (ltPropFixedColumnClass) {
                                colls[k].classList.add(ltPropFixedColumnClass)
                            }
                        }
                    }
                }
            }
            for (var n = columns.length - 1; n >= 0; n--) {
                j = columns.length - 1;
                if ((scrollLeft == 0 && !(window.chrome && direction == 'rtl')) || ((((parseFloat((headerList[columns[j].order + 1].property.right + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1)).toFixed(2)) <= parseFloat(obj.scrollDivClient.right.toFixed(2))) || (headerList[columns[j].order + 1].property.right + 2 < columns[j].property.left)) && direction == 'rtl') || ((headerList[columns[j].order + 1].property.left >= (obj.scrollDivClient.left + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1))) && (columns[j].property.left >= (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, columns.length - 1))) && direction != 'rtl'))) {
                    // var innerElem = headerList[columns[j].order].querySelector( 'lyte-th-data' );
                    headerList[columns[j].order].classList.contains('lyteTableFixed') && headerList[columns[j].order].classList.remove('lyteTableFixed');
                    if (ltPropFixedColumnClass) {
                        headerList[columns[j].order].classList.remove(ltPropFixedColumnClass)
                    }
                    // columns[j].style.removeProperty('left');
                    component.transform(false, columns[j], 0)
                    for (var zz = 0; zz < head.length; zz++) {
                        var colex = head[zz].getElementsByTagName('lyte-th')[columns[j].order];
                        if (colex) {
                            colex.classList.contains('lyteTableFixed') && colex.classList.remove('lyteTableFixed');
                            // colex.style.removeProperty('left');
                            component.transform(false, colex, 0)

                        }
                    }
                    var currCols = /*component.isIE11Lyte ?*/ component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/;
                    for (var z = 0; z < currCols.length; z++) {
                        // currCols[z].style.removeProperty('left');
                        component.transform(false, currCols[z], 0)
                        currCols[z].classList.contains('lyteTableFixed') && currCols[z].classList.remove('lyteTableFixed')
                        if (ltPropFixedColumnClass) {
                            currCols[z].classList.remove(ltPropFixedColumnClass)
                        }
                    }
                    Lyte.arrayUtils(columns, 'removeAt', j)
                }
                else {
                    break;
                }
            }
            for (var j = 0; j < columns.length; j++) {
                //positioning on scroll
                var left, cells = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/,
                    uA = navigator.userAgent.toLowerCase();
                if (j == 0) {
                    if (direction == 'rtl') {
                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (_lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {
                            left = scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                        else if (uA.indexOf('edge') != -1 || uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1) {
                            left = -scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                        else {
                            left = scrollLeft - 1 - (obj.scrollWidth) + obj.scrollDivClient.width + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                    }
                    else {
                        left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))
                    }
                }
                else {
                    if (direction == 'rtl') {
                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (_lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {
                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)
                        }
                        else {
                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1);
                        }
                    }
                    else {
                        left = component.transform(!1, columns[j - 1]) /*parseInt(columns[j - 1].style.left)*/ - component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)
                    }
                }
                for (var x = 0; x < cells.length; x++) {
                    !cells[x].classList.contains('lyteTableFixed') && cells[x].classList.add('lyteTableFixed');
                    //cells[x].style.left = left + 'px';
                    component.transform(false, cells[x], left)
                }
                // columns[j].style.left = left + 'px';
                component.transform(false, columns[j], left)
                for (var zz = 0; zz < head.length; zz++) {
                    var colex = head[zz].getElementsByTagName('lyte-th')[columns[j].order];
                    if (colex) {
                        !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed');
                        // colex.style.left = left + 'px';
                        component.transform(false, colex, left)
                    }
                }
            }
        }
        this.prevScollLeft = scrollLeft;
        this.prevScollTop = scrollTop;
    },

    transform: function (flag, elem, value) {
        var transform = (elem.style.transform || 'translateX(0px) translateY(0px)'),
            transX = parseFloat(/translateX\((.+)/.exec(transform)[1]),
            transY = parseFloat(/translateY\((.+)/.exec(transform)[1]);

        if (value != undefined) {
            if (!flag) {
                elem.style.transform = "translateY(" + transY + 'px) ' + 'translateX(' + value + 'px)';
            } else {
                elem.style.transform = "translateY(" + value + 'px) ' + 'translateX(' + transX + 'px)';
            }
        } else {
            return parseFloat(flag ? transY : transX);
        }
    },
    // border 

    borderChangeObs: function () {
        this.borderChange.call(this);
    }.observes('ltPropBorder').on('didConnect'),

    borderChange: function () {
        if (this.data.ltPropBorder) {
            this.$node.classList.add('border');
        }
        else {
            this.$node.classList.remove('border');
        }
    },

    widthObsObs: function () {
        this.widthObs.call(this);
    }.observes('ltPropWidth').on('didConnect'),

    widthObs: function () {
        this.$node.querySelector('lyte-table-structure').style.width = this.data.ltPropWidth;
    },

    heightObsObs: function () {
        this.heightObs.call(this);
    }.observes('ltPropHeight').on('didConnect'),

    heightObs: function () {
        this.$node.querySelector('lyte-table-structure').style.height = this.data.ltPropHeight;
    },

    sortableObs: function () {
        this.sortable.call(this);
    }.observes('ltPropColumnSortable').on('didConnect'),

    sortable: function () {
        var row = this.$node.querySelector('lyte-thead');
        if (row) {
            if (this.data.ltPropColumnSortable) {
                this.colSort = this.sortableColumns.bind(this)
                row.addEventListener('mousedown', this.colSort);
                row.addEventListener('touchstart', this.colSort);
                row.parentElement.classList.add('sortableTable')
            }
            else {
                row.removeEventListener('mousedown', this.colSort);
                row.removeEventListener('touchstart', this.colSort);
                row.parentElement.classList.remove('sortableTable')
            }
        }
    },

    composePath: function (event) {
        var arr = [], node = event.target.correspondingElement || event.target;
        while (node && node.tagName != 'HTML') {
            arr.push(node);
            node = node.parentNode;
        }
        return arr;
    },

    sortableColumns: function (event) {
        var target = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), 'lyte-th:not(.lyteTableFixed)');
        if (target && this.$node.contains(target)) {
            var ret, isTch = event.type == "touchstart";
            if (this.getMethods('onBeforeSelect')) {
                /**
                 * @method onBeforeSelect
                 * @version 1.0.3
                 */
                ret = this.executeMethod('onBeforeSelect', target, event, this.$node)
            }
            if (ret != false) {
                var evt = isTch ? event.touches[0] : event
                this._ww = window.innerWidth;
                this.mousemove = this.sortableMouseMove.bind(this);
                this.offLeft = this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.rtlfunc.call(this, 'left', target.getBoundingClientRect(), this._ww);
                this.colHead = target;
                this._thisBccr = this.$node.getBoundingClientRect()
                target.classList.add('sortSelect')
                document.documentElement.addEventListener(isTch ? "touchmove" : 'mousemove', this.mousemove);
                this.mouseup = this.sortableMouseup.bind(this);
                document.documentElement.addEventListener(isTch ? "touchend" : 'mouseup', this.mouseup);
                this.flag = true;
                event.preventDefault();
                if (this.getMethods('onSelect')) {
                    /**
                     * @method onSelect
                     * @version 1.0.3
                     */
                    this.executeMethod('onSelect', target, event, this.$node)
                }
            }
        }
    },

    horiScroll: function (dummyDiv, ww) {
        var lt = this.rtlfunc.call(this, 'left'), IE = this.isIE11Lyte || this.isEdgeLyte,
            isEvt, check1, check2;
        if (/mousemove|touchmove/i.test(dummyDiv.type)) {
            isEvt = true;
        }
        if (isEvt) {
            if (this._reqId) {
                return;
            }
            check1 = this.rtlfunc.call(this, 'clientX', dummyDiv, ww) > Math.min(this.rtlfunc.call(this, 'right', this._thisBccr, ww), ww - 2);
            check2 = this.rtlfunc.call(this, 'clientX', dummyDiv, ww) <= Math.max(0, this.rtlfunc('left', this._thisBccr, innerWidth));
        } else {
            check1 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;
            check2 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;
        }

        if (check1) {
            this.scrollDiv.scrollLeft += 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)
            if (isEvt) {
                this.resizeComponent.offLeft -= 2;
            }
            this._reqId = window.requestAnimationFrame(function () {
                delete this._reqId;
                this.horiScroll(dummyDiv, ww)
            }.bind(this))
        } else if (check2) {
            if (isEvt) {
                this.resizeComponent.offLeft += 2;
            }
            this.scrollDiv.scrollLeft -= 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)
            this._reqId = window.requestAnimationFrame(function () {
                delete this._reqId;
                this.horiScroll(dummyDiv, ww);
            }.bind(this))
        } else {
            window.cancelAnimationFrame(this._reqId);
            delete this._prevent;
        }
    },

    sortableMouseMove: function (event) {
        var isTch = event.type == "touchmove", evt = event;
        if (isTch && evt.touches.length != 1) {
            return
        } else if (isTch) {
            evt = evt.touches[0]
        }
        if (this.flag && this._timeout == undefined) {
            var target = this.colHead, xscroll;
            var clientRect = target.getBoundingClientRect();
            var div = document.createElement('div');
            div.classList.add('lyteTableSortHelper');
            div.innerHTML = this.colHead.innerText;
            this._xxoff = xscroll = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? -1 : 1);
            var yscroll = window.pageYOffset || document.documentElement.scrollTop
            div.style.height = clientRect.height + 'px';
            div.style.width = clientRect.width + 'px';
            div.style[this.rtlfunc.call(this, 'left')] = (xscroll + this.rtlfunc.call(this, 'left', clientRect, this._ww)) + 'px';
            div.style.top = (yscroll + clientRect.top) + 'px';
            this._timeout = setTimeout(function () {
                document.body.appendChild(div);
                this.flag = false;
            }.bind(this), 100)
        }
        var dummyDiv = document.querySelector('div.lyteTableSortHelper')
        if (dummyDiv) {
            var lft = this._dir ? "right" : "left", ww = window.innerWidth;
            var newLeft = Math.max(Math.min((this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.offLeft), this.rtlfunc.call(this, 'right', this._thisBccr, this._ww) - parseFloat(dummyDiv.style.width)), this.rtlfunc.call(this, 'left', this._thisBccr, this._ww));
            // if( ( newLeft > parseFloat( dummyDiv.style[ lft ] - this._xxoff ) ) || ( newLeft < parseFloat( dummyDiv.style[ lft ] ) - this._xxoff ) ){
            if ((parseFloat(newLeft) > this.rtlfunc('left', this._thisBccr, ww)) && ((parseFloat(newLeft) + parseFloat(dummyDiv.style.width)) < this.rtlfunc('right', this._thisBccr, ww))) {
                window.cancelAnimationFrame(this._reqId);
                delete this._prevent; delete this._scrollDir
            }
            if (this._prevent) {
                return
            }
            dummyDiv.style[lft] = (newLeft + this._xxoff) + 'px';
            this._prevent = true
            this.horiScroll(dummyDiv, ww)
            if (this.getMethods('onDrag')) {
                /**
                 * @method onDrag
                 * @version 1.0.3
                 */
                this.executeMethod('onDrag', this.colHead, dummyDiv, event, this.$node)
            }
        }
        event.preventDefault();
        event.stopPropagation();
    },

    sortableMouseup: function (event) {
        if (!this.flag) {
            var isTch = event.type == "touchend", dummyDiv = document.getElementsByClassName('lyteTableSortHelper')[0], clientRect = dummyDiv.getBoundingClientRect(), x = clientRect.left + clientRect.width / 2 + 2, y = clientRect.top + clientRect.height / 2,
                adjCol = this.closestFind.call(this, document.elementsFromPoint ? document.elementsFromPoint(x, y) : this.elementsFromPointCal.call(this, x, y), 'lyte-th:not(.lyteTableFixed)'),
                tbody = this.$node.getElementsByTagName('lyte-tbody')[0];
            if (adjCol != this.colHead && adjCol) {
                var Heads = this.colHead.parentElement.getElementsByTagName('lyte-th'),
                    colOrder = Array.prototype.indexOf.call(Heads, this.colHead),
                    adjOrder = Array.prototype.indexOf.call(Heads, adjCol),
                    ltPropHeader = this.data.ltPropHeader, ret;
                if (this.getMethods('onBeforeDrop')) {
                    /**
                     * @method onBeforeDrop
                     * @version 1.0.3
                     */
                    ret = this.executeMethod('onBeforeDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)
                }
                if (ret != false) {
                    if (!ltPropHeader.length) {
                        _lyteUiUtils.insertBefore(adjOrder > colOrder ? adjCol.nextElementSibling : adjCol, this.colHead);
                        var colGrp = /*this.isIE11Lyte ? */this.nthoftype.call(this, tbody, colOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( colOrder + 1) +')' )*/;
                        var AdjColGrp = /*this.isIE11Lyte ?*/ this.nthoftype.call(this, tbody, adjOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( adjOrder + 1) +')' )*/;
                        for (var i = 0; i < colGrp.length; i++) {
                            _lyteUiUtils.insertBefore(adjOrder > colOrder ? AdjColGrp[i].nextElementSibling : AdjColGrp[i], colGrp[i]);
                        }
                    }
                    else {
                        var flag = adjOrder > colOrder ? true : false;
                        var temp = Lyte.arrayUtils(ltPropHeader, 'removeAt', colOrder), newOrder = Array.prototype.indexOf.call(adjCol.parentElement.getElementsByTagName('lyte-th'), adjCol);
                        Lyte.arrayUtils(ltPropHeader, 'insertAt', colOrder < adjOrder ? (newOrder + 1) : newOrder, temp);
                        var newCol = adjCol.parentElement.getElementsByTagName('lyte-th', adjCol.parentElement)[colOrder < adjOrder ? (newOrder + 1) : newOrder];
                        if (adjCol.classList.contains('tableRowFixed')) {
                            newCol.classList.add('tableRowFixed');
                            newCol.style.top = adjCol.style.top;
                        }
                    }
                    if (this.getMethods('onDrop')) {
                        /**
                         * @method onDrop
                         * @version 1.0.3
                         */
                        this.executeMethod('onDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)
                    }
                }
            }
            document.body.removeChild(dummyDiv);
        } else {
            clearTimeout(this._timeout)
        }
        document.documentElement.removeEventListener(isTch ? "touchend" : 'mouseup', this.mouseup);
        document.documentElement.removeEventListener(isTch ? "touchmove" : 'mousemove', this.mousemove);
        this.colHead.classList.remove('sortSelect')
        window.cancelAnimationFrame(this._reqId)
        delete this.mouseup; delete this._xxoff;
        delete this.mousemove;
        delete this.offLeft;
        delete this.colHead;
        delete this.flag;
        delete this._timeout;
        delete this._thisBccr; delete this._ww;
        delete this._reqId; delete this._prevent; delete this._scrollDir
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
    },

    elementsFromPointCal: function (x, y) {
        var arr = [], element = document.elementFromPoint(x, y);
        while (element != document && element != document.documentElement && element != document.body && element != this.$node) {
            element.style.pointerEvents = 'none';
            arr.push(element);
            element = document.elementFromPoint(x, y);
        }
        for (var i = 0; i < arr.length; i++) {
            arr[i].style.pointerEvents = 'initial';
        }
        return arr;
    },

    resizeComponentAppendObs: function () {
        if (this.data.ltPropYield) {
            this.resizeComponentAppend.call(this);
        }
    }.observes('ltPropResize', 'ltPropResize.{}'),

    resizeComponentAppend: function () {
        var ltPropResize = this.data.ltPropResize, scrdiv = this.$node.getElementsByTagName('lyte-table-structure')[0],
            tRz = scrdiv.getElementsByTagName('lyte-table-resize')[0], vrz = scrdiv.getElementsByTagName('lyte-table-vertical-resize')[0],
            hrz = scrdiv.getElementsByTagName('lyte-table-horizontal-resize')[0];
        if (ltPropResize.vertical || ltPropResize.horizontal) {
            if (!tRz) {
                var comp = document.createElement('lyte-table-resize')
                scrdiv.appendChild(comp)
                comp.addEventListener('mousedown', this.actions.tableResize.bind(this));
                comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
            }
        } else if (tRz) {
            scrdiv.removeChild(tRz)
        }
        if (ltPropResize.vertical) {
            if (!vrz) {
                var comp = document.createElement('lyte-table-vertical-resize')
                scrdiv.appendChild(comp)
                comp.addEventListener('mousedown', this.actions.tableResize.bind(this))
                comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
            }
        }
        else if (vrz) {
            scrdiv.removeChild(vrz)
        }
        if (ltPropResize.horizontal) {
            if (!hrz) {
                var comp = document.createElement('lyte-table-horizontal-resize')
                scrdiv.appendChild(comp)
                comp.addEventListener('mousedown', this.actions.tableResize.bind(this))
                comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
            }
        }
        else if (hrz) {
            scrdiv.removeChild(hrz)
        }
    },

    data: function () {
        return {
            //user data
            /**
             * @componentProperty {object[]} ltPropContent
             * @version 1.0.0
             * @default []
             */
            ltPropContent: Lyte.attr("array", { "default": [] }),
            /**
             * @componentProperty {object[]} ltPropHeader
             * @version 1.0.0
             * @default []
             */
            ltPropHeader: Lyte.attr("array", { "default": [] }),
            /**
             * @componentProperty {string} ltPropId=''
             * @version 1.0.0
             */
            ltPropId: Lyte.attr("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropClass=''
             * @version 1.0.0
             */
            ltPropClass: Lyte.attr("string", { "default": '' }),
            /**
             * @componentProperty {boolean} ltPropBorder=false
             * @version 1.0.0
             */
            ltPropBorder: Lyte.attr("boolean", { "default": false }),
            /**
             * @componentProperty {string} ltPropHeaderLabelKey=''
             * @version 1.0.0
             */
            ltPropHeaderLabelKey: Lyte.attr("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropBodyLabelKey=''
             * @version 1.0.0
             */
            ltPropBodyLabelKey: Lyte.attr("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropWidth=100%
             * @version 1.0.0
             */
            ltPropWidth: Lyte.attr('string', { 'default': '100%' }),
            /**
             * @componentProperty {string} ltPropHeight=100%
             * @version 1.0.0
             */
            ltPropHeight: Lyte.attr('string', { 'default': '100%' }),
            /**
             * @typedef {object} tableResize
             * @property {boolean} horizontal
             * @property {boolean} vertical
             */

            /**
             * @componentProperty {tableResize} ltPropResize
             * @version 1.0.0
             * @default {}
             */
            ltPropResize: Lyte.attr('object', { 'default': {} }),
            /**
             * @componentProperty {string} ltPropFixedColumnClass=''
             * @version 1.0.0
             */
            ltPropFixedColumnClass: Lyte.attr('string', { 'default': '' }),
            /**
             * @componentProperty {boolean} ltPropYield=false
             * @version 1.0.0
             */
            ltPropYield: Lyte.attr('boolean', { 'default': false }),
            /**
             * @typedef {object} tableScroll
             * @property {boolean} horizontal=true
             * @property {boolean} vertical=true
             */
            /**
             * @componentProperty {tableScroll} ltPropScroll
             * @default {"horizontal":true,"vertical":true}
             */
            ltPropScroll: Lyte.attr('object', { 'default': { horizontal: true, vertical: true } }),
            /**
             * @componentProperty {boolean} ltPropColumnSortable=false
             * @version 1.0.0
             */
            ltPropColumnSortable: Lyte.attr('boolean', { 'default': false }),
            /**
             * @typedef {object} tableScrollbar
             * @property {left | right} verticalPosition=left
             * @property {top | bottom} horizontalPosition=bottom
             * @property {string} containerClass
             * @property {string} handlerClass
             * @property {string} horizontalContainerClass
             * @property {string} horizontalHandlerClass
             * @property {string} verticalContainerClass
             * @property {string} verticalHandlerClass
             * @property {boolean} preventVertical
             * @property {boolean} preventHorizontal
             * @property {number} keyStep=30
             * @property {hover | always | scroll} showOn=scroll
             * @property {number} wheelSpeed=1
             * @property {boolean} preventOnEnd=true
             * @property {object} offset={"x":0,"y":0}
             * @property {boolean} nested
             * @property {number} max=Infinity
             * @property {number} min=-Infinity
             */
            /**
             * @componentProperty {tableScrollbar} ltPropScrollbarOption
             * @version 1.0.0
             * @default {}
             */
            ltPropScrollbarOption: Lyte.attr('object', { 'default': {} }),
            /**
             * @componentProperty {boolean} ltPropDualResize=false
             * @version 1.0.5
             */
            ltPropDualResize: Lyte.attr('boolean', { default: false }),

            // scroll table test data
            /**
             * @experimental ltPropData
             */
            ltPropData: Lyte.attr("array", { "default": [] }),
            /**
             * @componentProperty {boolean} ltPropInfiniteScroll=false
             * @version 1.0.0
             */
            ltPropInfiniteScroll: Lyte.attr('boolean', { 'default': false }),
            /**
             * @componentProperty {string} ltPropCellHeight=20px
             * @version 1.0.2
             */
            ltPropCellHeight: Lyte.attr('string', { default: '20px' }),
            /**
             * @componentProperty {number} ltPropContentLength
             * @version 1.0.2
             */
            ltPropContentLength: Lyte.attr('number'),
            /**
             * @componentProperty {boolean} ltPropPreventScrollbar=false
             * @version 1.0.0
             */
            ltPropPreventScrollbar: Lyte.attr('boolean', { default: false }),

            lyteUnbound: Lyte.attr('boolean', { default: false }),

            // system data
            columns: Lyte.attr('array', { 'default': [] }),
            nonFixedColumn: Lyte.attr('array', { 'default': [] }),
            minWidth1: Lyte.attr('string', { 'default': '' }),
            minWidth2: Lyte.attr('string', { 'default': '' }),
            secondaryData: Lyte.attr('array', { 'default': [] }),
            boundary: Lyte.attr('object', { 'default': {} }),
            rowHeights: Lyte.attr('array', { 'default': [] })
        }
    },
    actions: {
        //  resize initialization  
        'tableResize': function (event) {
            // $L.fastdom.measure(function(){
            var isTch = event.type == "touchstart", evt = event;
            if (isTch && event.touches.length != 1) {
                return;
            } else if (isTch) {
                evt = event.touches[0];
            }
            var resizeComponent = event.target.parentElement, Component = this, prevSibling = resizeComponent.previousElementSibling;
            document.Component = this; this.resizeComponent = resizeComponent, this.targetElem = evt.target;
            if (((resizeComponent.parentElement.querySelector('lyte-th:last-of-type') != resizeComponent || this.data.ltPropDualResize) && resizeComponent.tagName == 'LYTE-TH') || resizeComponent.tagName != 'LYTE-TH') {
                this._thisBccr = this.$node.getBoundingClientRect();
                var wwidth = window.innerWidth, bcr = resizeComponent.getBoundingClientRect();
                if (this.data.ltPropDualResize) {
                    this.oriTab = this.$node.getElementsByTagName('lyte-table-structure')[0]
                    tabWid = this.oriTab.getBoundingClientRect().width;
                }
                resizeComponent.offLeft = bcr.width + this.rtlfunc.call(this, 'left', bcr, wwidth)
                resizeComponent.offTop = evt.clientY
                document.addEventListener(isTch ? 'touchend' : 'mouseup', this.mouseup)
                document.addEventListener(isTch ? 'touchmove' : 'mousemove', this.resizeFunc)
                if (resizeComponent.tagName == 'LYTE-TH') {
                    var headerList = this.$node.getElementsByTagName('lyte-th');
                    var arr = [], tabWid, dummyWid, dummyWid1, flag = resizeComponent.nextElementSibling;
                    $L.fastdom.measure(function () {
                        for (var i = 0; i < headerList.length; i++) {
                            if (!headerList[i].style.width || resizeComponent == headerList[i]) {
                                arr.push(headerList[i].offsetWidth)
                            }
                            else {
                                arr.push(null);
                            }
                        }
                        $L.fastdom.mutate(function () {
                            resizeComponent.classList.add('resizeSelect')
                            this.$node.classList.add('resizing')
                            for (var i = 0; i < headerList.length; i++) {
                                if (arr[i]) {
                                    headerList[i].style.width = arr[i] + 'px';
                                }
                            }
                            if (flag) {
                                dummyWid = flag.style.width;
                            }
                            dummyWid1 = resizeComponent.style.width;
                            $L.fastdom.measure(function () {
                                if (flag) {
                                    flag.style.removeProperty('width')
                                }
                                this.minWidth.call(this, resizeComponent, 'minWidth1')
                                if (flag) {
                                    flag.style.width = dummyWid
                                }
                                if (!this.data.ltPropDualResize) {
                                    resizeComponent.style.removeProperty('width')
                                    this.minWidth.call(this, flag, 'minWidth2')
                                    resizeComponent.style.width = dummyWid1;
                                }
                                $L.fastdom.mutate(function () {
                                    if (this.data.ltPropDualResize) {
                                        this.oriTab.style.width = tabWid + 'px';
                                    }
                                }.bind(this))
                            }.bind(this))
                        }.bind(this))
                    }.bind(this))
                } else {
                    var innTab = this.$node.getElementsByTagName('lyte-table-structure')[0];
                    innTab.style.width = innTab.getBoundingClientRect().width + 'px';
                    this.$node.classList.add('tableResing')
                }
            }
            // }.bind(this))
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
        }
    },
    //min - width calculation
    minWidth: function (resizeComponent, arg) {
        // for find original min width of a cell its width is set to its minumum width and width calculated 
        var minWidth = window.getComputedStyle(resizeComponent, null).getPropertyValue('min-width'),
            width = resizeComponent.style.width
        resizeComponent.style.width = minWidth == '0px' ? '50px' : minWidth;
        minWidth = resizeComponent.offsetWidth + 'px'
        resizeComponent.style.width = width
        this.setData(arg, minWidth)
    },

    resetScrollbar: function (evt) {
        this.$node.classList.remove('tableResing')
        $L.fastdom.measure(function () {
            var thisBccr = this.$node.getBoundingClientRect(), tabBccr = this.$node.getElementsByTagName('lyte-table-structure')[0].getBoundingClientRect(),
                xscroll = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? -1 : 1),
                ww = window.innerWidth;
            if (this.scrollDiv.resetScrollbar && this.scrollDiv.classList.contains('eventBinded')) {
                this.scrollDiv.resetScrollbar(true)
            }
            $L.fastdom.mutate(function () {
                var tbcr = this.rtlfunc.call(this, 'right', thisBccr, ww), tabr = this.rtlfunc.call(this, 'right', tabBccr, ww);
                var div = this.$node.querySelector('.lyteScrollContainer.lyteScrollContainerY:not(.left)'), divX = this.$node.querySelector('.lyteScrollContainer.lyteScrollContainerX');
                if (div) {
                    if (tbcr - tabr > 0) {
                        div.style[this.rtlfunc.call(this, 'right')] = (tbcr - tabr + xscroll) + 'px'
                    } else {
                        div.style.removeProperty('right')
                    }
                }

                if (divX) {
                    if (tbcr - tabr > 0) {
                        divX.style.width = (tabBccr.width / thisBccr.width * 100) + '%'
                    } else {
                        divX.style.removeProperty('width')
                    }
                }
            }.bind(this))
        }.bind(this))
    },

    // resize finishing
    mouseup: function (event) {
        var isTch = event.type == 'touchend', component = document.Component, resizeComponent = component.resizeComponent;
        component.resetScrollbar.call(component, event);
        delete document.Component; delete component.oriTab;
        document.removeEventListener(isTch ? 'touchend' : 'mouseup', component.mouseup);
        document.removeEventListener(isTch ? 'touchmove' : 'mousemove', component.resizeFunc);
        $L.fastdom.mutate(function () {
            resizeComponent.classList.remove('resizeSelect')
            component.$node.classList.remove('resizing')
            document.removeEventListener(isTch ? 'touchend' : 'mouseup', component.mouseup)
            document.removeEventListener(isTch ? 'touchmove' : 'mousemove', component.resizeFunc)
            delete document.Component; delete component.oriTab; delete this._thisBccr;
            if (component.getMethods('onResizeEnd')) {
                $L.fastdom.mutate(function () {
                    /**
                     * @method onResizeEnd
                     * @version 1.0.3
                     */
                    component.executeMethod('onResizeEnd', resizeComponent, component.$node)
                })
            }
        })
        window.cancelAnimationFrame(component._reqId);
        delete component._reqId;
        event.stopPropagation()
    },
    // resizing
    resizeFunc: function (event) {
        var isTch = event.type == "touchmove", evt = event;
        if (isTch && event.touches.length != 1) {
            return
        } else if (isTch) {
            evt = evt.touches[0];
        }
        var component = document.Component, ww = window.innerWidth, resizeComponent = component.resizeComponent, cx = component.rtlfunc.call(component, 'clientX', evt, ww), ltPropResize = component.data.ltPropResize, offset = cx - resizeComponent.offLeft,
            width2 = parseInt(resizeComponent.style.width);
        if ((ltPropResize.horizontal || resizeComponent.tagName == 'LYTE-TH') && offset) {
            var width = offset + width2, tableWidth = component.getData('tableWidth');
            if (resizeComponent.tagName == 'LYTE-TH') {
                if (width > Math.ceil(parseFloat(component.getData('minWidth1')))) {
                    var next = resizeComponent.nextElementSibling, width1 = next ? (next.getBoundingClientRect().width - offset) : 0;
                    if (!component.data.ltPropDualResize && width1 > Math.ceil(parseFloat(component.getData('minWidth2')))) {
                        next.style.width = (width1) + 'px'
                        resizeComponent.style.width = (width) + 'px'
                    } else if (component.data.ltPropDualResize) {
                        if (component.oriTab) {
                            component.oriTab.style.width = (parseInt(component.oriTab.style.width) + offset) + 'px';
                        }
                        resizeComponent.style.width = (width) + 'px';
                        if (cx > Math.max(component.rtlfunc('left', component._thisBccr, ww), 0) && cx < Math.min(component.rtlfunc('right', component._thisBccr, ww), ww)) {
                            window.cancelAnimationFrame(component._reqId);
                            delete component._reqId;
                        }
                    }
                }
            }
            else if (resizeComponent.tagName != 'LYTE-TH' && (component.targetElem.tagName == 'LYTE-TABLE-HORIZONTAL-RESIZE' || component.targetElem.tagName == 'LYTE-TABLE-RESIZE')) {
                var elem = resizeComponent.parentElement;
                if (elem.tagName == 'LYTE-YIELD') {
                    elem = elem.parentElement;
                }
                resizeComponent.style.width = width + 'px'
                // component.$node.style.width = resizeComponent.style.width;
            }
            resizeComponent.offLeft = cx
            delete resizeComponent.width;
        }
        component.horiScroll(evt, ww);
        if (ltPropResize.vertical && resizeComponent.tagName != 'LYTE-TH' && (component.targetElem.tagName == 'LYTE-TABLE-VERTICAL-RESIZE' || component.targetElem.tagName == 'LYTE-TABLE-RESIZE')) {
            resizeComponent.style.height = (evt.clientY + resizeComponent.getBoundingClientRect().height - resizeComponent.offTop) + 'px'
            resizeComponent.offTop = evt.clientY
        }
        event.preventDefault();
        event.stopPropagation();
    },

    arrayFrom: function (nodeList) {
        if (Array.from) {
            return Array.from(nodeList)
        }
        return Array.apply(Array, nodeList);
    },

    closestFind: function (path, query) {
        var elements = this.arrayFrom.call(this, document.querySelectorAll(query));
        for (var i = 0; i < path.length; i++) {
            if (Array.prototype.indexOf.call(elements, path[i]) != -1) {
                return path[i];
            }
        }
        return null;
    },

    findDomIndex: function (order) {
        var data = this.data.ltPropData;
        for (var i = 0; i < data.length; i++) {
            if (data[i].index == order) {
                return i;
            }
        }
        return -1;
    },

    insertRow: function (index, insertData) {
        var boundary = this._boundary,
            top = boundary.top,
            bottom = boundary.bottom,
            content = this.data.ltPropContent,
            data = this.data.ltPropData;

        this._prevent = true;

        Lyte.arrayUtils(content, 'insertAt', index, insertData);

        if (index <= bottom) {
            var start = Math.max(top, index);

            for (var i = start; i <= bottom; i++) {
                var domIndex = this.findDomIndex(i);
                Lyte.Component.set(data[domIndex], { index: data[domIndex].index, body: content[i] });
            }
        }

        if( this.data.ltPropContentLength > content.length ){
            var _length = data.length;

            Lyte.arrayUtils( data, 'push', {
                index : _length,
                body : content[ _length ],
                checked : false
            });

            boundary.bottom++;
            this._bottom++;

            if( this._rowHgt ){
                this._step = this._rowHgt * data.length;
            }
        }

        delete this._prevent;
    },

    removeRow: function (dataIndex) {
        var rows = this.arrayFrom($L('lyte-tbody lyte-tr:not(.dummy)', this.$node));

        if (dataIndex.constructor != Number) {
            dataIndex = dataIndex.dataOrder || rows.indexOf(dataIndex);
        }

        var domIndex = this.findDomIndex(dataIndex),
            boundary = this._boundary,
            top = boundary.top,
            bottom = boundary.bottom,
            content = this.data.ltPropContent,
            data = this.data.ltPropData;

        this._prevent = true;

        if (domIndex != -1) {
            if (bottom == content.length - 1) {
                for (var i = dataIndex; i <= bottom; i++) {
                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;
                    if (i + 1 == content.length) {
                        this.regex(rows[cIndex], true);

                        if ( this._dummy ) {
                            var _style = this._dummy.style;
                            _style.transform = 'translateY(' + ( parseFloat( _style.transform.match( /[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';
                            
                            if ( this._dummy1 ) {
                                var _style1 = this._dummy1.style;
                                _style1.transform = 'translateY(' + ( parseFloat( _style1.transform.match( /[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';
                            }
                        }
                        if( content[ top - 1 ] ){
                            Lyte.Component.set(data[cIndex], { index: data[cIndex].index, body: content[top - 1] });
                            rows[ cIndex ].dataOrder = top - 1;
                        }
                    } else {
                        Lyte.Component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });
                        rows[cIndex].dataOrder--;
                    }
                }
                boundary.bottom--;
                boundary.top--;
                this._bottom = (this._bottom - 1 + data.length) % data.length;
                this._top = (this._top - 1 + data.length) % data.length;
            } else {
                for (var i = dataIndex; i <= bottom; i++) {
                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;
                    Lyte.Component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });
                }
                if (this._dummy) {
                    var _style = this._dummy.style;
                    _style.height = Math.max( 0, parseFloat( _style.height ) - this._rowHgt ) + 'px';
                }
            }
            Lyte.arrayUtils(content, 'removeAt', dataIndex);
        } else {
            Lyte.arrayUtils(content, 'removeAt', dataIndex);
            if (dataIndex < top) {

                for (var i = top; i <= bottom; i++) {
                    var cIndex = (this._top + i - top + rows.length) % rows.length;
                    Lyte.Component.set(data[cIndex], { index: data[cIndex].index, body: content[i == content.length ? (top - 1) : i] });
                    if (i == bottom) {
                        this.regex(rows[cIndex], true);
                        this._bottom = (this._bottom - 1 + data.length) % data.length;
                        this._top = (this._top - 1 + data.length) % data.length;
                    }
                }

                boundary.bottom--;
                boundary.top--;

                var _style = this._dummy.style;
                _style.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style.transform.match(/[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) ) + 'px)';
                if (this._dummy1) {

                    var _style1 = this._dummy1.style;
                    _style1.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style1.transform.match( /[\d|.]+/ig )[ 0 ] ) - this._rowHgt ) ) + 'px)';
                }

            } else if (dataIndex > bottom) {
                if (this._dummy) {
                    this._dummy.style.height = Math.max(0, parseFloat(this._dummy.style.height) - this._rowHgt) + 'px';
                }
            }

        }

        if( content.length < this.data.ltPropContentLength ){
            Lyte.arrayUtils( data, 'pop' );
        }

        delete this._prevent;
    },

    scrollToRecord: function (rowIndex) {
        var content = this.data.ltPropContent,
            contentLength = content.length;

        if (rowIndex == undefined || rowIndex < 0 || rowIndex >= contentLength) {
            return;
        }

        if (!this._rowHgt) {
            this.$node.scrollTable();
        }

        $L.fastdom.clear(this._scrollToRecord);

        this._scrollToRecord = $L.fastdom.measure(this.processScrollToRecord.bind(this, rowIndex));

        // this.processScrollToRecord( rowIndex );
    },

    processScrollToRecord: function (rowIndex) {
        var boundary = this._boundary,
        top = boundary.top,
        bottom = boundary.bottom,
        content = this.data.ltPropContent,
        data = this.data.ltPropData,
        contentLength = data.length,
        length = content.length,
        step = this._step,
        rowHeight = this._rowHgt,
        scrollDiv = this.scrollDiv,
        offsetHeight = scrollDiv.offsetHeight,
        scrollHeight = scrollDiv.scrollHeight,
        scrollTop = scrollDiv.scrollTop,
        scrollPosition = Math.max(0, Math.min(rowIndex, content.length - contentLength)),
        newScrollTop = scrollPosition * rowHeight,
        scrollToSet;

        if( content.length <= contentLength ){
            scrollToSet = Math.max( 0, Math.min( scrollHeight - offsetHeight, rowIndex * rowHeight ) );
        } else if (bottom >= rowIndex) {
            scrollToSet = newScrollTop;
        } else {
            if (scrollPosition != rowIndex) {
                newScrollTop += (step - offsetHeight);
                var thead = $L('lyte-thead', this.$node).get(0);
                if (thead) {
                    newScrollTop += thead.getBoundingClientRect().height;
                }
            }

            var scrollHeight = scrollDiv.scrollHeight,
            maxScrollTop = scrollHeight - offsetHeight,
            diff = step - offsetHeight;

            if (newScrollTop <= maxScrollTop) {
                scrollToSet = newScrollTop;
            } else {
                var rows = this.arrayFrom($L('lyte-tbody lyte-tr:not(.dummy)', this.$node)),
                    fact = Math.floor(scrollPosition / contentLength),
                    newscrollPosition = scrollPosition % contentLength;

                for (var i = 0; i < contentLength; i++) {
                    var cIndex = scrollPosition + i,
                    domIndex = cIndex % contentLength,
                    dom = rows[i],
                    iteration = fact + (i < newscrollPosition ? 1 : 0);

                    Lyte.Component.set(data[domIndex], { index: cIndex, body: content[cIndex] });
                    this.cellSet(dom, "translateY(0px)")
                    for (var j = 0; j < iteration; j++) {
                        this.regex(dom);
                    }
                }

                if( !this._dummy ){
                    this.createDummy( this.$node.querySelector( 'lyte-tbody' ) );
                }

                this._dummy.style.transform = 'translateY(' + (scrollPosition * rowHeight) + 'px)';
                if (this._dummy1) {
                    this._dummy1.style.transform = 'translateY(' + (scrollPosition * rowHeight) + 'px)';
                }
                scrollToSet = newScrollTop;
                boundary.top = scrollPosition;
                boundary.bottom = scrollPosition + contentLength - 1;
                this._top = scrollPosition % contentLength;
                this._bottom = (scrollPosition + contentLength - 1) % contentLength;
            }
        }
        $L.fastdom.mutate(function () {
            scrollDiv.scrollTop = scrollToSet;
        })
    }

});
if (!_lyteUiUtils.registeredCustomElements['lyte-th']) {
    _lyteUiUtils.registeredCustomElements['lyte-th'] = true;
    /**
     * @customElement lyte-th,lyte-td
     */
    Lyte.createCustomElement("lyte-th", {
        static: {
            "observedAttributes": {
                get: function () {
                    return ['fixed', 'resize', 'icon'];
                }
            }
        },
        "attributeChangedCallback": function (attr, oldVal, newVal) {
            if (attr == 'fixed') {
                var scrollingDiv = this;
                while (scrollingDiv.tagName != 'DIV') {
                    scrollingDiv = scrollingDiv.parentElement;
                }
                if (newVal == 'enable') {
                    this.classList.add('lyteFixedColumn');
                } else {
                    this.classList.remove('lyteFixedColumn');
                }
            } else if (attr == 'resize') {
                if (newVal == 'enable') {
                    var tabHead = document.createElement('lyte-tablehead-resize');
                    tabHead.addEventListener('mousedown', this.resize);
                    tabHead.addEventListener('touchstart', this.resize);
                    this.appendChild(tabHead);
                } else {
                    var tabHead = this.getElementsByTagName('lyte-tablehead-resize')[0];
                    if (tabHead) {
                        this.removeChild(tabHead);
                    }
                }
            } else if (attr == 'icon') {
                if (newVal == 'disable') {
                    this.classList.add('lytePreventIcon');
                } else {
                    this.classList.remove('lytePreventIcon');
                }
            }
        },
        resize: function (event) {
            if (this.parentNode.classList.contains('lyteTableFixed')) {
                return;
            }
            var table = $L(event.target).closest('lyte-table')[0];
            table.component.actions.tableResize.call(table.component, event);
        }
    });

    function resizeTable (evt) {
        if (evt && evt.type == 'resize' && _lyteUiUtils.isMobile) {
            return;
        }
        var tables = document.body.querySelectorAll('lyte-table[lyte-rendered]');
        for (var i = 0; i < tables.length; i++) {
            var comp = tables[i].component;
            evt && evt.type == "orientationchange" ? setTimeout(comp.resetScrollbar.bind(comp), 500, evt) : comp.resetScrollbar.call(comp, evt);
        }
    }
}


/**
 * @syntax nonYielded
 *   <lyte-table  lt-prop-content='[{"cityName" : "Agra","serialNo" : "1"},{"cityName" : "Mysore", "serialNo" : "2"}]' lt-prop-header='[{"data" : "From", "bodyData" : "cityName"},{"data" : "No", "bodyData" : "serialNo"}]' lt-prop-header-label-key='data' lt-prop-body-label-key='bodyData' >
 *   </lyte-table>
 */

/**
 * @syntax yielded
 * <lyte-table lt-prop-yield="true">
 *      <template is="registerYield" yield-name="yield">
 *          <lyte-table-structure>
 *             <lyte-thead>
 *                <lyte-tr>
 *                   <lyte-th>From</lyte-th>
 *                   <lyte-th>No</lyte-th>
 *                   <lyte-th>Name</lyte-th>
 *                </lyte-tr>
 *             </lyte-thead>
 *             <lyte-tbody>
 *                <lyte-tr>
 *                   <lyte-td>Agra</lyte-td>
 *                   <lyte-td>1</lyte-td>
 *                   <lyte-td>Tajmahal</lyte-td>
 *                </lyte-tr>
 *                <lyte-tr>
 *                   <lyte-td>Mysore</lyte-td>
 *                   <lyte-td>2</lyte-td>
 *                   <lyte-td>Mysorepalace</lyte-td>
 *                </lyte-tr>
 *             </lyte-tbody>
 *          </lyte-table-structure>
 *      </template>
 *  </lyte-table>
 */

/**
 * @syntax
 * @attribute ltPropYield=true
 * @attribute ltPropInfiniteScroll=true
 *  <lyte-table style = 'height: 350px;' lt-prop-infinite-scroll = true lt-prop-yield = true lt-prop-content = {{contentJSON}} scroll-end = {{method('someMethod')}}>
 *   <template is = 'registerYield' yield-name = 'yield'>
 *       <lyte-table-structure>
 *           <lyte-thead>
 *               <lyte-tr>
*                  <lyte-th> From </lyte-th>
*                  <lyte-th> No </lyte-th>
*                  <lyte-th> Name </lyte-th>
 *              </lyte-tr>
 *           </lyte-thead>
 *           <lyte-tbody>
 *             <lyte-tr>
 *               <lyte-td> Agra </lyte-td>
 *               <lyte-td> 1 </lyte-td>
 *               <lyte-td> Taj Mahal </lyte-td>
 *             </lyte-tr>
 *              <lyte-tr>
 *               <lyte-td> Mysore </lyte-td>
 *               <lyte-td> 2 </lyte-td>
 *               <lyte-td> Mysore palace </lyte-td>
 *             </lyte-tr>
 *           </lyte-tbody>
 *       </lyte-table-structure>
 *   </template>
 *  </lyte-table>
 */
/**
 * Renders a tabs component
 * @component lyte-tabs
 * @version 1.0.0
 * @utility addTab,deleteTab,openTab,enableTab,disableTab,addCloseIcon
 * @methods onBeforeOpen,onOpen,onBeforeDelete,onDelete,onBeforeMenuOpen,onMenuOpen,onBeforeMenuCLose,onMenuClose,onMenuClick,onBeforeMenuRender,onAfterMenuRender
 */

Lyte.Component.register("lyte-tabs", {
_template:"<template tag-name=\"lyte-tabs\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"tabYield\"></lyte-yield> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropYield","ltPropHover","ltPropActiveClass","ltPropPosition","ltPropCloseIcon","prevTarget","ltPropHeight","ltPropType","ltPropMaxWidth","ltPropTabStyle","ltPropMenuWrapperClass","ltPropCurrentTab","menuLabels"],
    init: function () {
        this.$node.addTab = function (newTab) {
            this.component.constructTabs(this, newTab);
        };
        this.$node.deleteTab = function (tabId) {
            this.component.deleteTabContent(tabId);
        };
        this.$node.openTab = function (tabId) {
            this.component.openTabContent(tabId);
        };
        this.$node.enableTab = function (tabId) {
            this.component.enableTab(tabId);
        };
        this.$node.disableTab = function (tabId) {
            this.component.disableTab(tabId);
        };
        this.$node.addCloseIcon = function () {
            this.component.checkCloseIcon();
        };
        
    },

    data: function () {
        return {

            /**
             * @experimental ltPropYield
             */
            "ltPropYield": Lyte.attr("boolean", { "default": true }),

            /**
             * @componentProperty {string} ltPropHover
             * @version 1.0.0
             * @default lyteTabHover
             */
            "ltPropHover": Lyte.attr("string", { "default": "lyteTabHover" }),

            /**
             * @componentProperty {string} ltPropActiveClass
             * @version 1.0.0
             * @default lyteTabActive
             */
            "ltPropActiveClass": Lyte.attr("string", { "default": "lyteTabActive" }),
            /**
             * @typedef {object} position
             * @property {top|bottom|left|right} pos
             * @property {top|bottom|left|right} align
             */
            /**
             * @componentProperty {object} ltPropPosition
             * @version 1.0.0
             * @default { "pos":"top","align":"left" }
             */
            "ltPropPosition": Lyte.attr("object", { "default": { 'pos': 'top', 'align': 'left' } }),

            /**
             * @componentProperty {boolean} ltPropCloseIcon
             * @version 1.0.0
             * @default false
             * 
             */
            "ltPropCloseIcon": Lyte.attr("boolean", { "default": false }),
            // "ltPropChangedHeader" : Lyte.attr("boolean",{"default":false}),
            "prevTarget": Lyte.attr("object", { "default": null }),

            /**
             * @componentProperty {string} ltPropHeight
             * @version 1.0.0
             * @default 400px
             * @suffix px,pt,cm,mm,vh,vm,em
             */
            "ltPropHeight": Lyte.attr("string", { "default": "400px" }),

            /**
             * @componentProperty {string} ltPropType
             * @version 1.0.0
             * @options collapse
             */
            "ltPropType": Lyte.attr("string"), //options - collapse

            /**
             * @componentProperty {string} ltPropMaxWidth
             * @version 1.0.0
             * @default 90%
             * @suffix px,pt,cm,mm,vh,vm,em,%
             */
            "ltPropMaxWidth": Lyte.attr("string", { "default": "90%" }),

            /**
             * @componentProperty {string} ltPropTabStyle
             * @version 2.2.7
             * @options nested
             */
            "ltPropTabStyle": Lyte.attr("string"),     //nested

            /**
             * @componentProperty {string} ltPropMenuWrapperClass
             * @version 2.2.8
             */
            "ltPropMenuWrapperClass": Lyte.attr("string"),
            /**
             * @typedef {object} currentTab 
             * @property {string} index
             * @property {string} name
             */
            /**
             * @componentProperty {currentTab} ltPropCurrentTab
             * @version 3.6.0
             */
            "ltPropCurrentTab": Lyte.attr("object"),
            "menuLabels": Lyte.attr("array", { "default": [] })
        }
    },

    didConnect: function () {
        this.initialFunc(true);
    },

    didDestroy: function () {
        if (this.$node.checkTabs) {
            clearTimeout(this.$node.checkTabs);
            this.$node.checkTabs = false;
        }
    },

    /**
     * The method is going to perform the computations after the tabs component is rendered
     * @param {boolean} onRender - boolean value determines if afterRender method will be triggered or not
     *
     */
    initialFunc: function (onRender) {

        //Checking whether the lyte-tabs is having any content or not by counting its child element for avoiding unnecessary error
        if (this.$node.childElementCount > 1 || this.$node.children[0].tagName === "LYTE-TAB") {

            //Checking the format provided by user for lyte-tabs
            /* **-- NOT REQUIRED NOW --**   --   If the format is Format 2 then convert it to format 1 
            if(this.$node.firstElementChild.tagName === "LYTE-TAB"){
                var node = this.$node.cloneNode(true);
                this.$node.innerHTML = "";
                this.$node.append(document.createElement('lyte-tab-head'));
                this.$node.append(document.createElement('lyte-tab-body'));
                var childNodes = node.querySelectorAll('lyte-tab');
                for(var v=0; v<childNodes.length ; v++){
                    this.constructTabs(this.$node,childNodes[v]);
                }
            }
            **-- NOT REQUIRED NOW --** */
            this.checkTabStyle();
            this.$node.style.height = this.getData('ltPropHeight');
            var head = this.$node.querySelector('lyte-tab-head');
            head.classList.add('lyteTabNav');
            if (this.getData('ltPropType') == "collapse") {
                head.classList.add('lyteTabOverflowV');
            }
            var position = this.getData("ltPropPosition");
            var labels = head.querySelectorAll('lyte-tab-title') /*this.getHeader(head.children)*/;
            var contents = this.getContent(this.$node.querySelector('lyte-tab-body').children);
            var active = this.getData('ltPropActiveClass');
            var pos;
            this.setPosition(position);
            // if(this.getData('ltPropCloseIcon')){
            //     this.createCloseIcon(head.querySelectorAll('lyte-tab-title'));
            // }
            this.checkCloseIcon(head);

            var clickFn = function (event) { this.showTab(event) };
            var mouseoverFn = function (event) { this.mouseOver(event) };
            var mouseoutFn = function (event) { this.mouseOut(event) };

            //Binds the events to tab-head
            head.addEventListener('click', clickFn.bind(this), true);
            head.addEventListener('mouseover', mouseoverFn.bind(this), true);
            head.addEventListener('mouseout', mouseoutFn.bind(this), true);

            //To open a tab content
            for (var i = 0; i < labels.length; i++) {
                if (labels[i].classList.contains(active)) {
                    pos = i;
                }
            }
            for (var i = 0; i < contents.length; i++) {
                if (pos && (pos === i || labels[pos].getAttribute('lt-prop-id') === contents[i].id)) {
                    // contents[i].classList.add('lyteTabShow');
                    this.executeOnBeforeOpen(labels[pos], labels[pos].getAttribute('lt-prop-id'), null);
                    contents[i].classList.add('lyteTabShow');
                    this.setData('ltPropCurrentTab', { 'index': pos, 'name': labels[pos].textContent.trim() });
                    this.executeOnOpen(labels[pos], labels[pos].getAttribute('lt-prop-id'));
                }
                else {
                    // contents[i].classList.add('lyteTabHide');
                    contents[i].classList.add('lyteTabHide');
                }
            }
            if (!pos) {
                pos = 0;
                this.executeOnBeforeOpen(labels[0], labels[0].getAttribute('lt-prop-id'), null);
                labels[0].classList.add(active);
                contents[0].classList.remove('lyteTabHide');
                contents[0].classList.add('lyteTabShow');
                this.setData('ltPropCurrentTab', { 'index': pos, 'name': labels[pos].textContent.trim() });
                this.executeOnOpen(labels[0], labels[0].getAttribute('lt-prop-id'));
            }
            this.setData('prevTarget', labels[pos]);

            $L.fastdom.measure(function () {    //Sets the height and width of the tab label and content based on the given values and positions.
                if (this.getData('ltPropHeight') == "auto") {
                    if (position.pos === "left" || position.pos === "right") {
                        this.$node.querySelector('.lyteTabNav').style.height = "auto";
                        this.$node.querySelector('lyte-tab-body').style.height = "auto";
                    }
                    if (position.pos === "top" || position.pos === "bottom") {
                        this.$node.querySelector('lyte-tab-body').style.height = "auto";
                    }
                    this.makeAlignment(this.getData("ltPropPosition"));
                    onRender && this.getMethods('afterRender') && this.executeMethod('afterRender', this.$node);
                }
                else {
                    var cs = window.getComputedStyle(this.$node);
                    var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                        (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
                    var navHeight = this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height;
                    var thisHeight = parseInt(cs.height) - borderDimensionY;
                    $L.fastdom.mutate(function () {
                        if (position.pos === "left" || position.pos === "right") {
                            this.$node.querySelector('.lyteTabNav').style.height = thisHeight + "px";
                            this.$node.querySelector('lyte-tab-body').style.height = thisHeight + "px";
                        }
                        if (position.pos === "top" || position.pos === "bottom") {
                            this.$node.querySelector('lyte-tab-body').style.height = (thisHeight - navHeight) + "px";
                        }
                        this.makeAlignment(this.getData("ltPropPosition"));
                        onRender && this.getMethods('afterRender') && this.executeMethod('afterRender', this.$node);
                    }, this);
                }
            }, this);

            // this.customizeTitleTab(position.pos);
        }
        else {
            console.error("No content detected");
        }

    },

    checkTabStyle: function () {
        if (this.getData('ltPropTabStyle') === "nested") {
            this.$node.classList.add('lyteNestedTab');
        }
    },

    onPositionChange: function () {
        var comp = this.$node;
        // comp.className = '';
        comp.classList.remove('lyteTabDefaultLeft', 'lyteTabDefaultRight', 'lyteTabDefaultTop', 'lyteTabDefaultBottom');
        var compHead = comp.querySelector('lyte-tab-head');
        var compBody = comp.querySelector('lyte-tab-body');
        var compHeaders = comp.querySelectorAll('lyte-tab-title');
        compHead.classList.remove('lyteTabAlignStart', 'lyteTabAlignEnd', 'lyteTabAlignCenter');
        compHead.removeAttribute("style");
        compBody.removeAttribute("style");
        compHeaders[0].style.marginLeft = "";
        compHeaders[0].style.marginTop = "";
        for (var i = 0; i < compHeaders.length; i++) {
            compHeaders[i].style.float = "";
        }
        comp = null;
        compHead = null;
        compHeaders = null;
        compBody = null;
        this.initialFunc(false);
    }.observes('ltPropPosition'),

    onHeightChange: function () {
        this.$node.style.height = this.getData('ltPropHeight');
        this.setHeight(this.getData('ltPropPosition'));
    }.observes('ltPropHeight'),

    showTab: function (event) {
        var target = event.target.correspondingElement || event.target;
        while (target && target.parentNode && target.tagName != 'LYTE-TAB-TITLE') {
            target = target.parentNode;
        }
        if (!target || target.tagName == 'HTML' || target.isEqualNode(document) || target.tagName != 'LYTE-TAB-TITLE') {
            return;
        }
        var id = target.getAttribute('lt-prop-id');

        //If user has clicked on the close icon
        if (event.target.classList.contains('lyteTabCloseIcon')) {
            var returnVal = this.deleteTabContent(id);
            if (!returnVal) {
                return;
            }
            this.makeAlignment(this.getData('ltPropPosition'));
            target = (this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title').length > 0) ? this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title')[0] : null;
            if (!target) {
                this.setData('prevTarget', null);
                return
            }
            id = target.getAttribute('lt-prop-id');
        }
        // this.executeOnBeforeOpen(id,this.getData('prevTarget').getAttribute('lt-prop-id'));
        this.openTabContent(target);
        // this.openTabContent(id);
        // this.executeOnOpen(id);
        // this.setData('prevTarget',target);
    },

    mouseOver: function (event) {

        var target = event.target.correspondingElement || event.target;
        // console.log(target);
        while (target && target.parentNode && target.tagName != 'LYTE-TAB-TITLE') {
            target = target.parentNode;
        }
        if (!target || target.tagName == 'HTML' || target.isEqualNode(document)) {
            return;
        }
        var hover = this.getData('ltPropHover');
        // event.currentTarget.classList.add(hover);
        $L(target).addClass(hover);
    },

    mouseOut: function (event) {
        // console.log("out");
        var target = event.target.correspondingElement || event.target;
        while (target && target.parentNode && target.tagName != 'LYTE-TAB-TITLE') {
            target = target.parentNode;
        }
        if (!target || target.tagName == 'HTML' || target.isEqualNode(document)) {
            return;
        }
        var hover = this.getData('ltPropHover');
        // event.currentTarget.classList.remove(hover);
        $L(target).removeClass(hover);
    },

    getContent: function (children) {
        var contents = [];
        for (var i = 0; i < children.length; i++) {
            if (children[i].tagName == "LYTE-TAB-CONTENT") {
                contents.push(children[i]);
            }
        }
        return contents;
    },
    getHeader: function (children) {
        var headers = [];
        for (var i = 0; i < children.length; i++) {
            if (children[i].tagName == "LYTE-TAB-TITLE") {
                headers.push(children[i]);
            }
        }
        return headers;
    },


    //Changes tabs in Format 2 to Format 1 structure
    //Also creates new tab if called from the addTab function
    constructTabs: function (parentEle, node) {
        var title = "";
        var content = "";
        var id;
        var isObject = false;
        var titleEle = document.createElement('lyte-tab-title');
        var contentEle = document.createElement('lyte-tab-content');
        if (typeof node === "object" && node.tagName === "LYTE-TAB") {
            title = node.getAttribute("lt-prop-title");
            content = node.innerHTML;
            id = node.getAttribute("lt-prop-id");
        }
        else {
            title = node.title;
            content = node.content;
            id = node.id;
            isObject = true;
        }
        if (!id) {
            id = this.generateId(title);
        }
        titleEle.innerHTML = title;
        contentEle.innerHTML = content;
        titleEle.setAttribute('lt-prop-id', id);
        contentEle.id = id;
        contentEle.classList.add('lyteTabHide');
        parentEle.querySelector('lyte-tab-head').append(titleEle);
        parentEle.querySelector('lyte-tab-body').append(contentEle);

        //Checks whether the format is changed or a new tab is added
        //If a new tab is added it will execute the code inside this if-block
        if (isObject) {
            // var clickFn = function(event){this.showTab(event)};
            // var mouseoverFn = function(event){this.mouseOver(event)};
            // var mouseoutFn = function(event){this.mouseOut(event)};
            // titleEle.addEventListener('click',clickFn.bind(this));
            // titleEle.addEventListener('mouseover',mouseoverFn.bind(this));
            // titleEle.addEventListener('mouseout',mouseoutFn.bind(this));
            if (this.getData('ltPropCloseIcon')) {
                this.createCloseIcon(new Array(titleEle));
            }
            this.makeAlignment(this.getData('ltPropPosition'));
        }
    },

    deleteTabContent: function (tabId) {
        if (tabId) {
            var returnVal = true;
            if (this.getMethods('onBeforeDelete')) {
                returnVal = this.executeMethod('onBeforeDelete', tabId, this.$node);
                returnVal = returnVal === undefined ? true : returnVal;
            }
            if (!returnVal) {
                return false;
            }
            var content = this.$node.querySelector('#' + tabId);
            var head = this.$node.querySelector('lyte-tab-head');
            var headers = head.querySelectorAll('lyte-tab-title');
            var isCustomized = false;
            for (var v = 0; v < headers.length; v++) {
                if (headers[v].getAttribute('lt-prop-id') === tabId) {
                    if (headers[v].classList.contains('lyteTabCustomTitleWidth')) {
                        isCustomized = true;
                    }
                    head.removeChild(headers[v]);
                    if (content) {
                        this.$node.querySelector('lyte-tab-body').removeChild(content);
                    }
                    break;
                }
            }
            if (this.getMethods('onDelete')) {
                this.executeMethod('onDelete', tabId, this.$node);
            }

            return true;
            // if(isCustomized){
            //     this.customizeTitleTab("afterDelete");
            // }
        }
    },

    enableTab: function (tabId) {
        if (tabId) {
            if (typeof tabId == "string") {
                var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
                for (var v = 0; v < headers.length; v++) {
                    if (headers[v].getAttribute('lt-prop-id') === tabId) {
                        if (headers[v].classList.contains('lyteTabDisable')) {
                            headers[v].classList.remove('lyteTabDisable');
                            if (headers[v].classList.contains('lyteTabForceHide')) {
                                Lyte.arrayUtils(this.getData('menuLabels'), "push", this.getMenuLabel(headers[v])/*headers[v].textContent*/);
                            }
                        }
                        break;
                    }
                }
            }
            if (typeof tabId == "object" && tabId.classList.contains('lyteTabDisable')) {
                tabId.classList.remove('lyteTabDisable');
                if (tabId.classList.contains('lyteTabForceHide')) {
                    Lyte.arrayUtils(this.getData('menuLabels'), "push", this.getMenuLabel(tabId)/*tabId.textContent*/);
                }
            }
        }
    },

    disableTab: function (tabId) {
        if (tabId) {
            if (typeof tabId == "string") {
                var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
                for (var v = 0; v < headers.length; v++) {
                    if (headers[v].getAttribute('lt-prop-id') === tabId) {
                        if (!(headers[v].classList.contains('lyteTabDisable'))) {
                            headers[v].classList.add('lyteTabDisable');
                            if (headers[v].classList.contains('lyteTabForceHide')) {
                                var index = this.getData('menuLabels').indexOf(this.getMenuLabel(headers[v])/*headers[v].textContent*/);
                                if (index != -1) {
                                    Lyte.arrayUtils(this.getData('menuLabels'), "removeAt", index, 1);
                                }
                            }
                        }
                        break;
                    }
                }
            }
            if (typeof tabId == "object" && !(tabId.classList.contains('lyteTabDisable'))) {
                tabId.classList.add('lyteTabDisable');
                if (tabId.classList.contains('lyteTabForceHide')) {
                    var index = this.getData('menuLabels').indexOf(this.getMenuLabel(tabId)/*tabId.textContent*/);
                    if (index != -1) {
                        Lyte.arrayUtils(this.getData('menuLabels'), "removeAt", index, 1);
                    }
                }
            }
        }
    },

    openTabContent: function (tabId) {
        if (tabId) {
            var label;
            if (typeof tabId == "string") {
                var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
                var content = this.$node.querySelector('#' + tabId);
                for (var v = 0; v < headers.length; v++) {
                    if (headers[v].getAttribute('lt-prop-id') === tabId) {
                        if (headers[v].classList.contains(this.getData('ltPropActiveClass'))) {
                            return;
                        }
                        label = headers[v];
                        var returnVal = this.executeOnBeforeOpen(label, tabId, this.getData('prevTarget') ? this.getData('prevTarget').getAttribute('lt-prop-id') : null);
                        if (!returnVal) {
                            return;
                        }
                        this.hideAll();
                        label.classList.add(this.getData('ltPropActiveClass'));
                        if (content) {
                            content.classList.remove('lyteTabHide');
                            content.classList.add('lyteTabShow');
                        }
                        this.setData('ltPropCurrentTab', { 'index': v, 'name': label.textContent.trim() });
                        this.executeOnOpen(label, tabId);
                        this.setData('prevTarget', label);
                        break;
                    }
                }
            }
            if (typeof tabId == "object") {
                if (tabId.classList.contains(this.getData('ltPropActiveClass'))) {
                    return;
                }
                label = tabId;
                var id = tabId.getAttribute('lt-prop-id');
                var content = this.$node.querySelector('#' + id);
                var returnVal = this.executeOnBeforeOpen(tabId, id, this.getData('prevTarget') ? this.getData('prevTarget').getAttribute('lt-prop-id') : null);
                if (!returnVal) {
                    return;
                }
                this.hideAll();
                tabId.classList.add(this.getData('ltPropActiveClass'));
                if (content) {
                    content.classList.remove('lyteTabHide');
                    content.classList.add('lyteTabShow');
                }
                var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title'), pos;
                for (var v = 0; v < headers.length; v++) {
                    if (headers[v].isEqualNode(label) && headers[v].getAttribute('lt-prop-id') === id) {
                        pos = v;
                        break;
                    }
                }
                this.setData('ltPropCurrentTab', { 'index': pos, 'name': label.textContent.trim() });
                this.executeOnOpen(tabId, id);
                this.setData('prevTarget', tabId);
            }
            if (this.getData('ltPropType') == "collapse" && this.getData('menuLabels').indexOf(this.getMenuLabel(label)/*label.textContent*/) > -1) {
                this.collapseHeader(true);
            }
        }
    },

    checkCloseIcon: function (head) {
        if (this.getData('ltPropCloseIcon')) {
            head = head || this.$node.querySelector('lyte-tab-head');
            this.createCloseIcon(head.querySelectorAll('lyte-tab-title'));
        }
    },

    createCloseIcon: function (headers) {
        for (var v = 0; v < headers.length; v++) {
            if (!headers[v].addedCloseIcon) {
                // var span = document.createElement('span');
                // span.innerHTML = headers[v].innerHTML;
                // // span.style.float = "left";
                // headers[v].innerHTML = "";
                // headers[v].appendChild(span);
                var closeSpan = document.createElement('span');
                closeSpan.classList.add('lyteTabCloseIcon');
                // closeSpan.style.marginTop = (headers[0].getBoundingClientRect().height - 9 - 2) / 2 + 'px';
                headers[v].appendChild(closeSpan);
                headers[v].addedCloseIcon = true;
            }
        }
    },

    setPosition: function (position) {
        switch (position.pos) {
            case "left": this.$node.classList.add('lyteTabDefaultLeft');/*this.setHeight("left");*/break;
            case "right": this.$node.classList.add('lyteTabDefaultRight');/*this.setHeight("right");*/break;
            case "top": this.$node.classList.add('lyteTabDefaultTop');/*this.setHeight("top");*/break;
            case "bottom": this.$node.classList.add('lyteTabDefaultBottom');/*this.setHeight("bottom");*/break;
        }

    },

    checkHeightOnResize: function () {
        if (this.$node.getBoundingClientRect().height != (this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height + this.$node.querySelector('lyte-tab-body').getBoundingClientRect().height)) {
            this.setHeight(this.getData('ltPropPosition'));
        }
    },

    setHeight: function (position) {
        if (this.getData('ltPropHeight') == "auto") {
            if (position.pos === "left" || position.pos === "right") {
                this.$node.querySelector('.lyteTabNav').style.height = "auto";
                this.$node.querySelector('lyte-tab-body').style.height = "auto";
            }
            if (position.pos === "top" || position.pos === "bottom") {
                this.$node.querySelector('lyte-tab-body').style.height = "auto";
            }
            this.makeAlignment(this.getData("ltPropPosition"));
        }
        else {
            $L.fastdom.measure(function () {
                var cs = window.getComputedStyle(this.$node);
                var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                    (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
                var navHeight = this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height;
                var thisHeight = parseInt(cs.height) - borderDimensionY;
                $L.fastdom.mutate(function () {
                    // if(position.pos === "bottom"){
                    //     this.$node.querySelector('.lyteTabNav').style.top = (thisHeight - navHeight) + "px";
                    // }
                    if (position.pos === "left" || position.pos === "right") {
                        this.$node.querySelector('.lyteTabNav').style.height = thisHeight + "px";
                        this.$node.querySelector('lyte-tab-body').style.height = thisHeight + "px";
                    }
                    if (position.pos === "top" || position.pos === "bottom") {
                        this.$node.querySelector('lyte-tab-body').style.height = (thisHeight - navHeight) + "px";
                    }
                    this.makeAlignment(this.getData("ltPropPosition"));
                }, this);

            }, this);
        }
    },

    hideAll: function () {
        var labels = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title') /*this.getHeader(this.$node.querySelector('lyte-tab-head').children)*/;
        var contents = this.getContent(this.$node.querySelector('lyte-tab-body').children);
        var active = this.getData('ltPropActiveClass');
        for (var i = 0; i < labels.length; i++) {
            if (labels[i].classList.contains(active)) {
                labels[i].classList.remove(active);
            }
        }
        for (var v = 0; v < contents.length; v++) {
            if (contents[v].classList.contains('lyteTabShow')) {
                contents[v].classList.remove('lyteTabShow');
                contents[v].classList.add('lyteTabHide');
            }
            if (!contents[v].classList.contains('lyteTabHide')) {
                contents[v].classList.add('lyteTabHide');
            }
            if (!$L(contents[v]).hasClass('lyteTabHide')) {
                $L(contents[v]).addClass('lyteTabHide');
            }
        }
    },

    customizeTitleTab: function (prop) {
        $L.fastdom.measure(function () {
            var head = this.$node.querySelector('lyte-tab-head');
            var compWidth = this.getWidth(head, false);
            if (prop === "top" || prop === "bottom") {
                var totalWidth = 0;
                var width = 0;
                var titles = head.querySelectorAll('lyte-tab-title');
                if (this.getData('ltPropType') == "collapse") {
                    $L.fastdom.measure(function () {
                        for (var i = 0; i < titles.length; i++) {
                            totalWidth = totalWidth + this.getWidth(titles[i], true, true);
                        }
                        if (totalWidth > compWidth) {
                            this.collapseHeader();
                        }
                    }, this);
                }

            }
            if (prop === "afterDelete") {
                var titles = head.querySelectorAll('lyte-tab-title');
                var width = compWidth / titles.length;
                $L.fastdom.mutate(function () {
                    for (var i = 0; i < titles.length; i++) {
                        titles[i].style.width = width + "px";
                    }
                });
            }
        }, this);
    },

    /**
     * The method is going to do the calculations for collapsible tab and construct the menu items
     *
     */
    collapseHeader: function (onResize) {
        var head = this.$node.querySelector('lyte-tab-head'),
            compOffset = {
                width: this.getWidth(head, false),
                height: head.offsetHeight
            },
            maxWidth = this.getData('ltPropMaxWidth').indexOf('%') != -1 ? (parseInt(this.getData('ltPropMaxWidth')) * compOffset.width) / 100 : parseFloat(this.getData('ltPropMaxWidth')),
            headers = head.querySelectorAll('lyte-tab-title'),
            totalWidth = 0, allowed = -1,
            openedTab = Array.from(headers).findIndex(function (x) { return x.classList.contains('lyteTabActive') }),
            menuLabels = [];
        if (onResize) {
            for (var i = 0; i < headers.length; i++) {
                if (headers[i].classList.contains('lyteTabForceHide')) {
                    headers[i].classList.remove('lyteTabForceHide');
                }
            }
        }
        totalWidth += this.getWidth(headers[openedTab], true, true);
        for (var i = 0; i < headers.length; i++) {
            if (i != openedTab) {
                totalWidth += this.getWidth(headers[i], true, true);
                if (totalWidth > maxWidth) {
                    allowed = i;
                    break;
                }
            }
        }
        if (allowed > -1 && allowed < headers.length) {
            for (var i = allowed; i < headers.length; i++) {
                if (i == openedTab) {
                    if (openedTab > 0 && !(headers[i - 1].classList.contains('lyteTabForceHide'))) {
                        $L(headers[i - 1]).addClass('lyteTabForceHide');
                        if (!($L(headers[i - 1]).hasClass('lyteTabDisable'))) {
                            menuLabels.push(this.getMenuLabel(headers[i - 1])/*headers[i - 1].textContent*/);
                        }
                    }
                }
                else {
                    $L(headers[i]).addClass('lyteTabForceHide');
                    if (!($L(headers[i]).hasClass('lyteTabDisable'))) {
                        menuLabels.push(this.getMenuLabel(headers[i])/*headers[i].textContent*/);
                    }
                }
            }
            var menu = this.$node.querySelector('#lyteTabMenu');
            if (!menu) {
                var span = document.createElement('span');
                span.id = "moreMenu";
                var uniqueSel = this.createUniqueSlector();
                span.classList.add(uniqueSel);
                span.appendChild(document.createElement('span'));
                head.appendChild(span);
                this.createMenu(menuLabels, uniqueSel, "init");
                if (!onResize) {
                    if (this.getData('ltPropPosition').pos === "bottom") {
                        head.style.top = (head.offsetTop + (Math.ceil(compOffset.height / 2) - 1)) + "px";
                    }
                }
            }
            else/*if(onResize)*/ {
                Lyte.arrayUtils(this.getData('menuLabels'), "removeAt", 0, this.getData('menuLabels').length);
                Lyte.arrayUtils(this.getData('menuLabels'), "push", menuLabels);
            }
        }
        else {
            if (allowed == -1) {
                this.removeMenu();
            }
            // if(onResize){
            //     this.makeAlignment(this.getData('ltPropPosition'));
            // }
        }
    },

    createUniqueSlector: function () {
        var tabs = document.querySelectorAll('lyte-tabs');
        for (var i = 0; i < tabs.length; i++) {
            if (tabs[i].isEqualNode(this.$node)) {
                return "menuSel_" + i;
            }
        }
    },

    getMenuLabel: function (item) {
        var labelItem = item.querySelector('.lyteTabTitleLabel');
        return labelItem ? labelItem.textContent : item.textContent;
    },

    /**
     * The method is going to create the menu and add listeners for the methods
     *
     */
    createMenu: function (menuLabels, sel, prop) {
        if (prop == "init") {
            var menu = document.createElement('lyte-menu');
            menu.id = 'lyteTabMenu';
            this.setData('menuLabels', menuLabels);
            menu.ltProp({
                content: menuLabels,
                query: "." + sel,
                event: "click",
                callout: true
            });
            if (this.getData('ltPropMenuWrapperClass')) {
                menu.ltProp({
                    wrapperClass: this.getData('ltPropMenuWrapperClass')
                });
            }
            // this.onMenuLabelChange();
            menu.setMethods({
                onMenuClick: function (value, event, menu, menuOriginElem, subMenu) {
                    var labelText = arguments[0],
                        tab = arguments[2].parentElement.component,
                        head = arguments[3].parentElement,
                        headers = head.querySelectorAll('lyte-tab-title'),
                        label;
                    for (var i = 0; i < headers.length; i++) {
                        if (tab.getMenuLabel(headers[i])/*headers[i].textContent*/ == labelText && headers[i].classList.contains('lyteTabForceHide')) {
                            label = headers[i];
                            break;
                        }
                    }
                    if (label) {
                        label.classList.remove('lyteTabForceHide');
                        tab.openTabContent(label);
                        // LyteComponent.insertBefore(headers[0],label);
                        // tab.collapseHeader(true);
                    }
                    if (tab.getMethods('onMenuClick')) {
                        tab.executeMethod('onMenuClick', value, event, menu, menuOriginElem, subMenu, tab, label);
                    }
                },
                onBeforeOpen: function (menu, event, menuOriginElem) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onBeforeMenuOpen')) {
                        tab.executeMethod('onBeforeMenuOpen', menu, event, menuOriginElem, tab);
                    }
                },
                onOpen: function (menu, event, menuOriginElem) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onMenuOpen')) {
                        tab.executeMethod('onMenuOpen', menu, event, menuOriginElem, tab);
                    }
                },
                onBeforeClose: function (menu, event) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onBeforeMenuClose')) {
                        tab.executeMethod('onBeforeMenuClose', menu, event, tab);
                    }
                },
                onClose: function (menu, event) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onMenuClose')) {
                        tab.executeMethod('onMenuClose', menu, event, tab);
                    }
                },
                beforeRender: function (menu) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onBeforeMenuRender')) {
                        tab.executeMethod('onBeforeMenuRender', menu, tab);
                    }
                },
                afterRender: function (menu) {
                    var tab = menu.parentElement.component;
                    if (tab.getMethods('onAfterMenuRender')) {
                        tab.executeMethod('onAfterMenuRender', menu, tab);
                    }
                }
            });
            this.$node.appendChild(menu);
        }
    },

    removeMenu: function () {
        var menu = this.$node.querySelector('#lyteTabMenu');
        if (menu) {
            menu.remove();
            this.$node.querySelector('#moreMenu').remove();
        }
        this.setData('menuLabels', []);
    },

    onMenuLabelChange: function () {
        this.$node.querySelector('lyte-menu').ltProp({
            content: this.getData('menuLabels')
        })
    }/*.observes('menuLabels.[]')*/,

    makeAlignment: function (position) {
        var head = this.$node.querySelector('lyte-tab-head');
        if (position.align == "left" || position.align == "top") {
            head.classList.add('lyteTabAlignStart');
        }
        if (position.align == "right" || position.align == "bottom") {
            if (this.getData('ltPropType') == "collapse" && (position.pos == "top" || position.pos == "bottom")) {
                head.classList.add('lyteTabRightCollapse');
            }
            else {
                head.classList.add('lyteTabAlignEnd');
            }
        }
        if (position.align == "center") {
            head.classList.add('lyteTabAlignCenter');
        }
    },

    executeOnBeforeOpen: function (clickedItem, targetId, prevEleId) {
        var returnVal;
        if (this.getMethods('onBeforeOpen')) {
            returnVal = this.executeMethod('onBeforeOpen', this.$node.querySelector("#" + targetId), this.$node.querySelector("#" + prevEleId), this, clickedItem, this.getData('prevTarget') ? this.getData('prevTarget') : null);
        }
        return (returnVal === undefined ? true : returnVal);
    },

    executeOnOpen: function (clickedItem, targetId) {
        if (this.getMethods('onOpen')) {
            this.executeMethod('onOpen', this.$node.querySelector("#" + targetId), this, clickedItem);
        }
    },

    generateId: function (text) {
        while (text.indexOf(" ") !== -1) {
            text = text.replace(" ", "_");
        }
        return text;
    },

    getWidth: function (ele, includePadding, includeMargin) {
        includePadding = includePadding == undefined ? true : includePadding;
        var cs = getComputedStyle(ele),
            padding = parseInt(cs.paddingLeft) + parseInt(cs.paddingRight),
            margin = 0;
        if (includeMargin) {
            margin = parseInt(cs.marginLeft) + parseInt(cs.marginRight);
        }
        return parseFloat(cs.width) + (includePadding ? 0 : -padding) + margin;
    }
});

/**
 * @customElement lyte-tab-title,
 *                lyte-tab-head,
 *                lyte-tab-body,
 *                lyte-tab-content
 */

if (!_lyteUiUtils.registeredCustomElements['lyte-tab-title']) {

    _lyteUiUtils.registeredCustomElements['lyte-tab-title'] = true;

    Lyte.createCustomElement("lyte-tab-title", {
        static: {

        },
        connectedCallback: function () {
            // debugger
            var compEle = this.closest('lyte-tabs');
            if (compEle.getData('ltPropType') == "collapse") {
                if (compEle.checkTabs) {
                    clearTimeout(compEle.checkTabs);
                    compEle.checkTabs = false;
                }
                else {
                    this.closest('lyte-tab-head').classList.add('lyteTabVH');
                }
                compEle.checkTabs = setTimeout(function () {
                    var tab = this.closest('lyte-tabs');
                    if (tab) {
                        var comp = tab.component;
                        var head = this.parentElement;
                        var compWidth = comp.getWidth(head, false);
                        var totalWidth = 0;
                        var width = 0;
                        var titles = head.querySelectorAll('lyte-tab-title');
                        var activeTabIndex = -1;
                        for (var i = 0; i < titles.length; i++) {
                            totalWidth = totalWidth + comp.getWidth(titles[i], true, true);
                            if (titles[i].classList.contains(comp.getData('ltPropActiveClass'))) {
                                activeTabIndex = i;
                            }
                        }
                        if (activeTabIndex == -1) {
                            comp.openTabContent(titles[0]);
                        }
                        if (totalWidth > compWidth) {
                            if (comp.$node.ltProp('type') == "collapse") {
                                // $L.fastdom.mutate(function() {
                                comp.collapseHeader();
                                // },comp);
                            }
                        }
                        this.closest('lyte-tab-head').classList.remove('lyteTabVH');
                    }
                    compEle.checkTabs = false;
                }.bind(this), 100);
            }
        },
        disconnectedCallback: function () {
            var compEle = this.closest('lyte-tabs');
            if (compEle && compEle.checkTabs) {
                clearTimeout(compEle.checkTabs);
                compEle.checkTabs = false;
                this.closest('lyte-tab-head').classList.remove('lyteTabVH');
            }
        }
    });
}
/*if (!_lyteUiUtils.registeredCustomElements['lyte-tab-content']) {

    _lyteUiUtils.registeredCustomElements['lyte-tab-content'] = true;

    Lyte.createCustomElement("lyte-tab-content", {
        static: {

        },
        connectedCallback: function () {
            // debugger
            if(!this.classList.contains('lyteTabShow')){
                this.classList.add('lyteTabHide')
            }
            
        }
        
    });
}*/
window.addEventListener('resize', function () {
    if (window._lyteUiUtils.tabResizeTriggered) {
        clearTimeout(window._lyteUiUtils.tabResizeTriggered);
        window._lyteUiUtils.tabResizeTriggered = false;
    }
    window._lyteUiUtils.tabResizeTriggered = setTimeout(function () {
        var tabs = document.querySelectorAll('lyte-tabs');
        for (var i = 0; i < tabs.length; i++) {
            if (tabs[i].component.getData('ltPropType') == "collapse") {
                tabs[i].component.collapseHeader(true);
            }
            tabs[i].component.checkHeightOnResize();
        }
        window._lyteUiUtils.tabResizeTriggered = false;
    }, 50);
});

/**
 * @syntax yielded
 * <lyte-tabs>
 *     <template is = "registerYield" yield-name = "tabYield">
 *         <lyte-tab-head>
 *             <lyte-tab-title lt-prop-id = "tabs1"> Header 1 </lyte-tab-title>
 *             <lyte-tab-title lt-prop-id = "tabs2"> Header 2 </lyte-tab-title>
 *             <lyte-tab-title lt-prop-id = "tabs3"> Header 3 </lyte-tab-title>
 *             <lyte-tab-title lt-prop-id = "tabs4"> Header 4 </lyte-tab-title>
 *         </lyte-tab-head>
 *         <lyte-tab-body>
 *             <lyte-tab-content id = "tabs1"> Content 1 </lyte-tab-content>
 *             <lyte-tab-content id = "tabs2"> Content 2 </lyte-tab-content>
 *             <lyte-tab-content id = "tabs3"> Content 3 </lyte-tab-content>
 *             <lyte-tab-content id = "tabs4"> Content 4 </lyte-tab-content>
 *         </lyte-tab-body>
 *     </template>
 * </lyte-tabs>
 */

Lyte.Component.register( "lyte-tag", {
_template:"<template tag-name=\"lyte-tag\"> <lyte-dropdown on-before-show=\"{{method('preventOpen')}}\" on-add=\"{{method('onAdd')}}\" on-remove=\"{{method('onRemove')}}\" lt-prop-type=\"multisearch\" lt-prop-no-result=\"{{ltPropNoResult}}\" lt-prop-options=\"{{ltPropOptions}}\" lt-prop-user-value=\"{{ltPropUserValue}}\" lt-prop-system-value=\"{{ltPropSystemValue}}\" lt-prop-selected-list=\"{{lbind(ltPropSelectedList)}}\" lt-prop=\"{{stringify(ltPropDropdown)}}\"> <template is=\"registerYield\" yield-name=\"yield\"> <lyte-drop-button> <div class=\"lyteMultiSelect\"> <ul class=\"lyteMultipleSelect\"> <template is=\"for\" items=\"{{ltPropSelectedList}}\" item=\"item\" index=\"index\"> <li data-value=\"{{item[ltPropSystemValue]}}\"> <span class=\"lyteTagItem\">{{item[ltPropUserValue]}}</span> <lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove> </li> </template> <li class=\"lyteTagInputLi\"> <input placeholder=\"{{ltPropPlaceholder}}\" class=\"lyteDropdownTextField\" type=\"text\" oninput=\"{{action('buildItem',event)}}\" onblur=\"{{action('buildItem',event)}}\" onkeydown=\"{{action('handleOtherKeys',event)}}\"> </li> </ul> </div> </lyte-drop-button> <lyte-drop-box> <lyte-drop-body> <template is=\"for\" items=\"{{lyteOptions}}\" item=\"item\" index=\"index\"> <lyte-drop-item data-value=\"{{item[ltPropSystemValue]}}\"> <lyte-tag-label> {{item[ltPropUserValue]}} </lyte-tag-label> <template is=\"if\" value=\"{{item[ltPropDescriptionValue]}}\"><template case=\"true\"> <lyte-tag-description> {{item[ltPropDescriptionValue]}} </lyte-tag-description> </template></template> </lyte-drop-item> </template> </lyte-drop-body> </lyte-drop-box> </template> </lyte-dropdown> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1,1,1]},{"type":"for","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"attr","position":[1,1,1,3,1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropOptions","ltPropUserValue","ltPropSystemValue","ltPropDescriptionValue","ltPropSearchKeys","ltPropSelectedList","ltPropDelimiters","ltPropNoResult","ltPropDropdown","ltPropPlaceholder"],
	data: function() {
		// TODO: Decide default values for the attributes
		// FIX: Cannot read value of undefined
		return {
			'ltPropOptions': Lyte.attr( 'array', { 'default': [] } ),

			'ltPropUserValue': Lyte.attr( 'string', { 'default': '' } ),

			'ltPropSystemValue': Lyte.attr( 'string', { 'default': '' } ),

			'ltPropDescriptionValue': Lyte.attr( 'string', { 'default': '' } ),

			'ltPropSearchKeys': Lyte.attr( 'array', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'searchKeys', [] ) 
			} ),

			'ltPropSelectedList': Lyte.attr( 'array', { 'default': [] } ),

			'ltPropDelimiters': Lyte.attr( 'array', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'delimiters', [ ',', 'Enter' ] ) 
			} ),

			'ltPropNoResult': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'noResult', _lyteUiUtils.i18n( 'no.results.found' ) ) 
			} ),

			'ltPropDropdown': Lyte.attr( 'object', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'dropdown', {} ) 
			} ),

			'ltPropPlaceholder': Lyte.attr( 'string', { 
				'default': _lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'placeholder', '' ) 
			} )
		}		
	},

	didConnect: function() {
		this.setInputWidthBasedOnPlaceHolder();
		this.getDropBox().classList.add( 'lyteTagDropdown' );
		this.toggleDropIcon();
	},

	setInputWidthBasedOnPlaceHolder: function() {
		var placeholder = ( this.getData( 'ltPropPlaceholder' ) || '' ).trim(),
		input = this.getInput();

		if( placeholder.length === 0 ) {
			input.style.width = '5ch';
		}
		else {
			input.style.width = placeholder.length + 'ch';
		}
	},

	toggleDropIcon: function() {
		var options = this.getData( 'ltPropOptions' ) || [];

		if( options.length === 0 ) {
			this.getDropdown().classList.add( 'lyteTagRemoveIcon' );
		}
		else {
			this.getDropdown().classList.remove( 'lyteTagRemoveIcon' );
		}
	},

	filterItems: function( value ) {
		var visibleItems = this.getVisibleItems( value );

		this.hideItems();
		this.showItems( visibleItems );
		this.toggleNoResults();
	},

	hideItems: function() {
		var box = this.getDropBox(),
		items = box.querySelectorAll( 'lyte-drop-item' );

		items.forEach( function( item ) {
			item.classList.add( 'lyteTagHidden' );
		} );
	},

	showItems: function( resultArray ) {
		resultArray = resultArray || this.getDropBox().querySelectorAll( 'lyte-drop-item' );

		resultArray.forEach( function( item ) {
			item.classList.remove( 'lyteTagHidden' );
		} );
	},

	getVisibleItems: function( value ) {
		var result = this.filterOptions( value ), visibleItems = [], that = this;

		result.forEach( function( arrItem ) {
			visibleItems.push( that.getDropItem( arrItem ) );
		} ); 

		return visibleItems;
	},

	filterOptions: function( value ) {
		var options = this.getData( 'ltPropOptions' ) || [], that = this;

		return options.filter( function( option ) {
			return that.isValid( option, value );
		} );
	},

	isValid: function( option, value ) {
		var keys = this.getData( 'ltPropSearchKeys' ), that = this;

		return keys.some( function( key ) {
			return !!~( option[ key ] || '' ).indexOf( value );
		} );
	},

	getDropItem: function( arrItem ) {
		var sysValue = this.getData( 'ltPropSystemValue' ),
		dataValue = arrItem[ sysValue ];

		return this.getDropBox().querySelector( 'lyte-drop-item[data-value="' + dataValue + '"]' );
	},

	toggleNoResults: function() {
		if( this.hasVisibleItems() ) {
			this.hideNoResults();
		}
		else {
			this.showNoResults();
		}
	},

	hasVisibleItems: function() {
		return this.getDropBox().querySelectorAll( 'lyte-drop-item:not(.lyteTagHidden):not(.lyteDropdownActive)' ).length > 0;
	},

	showNoResults: function() {
		var noResults = this.getNoResults();

		noResults.style.display = 'block';
	},

	hideNoResults: function() {
		var noResults = this.getNoResults();

		noResults.style.display = 'none';
	},

	getNoResults: function() {
		return this.getDropBox().querySelector( '.lyteDropdownNoResult' );
	},

	getNoResults: function() {
		return this.getDropBox().querySelector( '.lyteDropdownNoResult' );
	},

	addToSelected: function( sel ) {
		Lyte.arrayUtils( this.getData( 'ltPropSelectedList' ), 'push', sel );
	},

	clearInput: function() {
		var input = this.getInput();

		input.value = '';
	},

	processInput: function( isBlur ) {
		var tags = this.getTags(),
		length = tags.length, that = this;

		if( !isBlur 
			&& length === 1 
			&& !this.isDelimiter( this.lastTypedChar() ) 
		) {
			this.filterItems( tags[ 0 ] );
		}
		else {
			tags.forEach( function( tag, index )  {
				that.filterItems( tag );
				that.buildTag( tag );
			} );

			this.showItems();
			this.toggleNoResults();
		}
	},

	getTags: function() {
		var rdelimiter = this.buildDelimiterRegex(),
		value = this.getInputValue(), result = [];

		value.split( rdelimiter ).forEach( function( item ) {
			item = item.trim();

			if( item.length ) {
				result.push( item );
			}
		} );

		return result;
	},

	buildDelimiterRegex: function() {
		var separators = this.getData( 'ltPropDelimiters' ) || [],
		res = '[';

		separators.forEach( function( item ) {
			res += item;
		} );

		res += ']'

		return new RegExp( res, 'g' );
	},

	isDelimiter: function( key ) {
		var delimiters = this.getData( 'ltPropDelimiters' );

		return !!~delimiters.indexOf( key );
	},

	lastTypedChar: function() {
		return this.getInputValue().slice( -1 );
	},

	buildTag: function( value ) {
		var box = this.getDropBox(),
		// TODO: Maybe this has something to do with lyteDropdownSelection
		firstItem = this.getHighLightedItem(),
		sel;

		if( firstItem ) {
			sel = this.getObjFromOptions( firstItem );
		}
		else {
			sel = this.buildObjManually( value );
		}

		if( sel ) {
			this.addToSelected( sel );
		}

		this.clearInput();
	},

	getObjFromOptions: function( item ) {
		var options = this.getData( 'ltPropOptions' ) || [],
		dataValue = item.getAttribute( 'data-value' ),
		sysValue = this.getData( 'ltPropSystemValue' );

		for( var i = 0; i < options.length; i++ ) {
			if( options[ i ][ sysValue ] === dataValue ) {
				return options[ i ];
			}
		}
	},

	buildObjManually: function( value ) {
		var userValue = this.getData( 'ltPropUserValue' ),
		sysValue = this.getData( 'ltPropSystemValue' ), obj = {};

		obj[ userValue ] = value;
		obj[ sysValue ] = value;

		return obj;
	},

	toggleDropdown: function() {
		var value = this.getInputValue();

		if( value.length === 0 ) {
			this.hideDropdown();
		}
		else {
			this.showDropdown();
		}
	},

	showDropdown: function() {
		this.getDropdown().open();
	},

	hideDropdown: function() {
		this.getDropdown().close();
	},

	setInputWidth: function() {
		var value = this.getInputValue(),
		placeholder = ( this.getData( 'ltPropPlaceholder' ) || '' ).trim();

		if( value.length < placeholder.length ) {
			this.setInputWidthBasedOnPlaceHolder();
		}
		else {
			input.style.width = value.length + 'ch';
		}
	},

	getDropBox: function() {
		return this.getDropdown().component.getDropBox();
	},

	getDropdown: function() {
		return this.$node.querySelector( 'lyte-dropdown' );
	},

	getInput: function() {
		return this.$node.querySelector( '.lyteDropdownTextField' );
	},

	getInputValue: function() {
		return this.getInput().value.trim();
	},

	getHighLightedItem: function() {
		return this.getDropBox().querySelector( 'lyte-drop-item.lyteDropdownSelection:not(.lyteTagHidden):not(.lyteDropdownActive)' );
	},

	optionsObserver: function() {
		this.toggleDropIcon();
	}.observes( 'ltPropOptions.[]' ),

	actions: {
		buildItem: function( event ) {
			var that = this,
			isBlur = event.type === 'blur';

			setTimeout( function() {
				that.processInput( isBlur );
				that.toggleDropdown();
			}, 10 );

			this.setInputWidth();
		},

		handleOtherKeys: function( event ) {
			var key = event.key,
			value = this.getInputValue(),
			highLightedItem = this.getHighLightedItem();

			// TODO: Need to remove key === 'Enter'
			if( key === 'Enter' && this.isDelimiter( key ) && !highLightedItem ) {
				this.buildTag( this.getInputValue() );
				event.preventDefault();
			}
		}
	},

	methods: {
		onAdd: function() {
			this.toggleNoResults();
			this.clearInput();
			this.hideDropdown();
		},

		onRemove: function() {
			this.toggleNoResults();
			this.clearInput();
			this.hideDropdown();
		},

		preventOpen: function() {
			var value = this.getInputValue(),
			options = this.getData( 'ltPropOptions' );

			if( value.length === 0 || options.length === 0 ) {
				return false;
			}
		}
	}
} );

/**
 * Tooltip is a component used to show information related to an element
 * @component lyte-tooltip
 * @version 1.0.0
 */


Lyte.Component.register('lyte-tooltip',{
_template:"<template tag-name=\"lyte-tooltip\"> </template>",
_dynamicNodes : [],
_observedAttributes :["ltPropId","ltPropClass","ltPropKeepAlive","ltPropTooltipConfig","ltPropIgnoreClass","tooltips"],
  init : function(){

    if( this.getMethods( 'beforeRender' ) ){
            /**
             * @method beforeRender
             * @version 1.0.1
             */
            this.executeMethod( 'beforeRender', this.$node );
        }
  },

  rtlfunc : function( lft, bcr, ww ) {
    if( this._dir && lft != 'top' && lft != 'clientY' ) {
      if( bcr ) {
        if( lft == 'right' ) {
          return ww - bcr.left;
        } else if( lft == 'clientX' ) {
          return ww - bcr.clientX;
        }
        return ww - bcr.right;
      } else if( lft == 'left' ) {
        return 'right';
      } else if( lft == 'right' ) {
        return 'left';
      }
    }
    return bcr ? bcr[ lft ] : lft;
  },
  
  data : function(){
    return {
      //user data
      /**
       * @componentProperty {string} ltPropId=''
       * @version 1.0.0
       */
      ltPropId : Lyte.attr('string', {default : ''}),
      /**
       * @componentProperty {string} ltPropClass=''
       * @version 1.0.0
       */
      ltPropClass : Lyte.attr('string', {default : ''}),
      /**
       * @componentProperty {boolean} ltPropKeepAlive=false
       * @version 1.0.0
       */
      ltPropKeepAlive : Lyte.attr('boolean', {default : false}),

      /**
       * @typedef {object} tooltipConfig
       * @property {left | right | top | bottom | topright | bottomright | topleft | bottomleft | followcursor} position
       * @property {box | callout} appearance=callout
       * @property {number} margin=0
       * @maxValue 20
       * @property {number} showdelay=0
       * @property {number} hidedelay=0
       * @property {number} maxdisplaytime=5000
       * @property {boolean} keeptooltip=false
       * @property {boolean} hideOnClick=true
       */

      /**
       * @componentProperty {tooltipConfig} ltPropTooltipConfig
       * @default {}
       * @version 2.2.20
       */
      ltPropTooltipConfig : Lyte.attr( 'object', { default : {} } ),

      /**
       * @componentProperty {string} ltPropIgnoreClass="lyteTooltipIgnore"
       * @version 3.28.2
       **/

      ltPropIgnoreClass : Lyte.attr( 'string', { default : "lyteTooltipIgnore" } ),

      // system data

      tooltips : Lyte.attr( 'object', { default : {} } )
    }
  },

  didConnect : function(){

      this._dir = _lyteUiUtils.getRTL();

      var tooltips = Array.from( document.body.getElementsByTagName( 'lyte-tooltip' ) );

      tooltips.forEach( function( item ){
        if( item != this.$node ){
           document.body.removeChild( item );
        }
      }.bind( this ) );

      this._mousemove = this.mousemove.bind( this );  
      this._mousedown = this.mousedown.bind( this );
      this._mouseup = this.mouseup.bind( this );
      this._keydown = this.keydown.bind( this );
      this._toolscroll = this.tooltipScroll.bind( this );

      document.addEventListener( 'mousemove', this._mousemove, true ); 
      window.addEventListener('scroll', this._toolscroll , true); 
      document.addEventListener( 'keydown', this._keydown, true);
      document.addEventListener( 'mousedown', this._mousedown, true );
      document.addEventListener( 'touchstart', this._mousedown );
      if( this.getMethods( 'afterRender' ) ) {
            /**
             * @method afterRender
             * @version 1.0.1
             */
          this.executeMethod('afterRender', this.$node);
      }
      /**
       * @utility trigger
       * @version 3.2.0
       */
      this.$node.trigger = function( node ){
        this.mousemove( { target : node || document.body } );
      }.bind( this )

  },

  tooltipScroll : function(event){
    var vis =  this.data.tooltips;

     for( var i in vis ){
        vis[ i ].classList.add( 'lyteTooltipHidden' );
     }
  },

  mousedown : function( evt ){
      this._mousedownFlag = true;
      var target = evt.target.correspondingElement || evt.target,
      $target = $L( target ),
      isTch = /touch/i.test( evt.type );

      if( isTch && evt.touches.length > 1 ){
          return;
      }

      if( $target.hasClass( 'lyteSliderHandler' ) ){
         delete this.prevTooltipNode;
         this._slider = true;   
      } 

      if( $target.hasClass( 'lyteTooltip' ) ){
         var act_node = target.nodeName1;
         this.hover_process( act_node );
         this.closeAllTooltip( act_node, true );
      } else {
         this.closeAllTooltip( void 0, true );
      }

      document.addEventListener( isTch ? 'touchend' : 'mouseup', this._mouseup, true)
  },

  mouseup : function( evt ){
      delete this._mousedownFlag;
      document.removeEventListener( evt.type, this._mouseup, true );

      if( this._slider ){
         delete this._slider;
         var target = evt.target.correspondingElement || evt.target;

         if( $L( target ).hasClass( 'lyteSliderHandler' ) ){
            this.mousemove( { target : target } );
         }
      }
  },

  keydown : function( evt ) {
     delete  this.prevTooltipNode;
     this.closeAllTooltip();
  },

  tooltipOpenCallback : function( arg1, arg2 ) {
      if( arg1.onTooltipShow ) {
          arg1.onTooltipShow.apply(this, arguments)     
      }
      if(this.getMethods( 'onTooltipShow' ) ) {
          /**
           * @method onTooltipShow
           * @version 1.0.2
           */
          this.executeMethod( 'onTooltipShow', arg1, arg2, arg1.tooltip );
      }
  },

  tooltipCloseCallback : function( arg1 ) {
      if( arg1.onTooltipHide ) {
          arg1.onTooltipHide.apply(this, arguments)     
      }
     if(this.getMethods( 'onTooltipHide' ) ) {
          /**
           * @method onTooltipHide
           * @version 1.0.2
           */
          this.executeMethod( 'onTooltipHide', arg1 );
      }
  },

  didDestroy : function(){
        window.removeEventListener('scroll', this._toolscroll , true);
        document.removeEventListener('mousemove', this._mousemove, true);
        document.removeEventListener('mousedown', this._mousedown, true);
        document.removeEventListener('touchstart', this._mousedown);
        document.removeEventListener( 'keydown', this._keydown, true );
        var exsttools = this.data.tooltips;

        for( var i in exsttools ){
          var current = exsttools[ i ];

           delete current.nodeName1.tooltipSpan;
           delete current.nodeName1.tooltip;
           if( current.parentNode ){
            document.body.removeChild( current );
          }
        }
        delete this.$node.trigger; delete this._toolscroll; delete this._mousedown; delete this._keydown; delete this._mousemove;
        this.data.tooltips = []; 
        this.data.tooltips = {};
  },

  propertySetting : function(nodeName1){
      var config = nodeName1.getAttribute( 'lt-prop-tooltip-config' ) || '{}';
      // if( config ){
          var config = JSON.parse( config );
          for( var key in config ){
              nodeName1.tooltip.config[ key ] = config[ key ];
          }
      // }
  },

  createTooltip : function( event, span, flag ){
      if( flag ){
         this.followcursor( event, span );
      } else {
         this.nonFollowcursor( event, span );
      }
      if( !this.getData( 'ltPropKeepAlive' ) ){
        var tooltip = span.nodeName1.tooltip;
        if( ( tooltip.config.keeptooltip != true && tooltip.config.keeptooltip != 'true' ) ) {
            tooltip.maxdisp = setTimeout( this.removeTooltip.bind( this, span ) , tooltip.config.maxdisplaytime );
        }
      }
  },

  followcursor : function(event, span){
    // here tooltip changes its position on every mousemov. so fastdom can't  be used here
      if( document.body.contains( span ) ){
            // span.innerText = span.nodeName1.tooltip.title; 
            if( !span._callbackHandled ) {
                this.tooltipOpenCallback( span.nodeName1, span );
                span._callbackHandled = true;
            }     
            if( span.classList.contains( 'lyteTooltipHidden' ) ){
              span.classList.remove( 'lyteTooltipHidden' );
              $L.fastdom.measure( this._followcursor.bind( this, event,span ) );
            } else {
              this._followcursor( event, span );
            }
        }
  },

  _followcursor : function( evt, span ){
      if( !this.data.tooltips[ span._random ] ){
        return;
      }
      var bcr = span.getBoundingClientRect(),
      nodeBcr = span.nodeName1.getBoundingClientRect(),
      scrollLeft = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? -1 : 1 ),
      scrollTop = window.pageYOffset || document.documentElement.scrollTop,
      iW = window.innerWidth,
      iH = window.innerHeight,
      margin = Math.min( 20, parseInt( span.nodeName1.tooltip.config.margin ) ),
      leftToSet = this.rtlfunc.call( this, 'clientX', evt, iW ),
      topToSet = ( evt.clientY + scrollTop + 5 + margin ),
      topCheck;

      if( leftToSet + bcr.width > iW ){
        if( leftToSet - bcr.width > 0 ){
           leftToSet = leftToSet - bcr.width;
        } else {
          var midFrmRgt = iW - ( this.rtlfunc( 'left', nodeBcr, iW ) + nodeBcr.width / 2 ),
          midFrmLeft = iW - midFrmRgt;

          if( midFrmRgt > bcr.width / 2 && midFrmLeft > bcr.width / 2 ){
              leftToSet = midFrmLeft - bcr.width * 0.5;
          } else {
             leftToSet = Math.max( 0, iW - bcr.width );
          }
          topCheck = true;
        }
      }

      span.style[ this.rtlfunc.call( this, 'left' ) ] = ( leftToSet + scrollLeft ) +'px';
      span.style.top = topToSet + 'px';
      if( topCheck ){
         $L.fastdom.measure( function(){
            if( !this.data.tooltips[ span._random ] ){
              return;
            }
            bcr = span.getBoundingClientRect();
            if( bcr.bottom > iH ){
               if( evt.clientY > (  iH - evt.clientY ) ){
                  span.style.top = ( evt.clientY - bcr.height - margin - 5 + scrollTop ) + 'px'
               }
            }
         }.bind( this ) )
      }
  },

  createsupp : function( span ){
     var inn = document.createElement( 'span' );
     inn.classList.add( 'lyteTooltipInnerSpan' );
     span.classList.add( 'lyteInnerToolAdded' );
     return span.appendChild( inn );
  },

  rightalign : function( innWidth, xscroll, newLeft, spanClientRect, span, prevent, event, lt, cls1, cls2, ddct, divWidth, appearance ){
      if( ( innWidth + xscroll ) < ( newLeft + spanClientRect.width ) )
             {
               span.classList.remove( cls1 );
               if( !prevent ){
                  this.nonFollowcursor( event, span, cls2 , true );
                }
               return true
            }
        else{
            if( newLeft < xscroll ){
               if( appearance ){
                  var inn = this.createsupp( span );
                  inn.style[ lt ] = divWidth * .75 - ( ddct ) + 'px';
               }
               span.style[ lt ] = 0;
            } else{
              span.style[ lt ] = newLeft + 'px';
            }
        }
  },

  refresh : function( evt, span ){
    var tooltip = span.nodeName1.tooltip,
    config = tooltip.config;

    span.textContent = tooltip.title = span.nodeName1.getAttribute( 'lt-prop-title' );

    this.clear_time( tooltip );

    this.createTooltip( evt, span );
  },

  clear_time : function( tooltip, arr ){
    ( arr || [ 'maxdisp', 'settime', 'bodyTimeout' ] ).forEach( function( item ){
         clearTimeout( tooltip[ item ] );
         delete tooltip[ item ];
    });
  },

  nonFollowcursor : function(event, span, position, prevent){
        var appearance = span.nodeName1.tooltip.config.appearance == "callout", dum;
        span.classList.remove( 'lyteTooltipHidden' );
        position = position || span.nodeName1.tooltip.config.position;
        dum = position || "bottom";
        if( appearance ){
          span.classList.add( "lyte" + dum[ 0 ].toUpperCase() + dum.slice( 1 ) )
        }
        if( !span._callbackHandled ) {
                this.tooltipOpenCallback( span.nodeName1, span );
                span._callbackHandled = true;
            } 
         $L.fastdom.measure(function(){
              // calculating page off set 
            if(  !span.nodeName1.tooltip ){
              return;
            }
            var xscroll = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? -1 : 1 );
            var yscroll = window.pageYOffset || document.documentElement.scrollTop, innWidth = window.innerWidth,  innHeight= window.innerHeight;  
            var spanClientRect = span.getBoundingClientRect();
            var nodeClientRect = span.nodeName1.getBoundingClientRect();
            var left = this.rtlfunc( 'left', nodeClientRect, innWidth ) + xscroll;
            var topPos = nodeClientRect.top + yscroll;
            var margin = Math.min( parseInt( span.nodeName1.tooltip.config.margin ), 20 );
            var toolwid = span.offsetWidth;
            var divWidth = nodeClientRect.width;
            var wid = nodeClientRect.height;
            var lt = this.rtlfunc( 'left' ),
            sty = window.getComputedStyle( span ),
            isContentBox = /content-box/.test( sty.boxSizing ),
            padLeft = isContentBox ? parseFloat( sty.paddingLeft ) : 0,
            padRight = isContentBox ? parseFloat( sty.paddingRight ) : 0,
            padTop = isContentBox ? parseFloat( sty.paddingTop ) : 0,
            padBottom = isContentBox ? parseFloat( sty.paddingBottom ) : 0,
            ddct, calloutstyle;
            if( appearance ) {
                calloutstyle = window.getComputedStyle( span, ':before' );
                ddct = parseFloat( calloutstyle.getPropertyValue( 'width' ) ) / 2 * 1.414;
                if( isNaN( ddct ) || !ddct ) {
                    ddct = parseFloat( window.getComputedStyle( span, position == "left" ? ":before" : ":after" ).getPropertyValue( 'border-left-width' ) )
                }
            } else {
                ddct = 0;
            }
            switch(position.toLowerCase())
              {
                case 'right' :
                 {
                    left += ddct;
                    var newLeft = left + divWidth + margin;
                    span.style.top=( topPos + wid / 2 - spanClientRect.height / 2 )+'px';
                    if( ( innWidth + xscroll ) < ( newLeft + spanClientRect.width ))
                      {
                         if( !prevent ){
                            if( innWidth - ( left + divWidth - xscroll - ddct ) < ( left - ddct - xscroll ) ){
                                span.classList.remove('lyteRight');
                                this.nonFollowcursor.call( this, event, span,'left', true );
                                break;
                            }
                        }
                        span.style[ lt ] = newLeft + 'px';
                        span.style.width = ( innWidth - newLeft - padLeft - padRight ) + 'px';
                        // span.style.top = this.calculateHeight( spanClientRect, textWid, span, padTop, padBottom ) + 'px';
                        $L.fastdom.mutate( function(){
                          $L.fastdom.measure( function(){
                              span.style.top = ( topPos + wid / 2 - span.getBoundingClientRect().height / 2 ) + 'px';
                          })
                        })
                      }
                    else{
                      span.style[ lt ] = newLeft + 'px';
                    }
                    break; 
                 }
                 case 'left' :
                   {
                      left -= ddct;
                      var newLeft = left - margin - toolwid;
                      span.style.top=( topPos + wid / 2 - spanClientRect.height / 2 ) + 'px';
                      if( newLeft < xscroll )
                        {
                           if( !prevent ){
                               if( left + ddct - xscroll < innWidth - ( left + ddct - xscroll + divWidth ) ){
                                 span.classList.remove('lyteLeft');
                                 this.nonFollowcursor.call(this,event, span,'right', true);
                                 break;
                               }
                            }
                            span.style[ lt ] = 0 + 'px';
                            span.style.width = ( left - xscroll - padLeft - padRight ) + 'px';
                            // span.style.top = this.calculateHeight( spanClientRect, textWid, span, padTop, padBottom ) + 'px';
                             $L.fastdom.mutate( function(){
                                $L.fastdom.measure( function(){
                                    span.style.top = ( topPos + wid / 2 - span.getBoundingClientRect().height / 2 ) + 'px';
                                })
                              })
                        }
                      else{
                           span.style[ lt ] = newLeft + 'px';
                      }  
                      break;  
                   }
                case 'bottom' :
                  {
                    topPos += ddct;
                    var newTop = ( topPos + wid + margin ), newLeft = left + divWidth / 2 - toolwid / 2;
                    if( ( yscroll + innHeight ) < ( newTop + spanClientRect.height ) ) {
                        span.classList.remove('lyteBottom');
                         if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'top', true);
                            break;
                          }
                    }
                    newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );
                    span.style[ lt ] = newLeft + 'px';
                    span.style.top = newTop + 'px';     
                    break;  
                  }     
                case 'top' :
                  {
                    topPos -= ddct;
                    var newTop = topPos - margin - span.clientHeight, newLeft = left + divWidth / 2 - toolwid / 2;
                    if( newTop < yscroll ) {
                       span.classList.remove('lyteTop');
                        if( !prevent ){
                          this.nonFollowcursor.call(this,event, span,'bottom', true);
                          break;
                        }
                    } 
                    newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );
                    span.style[ lt ] = newLeft + 'px';
                    // span.style.top = newTop + 'px';   
                    $L.fastdom.mutate( function(){
                          $L.fastdom.measure( function(){
                              span.style.top = ( topPos - margin - span.getBoundingClientRect().height ) + 'px';
                          })
                        })
                    break;     
                  }
                 case 'bottomright' :
                  {
                    topPos += ddct;
                    var newLeft = left + divWidth * .75 - ( appearance ? parseFloat( calloutstyle[ lt ] ) + ddct : 0.2 * toolwid ),
                    newTop = topPos + wid + margin;
                    if( this.rightalign( innWidth, xscroll, newLeft, spanClientRect, span, prevent, event, lt, 'lyteBottomright', 'bottomleft', ddct, divWidth, appearance ) ){
                       break;
                    }     
                   if( ( innHeight + yscroll ) < ( newTop + spanClientRect.height ) ) 
                       {
                         span.classList.remove('lyteBottomright');
                         if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'topright', true);
                          }
                         break
                       }
                     else{
                        span.style.top = newTop + 'px';
                     }  
                    break; 
                  }
                case 'topright' :
                  {
                    topPos -= ddct;
                    var newLeft = left + divWidth * .75 - ( appearance ? parseFloat( calloutstyle[ lt ] ) + ddct : 0.2 * toolwid ),
                    newTop = topPos - span.clientHeight - margin;
                    if( this.rightalign( innWidth, xscroll, newLeft, spanClientRect, span, prevent, event, lt, 'lyteTopright', 'topleft', ddct, divWidth, appearance ) ){
                       break;
                    } 
                    if( newTop < yscroll )
                        {
                           span.classList.remove('lyteTopright');
                           if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'bottomright', true);
                            }
                           break
                       }
                     else{
                        span.style.top = newTop + 'px';
                     }  
                     break;      
                 }
                case 'bottomleft' :
                   {
                     topPos += ddct;
                     var newLeft = left + divWidth *.25 - ( appearance ? parseFloat( calloutstyle[ lt ] ) : 0.8 * toolwid ) + 'px',
                     newTop =(topPos+wid+margin)+'px';
                     if(parseInt(newLeft) < xscroll)
                        {
                            span.classList.remove('lyteBottomleft');
                            if( !prevent ){
                                this.nonFollowcursor.call(this,event, span,'bottomright', true);
                            }
                            break;
                        }
                    else{
                        span.style[ lt ] = newLeft;
                    } 
                    if(( innHeight + yscroll ) < (parseInt(newTop) + spanClientRect.height))
                        {
                            span.classList.remove('lyteBottomleft');
                            if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'topleft', true);
                            }
                            break
                       }
                     else{
                        span.style.top = newTop;
                     } 
                     break; 
                    }
                 case 'topleft' :
                    {
                        topPos -= ddct;
                        var newLeft = left + divWidth *.25 - ( appearance ? parseFloat( calloutstyle[ lt ] ) : 0.8 * toolwid ) + 'px',
                        newTop = (topPos-parseInt(span.clientHeight)-margin)+'px';
                        if(parseInt(newLeft)< xscroll)
                          {
                              span.classList.remove('lyteTopleft');
                              if( !prevent ){
                                  this.nonFollowcursor.call(this,event, span,'topright', true);
                              }
                              break;
                          }
                        else{
                              span.style[ lt ] = newLeft;
                          } 
                        if(parseInt(newTop)< yscroll)
                          {   
                              span.classList.remove('lyteTopleft');
                              if( !prevent ){
                                  this.nonFollowcursor.call(this, event, span,'bottomleft', true);
                              }
                              break
                           }
                         else{
                            span.style.top = newTop;
                         }
                        break;    
                       }
                default:
                   {
                      var tooltop = ddct;
                      var newLeft = this.rtlfunc.call( this, 'clientX', event, innWidth ) - toolwid / 2 + xscroll;
                      var newTop = topPos + tooltop + wid + margin;
                      if( ( innHeight + yscroll ) < ( newTop + spanClientRect.height ) ) {
                          span.classList.remove('lyteBottom');
                          if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'top', true);
                            break;
                          }
                       }
                      newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );
                      span.style[ lt ] = newLeft + 'px';
                      span.style.top = newTop + 'px';   
                   }
                }
               span.style[ this.rtlfunc( 'right' ) ] = 'auto'; 
          }.bind(this))
    // }.bind(this))
  },

horicheck : function( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance ){
    var flag, flag2
    if( newLeft < xscroll ){
       newLeft = xscroll;
       flag = true
    }else if( innWidth + xscroll < newLeft + spanClientRect.width ) {
        newLeft = innWidth - spanClientRect.width + xscroll;
        flag2 = true;
    }

     if( ( flag || flag2 ) && appearance ){
       var inn = this.createsupp( span ), nodeleft = this.rtlfunc( 'left', nodeClientRect, innWidth ),
       leftVal;
       if( flag ){
          var lft = this.rtlfunc( 'left', nodeClientRect, innWidth );
          inn.style[ lt ] =  ( Math.min( spanClientRect.width, nodeClientRect.width ) + Math.min( lft , 0 ) )/ 2 + Math.max( 0, lft ) + 'px';
       } else {
          var rgt = innWidth - this.rtlfunc( 'right', nodeClientRect, innWidth );
          inn.style[ lt ] = spanClientRect.width - ( Math.max( 0 , rgt ) + ( Math.min( spanClientRect.width, nodeClientRect.width ) + Math.min( rgt, 0 ) ) / 2 ) + 'px';
       }
    }
    return newLeft
},

closeAllTooltip : function( current, frm_down ){

  var tooltips = this.data.tooltips;

  for( var key in tooltips ){
    var item = tooltips[ key ];
    if( item.nodeName1 != current ){
        var tooltip = item.nodeName1.tooltip;

        if( frm_down && !tooltip.config.hideOnClick ){
           continue;
        }

        if( tooltip.bodyTimeout == void 0 ){
          tooltip.bodyTimeout = setTimeout( this.removeTooltip.bind( this ), tooltip.config.hidedelay, item );
        }
    }
  }
},  

removeTooltip : function( span ){

        if( span.parentNode == document.body ){
          var node = span.nodeName1,
          tooltip = node.tooltip;

          this.clear_time( tooltip );

          if( this.prevTooltipNode == span.nodeName1 ){
             delete this.prevTooltipNode;
          }

          delete node.tooltipSpan;
          delete node.tooltip;

          document.body.removeChild( span );

          this.tooltipCloseCallback( node );
          delete this.data.tooltips[ span._random ];

        }
},

  hover_process : function( node ){
    var tooltip = ( node || {} ).tooltip;
    if( tooltip ){
        this.clear_time( tooltip );
    }
  },

  mousemove : function(event){
        if( this._mousedownFlag ) {
          return
        }
        var nodeName1 = event.target.correspondingElement || event.target;

        while(nodeName1 && nodeName1.tagName != 'BODY' && nodeName1 != document && nodeName1.tagName != 'HTML' ){
            
            var title = nodeName1.getAttribute ? nodeName1.getAttribute( 'lt-prop-title' ) : "",
            Jnode = $L( nodeName1 );

            if( Jnode.hasClass( 'lyteTooltip' ) ){
              var target_node = nodeName1.nodeName1;
              if( ( ( target_node.tooltip || {} ).config || {} ).hidedelay ){
                this.hover_process( target_node );
                return this.closeAllTooltip( target_node );
              }
            }

            if( Jnode.hasClass( this.data.ltPropIgnoreClass ) ){
                delete this.prevTooltipNode;
                nodeName1 = document.body;
                break;
            }

            if( title ){

                  if( nodeName1.getAttribute( 'title' ) ){
                      nodeName1.removeAttribute( 'title' );
                  }

                  nodeName1.tooltip = nodeName1.tooltip || {};

                  nodeName1.tooltip.config = $L.extend( { position : '', appearance : 'callout', margin : 0, showdelay : 0, hidedelay : 0, maxdisplaytime : 5000, keeptooltip : false, aria : false, hideOnClick : true }, this.data.ltPropTooltipConfig || {} );
                  nodeName1.tooltip.title = title;

                  this.propertySetting( nodeName1 );

                  var tooltip = nodeName1.tooltip;

                  if( this.prevTooltipNode != nodeName1 && !tooltip.tooltipSpan ){
                      this.prevTooltipNode = nodeName1;
                      var span = document.createElement('span'),
                      Jobj = $L( span ),
                      toolclass = Jnode.attr( 'lt-prop-tooltip-class' ),
                      ltPropId = this.getData( 'ltPropId' ), 
                      ltPropClass = this.getData( 'ltPropClass' ),
                      randomId = Date.now() + 'lytetooltip';

                      this.data.tooltips[ randomId ] = span;
                      span._random = randomId;

                      if( ltPropId ) {
                         Jobj.attr( 'id', ltPropId );
                      }
                      if( ltPropClass ) {
                         Jobj.addClass( ltPropClass );
                      }  

                      Jobj.addClass( 'lyteTooltip lyteTooltipHidden' );
                      if( this._dir ) {
                         Jobj.addClass( 'lyteRTL' );
                      }

                      Jobj.attr( 'style', Jnode.attr( 'lt-prop-tooltip-style' ) || '' );

                      if( !span.style.borderColor ){ 
                          span.style.borderColor = span.style.backgroundColor;
                      }

                      if( tooltip.config.appearance == 'callout' && tooltip.config.position != "followcursor" ) {
                        Jobj.addClass( 'lyteTooltipCallout' );
                        if( !tooltip.config.hideOnClick ){
                          tooltip.refresh = this.refresh.bind( this );
                        }
                      }

                      tooltip.tooltipSpan = span;
                      span.nodeName1 = nodeName1;
                      
                      Jobj.addClass( toolclass || '' );

                      if( tooltip.aria ){
                        Jobj.attr( 'role', 'tooltip' );
                      }

                      tooltip.settime = setTimeout( this.createTooltip.bind( this ), tooltip.config.showdelay, event, span, tooltip.config.position == 'followcursor' );
                      span.textContent = tooltip.title; 

                      document.body.appendChild( span );
                  } else if( tooltip.config.position == 'followcursor' && this.prevTooltipNode == nodeName1 && tooltip.tooltipSpan ){
                      var span = tooltip.tooltipSpan;

                      this.clear_time( tooltip, [ 'maxdisp', 'settime' ] );

                      if( !span._callbackHandled ){
                        tooltip.settime = setTimeout( this.createTooltip.bind( this ), tooltip.config.showdelay, event, span, true );
                      } else {
                        this.followcursor( event, span );
                      }
                  } else if( tooltip.tooltipSpan && tooltip.tooltipSpan.style.display == 'none' ) {
                      tooltip.tooltipSpan.style.display = '';

                      this.clear_time( tooltip );
                      
                      tooltip.settime = setTimeout( this.createTooltip.bind( this ),  tooltip.config.showdelay,event,  tooltip.tooltipSpan,  tooltip.config.position == 'followcursor' );
                  } else {
                      this.prevTooltipNode = nodeName1;
                  } 
                  this.closeAllTooltip( nodeName1 );    
                  break;       
                }
              else {
                nodeName1 = nodeName1.parentNode;
              }  
        }
      if(nodeName1 && ( [ 'BODY', 'HTML' ].indexOf( nodeName1.tagName ) != -1 ) && this.prevTooltipNode != nodeName1 ){
          delete this.prevTooltipNode;
          this.closeAllTooltip();
      } 
  }

});
if(document.readyState == "complete" || document.readyState == "interactive"){
  if(!document.body.querySelectorAll('lyte-tooltip').length){
        document.body.appendChild(document.createElement('lyte-tooltip'));
  }
}else{
  document.addEventListener('DOMContentLoaded',function(event){
    if(!document.body.querySelectorAll('lyte-tooltip').length){
        document.body.appendChild(document.createElement('lyte-tooltip'));
  }
})
}
;


/**
 * @syntax nonYielded
 * <lyte-tooltip></lyte-tooltip>
 */

/**
 * Renders data in tree view
 * @component lyte-tree
 * @version 1.0.6
 * @methods onToggle,onToggleEnd

 */
Lyte.Component.register("lyte-tree", {
_template:"<template tag-name=\"lyte-tree\"> <template is=\"for\" items=\"{{ltPropData}}\" item=\"item\" index=\"index\"> <div class=\"lyteTreeBodyDiv\"> <lyte-tree-body data-index=\"{{lyteUiTreeIndexHelp(indexVar,index)}}\" class=\"{{lyteUiTreeClassHelp(item.defaultState,item.collapsed,ltPropWrapperOpenClass,ltPropWrapperCloseClass)}}\" data-level=\"{{lyteUiTreeLevelHelp(indexVar,index)}}\"> <div class=\"mainContainer lyteTreeMainContainer {{lyteUiTreeChildHelp(item,ltPropLeafContainer,ltPropChildrenValue)}} {{lyteUiTreeHasChildHelp(item)}} {{lyteTreeMaxChild(indexVar,index,ltPropMaxLevel)}}\"> <lyte-yield collapsed=\"{{if(item.collapsed,'collapsed','')}}\" yield-name=\"content\" list-value=\"{{item}}\" class=\"{{lyteUiTreeChildHelp(item,ltPropLeafNodeClass,ltPropChildrenValue)}}\"></lyte-yield> <template is=\"if\" value=\"{{lyteUiTreeMaxLevelHelp(indexVar,index,ltPropMaxLevel)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(expHandlers(item[ltPropChildrenValue][&quot;length&quot;],'!==',0),'&amp;&amp;',expHandlers(item[ltPropChildrenValue],'!==',undefined)),'&amp;&amp;',expHandlers(item.collapsed,'!'))}}\"><template case=\"true\"> <template is=\"if\" value=\"{{expHandlers(expHandlers(item.defaultState,'!'),'||',expHandlers(item.defaultState,'===',&quot;open&quot;))}}\"><template case=\"true\"> <lyte-tree class=\"lyteTreeOpened lyteTreeChildrenLevel\" lt-prop-children-value=\"{{ltPropChildrenValue}}\" index-var=\"{{lyteUiTreeIndexHelp(indexVar,index)}}\" lt-prop-data=\"{{item[ltPropChildrenValue]}}\" id=\"{{ltPropId}}\" lt-prop-tree-lines=\"{{ltPropTreeLines}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-open-class=\"{{ltPropOpenClass}}\" lt-prop-wrapper-open-class=\"{{ltPropWrapperOpenClass}}\" lt-prop-leaf-node-class=\"{{ltPropLeafNodeClass}}\" lt-prop-close-class=\"{{ltPropCloseClass}}\" lt-prop-wrapper-close-class=\"{{ltPropWrapperCloseClass}}\" lt-prop-max-level=\"{{ltPropMaxLevel}}\" on-toggle=\"{{method('onToggle')}}\" on-toggle-end=\"{{method('onToggleEnd')}}\"> <template is=\"registerYield\" yield-name=\"content\" from-parent=\"\"> </template> </lyte-tree> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(item.defaultState,'===',&quot;close&quot;)}}\"><template case=\"true\"> <lyte-tree class=\"lyteTreeClosed lyteTreeChildrenLevel\" lt-prop-children-value=\"{{ltPropChildrenValue}}\" index-var=\"{{lyteUiTreeIndexHelp(indexVar,index)}}\" lt-prop-data=\"{{item[ltPropChildrenValue]}}\" id=\"{{ltPropId}}\" lt-prop-tree-lines=\"{{ltPropTreeLines}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-open-class=\"{{ltPropOpenClass}}\" lt-prop-wrapper-open-class=\"{{ltPropWrapperOpenClass}}\" lt-prop-leaf-node-class=\"{{ltPropLeafNodeClass}}\" lt-prop-close-class=\"{{ltPropCloseClass}}\" lt-prop-wrapper-close-class=\"{{ltPropWrapperCloseClass}}\" lt-prop-max-level=\"{{ltPropMaxLevel}}\" on-toggle=\"{{method('onToggle')}}\" on-toggle-end=\"{{method('onToggleEnd')}}\"> <template is=\"registerYield\" yield-name=\"content\" from-parent=\"\"> </template> </lyte-tree> </template></template></template></template> </template></template> </template></template> </div> </lyte-tree-body> </div> </template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"attr","position":[1,1,1,1]},{"type":"insertYield","position":[1,1,1,1]},{"type":"attr","position":[1,1,1,3]},{"type":"if","position":[1,1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]}],
_observedAttributes :["ltPropData","ltPropChildrenValue","ltPropLeafContainer","ltPropWrapperOpenClass","ltPropWrapperCloseClass","ltPropOpenClass","ltPropCloseClass","ltPropLeafNodeClass","ltPropMaxLevel","treeHeight","ltPropStateAttr","heightTransArr","collapsedAll","tempVar","indexVar"],
	data : function(){
		return {

			/**
			 * @componentProperty {array} ltPropData
			 */

			'ltPropData' : Lyte.attr('array' , {
				'default'  : []
			}),

			/**
			 * @componentProperty {string} ltPropChildrenValue
			 * @default children
			 */

			'ltPropChildrenValue' : Lyte.attr('string',{
				'default' : 'children'
			}),

			/**
			 * @componentProperty {string} ltPropLeafContainer
			 * @default lyteTreeNoChildContainer
			 */

			'ltPropLeafContainer' : Lyte.attr('string' , {
				'default' : 'lyteTreeNoChildContainer'
			}),

			/**
			 * @componentProperty {string} ltPropWrapperOpenClass
			 */

			'ltPropWrapperOpenClass' : Lyte.attr('string',{
				'default' : ''
			}),

			/**
			 * @componentProperty {string} ltPropWrapperCloseClass
			 */

			'ltPropWrapperCloseClass' : Lyte.attr('string',{
				'default' : ''
			}),

			/**
			 * @componentProperty {string} ltPropOpenClass
			 */

			'ltPropOpenClass' : Lyte.attr('string' , {
				'default'  : ''
			}),

			/**
			 * @componentProperty {string} ltPropCloseClass
			 */

			'ltPropCloseClass' : Lyte.attr('string' , {
				'default'  : ''
			}),

			/**
			 * @componentProperty {string} ltPropLeafNodeClass
			 * @default lyteTreeHasNoChild
			 */

			'ltPropLeafNodeClass' : Lyte.attr('string' , {
				'default'  : 'lyteTreeHasNoChild'
			}),

			'ltPropMaxLevel' : Lyte.attr('number' , {
				'default' : 35
			}),

			'treeHeight' :  Lyte.attr('number' , {
				'default'  : 0
			}),
			'ltPropStateAttr' : Lyte.attr('string' , {
				'default' : ''
			}),

			'heightTransArr' : Lyte.attr('array' , {
				default : []
			}),

			collapsedAll : Lyte.attr('boolean' , {
				default : false
			}),

			tempVar : Lyte.attr('string', { default : ''}),
			indexVar : Lyte.attr('string',{default : ''})
		}
	},

	init : function(){

		if($L(this.$node).attr('class') === undefined){
			$L(this.$node).addClass('lyteTreeOpened')
		}

		var _thisTree = this

	this.$node.expandAll = function(){
		var _this = this

		var treeBody = $L(this).find('lyte-tree')[0].closest('lyte-tree-body')
		var icon = $L(treeBody).find('lyte-tree-icon')[0]

		function openingFun(){

			var children = $L(_this).find('.lyteTreeChildrenLevel')
			var maxedChild = $L(_this).find('.lyteTreeMaxedChild')

			$L(children).find('.lyteTreeCollapsed').removeClass('lyteTreeCollapsed')

			$L(children).find('.lyteTreeClosed').addClass('lyteTreeOpened');
			$L(children).find('.lyteTreeClosed').removeClass('lyteTreeClosed');
			$L(maxedChild).find('.lyteTreeOpened').addClass('lyteTreeClosed');
			$L(maxedChild).find('.lyteTreeOpened').removeClass('lyteTreeOpened');

			$L(children).find('.lyteIconClosed').addClass('lyteIconOpened ' + _this.getData('ltPropOpenClass'));
			$L(children).find('.lyteIconClosed').removeClass('lyteIconClosed ' + _this.getData('ltPropCloseClass'));
			$L(maxedChild).find('.lyteIconOpened').addClass('lyteIconClosed ' + _this.getData('ltPropCloseClass'));
			$L(maxedChild).find('.lyteIconOpened').removeClass('lyteIconOpened ' + _this.getData('ltPropOpenClass'));

			$L(_this).find('.lyteTreeChildrenLevel').css({display : '' , height : 'auto'});

			icon.click();

			_this.setData('collapsedAll' , false);
		}


		if($L('.lyteTreeCollapsed').length > 0){
			if(this.getData('collapsedAll')){
				openingFun()
			}
		} else {

			$L(_thisTree.$node).find('.lyteIconClosed:not(.lyteTreeIconMaxed)').click();

		}

	}
	this.$node.collapseAll = function(){

		if(!this.getData('collapsedAll')){
			var _this = this

			var collTrans = function(){

				$L(_this).find('.lyteTreeOpened').addClass('lyteTreeClosed');
				$L(_this).find('.lyteTreeOpened').removeClass('lyteTreeOpened');

				$L(_this).find('.lyteIconOpened').addClass('lyteIconClosed ' + _this.getData('ltPropCloseClass'));
				$L(_this).find('.lyteIconOpened').removeClass('lyteIconOpened ' + _this.getData('ltPropOpenClass'));

				$L(_this).find('.lyteTreeChildrenLevel').css({display : 'none' , height : 'auto'});

				$L(_this).find('.lyteTreeChildrenLevel')[0].removeEventListener('transitionend' , collTrans)
			}

			var treeBody = $L(this).find('lyte-tree')[0].closest('lyte-tree-body')
			var icon = $L(treeBody).find('lyte-tree-icon')[0]
			if(!$L(icon).hasClass('lyteIconClosed')){
				icon.click();
				$L(this).find('.lyteTreeChildrenLevel')[0].addEventListener('transitionend' , collTrans)
			} else {
				$L(icon).addClass('lyteTreeIconClosedM');
				collTrans();
			}

			$L(this).addClass('lyteTreeCollapsed')


			this.setData('collapsedAll' , true);
		}

	}
},

	openrecursive : function( array ){
		if( array.length ){
			var newEl = array[ 0 ];
			array.shift();
			if( !newEl || newEl.classList.contains( 'lyteTreeOpened' ) ){
				this.openrecursive( array )
				return
			}
			var icon = newEl.parentElement.querySelector( 'lyte-tree-icon' );
			clearTimeout( newEl._treetime );
			newEl.classList.remove( 'lyteTreeClosed' );
			newEl.classList.add( 'lyteTreeOpened' );
			icon.classList.remove( 'lyteIconClosed' )
			icon.classList.add( 'lyteIconOpened' );
			newEl.style.display = "";
			newEl.style.height = "auto";
			this.data.ltPropCloseClass && icon.classList.remove( this.data.ltPropCloseClass );
			this.data.ltPropOpenClass && icon.classList.add( this.data.ltPropOpenClass );
			newEl._treetime = setTimeout( this.heightcalc.bind( this, newEl, array ) , 0)
		}
	},

	heightcalc : function( elem, array ){
		if( !document.body.contains( elem ) ){
			this.openrecursive( array );
			return
		}
		var height = elem.getBoundingClientRect().height;
		elem.style.height = 0;
		if( height == 0 ){
			this.transEnd( elem, array )
		} else {
			setTimeout( this.heightset.bind( this, elem, array, height ), 20 )
		}
	},

	heightset : function( elem, array, height ){
		if( !document.body.contains( elem ) ){
			this.openrecursive( array );
			return
		}
		elem.style.height = height + 'px';
		elem._trn = this.transEnd.bind( this, elem, array )
		elem.addEventListener( 'transitionend', elem._trn )
	},

	transEnd : function( elem, array ){
		elem.style.height = "auto"
		elem.removeEventListener( 'transitionend', elem._trn )
		delete elem._trn;
		this.openrecursive( array );
	},

	stateChange : function( arg ){
		if( arg.newValue ){
			var idx = arg.newValue, elements = [],
			tree = Array.from( this.$node.getElementsByTagName( 'lyte-tree' ) ),
			_length = idx.length,
			fn = function( sliced, new_tree, item ){
				var value = item.component.data.tempVar;
				if( value.startsWith( sliced ) ){
					new_tree.push( item );
				}
				return value == sliced;
			}

			for( var i =  1; i <= _length; i++ ){
				var sliced = idx.slice( 0, i ),
				new_tree = [],

				filtered = tree.filter( fn.bind( this, sliced, new_tree ) );

				tree = new_tree;

				elements.push( filtered[ 0 ] );
			}
			this.openrecursive( elements )
			this.setData( 'ltPropStateAttr', '' )
		}
	}.observes( 'ltPropStateAttr' ),
	didConnect : function(){

	},
	methods : {onToggle : function(){},onToggleEnd : function(){}}
});

if(!_lyteUiUtils.registeredCustomElements['lyte-tree-icon']){

	_lyteUiUtils.registeredCustomElements['lyte-tree-icon'] = true

	Lyte.createCustomElement("lyte-tree-icon" , {
		connectedCallback : function(){
			var currTreeElem = $L(this).closest('lyte-tree');
			if(currTreeElem.hasClass('lyteTreeClosed')){
				currTreeElem[0].style.display = 'none';
			}
			if(!this.hasAttribute('lyte-custom-icon')){
				this.innerHTML = '<i class="arrow up"></i>';
			}
		},
		constructor : function(){
			var res = true;
			var classComponent = $L(this).closest('lyte-tree')[0]
			var lyteTreeIcon = this;
			var iconCorresTree = $L(this).closest('.lyteTreeMainContainer').find('lyte-tree')[0]
			if(iconCorresTree){
				if($L(iconCorresTree).hasClass('lyteTreeOpened')){
					$L(lyteTreeIcon).addClass('lyteIconOpened ' + classComponent.getData('ltPropOpenClass'))
				} else if($L(iconCorresTree).hasClass('lyteTreeClosed')){
					$L(lyteTreeIcon).addClass('lyteIconClosed ' + classComponent.getData('ltPropCloseClass'))
				}
			}

			if(	$L(this).closest('.lyteTreeMainContainer').hasClass('lyteTreeHasChild') ||
					$L(this).closest('.lyteTreeMainContainer').hasClass('lyteTreeMaxedChild') ){
				$L(lyteTreeIcon).addClass('lyteIconClosed lyteTreeIconMaxed ' + classComponent.getData('ltPropCloseClass'))
			}

			this.addEventListener( 'click', function(evt) {
					evt.preventDefault();
					var element, btn;
					element = btn = this;
					if(element){
						while(element.nodeName !== "LYTE-TREE-BODY"){
							element = element.parentElement;
						}
					}
					var clickedBtn = element.parentElement.parentElement;
					if(clickedBtn && clickedBtn.component.getMethods('onToggle')){
						res =	clickedBtn.component.executeMethod('onToggle', element, evt, clickedBtn,lyteTreeIcon);
						if(res === undefined){
							res = true
						}
					}
					if(res){

						if(element.nodeName === "LYTE-TREE-BODY"){

							var treeCont = element.querySelector('lyte-tree');
							var transBoolean = false;
							var hTransBoolean = false;
							if((treeCont)&&(!treeCont.classList.contains('treeTransRunning'))){
								var thisBtn = treeCont.component;
									function trans(){
										transBoolean = false;
										treeCont.classList.remove('lyteTreeOpened');
										// element.classList.remove( classComponent.getData('ltPropWrapperOpenClass') )
										element.className = classComponent.getData('ltPropWrapperCloseClass')
										treeCont.classList.add('lyteTreeClosed');
										treeCont.style.height = "auto";
										btn.style.pointerEvents = "auto";
										treeCont.style.display='none';
										lyteTreeIcon.className = classComponent.getData('ltPropCloseClass');
										lyteTreeIcon.classList.add( 'lyteIconClosed' );
										treeCont.classList.remove('treeTransRunning');
										treeCont.removeEventListener('transitionend' , trans);
										if(clickedBtn && clickedBtn.component.getMethods('onToggleEnd')){
											res =	clickedBtn.component.executeMethod('onToggleEnd', element, evt, clickedBtn,lyteTreeIcon);
										}

									}
									function heightTrans(){
										// if((element.classList).indexOf(classComponent.getData('ltPropWrapperCloseClass'))>-1){
										// 	element.classList.remove( classComponent.getData('ltPropWrapperCloseClass') )
										// }
										hTransBoolean = false;
										element.className = classComponent.getData('ltPropWrapperOpenClass')
										treeCont.style.height = thisBtn.getData('treeHeight') + "px";
										treeCont.style.height = "auto";
										btn.style.pointerEvents = "auto";
										lyteTreeIcon.className = classComponent.getData('ltPropOpenClass');
										lyteTreeIcon.classList.add( 'lyteIconOpened' );
										treeCont.classList.remove('treeTransRunning');
										treeCont.removeEventListener('transitionend' , heightTrans);
										if(clickedBtn && clickedBtn.component.getMethods('onToggleEnd')){
											res =	clickedBtn.component.executeMethod('onToggleEnd', element, evt, clickedBtn,lyteTreeIcon);
										}

									}
								if(treeCont.classList.contains('lyteTreeOpened')){
									var closingTempHeight = treeCont.getBoundingClientRect().height;
									treeCont.style.height = closingTempHeight + "px";
									setTimeout(function() {
										var closingTempHeight1 = treeCont.getBoundingClientRect().height;
										treeCont.style.height = "0px";
										treeCont.classList.add('treeTransRunning');
										transBoolean = true
									}, 10);
									treeCont.addEventListener('transitionend' , trans);
								} else {
									treeCont.classList.remove('lyteTreeClosed');
									treeCont.classList.add('lyteTreeOpened');
									treeCont.style.display='';
									treeCont.style.height='auto';

									if($L(treeCont).closest('.lyteTreeCollapsed').length>0){
										$L(treeCont).closest('.lyteTreeCollapsed')[0].setData('collapsedAll' , false)
										$L(treeCont).closest('.lyteTreeCollapsed').removeClass('lyteTreeCollapsed')
									}

									thisBtn.setData('treeHeight' , treeCont.getBoundingClientRect().height);
									treeCont.style.height='0px';
									setTimeout(function() {
										treeCont.style.height= thisBtn.getData('treeHeight') + 'px'
										treeCont.classList.add('treeTransRunning');
										hTransBoolean = true
									}, 30);
									treeCont.addEventListener('transitionend' , heightTrans);

								}

								var treeTime = getComputedStyle(treeCont).transitionDuration
								treeTime = parseFloat(treeTime.match(/-?\d.\d+/g)[0]) * 1500;

									setTimeout(function(){
										if(transBoolean){
											trans(treeCont);
										}
										if(hTransBoolean){
											heightTrans(treeCont);
										}
									} , treeTime)

							}
						}

						if(res !== undefined){
							if( res && res.then ) {

									res.then( function( arg ) {
										lyteTreePromiseFun();
									},function(){});
								}	else {
									if(res){
										lyteTreePromiseFun();
									}
								}
							} else {
								lyteTreePromiseFun();
							}
							function lyteTreePromiseFun(){
								var treeDt = clickedBtn.component.getData('ltPropData');
								var path = element.getAttribute('data-index').split(" ");

								if(path.length<2){
									var pathIndex = path[0];
									var x = treeDt[pathIndex];
									if(x !== undefined){
										Lyte.objectUtils(x, 'add', 'collapsed', false);
									}
								} else {
									var x = treeDt;
									for(var pathIndex = 1;pathIndex<path.length;pathIndex++){
										var x = treeDt[path[pathIndex]];
									}
									Lyte.objectUtils(x, 'add', 'collapsed', false)
								}
							}
					} else {
						lyteTreeIcon.className = classComponent.getData('ltPropOpenClass');
						lyteTreeIcon.classList.add( 'lyteIconOpened' );
					}
			}.bind(this));
		},
		static : {"observedAttributes" : {}}
	});

}

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-tree-content' ] ) {
	_lyteUiUtils.registeredCustomElements[ 'lyte-tree-content' ] = true;

	Lyte.createCustomElement( "lyte-tree-content", {
		static: {
			"observedAttributes" : {
				get : function() {
					return [ ];
				}
			}
		},

		"connectedCallback": function() {
			var level = $L(this).closest('lyte-tree-body')[0].getAttribute('data-index').split(' ').length;
			this.setAttribute('lyte-tree-level' , level)
		}
	} );
}



/**
 * @syntax yielded
 *	 <lyte-tree>
 *	 <template is="registerYield" yield-name="content">
 *			 <lyte-tree-content onclick="{{action('test')}}">
 *				 <lyte-tree-icon lyte-custom-icon>
 *					 <div set-level="{{treeCheck(this)}}"></div>
 *						 <div class="collapseBox">
 *							 <div class="arrow"></div>
 *						 </div>
 *				 </lyte-tree-icon>
 *			 </lyte-tree-content>
 *		 </template>
 *	 </lyte-tree>
 */

// Convert most functions to this.

/**
 * Renders a tour component
 * @component lyte-tour
 * @version 3.1.0
 * @utility startTour, closeStep, nextStep, prevStep, goToStep, changeHint, skipTour
 * @methods onStart, onEnd, onBeforeNext, onNext, onBeforePrev, onPrev, onHintChange, onStepClose
 * @dependencies lyte-shortcut
 */


Lyte.Component.register("lyte-tour", {
_template:"<template tag-name=\"lyte-tour\"> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole case=\"true\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"lyteTourWrap\"> <template is=\"if\" value=\"{{ltPropFreezeLayer}}\"><template case=\"true\"> <div class=\"lyteTourFreezeLayer\"></div> </template></template> <template is=\"if\" value=\"{{expHandlers(closeStepFlag,'!')}}\"><template case=\"true\"><div class=\"lyteTourContainer {{ltPropWrapperClass}}\"> <div class=\"lyteTourLeftArrow lyteTourArrow lyteTourDefaultArrow\"></div> <div class=\"lyteTourTopArrow lyteTourArrow\"></div> <div class=\"lyteTourRightArrow lyteTourArrow\"></div> <div class=\"lyteTourBottomArrow lyteTourArrow\"></div> </div></template></template> </div> </template> </lyte-wormhole> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropTakeTour","ltPropBindToBody","ltPropWrapperClass","ltPropCreateDummy","ltPropHeight","ltPropWidth","ltPropArrowWidth","ltPropArrowHeight","ltPropArrowPosition","ltPropFixedArrow","ltPropFreezeLayer","ltPropSmartPlacement","ltPropResumeHint","ltPropResumeStep","isStepClosed","isResizeEventOn","windowDimension","tourHintIndex","hintElements","tourStepIndex","totalHints","totalSteps","localSteps","scrollTop","closeStepFlag","arrowDiagonalLength"],
	data : function(){
		return {
			'ltPropTakeTour' 			: Lyte.attr('boolean' , { default : false }),
			'ltPropBindToBody' 		: Lyte.attr("boolean" , { default : false }),

			'ltPropWrapperClass'	: Lyte.attr("string" , {default : 'lyteTourWrapper'}),
			'ltPropCreateDummy'		: Lyte.attr("boolean" , {default : false}),

			/**
			 * @componentProperty {number} ltPropHeight
			 * @default 500
			 */

			'ltPropHeight'				: Lyte.attr('number' , { default : 'auto' }),

			/**
 			 * @componentProperty {number} ltPropWidth
 			 * @default 500
 			 */

			'ltPropWidth'					: Lyte.attr('number' , { default : 'auto' }),
			'ltPropArrowWidth'		: Lyte.attr('number' , { default : 10 }),
			'ltPropArrowHeight'		: Lyte.attr('number' , { default : 10 }),
			'ltPropArrowPosition'	: Lyte.attr('string' , { default : 'start' }),
			'ltPropFixedArrow'		: Lyte.attr('boolean' , { default : false }),

				/**
			 * @componentProperty {boolean} ltPropFreezeLayer
			 * @default true
			 *
			 */

			'ltPropFreezeLayer'		: Lyte.attr('boolean' , { default : true }),
			'ltPropSmartPlacement': Lyte.attr('boolean' , { default : true }),
			'ltPropResumeHint'		: Lyte.attr('number' , {default : 0}),
			'ltPropResumeStep'		: Lyte.attr('number' , {default : 0}),

			'isStepClosed'				: Lyte.attr('boolean' , {default : false}),
			'isResizeEventOn'			: Lyte.attr('boolean' , {default : false}),

			'windowDimension'			: Lyte.attr('object' , {
				default : {
					height : window.innerHeight,
					width : window.innerWidth
				}
			}),

			'tourHintIndex' 			: Lyte.attr('number' , { default : 0 }),
			'hintElements'				: Lyte.attr('array' , { default : [ ] }),
			'tourStepIndex'				: Lyte.attr('number' , { default : 0 }),
			'totalHints'					: Lyte.attr('number' , { default : 0 }),
			'totalSteps'					: Lyte.attr('number' , { default : 0 }),
			'localSteps'					: Lyte.attr('number' , { default : 0 }),
			'scrollTop'						: Lyte.attr('number' , { default : 0 }),
			'closeStepFlag'				: Lyte.attr('boolean' , { default : false }),
			'arrowDiagonalLength' : Lyte.attr('number' , {default : 0})
		}
	},

	setTourDimensions : function(){
	 $L(this.$node).find('.lyteTourContainer').css({
			'width' : this.getData('ltPropWidth'),
			'height' : this.getData('ltPropHeight')
	 });
		$L(this.$node).find('.lyteTourArrow').css({
			'width' : this.getData('ltPropArrowWidth'),
			'height' : this.getData('ltPropArrowHeight')
	 });
	},

	startLyteTour : function(){

		this.setData('ltPropBindToBody' , true)
		// this.setData('isStepClosed' , false);

		this.setTourDimensions();

		var totalSteps = $L(this.$node).find('lyte-tour-step');
		var tourHints = $L(this.$node).find('lyte-tour-hint');

		var tourArr = [];

		// FIX: Make this forloop another function -  calculate variables inside that function and store hintElements in that function
		// Also there is probably an easier way to push values into a dummy array - .concat() for eg.
		for(var i=0;i < tourHints.length;i++){
			tourArr.push( tourHints[i].getData('ltPropLabel') )
		}
		this.setData('hintElements' , tourArr);
		// FIX: this can be a function - this.getCurrentHint()
		var currentHint = tourHints[this.getData('tourHintIndex')];
		var tourSteps = $L(currentHint).find('lyte-tour-step');

		// FIX: this can be a function - this.getCurrentStep()
		var currentStep = tourSteps[this.getData('tourStepIndex')]

		// FIX: these can be moved to a function - this.setTourParameters()
		this.setData('totalHints' , tourHints.length);


		if(this.getData('ltPropResumeHint') && (this.getData('ltPropResumeHint') !== 0)){
			if(!(this.getData('ltPropResumeHint') > tourHints.length)){
					this.setData('tourHintIndex' , this.getData('ltPropResumeHint'))
			}
		}
		var currentHint = tourHints[this.getData('tourHintIndex')];

		var tourSteps = $L(currentHint).find('lyte-tour-step');
		this.setData('localSteps' , tourSteps.length);
		this.setData('totalSteps' , totalSteps.length);

		if(this.getData('ltPropResumeStep') && (this.getData('ltPropResumeStep') !== 0)){
			if(!(this.getData('ltPropResumeStep') > tourSteps.length)){
				this.setData('tourStepIndex' , this.getData('ltPropResumeStep'))
			}
		}
		var currentStep = tourSteps[this.getData('tourStepIndex')]
		if(currentHint.component.getData('ltPropBackgroundAnimation')){
			currentHint.component.setData('ltPropBindToBody' , true);
			currentHint.classList.add('activeAnimation');
		}
		this.setData('closeStepFlag' , false);

		var arrow = $L('.lyteTourArrow')[0];

		arrow.style.transform = "rotate(0deg)";
		this.setData('arrowDiagonalLength' , arrow.getBoundingClientRect().width);
		arrow.style.transform = "rotate(45deg)";

		$L(currentStep).addClass('lyteTourCStep')

		document.addEventListener('keydown' , this.tabKeydownFun)

		if(!this.getData('isResizeEventOn')){

			this.setData('isResizeEventOn' , true)

			window.addEventListener('resize' , this.$node.moveContainer)

		}

		currentStep.component.startLyteStep( currentStep );

	},
	methods : {
		onStart : function(){},
		onEnd : function(){},
		onStepClose : function(){},
		onBeforeNext : function(){},
		onNext : function(){},
		onBeforePrev : function(){},
		onPrev : function(){},
		onHintChange : function(){}
	},
	init : function(){

		// FIX: All of these can have single var definitions var _this = this, lyteTourComp = _this.$node....
		var _this = this;
		var lyteTourComp = _this.$node;
		var currentHint , currentStep , pastHint;
		var nextStepEle;
		var prevStepEle;

		// FIX: Better formating needed over here
		shortcut.register( 'left' , function() {
			if((!(_this.getData('closeStepFlag')))&&(_this.getData('ltPropBindToBody'))){
	 	 		_this.$node.prevStep();
			}
	  });

		// FIX: Better formating needed over here
	  shortcut.register( 'right' , function() {
			if((!(_this.getData('closeStepFlag')))&&(_this.getData('ltPropBindToBody'))){
	 	 		_this.$node.nextStep();
			}
	  });

	  // FIX: Better formating needed over here
		shortcut.register( 'esc' , function() {

			if((_this.getData('closeStepFlag'))&&(_this.getData('ltPropBindToBody'))){
				_this.$node.skipTour();
			} else {
				// FIX: No need for empty else block
				// _this.$node.closeStep();
				// var arr = $L('.lyteTourDefaultArrow')[0];
				// if(arr){
				// 	arr.classList.remove('lyteTourDefaultArrow');
				// }
			}

	 });

		 this.$node.startTour = function(){
			 _this.startLyteTour();
		 }

		this.$node.closeStep = function(){

			// FIX: There must be an if( this.getMethods( 'onStepClose' ) )
			_this.executeMethod('onStepClose')

			// DOUBT: Why are we setting ltPropBindToBody false for the first step of the document?
			$L('lyte-tour-step')[0].component.setData('ltPropBindToBody' , false);

			// FIX: Feels like the name of this function should setCurrentHint();
			_getCurrentHint();

			// FIX: This should be setcurrentStep I guess
			_getCurrentStep();

			// FIX: Looks like this needs to be closeCurrentStep
			_removeBindToBody();

			// The above two functions can be combined to removeCurrentStep

			if(_this.getData('closeStepFlag')){
				_this.$node.skipTour();
			}

			_this.setData('closeStepFlag' , true);


			// FIX: Overall function can be like this:
			/* this.setCurrentHint();
			 * this.animateCurrentHint();
			 * this.animatePreviousHint();
			 * this.setCurrentStep();
			 * this.closeCurrentStep();
			 *
			 *
			 */

		}

		this.$node.nextStep = function(){


			_this.setData('scrollTop' , document.documentElement.scrollTop);

			// FIX: this.setCurrentHint();
			// FIX: this.animateCurrentHint();
			// FIX: this.animatePreviousHint();
			_getCurrentHint();

			// FIX: this.setCurrentStep();
			_getCurrentStep();

			// FIX: this.setNextStep();
			_getNextStep();

			// FIX: this.closeCurrentStep();
			_removeBindToBody();

			// FIX: this should also be inside the this.setNextStep() -> this.updateStepIndex( 1 );
			_this.updateStepIndex( '+' );

			// FIX: may need to be in if
			var returnedValue = currentStep.component.executeMethod('onBeforeChange');

			if($L('.lyteTourContainerNoTransition')){
				$L('.lyteTourContainerNoTransition').removeClass('lyteTourContainerNoTransition')
			}

			if( returnedValue ) {

				// Make this a function
				returnedValue.then(function(){

					// FIX: Add a check here to see if the component exists

					_this.executeMethod('onBeforeNext' , currentStep , nextStepEle);

					// FIX: this.isLastStep()
					if(_this.getData('localSteps')-1 < _this.getData('tourStepIndex')){

						// FIX: this.updateHintIndex( 1 );
						_this.updateHintIndex( '+' );
						_this.updateLocalSteps();
						pastHint = currentHint;
						// FIX: setCurrentHint
						_getCurrentHint();
						_this.setData('tourStepIndex' , 0);

						// FIX: this.areHintsDone()
						if(_this.getData('totalHints')-1 < _this.getData('tourHintIndex')){

							_this.resetTourData();
							// FIX: May need an if
							_this.executeMethod('onEnd')
							return;

						}
					}

					// setCurrentStep
					_getCurrentStep();

					// FIX: Should be pass currentStep?
					currentStep.component.startLyteStep( currentStep );

					// FIX: setPreviousStep
					_getPrevStep();
					_this.executeMethod('onNext' , prevStepEle ,currentStep)

				})

			}
			else {


				_this.executeMethod('onBeforeNext' , currentStep , nextStepEle);

				if(_this.getData('localSteps')-1 < _this.getData('tourStepIndex')){

					_this.updateHintIndex( '+' );
					_this.updateLocalSteps();
					pastHint = currentHint;
					_getCurrentHint();
					_this.setData('tourStepIndex' , 0);

					if(_this.getData('totalHints')-1 < _this.getData('tourHintIndex')){


						if($L('.lyteTourDummyWrap').length){
							$L('.lyteTourDummyWrap')[0].remove();
						}

						if(this.getData('isResizeEventOn')){

							this.setData('isResizeEventOn' , false)

							window.removeEventListener('resize' , _this.$node.moveContainer)

						}

						_this.resetTourData();
						_this.executeMethod('onEnd')
						return;

					}
				}
				_getCurrentStep();
				currentStep.component.startLyteStep( currentStep );
				_getPrevStep();
				_this.executeMethod('onNext' , prevStepEle ,currentStep)

			}

		}


		// FIX: This needs the same fixes as previous function
		this.$node.prevStep = function(){

			_this.setData('scrollTop' , document.documentElement.scrollTop);

			_getCurrentHint();
			_getCurrentStep();
			_getPrevStep();
			_removeBindToBody();
			_this.updateStepIndex( '-' );

			var returnedValue = currentStep.component.executeMethod('onBeforeChange');

			if($L('.lyteTourContainerNoTransition')){
				$L('.lyteTourContainerNoTransition').removeClass('lyteTourContainerNoTransition')
			}

			if( returnedValue ) {



				_this.executeMethod('onBeforePrev' , currentStep , prevStepEle);

				if(_this.getData('tourStepIndex') < 0 ){

					_this.updateHintIndex( '-' );
					pastHint = currentHint;

					if(_this.getData('tourHintIndex') < 0 ){

						_this.setData('tourHintIndex' , 0 );
						_this.setData('tourStepIndex' , 0 );
						pastHint = "";

					} else {

						_this.updateLocalSteps();
						_this.setData('tourStepIndex' , _this.getData('localSteps') - 1 );

					}

				}
				_getCurrentHint();
				_getCurrentStep();
				currentStep.component.startLyteStep( currentStep );

				_this.executeMethod('onPrev' , nextStepEle , currentStep)

			} else {



				_this.executeMethod('onBeforePrev' , currentStep , prevStepEle);

				if(_this.getData('tourStepIndex') < 0 ){

					_this.updateHintIndex( '-' );
					pastHint = currentHint;

					if(_this.getData('tourHintIndex') < 0 ){

						_this.setData('tourHintIndex' , 0 );
						_this.setData('tourStepIndex' , 0 );
						pastHint = "";

					} else {

						_this.updateLocalSteps();
						_this.setData('tourStepIndex' , _this.getData('localSteps') - 1 );

					}

				}
				_getCurrentHint();
				_getCurrentStep();
				currentStep.component.startLyteStep( currentStep );

				_this.executeMethod('onPrev' , nextStepEle , currentStep)

			}

		}

		// FIX: Change function names of the functions below
		this.$node.goToStep = function(ind){

			if($L('.lyteTourContainerNoTransition')){
				$L('.lyteTourContainerNoTransition').removeClass('lyteTourContainerNoTransition')
			}

			_getCurrentHint();
			_getCurrentStep();
			_removeBindToBody();

			_this.setData('tourStepIndex' , ind );

			_getCurrentHint();
			_getCurrentStep();

			currentStep.component.startLyteStep( currentStep );

		}



		// FIX: Change function names of the functions below
		this.$node.changeHint = function(str){

			if($L('.lyteTourContainerNoTransition')){
				$L('.lyteTourContainerNoTransition').removeClass('lyteTourContainerNoTransition')
			}

			_this.setData('closeStepFlag' , false);

			var tourArr = _this.getData('hintElements');

			// setCurrentHint
			_getCurrentHint();

			// setCurrentStep
			_getCurrentStep();

			// removeCurrentStep
			_removeBindToBody();

			_this.setData('tourHintIndex' , tourArr.indexOf(str) );
			_this.setData('tourStepIndex' , 0 );
			pastHint = currentHint;

			// setCurrentHint
			_getCurrentHint();

			// setCurrentStep
			_getCurrentStep();
			currentStep.component.startLyteStep( currentStep );

			_this.executeMethod('onHintChange' , pastHint , currentHint)

			/* This code can be simplied i guess
				removeCurrentStep();
				pastHint = currentHint;
				this.setData()
				this.setData();
				setCurrentHint();
				setCurrentStep();
			*/

		}

		this.$node.skipTour = function(){

			// FIX: this.closeCurrentStep();


			if($L('.lyteTourActiveStep')){
				$L('.lyteTourActiveStep')[0].classList.remove('lyteTourActiveStep')
			}
			if($L('.lyteTourActiveTarget')){
				$L('.lyteTourActiveTarget')[0].classList.remove('lyteTourActiveTarget')
			}

			if($L('.lyteTourDummyWrap').length){
				$L('.lyteTourDummyWrap')[0].remove();
			}

			if(!currentStep){
				_getCurrentHint();
				_getCurrentStep();
			}
			currentStep.component.setData('ltPropBindToBody' , false)
			_this.resetTourData();

			// FIX: Should this be a global selector?
			if($L('.activeAnimation')[0]){
				$L('.activeAnimation')[0].component.setData('ltPropBindToBody' , false);
			}

			if(this.getData('isResizeEventOn')){

				this.setData('isResizeEventOn' , false)

				window.removeEventListener('resize' , _this.$node.moveContainer)

			}

			// This might need to be inside an if block
			_this.executeMethod('onEnd')

		}

		function _getCurrentHint(){
			currentHint = $L(lyteTourComp).find('lyte-tour-hint')[_this.getCurrentHintIndex()];

			// FIX: Change this to a function - this.animateCurrentHint()
			if(currentHint){
				if(currentHint.component.getData('ltPropBackgroundAnimation')){
					// DOUBT: Should this bindToBody be inside the if block
					currentHint.component.setData('ltPropBindToBody' , true);
					currentHint.classList.add('activeAnimation');
				}
			}

			// FIX: Change this to a function = this.animatePreviousHint()
			if(pastHint){
				if(pastHint.component.getData('ltPropBackgroundAnimation')){
					// DOUBT: should this ltPropBindToBody be inside the if block
					pastHint.component.setData('ltPropBindToBody' , false);
					pastHint.classList.remove('activeAnimation');
				}
			}
		}

		function _getCurrentStep(){
			if($L('.lyteTourCStep')){
				$L('.lyteTourCStep').removeClass('lyteTourCStep')
			}
			currentStep = $L(currentHint).find('lyte-tour-step')[_this.getCurrentStepIndex()];

			$L(currentStep).addClass('lyteTourCStep')

		}

		function _getNextStep(){


			// FIX: change this if condition to -> !this.isCurrentHintDone()
			// nextStepEle = this.getNextStep();
			if(_this.getCurrentStepIndex()+1 < $L(currentHint).find('lyte-tour-step').length){

				nextStepEle = $L(currentHint).find('lyte-tour-step')[_this.getCurrentStepIndex() + 1]

			} else {

				// FIX: This should be an else if( !this.areHintsDone() )
				// var hint = this.getNextHint();
				// nextStepEle = ..
				if(_this.getCurrentHintIndex()+1 < $L(lyteTourComp).find('lyte-tour-hint').length){

					var nextHint = $L(lyteTourComp).find('lyte-tour-hint')[_this.getCurrentHintIndex()+1]

					nextStepEle = $L(nextHint).find('lyte-tour-step')[0]

				}

			}

		}

		function _getPrevStep(){

			// FIX: if( !this.atStartOfHint() )
			// prevStepEle = this.getPreviousStep()
			if(_this.getCurrentStepIndex()-1>=0){

				prevStepEle = $L(currentHint).find('lyte-tour-step')[_this.getCurrentStepIndex() - 1]

			} else {

				// FIX: if( !this.isFirstHint() )
				// prevHint = this.getPreviousHint();
				// prevStepEle = ...
				if(_this.getCurrentHintIndex() - 1 >= 0){

					var prevHint = $L(lyteTourComp).find('lyte-tour-hint')[_this.getCurrentHintIndex()-1]

					prevStepEle = $L(prevHint).find('lyte-tour-step')[$L(prevHint).find('lyte-tour-step').length-1]

				}

			}

		}

		function _removeBindToBody(){
			currentStep.component.setData('ltPropBindToBody' , false);
		}

		this.$node.moveContainer = function(){

			_getCurrentHint();
			_getCurrentStep();

			$L('.lyteTourContainer').addClass('lyteTourContainerNoTransition')

			currentStep.component.startLyteStep( currentStep );

		}

	},

	// Tab keydown event function

	tabKeydownFun : function(event){
		if((event.keyCode === 9) || (event.keyCode === 16)){
			document.activeElement.blur()
			event.preventDefault();
		} else {
			$L(this).trigger('keydown')
		}
	},

	// FIX: v is number which is either 1 or -1 so add number to tourStepIndex
	updateStepIndex : function(v){
		if( v === '+' ){
			this.setData('tourStepIndex' , this.getData('tourStepIndex') + 1 );
		} else if( v === '-' ){
			this.setData('tourStepIndex' , this.getData('tourStepIndex') - 1 );
		}
	},

	// FIX: Same as previous function
	updateHintIndex : function(v){
		if( v === '+' ){
			this.setData('tourHintIndex' , this.getData('tourHintIndex') + 1 );
		} else if( v === '-' ){
			this.setData('tourHintIndex' , this.getData('tourHintIndex') - 1 );
		}
	},

	updateLocalSteps : function(){

		var lyteTour = this.$node;
		var currentHint = $L(lyteTour).find('lyte-tour-hint')[this.getCurrentHintIndex()];
		var currentHintSteps = $L(currentHint).find('lyte-tour-step');

		this.setData('localSteps' , currentHintSteps.length);

	},

	getCurrentStepIndex : function(){
		return this.getData('tourStepIndex');
	},



	getCurrentHintIndex : function(){
		return this.getData('tourHintIndex');
	},

	resetTourData : function(){
		this.setData('totalHints' , 0);
		this.setData('totalSteps' , 0);
		this.setData('localSteps' , 0);
		this.setData('tourStepIndex' , 0);
		this.setData('tourHintIndex' , 0);
		this.setData('ltPropBindToBody' , false)
	},

	actions : {
		nextStep : function(){
			this.setData('tourStepIndex' , this.getData('tourStepIndex')+1);
			var currentHint = $L(this.$node).find('lyte-tour-hint')[this.getData('tourHintIndex')];
			var currentStep = $L(currentHint).find('lyte-tour-step')[this.getData('tourStepIndex')];


			currentStep.component.setData('ltPropBindToBody' , true);
			$L('.lyteTourStep')[0].style.display = "block";
		}
	},

	didDestroy : function(){
		document.removeEventListener('keydown' , this.tabKeydownFun)
	}
});


if(!_lyteUiUtils.registeredCustomElements['lyte-tour-next-button']){

	_lyteUiUtils.registeredCustomElements['lyte-tour-next-button'] = true;

	Lyte.createCustomElement('lyte-tour-next-button' , {

		connectedCallback : function(){

			if(!this.lyteTourComponent){
				this.lyteTourComponent = $L(this).closest('lyte-tour')[0];
			}

		},

		constructor : function(){

			var _this = this
			$L(this).addClass('lyteTourButtons')

			this.addEventListener('click' , function(){


				if(_this.hasAttribute('lyte-tour-finish-button')){
					if($L('.lyteTourDummyWrap').length){
						$L('.lyteTourDummyWrap')[0].remove();
					}
				}
				_this.lyteTourComponent.nextStep();

			} . bind(this))

		},
		static : {"observedAttributes" : {}}

	})

}

if(!_lyteUiUtils.registeredCustomElements['lyte-tour-prev-button']){

	_lyteUiUtils.registeredCustomElements['lyte-tour-prev-button'] = true;

	Lyte.createCustomElement('lyte-tour-prev-button' , {

		connectedCallback : function(){

			if(!this.lyteTourComponent){
				this.lyteTourComponent = $L(this).closest('lyte-tour')[0];
			}

		},

		constructor : function(){

			var _this = this
			$L(this).addClass('lyteTourButtons')

			this.addEventListener('click' , function(){

				_this.lyteTourComponent.prevStep();

			} . bind(this))

		},
		static : {"observedAttributes" : {}}

	})

}

/**
 * Renders a tour hint component
 * @component lyte-tour-hint
 * @version 3.1.0
 */


Lyte.Component.register("lyte-tour-hint", {
_template:"<template tag-name=\"lyte-tour-hint\"> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole case=\"true\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"lyteTourTargetBackground\"></div> </template> </lyte-wormhole> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropBackgroundAnimation","ltPropBindToBody","tourStepIndex","ltPropArrowPosition","ltPropAppendBackground","ltPropLabel"],
	data : function(){
		return {

			/**
			 * @componentProperty {boolean} ltPropBackgroundAnimation
			 * @default false
			 * 
			 */

			 'ltPropBackgroundAnimation' : Lyte.attr('boolean' , { default : false }),

			'ltPropBindToBody' : Lyte.attr('boolean' , { default : false }),
			'tourStepIndex'			: Lyte.attr('number' , { default : 0 }),
			'ltPropArrowPosition'	: Lyte.attr('string' , { default : 'start' }),
			'ltPropAppendBackground' : Lyte.attr('boolean' , { default : false }),
			'ltPropLabel'	: Lyte.attr('string' , { default : '' })
		}
	},
	init : function(){

	}
});

/**
 * Renders a tour step component
 * @component lyte-tour-step
 * @version 3.1.0
 * @methods onChange, onBeforeChange
 */

Lyte.Component.register("lyte-tour-step", {
_template:"<template tag-name=\"lyte-tour-step\"> <template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> <lyte-wormhole case=\"true\" lt-prop-query=\".lyteTourContainer\"> <template is=\"registerYield\" yield-name=\"lyte-content\"> <div class=\"lyteTourStep\"> <lyte-yield yield-name=\"lyteTourStep\"></lyte-yield> </div> </template> </lyte-wormhole> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"insertYield","position":[1,1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropBindToBody","ltPropSelector","ltPropClickable","ltPropArrowPosition","ltPropPosition","ltPropScrollToView","arrowPositionOnBox","initialArrowFlag"],
	data : function(){
		return {
			'ltPropBindToBody' 	: Lyte.attr('boolean' , { default : false }),

			/**
			 * @componentProperty {string} ltPropSelector
			 */

			'ltPropSelector'	 	: Lyte.attr('string'),
			'ltPropClickable'		: Lyte.attr('boolean' , { default : false }),

			/**
			 * @componentProperty {start | end |center} ltPropArrowPosition
			 * @default start
			 */

			'ltPropArrowPosition'	: Lyte.attr('string' , { default : 'start' }), //start , end , center

				/**
			 * @componentProperty {right|left|top|bottom} ltPropPosition
			 * @default right
			 * @options right , left , top , bottom
			 */

			'ltPropPosition'		: Lyte.attr('string' , { default : 'right' }), // right , left , top , bottom
			'ltPropScrollToView': Lyte.attr('boolean' , { default : false }),

			'arrowPositionOnBox': Lyte.attr('string' , {default : 'left'}),
			'initialArrowFlag'	: Lyte.attr('boolean' , {default : false})
		}
	},

	startLyteStep : function( th ){

		var _this = th.component;

		var parentTour = $L(this.$node).closest('lyte-tour')[0]

		// FIX: Maybe this is a different function
		if(this.getData('ltPropPosition') === 'right'){
			this.setData('arrowPositionOnBox' , 'left');
		} else if(this.getData('ltPropPosition') === 'left'){
			this.setData('arrowPositionOnBox' , 'right');
		} else if(this.getData('ltPropPosition') === 'top'){
			this.setData('arrowPositionOnBox' , 'bottom');
		} else if(this.getData('ltPropPosition') === 'bottom'){
			this.setData('arrowPositionOnBox' , 'top');
		}

		// FIX: Not sure if the th. should be there. Maybe it needs to be just this.
		th.setData('ltPropBindToBody' , true);

		// FIX: Global selector - This and the next statement must be a single function -> this.changeActiveStep()
		if($L('.lyteTourActiveTarget').length){
			$L('.lyteTourActiveTarget').removeClass('lyteTourActiveTarget');
		}

		var currentStepTarget = $L(this.getData('ltPropSelector'))[0];

		if(parentTour.getData('ltPropCreateDummy')){

			var tar = $L(this.getData('ltPropSelector'))[0]
			var body = $L('body')[0]
			var selectorString = this.getData('ltPropSelector').split(".")[1]

			var dummy;
			var dummyWrap;

			if($L(this.getData('ltPropSelector')+"Dummy").length){
				dummy = $L(this.getData('ltPropSelector')+"Dummy")[0]
				dummy.classList.add("lyteTourResetSpacing")
				dummy.classList.add("lyteTourActiveTarget")
				dummy.classList.add("lyteTourDummyTarget")
			} else {
				dummy = tar.cloneNode(true)
				dummy.classList.add("lyteTourResetSpacing")
				dummy.classList.add("lyteTourActiveTarget")
				dummy.classList.add("lyteTourDummyTarget")
				dummy.classList.add(selectorString+"Dummy")
			}

			var tourWrap = $L('.lyteTourWrap')[0]



			if($L('.lyteTourDummyWrap').length){
				dummyWrap = $L('.lyteTourDummyWrap')[0]
			} else {
				 dummyWrap = document.createElement('DIV')
				 dummyWrap.setAttribute("class" , "lyteTourDummyWrap");
			}


			var tarDim = tar.getBoundingClientRect();
			var border = getComputedStyle(tar).borderRadius;

			dummy.style.position = "absolute";
			dummy.style.top = tarDim.top + "px";
			dummy.style.left = tarDim.left + "px";
			dummy.style.width = tarDim.width + "px";
			dummy.style.height = tarDim.height + "px";

			body.appendChild(dummyWrap)
			dummyWrap.appendChild(dummy)
			currentStepTarget = dummy;
		}



		// FIX: global selector
		$L('.lyteTourStep')[0].classList.add('lyteTourActiveStep');

		// FIX: Global selector can cause problem
		var lyteTourContainer = $L('.lyteTourContainer')[0];
		var stepData = lyteTourContainer.getBoundingClientRect();

		// FIX: Reuse get bounding client rects - no need to invoke them again
		var cs_top = stepData.top,
				cs_bottom = stepData.bottom,
				cs_right = stepData.right,
				cs_left = stepData.left,
				cs_height = stepData.height,
				cs_width = stepData.width;

		var currentStepTargetDim = currentStepTarget.getBoundingClientRect();

		var cst_top = currentStepTargetDim.top,
				cst_bottom = currentStepTargetDim.bottom,
				cst_right = currentStepTargetDim.right,
				cst_left = currentStepTargetDim.left,
				cst_height = currentStepTargetDim.height,
				cst_width = currentStepTargetDim.width;

		var deviation = 12;

		var backDiv = $L('.lyteTourTargetBackground');

		currentStepTarget.classList.add('lyteTourActiveTarget')

		backDiv.css({
			'width' : currentStepTargetDim.width,
			'height' : currentStepTargetDim.height,
			'top' :  currentStepTargetDim.top,
			'left' :  currentStepTargetDim.left
		})

		var tourNewTop;
		var arrowNewTop;

		var initialArrowFlag = false;

		var tourMidHeight = lyteTourContainer.getBoundingClientRect().height / 2;
		var targetMidHeight = currentStepTarget.getBoundingClientRect().top + (currentStepTarget.getBoundingClientRect().height / 2);
		var tourMidWidth = lyteTourContainer.getBoundingClientRect().width / 2;
		var targetMidWidth = currentStepTarget.getBoundingClientRect().left + (currentStepTarget.getBoundingClientRect().width / 2);

		var lyteTourArrow = $L('.lyteTourArrow')[0];

		lyteTourArrow.style.transform = "rotate(45deg)"


		var arrowData = lyteTourArrow.getBoundingClientRect();


		function arrowTranslate( placement , side){
			var returnVal = {};
			var arrowRotateVal = 45;
			var arrowUserPref = _this.getData('ltPropArrowPosition');

			if(!placement){
				placement = _this.getData('ltPropArrowPosition');
			}
			if(!side){
				side = _this.getData('arrowPositionOnBox');
			}

			switch ( side ){

				case 'left':

				$L('.lyteTourDefaultArrow').removeClass('lyteTourDefaultArrow');
				$L('.lyteTourLeftArrow').addClass('lyteTourDefaultArrow');

				break;

				case 'top':

				$L('.lyteTourDefaultArrow').removeClass('lyteTourDefaultArrow');
				$L('.lyteTourTopArrow').addClass('lyteTourDefaultArrow');

				break;

				case 'right':

				$L('.lyteTourDefaultArrow').removeClass('lyteTourDefaultArrow');
				$L('.lyteTourRightArrow').addClass('lyteTourDefaultArrow');

				break;

				case 'bottom':

				$L('.lyteTourDefaultArrow').removeClass('lyteTourDefaultArrow');
				$L('.lyteTourBottomArrow').addClass('lyteTourDefaultArrow');

				break;

			}

			lyteTourArrow = $L('.lyteTourDefaultArrow')[0];
			arrowData = lyteTourArrow.getBoundingClientRect();



			var arrowPlacement = side + (placement.charAt(0).toUpperCase() + placement.slice(1));

			var arrowNewX = -(arrowData.width/2),
					arrowNewY = ((Math.sqrt(2)*arrowData.width - arrowData.width)/2) + 20 ;

			var test = setArrowPosition(arrowPlacement);

			arrowNewX = test.xValue;
			arrowNewY = test.yValue;

			returnVal.arrowVal = "translate(" + arrowNewX + " ," + arrowNewY + ") rotate("+ 45 +"deg)";

			return returnVal;

		}

		function setArrowPosition( placement ){

			var arrowXVal , arrowYVal;
			var retVal = {};

			$L('.lyteTourArrow').css({
				'transform' : 'rotate(45deg)'
			})

			var arrowDia = _this.$node.closest('lyte-tour').getData('arrowDiagonalLength');

			var arrowDis = ((cst_height - arrowDia)/2) + deviation

				switch ( placement ){

					case 'leftStart':
					arrowXVal = '-50%';
					arrowYVal = arrowDis + "px";
					break;

					case 'leftCenter':
					arrowXVal = '-50%';
					arrowYVal = ((cs_height - arrowDis)/2)+"px";
					break;

					case 'leftEnd':
					arrowXVal = '-50%';
					arrowYVal = (cs_height - arrowDis - arrowDia) + "px";
					break;

					case 'topStart':
					arrowXVal = arrowDis + "px";
					arrowYVal = '-50%';
					break;

					case 'topCenter':
					arrowXVal = ((cs_width - arrowDia)/2)+"px";
					arrowYVal = '-50%';
					break;

					case 'topEnd':
					arrowXVal = (cs_width - arrowDis - arrowDia)+"px";
					arrowYVal = '-50%';
					break;

					case 'rightStart':
					arrowXVal = '50%';
					arrowYVal = arrowDis + "px";
					break;

					case 'rightCenter':
					arrowXVal = '50%';
					arrowYVal = ((cs_height - arrowDia)/2)+"px";
					break;

					case 'rightEnd':
					arrowXVal = '50%';
					arrowYVal = (cs_height - arrowDis - arrowDia)+"px";
					break;

					case 'bottomStart':
					arrowXVal = arrowDis + "px";
					arrowYVal =  '50%';
					break;

					case 'bottomCenter':
					arrowXVal = ((cs_width - arrowDia)/2)+"px";
					arrowYVal = '50%';
					break;

					case 'bottomEnd':
					arrowXVal = (cs_width - arrowDis - arrowDia)+"px";
					arrowYVal = '50%';
					break;


				}

				retVal.xValue = arrowXVal;
				retVal.yValue = arrowYVal;

				return retVal;

		}

		function setArrowStyle(placement , side){
			var arrowTransVal = arrowTranslate( placement , side );

			if(!($L('lyte-tour')[0].component.getData('ltPropFixedArrow'))){
				$L('.lyteTourArrow').css({
					'transform' : arrowTransVal.arrowVal
				})
				initialArrowFlag = true;
			}
		}

		function stepTranslate(){

			var userPref = _this.getData('ltPropPosition');
			var stepNewX = 10 , stepNewY = 10;
			var returnVal = {};
			var arrowPlace = _this.getData('ltPropArrowPosition');
			var arrow = $L('.lyteTourArrow')[0];
			var arrowDia = _this.$node.closest('lyte-tour').getData('arrowDiagonalLength');

			var setArrowPos = _this.getData('ltPropArrowPosition');
			var setArrowSide = _this.getData('ltPropPosition');

			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;

			switch(userPref){

				case 'right':

				stepNewX = cst_right + arrowDia;
				stepNewY = cst_top - deviation;

				if(setArrowPos === "center"){
					stepNewY = cst_top + (cst_height - cs_height)/2
					deviation = 0;
				}
				if(setArrowPos === "end"){
					stepNewY = cst_top  - cs_height + cst_height + deviation
				}

				setArrowSide = "left"

				if((cst_right + cs_width) > windowWidth){
					stepNewX = cst_left  - (cs_width + arrowDia)
					setArrowSide = "right"
				}
				if((cst_top + cs_height) > windowHeight){
					stepNewY = cst_top  - cs_height + cst_height
					deviation = 0;
					setArrowPos = "end";
				}
				if(stepNewY <= 0){
					stepNewY = cst_top;
					deviation = 0;
					setArrowPos = "start";
				}

				setArrowStyle(setArrowPos , setArrowSide);

				break;

				case 'left' :

				stepNewX = cst_left - (cs_width + arrowDia)
				stepNewY = cst_top - deviation;

				setArrowSide = "right"

				if(setArrowPos === "center"){
					stepNewY = cst_top + (cst_height - cs_height)/2
					deviation = 0;
				}
				if(setArrowPos === "end"){
					stepNewY = cst_top  - cs_height + cst_height + deviation
				}

				if(cst_left < cs_width){
					stepNewX = cst_right + arrowDia;
					setArrowSide = "left"
				}
				if((cst_top + cs_height) > windowHeight){
					stepNewY = cst_top  - cs_height + cst_height
					deviation = 0;
					setArrowPos = "end";
				}
				if(stepNewY <= 0){
					stepNewY = cst_top;
					deviation = 0;
					setArrowPos = "start";
				}

				setArrowStyle(setArrowPos , setArrowSide);

				break;


				// The same applies for these to case blocks
				case 'top':

				stepNewY = cst_top - (cs_height + arrowDia);
				stepNewX = cst_left - deviation

				setArrowSide = "bottom"

				if(setArrowPos === "center"){
					stepNewX = cst_left + (cst_width - cs_width)/2
					deviation = 0
				}
				if(setArrowPos === "end"){
					stepNewX = cst_left  - cs_width + cst_width + deviation
				}

				if(cst_top < cs_height){
					stepNewY = cst_bottom + arrowDia;
					setArrowSide = "top"
				}
				if((cst_left + cs_width) > windowWidth){
					stepNewX = cst_left  - cs_width + cst_width
					deviation = 0
					setArrowPos = "end";
				}
				if(stepNewX <= 0){
					stepNewX = cst_left;
					deviation = 0
					setArrowPos = "start";
				}

				setArrowStyle(setArrowPos , setArrowSide);

				break;

				case 'bottom':

				stepNewX = cst_left - deviation;
				stepNewY = cst_bottom + arrowDia;

				setArrowSide = "top"

				if(setArrowPos === "center"){
					stepNewX = cst_left + (cst_width - cs_width)/2
					deviation = 0
				}
				if(setArrowPos === "end"){
					stepNewX = cst_left - cs_width + cst_width + deviation
				}

				if((cst_bottom + cs_height) > windowHeight){
					stepNewY = cst_top - (cs_height + arrowDia)
					setArrowSide = "bottom"
				}
				if((cst_left + cs_width) > windowWidth){
					stepNewX = cst_left - cs_width + cst_width
					deviation = 0
					setArrowPos = "end";
				}
				if(stepNewX <= 0){
					stepNewX = cst_left;
					deviation = 0
					setArrowPos = "start";
				}

				setArrowStyle(setArrowPos , setArrowSide);

				break;

			}

			returnVal.stepNewX = stepNewX
			returnVal.stepNewY = stepNewY
			returnVal.stepVal = "translate(" + stepNewX + "px ," + stepNewY + "px)";

			return returnVal;

		}

		var stepTranslateVal = stepTranslate();

		$L('.lyteTourContainer').css({
			'transform' : stepTranslateVal.stepVal
		})

		this.executeMethod('onChange')

	},
	methods : {
		onChange : function(){},
		onBeforeChange : function(){}
	}
});

/**
 * This component is used to show tooltip when its content exceeds
 * @component lyte-text
 * @version 2.2.0
 */

Lyte.Component.register("lyte-text", {
_template:"<template tag-name=\"lyte-text\" lt-prop-title=\"{{if(expHandlers(tooltip,'&amp;&amp;',ltPropShow),ltPropValue,'')}}\" onmouseenter=\"{{action('mouse')}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield class=\"lyteTextYield\" yield-name=\"lyte-text\" lt-prop-value=\"{{ltPropValue}}\"></lyte-yield> </template><template case=\"false\"> {{ltPropValue}} </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1]}]}},"default":{}}],
_templateAttributes :{"type":"attr","position":[]},
_observedAttributes :["ltPropValue","ltPropShow","ltPropYield","tooltip","lyteUnbound"],
	data : function(){
		return {
			/**
			 * @componentProperty {string} ltPropValue=''
			 * @version 2.2.0
			 */
			ltPropValue : Lyte.attr( 'string', { default : '' } ),
			/**
			 * @componentProperty {boolean} ltPropShow=true
			 * @version 2.2.0
			 */
			ltPropShow : Lyte.attr( 'boolean', { default : true } ),
			/**
			 * @componentProperty {boolean} ltPropYield=false
			 * @version 2.2.20
			 */


			ltPropYield : Lyte.attr( 'boolean', { default : false } ),

			tooltip : Lyte.attr( 'boolean', { default : false } ),
			lyteUnbound : Lyte.attr( 'boolean', { default : false } )
		}		
	},

	reset : function(){
		var scrwd = this.$node.scrollWidth, offwd = this.$node.offsetWidth;
		this.setData( 'tooltip', scrwd > offwd );
		if( this.$node._fR ){
			if( this.data.tooltip && this.data.ltPropShow ){
				this.$node.setAttribute( 'lt-prop-title', this.data.ltPropValue );
			} else {
				this.$node.removeAttribute( 'lt-prop-title' )
			}
		}
	},

	actions : {
		mouse : function(){
			this.reset();
		}
	}
});

/**
 * @syntax nonYielded
 * <lyte-text lt-prop-value = "some long text having higher width"></lyte-text>
 */

/**
 * @syntax yielded
 * <lyte-text lt-prop-yield = true lt-prop-value = "some long text having higher width">
 * 	 <template is = "registerYield" yield-name = "lyte-text">
 *		your value
 *	 </template>
 * </lyte-text>
 */
/**
 * This component is used to append a dom anywhere in the document
 * @component lyte-wormhole
 * @version 2.2.6
 * @methods onBeforeAppend,onAppend
 */


Lyte.Component.register("lyte-wormhole",{
_template:"<template tag-name=\"lyte-wormhole\"> <lyte-yield yield-name=\"lyte-content\"></lyte-yield> </template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropQuery"],

	data : function(){
		return {
			/**
			 * @componentProperty {string} ltPropQuery
			 * @version 2.2.6
			 */
			ltPropQuery : Lyte.attr( 'string' )
		}
	},

	didConnectFunc :function(){
		var ret, outlet = this.data.ltPropQuery ? document.querySelector( this.data.ltPropQuery ) : document.body;
		if( !outlet ) {
			console.error( 'Provide valid outlet to append' );
			return;
		}
		if( this.getMethods( 'onBeforeAppend' ) && this.executeMethod( 'onBeforeAppend', this.$node, outlet ) == false ) {
			return;
		}
		_lyteUiUtils.appendChild( outlet, this.$node );
		this.appended = true;
		if( this.getMethods( 'onAppend' ) ){
			this.executeMethod( 'onAppend', this.$node, outlet )
		}
	}.observes( 'ltPropQuery' ).on( 'didConnect' )
});

/**
 * @syntax yielded
 * <lyte-wormhole>
 * 	  <template is = "registerYield" yield-name = "lyte-content">
 * 		 Some wormhole content
 *	  </template>
 * </lyte-wormhole>
 */

/**
 * Renders a rating component
 * @component lyte-rating
 * @version 3.1.0
 * @methods onRender,onClick,onHover,onOut
 */

Lyte.Component.register("lyte-rating", {
_template:"<template tag-name=\"lyte-rating\" class=\"{{lyteUiAddClassRating(this,ltPropWrapperClass,ltPropReadOnly)}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"rateIcon\"></lyte-yield> </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ifNotEquals(ltPropAppearance,'smiley'),'&amp;&amp;',lyteUiIfEqualsAny(ltPropType,'switch','multiple'))}}\"><template case=\"true\"> <template is=\"for\" items=\"{{countArray}}\" item=\"item\" index=\"index\"> <lyte-rate-icon class=\"{{lyteUiGetArrayValueByIndex(emptyIconArray,index)}}\" data-lrc=\"{{item.ind}}\" style=\"{{lyteUiConcat('width:',ltPropWidth,'; height:',ltPropHeight,';')}}\"></lyte-rate-icon> </template> </template><template case=\"false\"><template is=\"if\" value=\"{{ifEquals(ltPropType,'svg')}}\"><template case=\"true\"> <template is=\"for\" items=\"{{countArray}}\" item=\"item\" index=\"index\"> <lyte-rate-icon class=\"{{lyteUiGetArrayValueByIndex(emptyIconArray,index)}}\" data-lrc=\"{{item.ind}}\"> <template is=\"if\" value=\"{{lyteUiCheckHalfRatingSvg(ltPropHalfIncrement,ltPropPrecision)}}\"><template case=\"true\"> <svg viewBox=\"{{item.viewbox}}\" style=\"{{lyteUiConcat('width:',ltPropWidth,'; height:',ltPropHeight,lyteUiGetFillOrStroke(ltPropAppearance,ltPropEmptyColor,ltPropStroke))}}\"> <linearGradient id=\"{{lyteUiConcat('filledGradient',ratingNum,'__',item.ind)}}\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"> <stop offset=\"0%\" style=\"{{expHandlers(expHandlers('stop-color:','+',ltPropEmptyColor),'+',';')}}\"></stop> <stop offset=\"0%\" style=\"{{expHandlers(expHandlers('stop-color:','+',ltPropEmptyColor),'+',';')}}\"></stop> <stop offset=\"0%\" style=\"{{expHandlers(expHandlers('stop-color:','+',ltPropEmptyColor),'+',';')}}\"></stop> </linearGradient> <use href=\"{{item.appearance}}\" fill=\"{{lyteUiConcat('url(#','filledGradient',ratingNum,'__',item.ind,')')}}\"></use> </svg> </template><template case=\"false\"> <svg viewBox=\"{{item.viewbox}}\" style=\"{{lyteUiConcat('width:',ltPropWidth,'; height:',ltPropHeight,lyteUiGetFillOrStroke(ltPropAppearance,ltPropEmptyColor,ltPropStroke))}}\"> <use href=\"{{item.appearance}}\"></use> </svg> </template></template> </lyte-rate-icon> </template> </template><template case=\"false\"> <template is=\"for\" items=\"{{countArray}}\" item=\"item\" index=\"index\"> <lyte-rate-icon class=\"{{ltPropEmptyIcon}}\" data-lrc=\"{{item.ind}}\" style=\"{{lyteUiConcat('width:',ltPropWidth,'; height:',ltPropHeight,';')}}\"></lyte-rate-icon> </template> </template></template></template></template></template></template> <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 18 18\" style=\"display: none;\" xml:space=\"preserve\"> <g> <path id=\"heart\" d=\"M7.2,1C4.5,1,2.3,3.4,2.1,6.7c0,0.1-0.1,0.9,0.2,2.2c0.4,1.8,1.3,3.4,2.6,4.7l6.6,6.5l6.7-6.5 c1.3-1.3,2.2-2.9,2.6-4.7c0.3-1.2,0.2-2,0.2-2.2C20.7,3.4,18.6,1,15.9,1c-1.8,0-3.4,1-4.4,2.7C10.5,2,8.9,1,7.2,1L7.2,1z\"></path> </g> </svg> <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 18 18\" style=\"display: none;\" xml:space=\"preserve\"> <style type=\"text/css\"> .st0{fill:none;stroke-miterlimit:10;} </style> <g> <path id=\"lineHeart\" class=\"st0\" d=\"M6.1,1C3.4,1,1.2,3.4,1,6.7c0,0.1-0.1,0.9,0.2,2.2c0.4,1.8,1.3,3.4,2.6,4.7l6.6,6.5l6.7-6.5 c1.3-1.3,2.2-2.9,2.6-4.7c0.3-1.2,0.2-2,0.2-2.2C19.7,3.4,17.6,1,14.9,1c-1.8,0-3.4,1-4.4,2.7C9.4,2,7.8,1,6.1,1L6.1,1z\"></path> </g> </svg> <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"5 5 89.6 80\" style=\"display: none;\" xml:space=\"preserve\"> <polygon id=\"star\" points=\"17,4.7 19.5,12 27,12 21,16.6 23.2,23.8 17,19.5 10.8,23.8 13,16.6 7,12 14.5,12 \"></polygon> </svg> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","'; height:'","ltPropHeight","';'"]}}}},{"type":"componentDynamic","position":[1]}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","'; height:'","ltPropHeight",{"type":"helper","value":{"name":"lyteUiGetFillOrStroke","args":["ltPropAppearance","ltPropEmptyColor","ltPropStroke"]}}]}}}},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"expHandlers","args":[{"type":"helper","value":{"name":"expHandlers","args":["'stop-color:'","'+'","ltPropEmptyColor"]}},"'+'","';'"]}}}},{"type":"attr","position":[1,1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"expHandlers","args":[{"type":"helper","value":{"name":"expHandlers","args":["'stop-color:'","'+'","ltPropEmptyColor"]}},"'+'","';'"]}}}},{"type":"attr","position":[1,1,5],"attr":{"style":{"name":"style","helperInfo":{"name":"expHandlers","args":[{"type":"helper","value":{"name":"expHandlers","args":["'stop-color:'","'+'","ltPropEmptyColor"]}},"'+'","';'"]}}}},{"type":"attr","position":[1,3]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","'; height:'","ltPropHeight",{"type":"helper","value":{"name":"lyteUiGetFillOrStroke","args":["ltPropAppearance","ltPropEmptyColor","ltPropStroke"]}}]}}}},{"type":"attr","position":[1,1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","'; height:'","ltPropHeight","';'"]}}}},{"type":"componentDynamic","position":[1]}]}]}},"default":{}}]}},"default":{}}]}},"default":{}}],
_templateAttributes :{"type":"attr","position":[]},
_observedAttributes :["ltPropValue","ltPropCount","ltPropWrapperClass","ltPropType","ltPropAppearance","ltPropReadOnly","ltPropClearable","ltPropHalfIncrement","ltPropEmptyIcon","ltPropFullIcon","ltPropHalfIcon","ltPropHoverFullIcon","ltPropHoverHalfIcon","ltPropYield","ltPropEmptyColor","ltPropFillColor","ltPropHoverColor","ltPropWidth","ltPropHeight","ltPropHref","ltPropPrecision","ltPropStroke","countArray","currentHover","emptyIconArray","fullIconArray","halfIconArray","hoverFullIconArray","hoverHalfIconArray","starVB","lineStarVB","heartVB","lineHeartVB","ratingNum"],
	data : function(){
		return {

			/**
             * @componentProperty {number} ltPropValue
             * @version 3.1.0
             * @default 0
             */
			"ltPropValue" : Lyte.attr("number",{"default":0}),

			/**
             * @componentProperty {number} ltPropCount
             * @version 3.1.0
             * @default 5
             */
			"ltPropCount" : Lyte.attr("number",{"default":5}),

			/**
             * @componentProperty {string} ltPropWrapperClass
             * @version 3.1.0
             */
			"ltPropWrapperClass" : Lyte.attr("string"),

			/**
             * @componentProperty {svg|multiple|switch|toggle|class} ltPropType
             * @version 3.1.0
             * @default svg
             */
			"ltPropType" : Lyte.attr("string",{"default":"svg"}),	//svg,multiple,switch,toggle,class

			/**
             * @componentProperty {star|heart|lineStar|lineHeart|smiley|likeDislike|custom} ltPropAppearance
             * @version 3.1.0
             */
			"ltPropAppearance" : Lyte.attr("string"),				//star,heart,lineStar,lineHeart,smiley,likeDislike,custom

			/**
             * @componentProperty {boolean} ltPropReadOnly
             * @version 3.1.0
             * @default false
             * 
             */
			"ltPropReadOnly" : Lyte.attr("boolean",{"default":false}),

			/**
             * @componentProperty {boolean} ltPropClearable
             * @version 3.1.0
             * @default false
             * 
             */
			"ltPropClearable" : Lyte.attr("boolean",{"default":false}),

			/**
             * @componentProperty {boolean} ltPropHalfIncrement
             * @version 3.1.0
             * @default false
             * 
             */
			"ltPropHalfIncrement" : Lyte.attr("boolean",{"default":false}),

			/**
             * @componentProperty {string} ltPropEmptyIcon
             * @version 3.1.0
             * @default lyteRatingEmpty
             */
			"ltPropEmptyIcon" : Lyte.attr("string",{"default":"lyteDummyRC"}),

			/**
             * @componentProperty {string} ltPropFullIcon
             * @version 3.1.0
             * @default lyteRatingFilled
             */
			"ltPropFullIcon" : Lyte.attr("string",{"default":"lyteDummyRC"}),

			/**
             * @componentProperty {string} ltPropHalfIcon
             * @version 3.1.0
             * @default lyteRatingHalf
             */
			"ltPropHalfIcon" : Lyte.attr("string",{"default":"lyteDummyRC"}),

			/**
             * @componentProperty {string} ltPropHoverFullIcon
             * @version 3.1.0
             * @default lyteRatingHoverFilled
             */
			"ltPropHoverFullIcon" : Lyte.attr("string",{"default":"lyteDummyRC"}),

			/**
             * @componentProperty {string} ltPropHoverHalfIcon
             * @version 3.1.0
             * @default lyteRatingHoverHalf
             */
			"ltPropHoverHalfIcon" : Lyte.attr("string",{"default":"lyteDummyRC"}),

			/**
             * @componentProperty {boolean} ltPropYield
             * @version 3.1.0
             * @default false
             * 
             */
			"ltPropYield" : Lyte.attr("boolean",{"default":false}),

			/**
             * @componentProperty {colorString} ltPropEmptyColor
             * @version 3.1.0
             * @default #c7c7c7
             */
			"ltPropEmptyColor" : Lyte.attr("string",{"default":"#c7c7c7"}),

			/**
             * @componentProperty {colorString} ltPropFillColor
             * @version 3.1.0
             * @default #f00
             */
			"ltPropFillColor" : Lyte.attr("string",{"default":"#f00"}),

			/**
             * @componentProperty {colorString} ltPropHoverColor
             * @version 3.1.0
             * @default #FF7778
             */
			"ltPropHoverColor" : Lyte.attr("string",{"default":"#FF7778"}),

			/**
             * @componentProperty {string} ltPropWidth
             * @version 3.1.0
             * @default 22px
             * @suffix px,pt,cm,mm,vh,vm,em
             */
			"ltPropWidth" : Lyte.attr("string",{"default":"22px"}),

			/**
             * @componentProperty {string} ltPropHeight
             * @version 3.1.0
             * @default 22px
             * @suffix px,pt,cm,mm,vh,vm,em
             */
			"ltPropHeight" : Lyte.attr("string",{"default":"22px"}),

			/**
             * @componentProperty {string} ltPropHref
             * @version 3.1.0
             */
			"ltPropHref" : Lyte.attr("string"),

			/**
             * @componentProperty {number} ltPropPrecision
             * @version 3.1.0
             * @default 0.5
             */
			"ltPropPrecision" : Lyte.attr("number",{"default":0.5}),

			/**
             * @componentProperty {string} ltPropStroke
             * @version 3.1.0
             */
			"ltPropStroke" : Lyte.attr("string"),
			"countArray" : Lyte.attr("array",{"default":[]}),
			"currentHover" : Lyte.attr("number",{"default":0}),
			"emptyIconArray" : Lyte.attr("array",{"default":[]}),
			"fullIconArray" : Lyte.attr("array",{"default":[]}),
			"halfIconArray" : Lyte.attr("array",{"default":[]}),
			"hoverFullIconArray" : Lyte.attr("array",{"default":[]}),
			"hoverHalfIconArray" : Lyte.attr("array",{"default":[]}),
			"starVB" : Lyte.attr("string",{"default":"6.5 4.5 21 21"}),
			"lineStarVB" : Lyte.attr("string",{"default":"5.5 2.5 23 23"}),
			"heartVB" : Lyte.attr("string",{"default":"1.5 0.5 20 20"}),
			"lineHeartVB" : Lyte.attr("string",{"default":"1 0 21 21"}),
			"ratingNum" : Lyte.attr("number",{"default":0})
		}		
	},

	initFn : function(){
		this.$node.classList.remove('heart','lineHeart','star','lineStar','custom','lyteRatingSmiley','three','five');
		if(this.getData('ltPropType') == "multiple"){
			if(this.getData('ltPropAppearance') == "custom"){
				var emptyIconArray = this.getData('ltPropEmptyIcon').split(",");
				var fullIconArray = this.getData('ltPropFullIcon').split(",");
				var hoverFullIconArray = this.getData('ltPropHoverFullIcon').split(",");
				if(this.getData('ltPropHalfIncrement')){
					var halfIconArray = this.getData('ltPropHalfIcon').split(",");
					var hoverHalfIconArray = this.getData('ltPropHoverHalfIcon').split(",");
					this.setData('halfIconArray',halfIconArray);
					this.setData('hoverHalfIconArray',hoverHalfIconArray);
				}
				this.setData('emptyIconArray',emptyIconArray);
				this.setData('fullIconArray',fullIconArray);
				this.setData('hoverFullIconArray',hoverFullIconArray);
			}
			else{	//If not custom then by default it will be smiley
				this.setData('ltPropAppearance','smiley');
				this.$node.classList.add('lyteRatingSmiley');
				if(this.getData('ltPropCount') == 3){
					this.$node.classList.add('three');
				}
				else{
					this.setData('ltPropCount',5);
					this.$node.classList.add('five');
				}
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHover');
				this.setData('ltPropHalfIncrement', false);
			}
		}
		else if(this.getData('ltPropType') == "switch"){
			if(this.getData('ltPropAppearance') == "custom"){
				var emptyIconArray = this.getData('ltPropEmptyIcon').split(",");
				var fullIconArray = this.getData('ltPropFullIcon').split(",");
				var hoverFullIconArray = this.getData('ltPropHoverFullIcon').split(",");
				this.setData('emptyIconArray',emptyIconArray);
				this.setData('fullIconArray',fullIconArray);
				this.setData('hoverFullIconArray',hoverFullIconArray);
				
			}
			else{	//If not custom then by default it will be likeDislike
				this.setData('ltPropAppearance','likeDislike');
				this.setData('ltPropEmptyIcon','lrcSwitchLikeEmpty,lrcSwitchDislikeEmpty');
				this.setData('ltPropFullIcon','lrcSwitchLike,lrcSwitchDislike');
				this.setData('ltPropHoverFullIcon','lrcSwitchHoverLike,lrcSwitchHoverDislike');
				var emptyIconArray = this.getData('ltPropEmptyIcon').split(",");
				var fullIconArray = this.getData('ltPropFullIcon').split(",");
				var hoverFullIconArray = this.getData('ltPropHoverFullIcon').split(",");
				this.setData('emptyIconArray',emptyIconArray);
				this.setData('fullIconArray',fullIconArray);
				this.setData('hoverFullIconArray',hoverFullIconArray);
			}
			this.setData('ltPropCount',2);
			this.setData('ltPropHalfIncrement',false);
			this.setData('ltPropClearable',true);
		}
		else if(this.getData('ltPropType') == "toggle"){
			if(this.getData('ltPropAppearance') != "custom"){
				this.setData('ltPropAppearance','heart');
				this.setData('ltPropEmptyIcon','lrcToggleEmpty');
				this.setData('ltPropFullIcon','lrcToggleFill');
				this.setData('ltPropHoverFullIcon','lrcToggleHover2');
			}
			this.setData('ltPropCount',1);
			this.setData('ltPropHalfIncrement',false);
			this.setData('ltPropClearable',true);
		}
		else if(this.getData('ltPropType') == "svg"){
			if(this.getData('ltPropAppearance') == "heart"){
				this.$node.classList.add('heart');
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHoverFilled');
				if(this.getData('ltPropHalfIncrement')){
					this.setData('ltPropHalfIcon','lyteRatingHalf');
					this.setData('ltPropHoverHalfIcon','lyteRatingHoverHalf');
				}
			}
			else if(this.getData('ltPropAppearance') == "lineHeart"){
				this.$node.classList.add('lineHeart');
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHoverFilled');
				if(this.getData('ltPropHalfIncrement')){
					this.setData('ltPropHalfIcon','lyteRatingHalf');
					this.setData('ltPropHoverHalfIcon','lyteRatingHoverHalf');
				}
			}
			else if(this.getData('ltPropAppearance') == "lineStar"){
				this.$node.classList.add('lineStar');
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHoverFilled');
				if(this.getData('ltPropHalfIncrement')){
					this.setData('ltPropHalfIcon','lyteRatingHalf');
					this.setData('ltPropHoverHalfIcon','lyteRatingHoverHalf');
				}
			}
			else{
				this.setData('ltPropAppearance','star');
				this.$node.classList.add('star');
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHoverFilled');
				if(this.getData('ltPropHalfIncrement')){
					this.setData('ltPropHalfIcon','lyteRatingHalf');
					this.setData('ltPropHoverHalfIcon','lyteRatingHoverHalf');
				}
			}
			if(this.getData('ltPropType') == "svg" && this.getData('ltPropHalfIncrement')){
				ratingNum += 1;
				this.setData('ratingNum',ratingNum);
			}
		}
		else if(this.getData('ltPropType') == "class"){
			this.setData('ltPropAppearance','class');
			if(this.getData('ltPropEmptyIcon') == "lyteDummyRC" || this.getData('ltPropFullIcon') == "lyteDummyRC" || this.getData('ltPropHoverFullIcon') == "lyteDummyRC"){
				this.$node.classList.add('star');
				this.setData('ltPropEmptyIcon','lyteRatingEmpty');
				this.setData('ltPropFullIcon','lyteRatingFilled');
				this.setData('ltPropHoverFullIcon','lyteRatingHoverFilled');
				if(this.getData('ltPropHalfIncrement')){
					this.setData('ltPropHalfIcon','lyteRatingHalf');
					this.setData('ltPropHoverHalfIcon','lyteRatingHoverHalf');
				}
			}
		}
		if(this.getData('ltPropCount') != this.getData('countArray').length){
			this.setCountArray();
		}
	}.observes("ltPropType","ltPropCount"/*,"ltPropHalfIncrement"*/).on("init"),

	appearanceChanged : function(){
		var value = this.getData('ltPropType');
		this.setData('ltPropType','');
		this.setData('ltPropType',value);
		this.setCountArray();
		this.setRating();
	}.observes("ltPropAppearance","ltPropHalfIncrement"),

	appearanceChanged : function(){
		var value = this.getData('ltPropType');
		this.setData('ltPropType','');
		this.setData('ltPropType',value);
	}.observes("ltPropAppearance"),

	didConnectFn : function(){
		this.setRating();
		if(!this.rendered){
			if(this.getMethods("onRender")){
				this.executeMethod("onRender",this);
			}  
            if(this.getData('ltPropValue') > 0){
            	this.rated = true;
            }
            this.rendered = true;
        }
	}.observes("ltPropValue").on("didConnect"),

	setCountArray : function(){
		var countArray = [];
		for(var i = 1; i <= this.getData('ltPropCount'); i++){
			var obj = {};
			obj.ind = i;
			if(this.getData('ltPropType') == "svg"){
				if(this.getData('ltPropAppearance') === "star"){
					obj.appearance = "#star";
					obj.viewbox = this.getData('starVB');
				}
				if(this.getData('ltPropAppearance') === "lineStar"){
					obj.appearance = "#star";
					obj.viewbox = this.getData('lineStarVB');
				}
				if(this.getData('ltPropAppearance') === "heart"){
					obj.appearance = "#heart";
					obj.viewbox = this.getData('heartVB');
				}
				if(this.getData('ltPropAppearance') === "lineHeart"){
					obj.appearance = "#heart";
					obj.viewbox = this.getData('lineHeartVB');
				}
			}
			countArray.push(obj);
		}
		this.setData('countArray',countArray);
	},

	svgIconObserver : function(){
		this.setRating();
	}.observes('ltPropFillColor'),

	setRating : function(stopMethod){
		this.clearHoverClasses();
		var currentRating = this.getData('ltPropValue'),
			ratedNodes = this.$node.querySelectorAll('.lyteRated'),
			nodes = this.$node.querySelectorAll('lyte-rate-icon');
		if(this.getData('ltPropType') == "svg"){
			if(this.getData('ltPropHalfIncrement')){
				var stops;
				for(var i = 0; i < Math.floor(currentRating); i++){
					stops = nodes[i].querySelectorAll('linearGradient stop');
					stops[1].setAttribute('offset','100%');
					stops[2].setAttribute('offset','0%');
					stops[0].style.stopColor = this.getData('ltPropFillColor');
					stops[1].style.stopColor = this.getData('ltPropFillColor');
					nodes[i].classList.add(this.getData('ltPropFullIcon'),"lyteRated");
				}
				for(var i = Math.floor(currentRating); i < nodes.length; i++){
					stops = nodes[i].querySelectorAll('linearGradient stop');
					stops[1].setAttribute('offset','0%');
					stops[2].setAttribute('offset','0%');
					stops[0].style.stopColor = this.getData('ltPropEmptyColor');
					stops[1].style.stopColor = this.getData('ltPropEmptyColor');
					stops[2].style.stopColor = this.getData('ltPropEmptyColor');
					nodes[i].classList.remove(this.getData('ltPropFullIcon'),this.getData('ltPropHalfIcon'),"lyteRated");
				}
				if(currentRating > 0){
					stops = nodes[Math.ceil(currentRating)-1].querySelectorAll('linearGradient stop');
					stops[1].setAttribute('offset',(currentRating % 1 != 0 ? parseInt((currentRating - Math.floor(currentRating))*100) : 100 )+'%');
					stops[2].setAttribute('offset',parseInt((currentRating - Math.floor(currentRating) + 0.01)*100)+'%');
					stops[0].style.stopColor = this.getData('ltPropFillColor');
					stops[1].style.stopColor = this.getData('ltPropFillColor');
					stops[2].style.stopColor = this.getData('ltPropEmptyColor');
					nodes[Math.ceil(currentRating)-1].classList.add(this.getData('ltPropHalfIcon'),"lyteRated");
				}
			}
			else{
				if(ratedNodes.length > 0 && this.getData('ltPropHalfIcon') && ratedNodes[ratedNodes.length-1].classList.contains(this.getData('ltPropHalfIcon'))){
					ratedNodes[ratedNodes.length-1].classList.remove(this.getData('ltPropHalfIcon'));
					ratedNodes[ratedNodes.length-1].classList.add(this.getData('ltPropFullIcon'))
				}
				if(currentRating < ratedNodes.length){
					var obj;
					for(var i = currentRating; i < ratedNodes.length; i++){
						if(this.getData("ltPropAppearance") == "lineHeart"){
							// $L('use',ratedNodes[i]).attr("href","#lineHeart");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","appearance","#lineHeart");
							Lyte.objectUtils(obj,"add","viewbox",this.getData('lineHeartVB'));
						}
						if(this.getData("ltPropAppearance") == "lineStar"){
							// $L('use',ratedNodes[i]).attr("href","#lineStar");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","viewbox",this.getData('lineStarVB'));
						}
						if(this.getData("ltPropAppearance") == "lineHeart" || this.getData("ltPropAppearance") == "lineStar"){
							$L('svg',ratedNodes[i]).css('stroke',this.getData('ltPropEmptyColor'));
							$L('svg',ratedNodes[i]).css('fill',"transparent");
						}
						else{
							$L('svg',ratedNodes[i]).css('fill',this.getData('ltPropEmptyColor'));
						}
						ratedNodes[i].classList.remove(this.getData('ltPropFullIcon'),"lyteRated");
						if(this.getData('ltPropHalfIcon')){
							ratedNodes[i].classList.remove(this.getData('ltPropHalfIcon'));
						}
					}
				}
				else if(currentRating > ratedNodes.length){
					var obj;
					for(var i = 0; i < currentRating && i < nodes.length; i++){
						if(this.getData("ltPropAppearance") == "lineHeart"){
							// $L('use',nodes[i]).attr("href","#heart");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","appearance","#heart");
							Lyte.objectUtils(obj,"add","viewbox",this.getData('heartVB'));
						}
						if(this.getData("ltPropAppearance") == "lineStar"){
							// $L('use',nodes[i]).attr("href","#star");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","viewbox",this.getData('starVB'));
						}
						$L('svg',nodes[i]).css('fill',this.getData('ltPropFillColor'));
						$L('svg',nodes[i]).css('stroke',"");
						nodes[i].classList.add(this.getData('ltPropFullIcon'),"lyteRated");
					}
				}
			}
		}
		else if(this.getData('ltPropType') == "switch"){
			if(ratedNodes.length){
				var prevValue = parseInt(ratedNodes[0].getAttribute('data-lrc'));
				ratedNodes[0].classList.remove(this.getClass(prevValue-1,'fi'),"lyteRated");
			}
			if(currentRating > 0){
				nodes[currentRating - 1].classList.add(this.getClass(currentRating-1,'fi'),"lyteRated");
			}
		}
		else if(this.getData('ltPropType') === "multiple" && this.getData('ltPropAppearance') != 'smiley'){
			if(currentRating % 1 !== 0){
				for(var i = 0; i < Math.floor(currentRating); i++){
					nodes[i].classList.add(this.getClass(i,'fi'),"lyteRated");
				}
				for(var i = Math.floor(currentRating); i < nodes.length; i++){
					nodes[i].classList.remove(this.getClass(i,'fi'),this.getClass(i,'hi'),"lyteRated");
				}
				nodes[Math.ceil(currentRating)-1].classList.add(this.getClass(Math.ceil(currentRating)-1,'hi'),"lyteRated");
			}
			else{
				if(ratedNodes.length > 0 && this.getData('halfIconArray').length && ratedNodes[ratedNodes.length-1].classList.contains(this.getClass(ratedNodes.length-1,'hi'))){
					ratedNodes[ratedNodes.length-1].classList.remove(this.getClass(ratedNodes.length-1,'hi'));
					ratedNodes[ratedNodes.length-1].classList.add(this.getClass(ratedNodes.length-1,'fi'))
				}
				if(currentRating < ratedNodes.length){
					for(var i = currentRating; i < ratedNodes.length; i++){
						ratedNodes[i].classList.remove(this.getClass(i,'fi'),"lyteRated");
						if(this.getData('halfIconArray').length){
							ratedNodes[i].classList.remove(this.getClass(i,'hi'));
						}
					}
				}
				else if(currentRating > ratedNodes.length){
					for(var i = ratedNodes.length; i < currentRating && i < nodes.length; i++){
						nodes[i].classList.add(this.getClass(i,'fi'),"lyteRated");
					}
				}
			}
		}
		else{
			if(currentRating % 1 !== 0){
				for(var i = 0; i < Math.floor(currentRating); i++){
					nodes[i].classList.add(this.getData('ltPropFullIcon'),"lyteRated");
				}
				for(var i = Math.floor(currentRating); i < nodes.length; i++){
					nodes[i].classList.remove(this.getData('ltPropFullIcon'),this.getData('ltPropHalfIcon'),"lyteRated");
				}
				nodes[Math.ceil(currentRating)-1].classList.add(this.getData('ltPropHalfIcon'),"lyteRated");
			}
			else{
				if(ratedNodes.length > 0 && this.getData('ltPropHalfIcon') && ratedNodes[ratedNodes.length-1].classList.contains(this.getData('ltPropHalfIcon'))){
					ratedNodes[ratedNodes.length-1].classList.remove(this.getData('ltPropHalfIcon'));
					ratedNodes[ratedNodes.length-1].classList.add(this.getData('ltPropFullIcon'))
				}
				if(currentRating < ratedNodes.length){
					for(var i = currentRating; i < ratedNodes.length; i++){
						ratedNodes[i].classList.remove(this.getData('ltPropFullIcon'),"lyteRated");
						if(this.getData('ltPropHalfIcon')){
							ratedNodes[i].classList.remove(this.getData('ltPropHalfIcon'));
						}
					}
				}
				else if(currentRating > ratedNodes.length){
					for(var i = ratedNodes.length; i < currentRating && i < nodes.length; i++){
						nodes[i].classList.add(this.getData('ltPropFullIcon'),"lyteRated");
					}
				}
			}
		}
		
		if(!stopMethod && this.getMethods("onClick")){
            this.executeMethod("onClick",this.getData('ltPropValue'),this);
        }
	},

	getClass : function(index, iconType){
		if(iconType == "fi"){
			return Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('fullIconArray'),index);
		}
		if(iconType == "hi"){
			return Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('halfIconArray'),index);
		}
		if(iconType == "hfi"){
			return Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('hoverFullIconArray'),index);
		}
		if(iconType == "hhi"){
			return Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('hoverHalfIconArray'),index);
		}
	},

	clearHoverClasses : function(){
		var hoveredNodes = this.$node.querySelectorAll('.lyteRatingHover');
		for(var i = 0; i<hoveredNodes.length; i++){
			if(this.getData('ltPropType') == "switch"){
				hoveredNodes[i].classList.remove(this.getClass(parseInt(hoveredNodes[i].getAttribute('data-lrc'))-1, 'hfi'),'lyteRatingHover');
			}
			else if(this.getData('ltPropType') == "multiple" && this.getData('ltPropAppearance') != 'smiley'){
				hoveredNodes[i].classList.remove(this.getClass(parseInt(hoveredNodes[i].getAttribute('data-lrc'))-1, 'hfi'),'lyteRatingHover');
				if(this.getData('hoverHalfIconArray').length){
					hoveredNodes[i].classList.remove(this.getClass(parseInt(hoveredNodes[i].getAttribute('data-lrc'))-1, 'hhi'),'lyteRatingHover');
				}
			}
			else{
				hoveredNodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),'lyteRatingHover');
			}
		}
	},

	getCurrentValue : function(event,ele){
		var value = parseInt(ele.getAttribute('data-lrc'));
		if(this.getData('ltPropHalfIncrement')){
			var elemOffset = ele.getBoundingClientRect();
			if(event.clientX <= elemOffset.left + (elemOffset.width/2)){
				value = (value-1)+0.5;
			}
		}
		return value;
	},

	onClick : function(event){
		if(this.getData('ltPropClearable')){
			if(this.rated && this.getData('currentHover') == this.getData('ltPropValue')){
				this.setData('ltPropValue',0);
				this.rated = false;
				this.setData('currentHover',0)
			}
			else{
				var value = this.getCurrentValue(event,event.target.closest('lyte-rate-icon'));
				if(value != this.getData('currentHover')){
					this.setData('currentHover',value);
				}
				this.setData('ltPropValue',this.getData('currentHover'));
				this.rated = true;
			}
		}
		else{
			this.setData('ltPropValue',this.getData('currentHover'));
		}
	},

	onOver : function(event){
		var target = event.target.closest('lyte-rate-icon'),
			value = parseInt(target.getAttribute('data-lrc')),
			hoveredNodes = this.getData('currentHover'),
			nodes = this.$node.querySelectorAll('lyte-rate-icon'),
			prevValue = hoveredNodes;
		if(this.getData('ltPropType') == "svg"){
			if(Lyte.Component.registeredHelpers.lyteUiCheckHalfRatingSvg(this.getData('ltPropHalfIncrement'), this.getData('ltPropPrecision'))){
				// console.log(this.getData('currentHover'));
				var precision = this.getData('ltPropPrecision') * 100, stops,
				elemOffset = target.querySelector('use').getBoundingClientRect();
				hoveredNodes = Math.ceil(hoveredNodes);
				if((value - 1) < hoveredNodes){
					for(var i = value-1; i < hoveredNodes; i++){
						stops = nodes[i].querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset','0%');
						stops[2].setAttribute('offset','0%');
						stops[0].style.stopColor = this.getData('ltPropEmptyColor');
						stops[1].style.stopColor = this.getData('ltPropEmptyColor');
						stops[2].style.stopColor = this.getData('ltPropEmptyColor');
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
					}
				}
				else if((value - 1) > hoveredNodes){
					for(var i = hoveredNodes; i < value-1; i++){
						stops = nodes[i].querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset','100%');
						stops[2].setAttribute('offset','0%');
						stops[0].style.stopColor = this.getData('ltPropHoverColor');
						stops[1].style.stopColor = this.getData('ltPropHoverColor');
						stops[2].style.stopColor = this.getData('ltPropHoverColor');
						nodes[i].classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
					}
					for(var i = value-1; i < nodes.length; i++){
						stops = nodes[i].querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset','0%');
						stops[2].setAttribute('offset','0%');
						stops[0].style.stopColor = this.getData('ltPropEmptyColor');
						stops[1].style.stopColor = this.getData('ltPropEmptyColor');
						stops[2].style.stopColor = this.getData('ltPropEmptyColor');
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
					}
				}
				else{
					for(var i = value-1; i < nodes.length; i++){
						stops = nodes[i].querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset','0%');
						stops[2].setAttribute('offset','0%');
						stops[0].style.stopColor = this.getData('ltPropEmptyColor');
						stops[1].style.stopColor = this.getData('ltPropEmptyColor');
						stops[2].style.stopColor = this.getData('ltPropEmptyColor');
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
					}
				}
				target.classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
				// if(event.clientX >= elemOffset.left && event.clientX <= elemOffset.right){
					var currWidth = Math.abs(event.clientX - Math.round(elemOffset.left)),
					totalWidth = Math.round(elemOffset.width),
					percentage = parseInt(Math.min(((currWidth/totalWidth)*100), 100));
					// console.log(currWidth,totalWidth,percentage)
					if(percentage != 0 && percentage % precision == 0){
						stops = target.querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset', percentage + '%');
						stops[2].setAttribute('offset', (percentage + 1) + '%');
						stops[0].style.stopColor = this.getData('ltPropHoverColor');
						stops[1].style.stopColor = this.getData('ltPropHoverColor');
						stops[2].style.stopColor = this.getData('ltPropEmptyColor');
						target.classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
						this.setData('currentHover',(value - 1)+(percentage/100));
					}
					else{
						var quo = parseInt(percentage / precision),
						nearest = Math.min((quo+1)*precision,100);
						stops = target.querySelectorAll('linearGradient stop');
						stops[1].setAttribute('offset', nearest + '%');
						stops[2].setAttribute('offset', (nearest + 1) + '%');
						stops[0].style.stopColor = this.getData('ltPropHoverColor');
						stops[1].style.stopColor = this.getData('ltPropHoverColor');
						stops[2].style.stopColor = this.getData('ltPropEmptyColor');
						target.classList.add(this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
						this.setData('currentHover',(value-1)+(nearest/100));
					}
				// }
			}
			else{
				var obj;
				if(value > hoveredNodes){
					for(var i = hoveredNodes; i < value; i++){
						nodes[i].classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
						if(this.getData("ltPropAppearance") == "lineHeart"){
							// $L('use',nodes[i]).attr("href","#heart");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","appearance","#heart");
							Lyte.objectUtils(obj,"add","viewbox",this.getData('heartVB'));
						}
						if(this.getData("ltPropAppearance") == "lineStar"){
							// $L('use',nodes[i]).attr("href","#star");
							obj = this.getData('countArray')[i];
							Lyte.objectUtils(obj,"add","viewbox",this.getData('starVB'));
						}
						$L('svg',nodes[i]).css('fill',this.getData('ltPropHoverColor'));
						$L('svg',nodes[i]).css('stroke',"");
					}
				}
				else if(value < hoveredNodes){
					for(var i = value; i < hoveredNodes; i++){
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
						if(value < this.getData('ltPropValue')){
							if(this.getData("ltPropAppearance") == "lineHeart"){
								// $L('use',nodes[i]).attr("href","#heart");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","appearance","#heart");
								Lyte.objectUtils(obj,"add","viewbox",this.getData('heartVB'));
							}
							if(this.getData("ltPropAppearance") == "lineStar"){
								// $L('use',nodes[i]).attr("href","#star");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","viewbox",this.getData('starVB'));
							}
							$L('svg',nodes[i]).css('fill',this.getData('ltPropFillColor'));
							$L('svg',nodes[i]).css('stroke',"");
						}
						else{
							if(this.getData("ltPropAppearance") == "lineHeart"){
								// $L('use',nodes[i]).attr("href","#lineHeart");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","appearance","#lineHeart");
								Lyte.objectUtils(obj,"add","viewbox",this.getData('lineHeartVB'));
							}
							if(this.getData("ltPropAppearance") == "lineStar"){
								// $L('use',nodes[i]).attr("href","#lineStar");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","viewbox",this.getData('lineStarVB'));
							}
							if(this.getData("ltPropAppearance") == "lineHeart" || this.getData("ltPropAppearance") == "lineStar"){
								$L('svg',nodes[i]).css('stroke',this.getData('ltPropEmptyColor'));
								$L('svg',nodes[i]).css('fill',"transparent");
							}
							else{
								$L('svg',nodes[i]).css('fill',this.getData('ltPropEmptyColor'));
							}
						}
					}
				}
				else{
					for(var i = 0; i < hoveredNodes; i++){
						if(!(nodes[i].classList.contains("lyteRatingHover"))){
							nodes[i].classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
							if(this.getData("ltPropAppearance") == "lineHeart"){
								// $L('use',nodes[i]).attr("href","#heart");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","appearance","#heart");
								Lyte.objectUtils(obj,"add","viewbox",this.getData('heartVB'));
							}
							if(this.getData("ltPropAppearance") == "lineStar"){
								// $L('use',nodes[i]).attr("href","#star");
								obj = this.getData('countArray')[i];
								Lyte.objectUtils(obj,"add","viewbox",this.getData('starVB'));
							}
							$L('svg',nodes[i]).css('fill',this.getData('ltPropHoverColor'));
							$L('svg',nodes[i]).css('stroke',"");
						}
					}
				}
				this.setData('currentHover',value);
			}
		}
		else if(this.getData('ltPropType') == "switch"){
			nodes[value-1].classList.add(Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('hoverFullIconArray'),value-1),'lyteRatingHover');
			this.setData('currentHover',value);
		}
		else if(this.getData('ltPropType') == "multiple" && this.getData('ltPropAppearance') != 'smiley'){
			if(this.getData('ltPropHalfIncrement')){
				hoveredNodes = Math.round(hoveredNodes);
				var elemOffset = target.getBoundingClientRect();
				if((value - 1) < hoveredNodes){
					for(var i = value-1; i < hoveredNodes; i++){
						nodes[i].classList.remove(this.getClass(i,'hfi'), this.getClass(i,'hhi'),"lyteRatingHover");
					}
				}
				else if((value - 1) > hoveredNodes){
					for(var i = hoveredNodes; i < value-1; i++){
						nodes[i].classList.add(this.getClass(i,'hfi'),"lyteRatingHover");
					}
				}
				target.classList.remove(this.getClass(value,'hfi'), this.getClass(value,'hhi'),"lyteRatingHover");
				if(event.clientX > elemOffset.left + (elemOffset.width/2)){
					target.classList.add(this.getClass(value,'hfi'),"lyteRatingHover");
					this.setData('currentHover',value);
				}
				else{
					target.classList.add(this.getClass(value,'hhi'),"lyteRatingHover");
					this.setData('currentHover',(value-1)+0.5);
				}
			}
			else{
				if(value > hoveredNodes){
					for(var i = hoveredNodes; i < value; i++){
						nodes[i].classList.add(this.getClass(i,'hfi'),"lyteRatingHover");
					}
				}
				else if(value < hoveredNodes){
					for(var i = value; i < hoveredNodes; i++){
						nodes[i].classList.remove(this.getClass(i,'hfi'),"lyteRatingHover");
					}
				}
				this.setData('currentHover',value);
			}
		}
		else{
			if(this.getData('ltPropHalfIncrement')){
				hoveredNodes = Math.round(hoveredNodes);
				var elemOffset = target.getBoundingClientRect();
				if((value - 1) < hoveredNodes){
					for(var i = value-1; i < hoveredNodes; i++){
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
					}
				}
				else if((value - 1) > hoveredNodes){
					for(var i = hoveredNodes; i < value-1; i++){
						nodes[i].classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
					}
				}
				target.classList.remove(this.getData('ltPropHoverFullIcon'),this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
				if(event.clientX > elemOffset.left + (elemOffset.width/2)){
					target.classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
					this.setData('currentHover',value);
				}
				else{
					target.classList.add(this.getData('ltPropHoverHalfIcon'),"lyteRatingHover");
					this.setData('currentHover',(value-1)+0.5);
				}
			}
			else{
				if(value > hoveredNodes){
					for(var i = hoveredNodes; i < value; i++){
						nodes[i].classList.add(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
					}
				}
				else if(value < hoveredNodes){
					for(var i = value; i < hoveredNodes; i++){
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),"lyteRatingHover");
					}
				}
				this.setData('currentHover',value);
			}
		}
		if(prevValue != this.getData('currentHover') && this.getMethods("onHover")){
            this.executeMethod("onHover",this.getData('currentHover'),this);  
        }
	},

	onOut : function(event){
		var target = event.target.closest('lyte-rate-icon');
		if(this.getData('ltPropType') == "switch"){
			target.classList.remove(Lyte.Component.registeredHelpers.lyteUiGetArrayValueByIndex(this.getData('hoverFullIconArray'), parseInt(target.getAttribute('data-lrc')) - 1),'lyteRatingHover');
			this.setData('currentHover',0);
		}
		else{
			var children = this.$node.querySelectorAll('lyte-rate-icon');
			var left = children[0].getBoundingClientRect().left;
			var right = children[children.length-1].getBoundingClientRect().right;
			var offset = target.getBoundingClientRect();
			if(event.clientX <= left || event.clientX >= right || event.clientY <= offset.top || event.clientY >= offset.bottom){
				// console.log("mouseout",target);
				var nodes = this.$node.querySelectorAll('.lyteRatingHover');
				var obj;
				for(var i = 0; i < nodes.length; i++ ){
					if(this.getData('ltPropType') == "svg"){
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),'lyteRatingHover');
						if(this.getData('ltPropHalfIncrement')){
							// console.log("WIP");
							this.setRating(true);
						}
						else{
							if(i < this.getData('ltPropValue')){
								$L('svg',nodes[i]).css('fill',this.getData('ltPropFillColor'));
							}
							else{
								if(this.getData("ltPropAppearance") == "lineHeart"){
									// $L('use',nodes[i]).attr("href","#lineHeart");
									obj = this.getData('countArray')[i];
									Lyte.objectUtils(obj,"add","appearance","#lineHeart");
									Lyte.objectUtils(obj,"add","viewbox",this.getData('lineHeartVB'));
								}
								if(this.getData("ltPropAppearance") == "lineStar"){
									// $L('use',nodes[i]).attr("href","#lineStar");
									obj = this.getData('countArray')[i];
									Lyte.objectUtils(obj,"add","viewbox",this.getData('lineStarVB'));
								}
								if(this.getData("ltPropAppearance") == "lineHeart" || this.getData("ltPropAppearance") == "lineStar"){
									$L('svg',nodes[i]).css('stroke',this.getData('ltPropEmptyColor'));
									$L('svg',nodes[i]).css('fill',"transparent");
								}
								else{
									$L('svg',nodes[i]).css('fill',this.getData('ltPropEmptyColor'));
									$L('svg',nodes[i]).css('stroke',"");
								}
							}
						}
					}
					else if(this.getData('ltPropType') == "multiple" && this.getData('ltPropAppearance') != 'smiley'){
						nodes[i].classList.remove(this.getClass(i,'hfi'),'lyteRatingHover');
						if(this.getData('halfIconArray').length){
							nodes[i].classList.remove(this.getClass(i,'hhi'));
						}
					}
					else{
						nodes[i].classList.remove(this.getData('ltPropHoverFullIcon'),'lyteRatingHover');
						if(this.getData('ltPropHoverHalfIcon')){
							nodes[i].classList.remove(this.getData('ltPropHoverHalfIcon'));
						}
					}
				}
				this.setData('currentHover',0);
			}
		}
		if(this.getMethods("onOut")){
            this.executeMethod("onOut",parseInt(target.getAttribute('data-lrc')),this);  
        }
	}
});

if( !_lyteUiUtils.registeredCustomElements[ 'lyte-rate-icon' ] ){
    
    _lyteUiUtils.registeredCustomElements[ 'lyte-rate-icon' ] = true;

    Lyte.createCustomElement("lyte-rate-icon", {
	    static : {

	    },
	    connectedCallback : function(){
	        var comp = this.closest('lyte-rating').component;
	        this.addEventListener('click',comp.onClick.bind(comp));
	        this.addEventListener('mousemove',comp.onOver.bind(comp));
	        this.addEventListener('mouseout',comp.onOut.bind(comp));
	        if(comp.getData('ltPropYield')){
	        	if(comp.timeoutId){
	        		clearTimeout(comp.timeoutId);
	        		comp.timeoutId = false;
	        	}
	        	comp.timeoutId = setTimeout(function(){
	        		var nodes = this.closest('lyte-rating').querySelectorAll('lyte-rate-icon');
	        		for(var i = 0; i<nodes.length; i++){
	        			nodes[i].setAttribute('data-lrc',i+1);
	        		}
	        	}.bind(this),100);
	        }
	    },
	    disconnectedCallback : function(){
	        
	    }
	});
}

/**
 * @syntax nonYielded
 * <lyte-rating lt-prop-type = "svg" lt-prop-appearance = "star"> </lyte-rating>
 * </lyte-rating> 
 */

if(!_LyteBanner_){
	var _LyteBanner_ =  {};
}
/**
 * Renders a banner
 * @component lyte-banner
 * @version 3.1.0
 * @methods onBeforeShow,onShow,onBeforeClose,onClose
 * @dependency lyte-modal
 * @condition ltPropFloating true
 */
Lyte.Component.register("lyte-banner",{
_template:"<template tag-name=\"lyte-banner\" style=\"{{if(ltPropInline,concat(ltPropPosition,':0;'))}}\" class=\"{{if(ltPropInline,'lyteBannerInlineFloating','')}}\"> <template is=\"if\" value=\"{{ltPropFloating}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropInline}}\"><template case=\"true\"> <div class=\"lyteBannerFloating {{ltPropClass}}\" style=\"display:none;width:{{ltPropWidth}}; height:{{ltPropHeight}};{{if(expHandlers(ltPropPosition,'===','top'),'top:-100%','bottom:-100%')}};\"> <lyte-yield yield-name=\"yield\"></lyte-yield> <template is=\"if\" value=\"{{ltPropShowCloseButton}}\"><template case=\"true\"> <span class=\"lyteModalClose lyteBannerClose\" onclick=\"{{action('close')}}\"></span> </template></template> </div> </template><template case=\"false\"> <lyte-modal id=\"_lyteBannerModal\" lt-prop=\"{{stringify(ltPropModal)}}\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-show=\"{{lbind(ltPropShow)}}\" lt-prop-freeze=\"false\" lt-prop-allow-multiple=\"true\" lt-prop-close-on-escape=\"false\" lt-prop-re-render-modal=\"{{lbind(ltPropReRenderModal)}}\" lt-prop-bind-to-body=\"{{lbind(ltPropBindToBody)}}\" lt-prop-show-close-button=\"{{ltPropShowCloseButton}}\" lt-prop-overlay-close=\"false\" lt-prop-wrapper-class=\"lyteBannerModal {{if(ltPropModal.wrapperClass,ltPropModal.wrapperClass,'')}}\" on-show=\"{{method(&quot;modalOnShow&quot;)}}\" on-before-show=\"{{method(&quot;modalOnBeforeShow&quot;)}}\" on-close=\"{{method(&quot;modalOnClose&quot;)}}\" on-before-close=\"{{method(&quot;modalOnBeforeClose&quot;)}}\" lt-prop-transition=\"{{ltPropTransition}}\" lt-prop-offset=\"{{if(ltPropModal.offset,ltPropModal.offset,ltPropOffset)}}\"> <template is=\"registerYield\" yield-name=\"modal\"> <lyte-modal-content class=\"lyteBannerModalContent {{ltPropClass}}\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </lyte-modal-content> </template> </lyte-modal> </template></template> </template><template case=\"false\"> <div class=\"lyteBannerNonFloating {{ltPropClass}}\" style=\"display:none;width:{{ltPropWidth}}; height:{{ltPropHeight}};\"> <lyte-yield yield-name=\"yield\"></lyte-yield> <template is=\"if\" value=\"{{ltPropShowCloseButton}}\"><template case=\"true\"> <span class=\"lyteModalClose lyteBannerClose\" onclick=\"{{action('close')}}\"></span> </template></template> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'display:none;width:'","ltPropWidth","'; height:'","ltPropHeight","';'",{"type":"helper","value":{"name":"if","args":[{"type":"helper","value":{"name":"expHandlers","args":["ltPropPosition","'==='","'top'"]}},"'top:-100%'","'bottom:-100%'"]}},"';'"]}}}},{"type":"insertYield","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'display:none;width:'","ltPropWidth","'; height:'","ltPropHeight","';'"]}}}},{"type":"insertYield","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]}},"default":{}}],
_templateAttributes :{"type":"attr","position":[],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropInline",{"type":"helper","value":{"name":"concat","args":["ltPropPosition","':0;'"]}}]}}}},
_observedAttributes :["ltPropModal","ltPropFloating","ltPropInline","ltPropTransition","ltPropOffset","ltPropShow","ltPropShowCloseButton","ltPropPosition","ltPropInitialSpacing","ltPropBannerSpacing","ltPropWidth","ltPropHeight","ltPropClass","ltPropReRenderModal","ltPropBindToBody","returnFalse","handleLbind"],
	data:function(){
		return {
			/** 
			 * @componentProperty {object} ltPropModal
			 * @default {}
			 * @component lyte-modal
			 * @ignore-props ltPropShow,ltPropTransition,ltPropOffset,ltPropShowCloseButton,ltPropWidth,ltPropHeight,ltPropReRenderModal,ltPropBindToBody
			 */
			"ltPropModal":Lyte.attr("object",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-banner', 'modal', {} )
			}),
			/** 
			 * @componentProperty {boolean} ltPropFloating=true
			 */
			"ltPropFloating":Lyte.attr("boolean",{"default":true}),
			/** 
			 * @componentProperty {boolean} ltPropInline=false
			 */
			"ltPropInline":Lyte.attr("boolean",{"default":false}),
			/** 
			 * @typedef {object} transitionObject
			 * @property {slideFromTop|slideFromBottom|slideFromLeft|slideFromRight|fadeIn} animation=slideFromTop
			 * @property {string} duration=0.5
			*/
			/** 
			 * @componentProperty {transitionObject} ltPropTransition
			 * @default {"animation":"slideFromTop","duration":"0.5"}
			 */
			"ltPropTransition":Lyte.attr("object",{"default":{animation:"slideFromTop",duration:"0.5"}}),
			/**
			 * @typedef {object} offset
			 * @property {string} left
			 * @property {string} top
			 * @property {string} right
			 * @property {string} bottom
			 */
			/** 
			 * @componentProperty {offset} ltPropOffset
			 * @default {}
			 */
			"ltPropOffset" : Lyte.attr("object",{"default":{}}),
			/** 
			 * @componentProperty {boolean} ltPropShow=false
			 */
			"ltPropShow":Lyte.attr("boolean",{"default":false}),
			/** 
			 * @componentProperty {boolean} ltPropShowCloseButton=true
			 */
			"ltPropShowCloseButton":Lyte.attr("boolean",{"default":true}),
			/** 
			 * @componentProperty {top|bottom} ltPropPosition=top
			 */
			"ltPropPosition":Lyte.attr("string",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-banner', 'position', "top" )
			}),
			/** 
			 * @componentProperty {string} ltPropInitialSpacing=0px
			 * @suffix px
			 */
			"ltPropInitialSpacing":Lyte.attr("string",{"default":"0px"}),
			/** 
			 * @componentProperty {string} ltPropBannerSpacing=2px
			 * @suffix px
			 */
			"ltPropBannerSpacing":Lyte.attr("string",{"default":"2px"}),
			/** 
			 * @componentProperty {string} ltPropWidth=100%
			 */
			"ltPropWidth":Lyte.attr("string",{"default":"100%"}),
			/** 
			 * @componentProperty {string} ltPropHeight=auto
			 */
			"ltPropHeight":Lyte.attr("string",{"default":"auto"}),
			/** 
			 * @componentProperty {string} ltPropClass=""
			 */
			"ltPropClass":Lyte.attr("string",{
				"default": _lyteUiUtils.resolveDefaultValue( 'lyte-banner', 'class', "" )
			}),
			/** 
			 * @componentProperty {boolean} ltPropReRenderModal=false
			 */
			"ltPropReRenderModal" : Lyte.attr("string",{"default":false}),
			/** 
			 * @componentProperty {boolean} ltPropBindToBody=false
			 */
			"ltPropBindToBody" : Lyte.attr("string",{"default":false}),
			"returnFalse" : Lyte.attr("boolean",{"default":false}),
			"handleLbind" : Lyte.attr("boolean",{"default":false})
		}		
	},
	onBeforeShow : function(){
		if(this.getMethods('onBeforeShow')){
			return this.executeMethod("onBeforeShow",this);
		}
	},
	onShow : function(){
		if(this.getMethods('onShow')){
			this.executeMethod("onShow",this);
		}
	},
	onBeforeClose : function(){
		if(this.getMethods('onBeforeClose')){
			return this.executeMethod("onBeforeClose",this);
		}
	},
	onClose : function(){
		if(this.getMethods('onClose')){
			this.executeMethod("onClose",this);
		}
	},
	isCheckedLbound: function() {
		if( !this.$node._attributeDetails ) {
			return false;
		}
		return this.$node._attributeDetails[ 'lt-prop-show' ] ? !!this.$node._attributeDetails[ 'lt-prop-show' ].isLbind : false;
	},
	showBanner : function(banner){
		if(this.data.ltPropInline){
			this.calculateOffset(banner);
			this.transitionForOpen(banner);
		}
		else{
			banner.style.display = "block";
			this.onShow();
		}
	},
	closeBanner : function(banner){
		if(this.data.ltPropInline){
			this.transitionForClose(banner);
		}
		else{
			banner.style.display = "none";
			this.onClose();
		}
	},
	calculateOffset : function(banner){
		var offset = this.data.ltPropOffset;
		if(offset.left == "center"){
			var width = banner.offsetWidth/2;
			offset.left = "calc( 50% - "+width+"px)";
	    }
		for(var key in offset){
			banner.style[key] = offset[key];
		}
	},
	transitionForOpen : function(banner){
		var transition = this.data.ltPropTransition,
		offset = this.data.ltPropOffset,
		position = this.data.ltPropPosition,
		value = offset[position]?offset[position]:0,
		percent,bannerHeight;
		banner.style.display = "block";
		this._transitionEnd = this.transitionEnd.bind(this,"onShow");
		bannerHeight = banner.offsetHeight;
		if(value){
			percent = value.indexOf('%')>=0
		}
		this.$node.style.height = percent? "100%":( bannerHeight + value) +"px";
		banner.style.transitionDuration = transition.duration+"s";
		if(transition.duration){
			setTimeout(function(){
				banner.addEventListener("transitionend",this._transitionEnd,true);
				banner.style[position] = value;
			}.bind(this),10);
		}
	},
	transitionForClose :function(banner){
		var position = this.data.ltPropPosition;
		this._transitionEnd = this.transitionEnd.bind(this,"onClose");
		if(banner.style.display != "none"){
			banner.addEventListener("transitionend",this._transitionEnd,true);
			banner.style[position] = "-100%";
		}
	},
	transitionEnd : function(callback){
		var banner = event.target;
		banner.removeEventListener("transitionend",this._transitionEnd,true);
		this.getMethods(callback) && this.executeMethod(callback,this);
		if(callback === "onClose"){
			banner.style.display = "none";
		}
		delete this._transitionEnd;
	},
	getBannerIndex : function(position) {
		var banners  = _LyteBanner_[position],
		bannerLength = banners.length,
		bannerIndex;
		for(var index=0;index<bannerLength;index++){
			if(this === banners[index]){
				bannerIndex =  index;
				break;
			}
		}
		return bannerIndex;
	},
	getTotalHeight : function(bannerIndex) {
		var currentModal = this.$node.querySelector("lyte-modal").component,
		compPosition = currentModal.actualModalDiv.getBoundingClientRect(),
		initDiff = parseFloat(this.$node.ltProp("InitialSpacing")),
		bannerDiff = parseFloat(this.$node.ltProp("BannerSpacing")),
		height = bannerIndex-1<0?initDiff:bannerDiff;
		height = height + compPosition.height;
		return height;
	},
	rearrangeBanner : function(){
		var position = this.$node.ltProp("Position");
		if(position != ""){
			var bannerIndex = this.getBannerIndex(position);
			var height = this.getTotalHeight(bannerIndex);
			var banners  = _LyteBanner_[position],
			bannerLength = banners.length;
			for(var index=bannerIndex+1;index<bannerLength;index++){
				var modal = banners[index].$node.querySelector("lyte-modal"),
				bannerDiff = parseFloat(banners[index].$node.ltProp("BannerSpacing")),
				initDiff = parseFloat(banners[index].$node.ltProp("InitialSpacing")),
				tempHeight=0;
				var modal_pos = modal.component.actualModalDiv.getBoundingClientRect();
				var offset = modal.ltProp("offset");
				tempHeight = (position == "top")? modal_pos.top - height:parseInt(offset.bottom) - height;
				if(parseInt(tempHeight)-bannerDiff <= 0){
					height = height + bannerDiff - initDiff;
					tempHeight = tempHeight - bannerDiff;
					tempHeight = tempHeight + initDiff;
				}
				if(position === "top"){
					offset.top = tempHeight+"";
				}
				else{
					offset.bottom = tempHeight+"";
				}
				modal.component.computeOffsetImpl();
			}
			_LyteBanner_[position].splice(bannerIndex,1);
			this.$node.ltProp("offset", {top:"center",left:"center"});
		}else{
			this.$node.ltProp("position","top");
		}
	},
	isNotCustomOffset : function(component) {
		var obj = {top:"center",left:"center"},
		keys = Object.keys(component.$node.ltProp("offset")),
		keysLength = keys.length,
		offsetFlag=true;
		for(var index=0;index<keysLength;index++){
			var key = keys[index];
			if(obj[key] != component.$node.ltProp("offset")[key]){
				offsetFlag = false;
			}
		}
		return offsetFlag;
	},
	didDestroy : function(){
		this.data.ltPropFloating && this.data.ltPropShow && this.rearrangeBanner();
	},
	actions:{
        close:function(){
			this.setData('ltPropShow',false);
        }
    },
	methods:{
		modalOnBeforeShow:function(component){
			if(this.onBeforeShow() === false){
				this.setData("returnFalse",true);
				return false;
			}
			var height=0,
			offsetFlag=this.isNotCustomOffset(component);
			if(offsetFlag){
				var position = this.$node.ltProp("Position"),
				init_diff = parseFloat(this.$node.ltProp("InitialSpacing")),
				banner_diff = parseFloat(this.$node.ltProp("BannerSpacing"));
				if(position){
					_LyteBanner_[position] = _LyteBanner_[position] || [];
					var banners =  _LyteBanner_[position];
					if(banners.length){
						var index = banners.length-1;
						var modal = banners[index].$node.querySelector("lyte-modal");
						var modal_pos = modal.component.actualModalDiv.getBoundingClientRect();
						height =  modal_pos.height;
						if(modal.ltProp("offset")){
							if(modal.ltProp("offset")[position]){
								height = height + parseInt(modal.ltProp("offset")[position],10);
							}
						}
						if(banner_diff){
							height = height + banner_diff;
						}
						if(position == "top"){
							component.$node.ltProp("offset",{top:height+"px",left:"0px"});
						}
						else{
							this.$node.ltProp("transition",{"animation":"slideFromBottom"});
							this.$node.ltProp("offset",{bottom:height+"px",left:"0px"});
						}
					}
					else{
						if(init_diff){
							height = height + init_diff;
						}
						if(position !="top"){
							this.$node.ltProp("transition",{"animation":"slideFromBottom"});
							this.$node.ltProp("offset",{bottom:height+"px",left:"0px"});
						}
						else{
							this.$node.ltProp("offset",{top:height+"px",left:"0px"});
						}
					}
					_LyteBanner_[position].push(this);
				}
			}
			else{
				this.$node.ltProp("position","");
			}
		},
		modalOnShow:function(comp){
			this.onShow();
		},
		modalOnBeforeClose:function(event,component){
			if(this.onBeforeClose() === false){
				this.setData("returnFalse",true);
				return false;
			}
			this.rearrangeBanner();
		},
		modalOnClose:function(component){
			this.onClose();
		}
	},
	showChanges:function(change){
		var show = this.$node.ltProp("Show");
		var floating = this.$node.ltProp("Floating"),
		inline = this.data.ltPropInline;
		if(this.data.returnFalse){
			this.setData("returnFalse",false);
			return;
		}
		if( this.getData( 'handleLbind' ) ) {
			this.setData( 'returnFalse', true );
			this.setData( 'ltPropShow', !this.getData( 'ltPropShow' ) );
			this.setData( 'handleLbind', false );
			return ;
		}
		if(!floating || (floating && inline)){
			var banner = this.$node.querySelector(inline?".lyteBannerFloating":".lyteBannerNonFloating"),
			returnValue;
			if(show){
				returnValue = this.onBeforeShow();
				if(returnValue == false){
					if(change && this.isCheckedLbound()){
						this.setData( 'handleLbind', true );
						this.data.ltPropShow = false;
					}
					else{
						this.setData("returnFalse",true);
						this.setData('ltPropShow',false);
					}
					return;
				}
				this.showBanner(banner);
			}
			else if(change && change.item === "ltPropShow"){ //to prevent closeCallback on didConnect
				returnValue = this.onBeforeClose();
				if(returnValue == false){
					if(this.isCheckedLbound()){
						this.setData( 'handleLbind', true );
						this.data.ltPropShow = true;
					}
					else{
						this.setData("returnFalse",true);
						this.setData('ltPropShow',true);
					}
					return;
				}
				this.closeBanner(banner);
			}
		}
	}.observes('ltPropShow','ltPropFloating').on("didConnect")
	
});
/**
 * @syntax yielded 
 *	<lyte-banner>
 * 		<template is = "registerYield" yield-name = "yield">
 *       	<div>
 *				Example Banner
 *         	</div>
 *   	</template>
 *	</lyte-banner>
 */

if(!_LyteDrawer_){
	var _LyteDrawer_ =  [];
}
Lyte.Component.register("lyte-drawer", {
_template:"<template tag-name=\"lyte-drawer\"> <template is=\"if\" value=\"{{expHandlers(ltPropLayout,'==',&quot;modal&quot;)}}\"><template case=\"true\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-modal lt-prop=\"{{stringify(ltPropModal)}}\" lt-prop-allow-multiple=\"true\" lt-prop-show-close-button=\"false\" lt-prop-close-on-escape=\"false\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-wrapper-class=\"{{ltPropWrapperClass}}\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-freeze=\"{{ltPropFreeze}}\" on-before-show=\"{{method(&quot;modalOnBeforeShow&quot;)}}\" on-show=\"{{method(&quot;modalOnShow&quot;)}}\" on-close=\"{{method(&quot;modalOnClose&quot;)}}\" on-before-close=\"{{method(&quot;modalOnBeforeClose&quot;)}}\"> <template is=\"registerYield\" yield-name=\"modal\"> <lyte-modal-content onclick=\"{{action(&quot;selectedItem&quot;,event,&quot;modal&quot;)}}\"> <lyte-yield yield-name=\"drawerPanel\"></lyte-yield> </lyte-modal-content> </template> </lyte-modal> </template><template case=\"false\"> <lyte-modal lt-prop=\"{{stringify(ltPropModal)}}\" lt-prop-allow-multiple=\"true\" lt-prop-show-close-button=\"false\" lt-prop-close-on-escape=\"false\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-wrapper-class=\"{{{{ltPropWrapperClass}}}}\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-freeze=\"{{ltPropFreeze}}\" on-before-show=\"{{method(&quot;modalOnBeforeShow&quot;)}}\" on-show=\"{{method(&quot;modalOnShow&quot;)}}\" on-close=\"{{method(&quot;modalOnClose&quot;)}}\" on-before-close=\"{{method(&quot;modalOnBeforeClose&quot;)}}\"> <template is=\"registerYield\" yield-name=\"modal\"> <lyte-modal-content onclick=\"{{action(&quot;selectedItem&quot;,event,&quot;modal&quot;)}}\"> <lyte-drawer-body> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"index\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\"> <lyte-drawer-group> <lyte-drawer-label> {{lyteUiReturnOnlyKey(item)}} </lyte-drawer-label> <template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteUiReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\"> <template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\"> <lyte-drawer-item data-value=\"{{subitem[ltPropSystemValue]}}\"> {{subitem[ltPropUserValue]}} </lyte-drawer-item> </template><template case=\"false\"> <lyte-drawer-item data-value=\"{{subitem}}\"> {{subitem}} </lyte-drawer-item> </template></template></template> </lyte-drawer-group> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\"> <lyte-drawer-item data-value=\"{{item[ltPropSystemValue]}}\"> {{item[ltPropUserValue]}} </lyte-drawer-item> </template><template case=\"false\"> <lyte-drawer-item data-value=\"{{item}}\"> {{item}} </lyte-drawer-item> </template></template></template></template></template> </lyte-drawer-body> </lyte-modal-content> </template> </lyte-modal> </template></template> </template><template case=\"false\"> <div class=\"lyteDrawerInlineBody {{if(ltPropShow,'drawerPanelShown','drawerPanelHidden')}}\" style=\"height:{{ltPropHeight}};\"> <div class=\"lyteDrawerPanel\" onclick=\"{{action(&quot;selectedItem&quot;,event,&quot;inline&quot;)}}\" style=\"width:{{ltPropWidth}};\"> <div class=\"drawerWrapper {{ltPropWrapperClass}}\"> <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"drawerPanel\"> </lyte-yield> </template><template case=\"false\"> <lyte-drawer-body> <template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"index\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\"> <lyte-drawer-group> <lyte-drawer-label> {{lyteUiReturnOnlyKey(item)}} </lyte-drawer-label> <template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteUiReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\"> <template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\"> <lyte-drawer-item data-value=\"{{subitem[ltPropSystemValue]}}\"> {{subitem[ltPropUserValue]}} </lyte-drawer-item> </template><template case=\"false\"> <lyte-drawer-item data-value=\"{{subitem}}\"> {{subitem}} </lyte-drawer-item> </template></template></template> </lyte-drawer-group> </template><template case=\"false\"><template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\"> <lyte-drawer-item data-value=\"{{item[ltPropSystemValue]}}\"> {{item[ltPropUserValue]}} </lyte-drawer-item> </template><template case=\"false\"> <lyte-drawer-item data-value=\"{{item}}\"> {{item}} </lyte-drawer-item> </template></template></template></template></template> </lyte-drawer-body> </template></template> </div> </div> <div class=\"lyteDrawerContent\"> <lyte-yield yield-name=\"drawerContent\"> </lyte-yield> </div> <template is=\"if\" value=\"{{expHandlers(ltPropShow,'&amp;&amp;',ltPropFreeze)}}\"><template case=\"true\"> <lyte-drawer-freeze style=\"{{currentPosition}}:{{ltPropWidth}};\"></lyte-drawer-freeze> </template></template> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'height:'","ltPropHeight","';'"]}}}},{"type":"attr","position":[1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'width:'","ltPropWidth","';'"]}}}},{"type":"attr","position":[1,1,1]},{"type":"attr","position":[1,1,1,1]},{"type":"if","position":[1,1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"insertYield","position":[1,3,1]},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["''","currentPosition","':'","ltPropWidth","';'"]}}}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropPosition","ltPropWidth","ltPropHeight","ltPropModal","ltPropFreeze","ltPropAnimationseconds","ltPropMiniVariant","ltPropUserValue","ltPropSystemValue","ltPropOptions","ltPropShow","ltPropSelectedClass","ltPropSelected","ltPropCloseOnSelect","ltPropCloseOnOutsideClick","ltPropDisableOptions","ltPropWrapperClass","ltPropLayout","ltPropDisplayType","ltPropYield","marginProperty","returnedFalse","currentPosition"],
	data : function(){
		return {
			ltPropPosition:Lyte.attr("string",{"default":"left"}),
			ltPropWidth:Lyte.attr("string",{"default":"200px"}),
			ltPropHeight:Lyte.attr("string",{"default":"100%"}),
			ltPropModal:Lyte.attr("object",{"default":{}}),
			ltPropFreeze:Lyte.attr("boolean",{"default":true}),
			ltPropAnimationseconds:Lyte.attr("string",{"default":"1"}),
			ltPropMiniVariant:Lyte.attr("boolean",{"default":true}),
			ltPropUserValue: Lyte.attr("string",{default:"name"}),
			ltPropSystemValue:Lyte.attr("string",{default:"value"}),
			ltPropOptions:Lyte.attr("array",{default:[]}),
			ltPropShow:Lyte.attr("boolean",{"default":false}),
			ltPropSelectedClass:Lyte.attr("string"),
			ltPropSelected:Lyte.attr("string"),
			ltPropCloseOnSelect:Lyte.attr("boolean",{"default":false}),
			ltPropCloseOnOutsideClick : Lyte.attr("boolean",{"default":true}),
			ltPropDisableOptions:Lyte.attr("array",{"default":[]}),
			ltPropWrapperClass:Lyte.attr("string"),
			// visibleState:Lyte.attr("boolean",{default:true}),
			ltPropLayout:Lyte.attr("string",{"default":"modal"}),
			ltPropDisplayType:Lyte.attr("string",{"default":"displace"}),
			ltPropYield:Lyte.attr("boolean",{default:false}),

			marginProperty:Lyte.attr("string",{"default":"marginLeft"}),
			returnedFalse : Lyte.attr("boolean",{"default" : false}),
			currentPosition : Lyte.attr("string")
		}		
	},
	methods:{
		modalOnBeforeShow:function(component){
			var position = this.$node.ltProp("position"),
			type = this.$node.ltProp("type"),
			offset = component.$node.ltProp("offset");
			var lyteDrawerBody = component.actualModalDiv.querySelector("lyte-drawer-body");
			// for(var i = 0 ; i<LytePopup.components.length; i++){
			// 	var parent = LytePopup.components[i].$node.parentElement;
			// 	if(parent && parent.tagName == "LYTE-DRAWER" && parent.component.getData("visibleState")){
			// 		parent.component.setData("visibleState",false);
			// 		break;
			// 	}
			// }
			if(position == "bottom"){
				var height = this.$node.ltProp("height");
				if(height == "100%"){
					this.$node.ltProp("height",component.actualModalDiv.querySelector("lyte-yield").getBoundingClientRect().height+"px");
				}
				height = this.$node.ltProp("height");
				var tempHeight = (height.indexOf('px') >= 0)?parseInt(height):(parseInt(height)/100)*window.innerHeight;
				if(tempHeight > window.innerHeight/2){
					this.$node.ltProp("height",window.innerHeight/2+"px");
				}
				this.$node.ltProp("width","100%");
			}
			else{
				this.$node.ltProp("height","100%");
				var width = this.$node.ltProp("width");
				if(width == "100%"){
					this.$node.ltProp("width","200px");
				}
			}
			if(lyteDrawerBody){
				var comp = this,
				tempHeight = this.$node.ltProp("height");
				tempHeight = (tempHeight.indexOf('px') >= 0)?parseInt(tempHeight):(parseInt(tempHeight)/100)*window.innerHeight;
				if(!isNaN(parseInt(offset.top))){
					tempHeight = (tempHeight - parseInt(offset.top));
				}
				lyteDrawerBody.style.height = tempHeight+"px";
				lyteDrawerBody.addEventListener("scroll",function(event){
					comp.scrollEvent(event);
				},true);
			}
			// if(type == "permanent"){
			// 	this.$node.ltProp("freeze",false);
			// }
			// else{
			// 	this.$node.ltProp("freeze",true);
			// }
			if(this.getMethods("onBeforeShow")){
				return this.executeMethod("onBeforeShow",this) ; 
			}
		},
		modalOnShow:function(component){
			_LyteDrawer_.push(this.$node);
			var lyteContent = component.actualModalDiv.querySelector("lyte-modal-content");
			component.actualModalDiv.parentElement.style.overflow = "hidden";
			lyteContent.style["overflow-y"] = "hidden";
			lyteContent.style.padding = "0px 0px";
			this.selectedOptionOperation();
			this.disableOnoptionsOperation();
			//var freezeLayer = component.childComp.querySelector("lyte-modal-freeze");
			// if(freezeLayer){
			// 	freezeLayer.addEventListener("click",function(){
			// 		for(var i = LytePopup.components.length -1 ; i>=0; i--){
			// 			if(LytePopup.components[i].$node.tagName == "LYTE-MODAL" && LytePopup.components[i].childComp.style.visibility == "visible"){
			// 				var popover = LytePopup.components[i].$node;
			// 				var parent = popover.parentElement;
			// 				if(parent && parent.tagName == "LYTE-DRAWER" && parent.ltProp('show') && parent.ltProp("CloseOnOutsideClick")){
			// 					parent.ltProp('show',false);
			// 					break;
			// 				}
			// 			}
			// 		}
			// 		console.log(this);
			// 	});
			// }
			if(this.getMethods("onShow")){
				return this.executeMethod("onShow",this) ; 
			}
		},
		modalOnBeforeClose:function(event,component){
			if(this.getMethods("onBeforeClose")){
				return this.executeMethod("onBeforeClose",this) ; 
			}
		},
		modalOnClose:function(component){
			_LyteDrawer_.pop();
			setTimeout(function(){
				component.$node.ltProp('reRenderModal',true);
			},500);
			if(this.getMethods("onClose")){
				return this.executeMethod("onClose",this) ; 
			}
		}
	},
	didConnect:function(){
		var lyteDrawerBody = this.$node.querySelector("lyte-drawer-body"),comp = this,layout=this.$node.ltProp("layout");
		if(lyteDrawerBody&&(layout == "inline")){
			lyteDrawerBody.addEventListener("scroll",function(event){
				comp.scrollEvent(event);
			},true);
		}
		// var drawer = this.$node,
		// layout = this.$node.ltProp("layout");
		// var yield = drawer.querySelectorAll("lyte-yield"),temp;
		// if(layout == "modal"){
		// 	// temp = yield[0].getAttribute("yield-name");
		// 	if(!yield.length){
		// 		this.setData("noyield",true);
		// 	}
		// 	else{
		// 		this.setData("noyield",false);
		// 	}
		// }
		// else{
		// 	temp = yield[1].getAttribute("yield-name");
		// 	if(yield == "yield"){
		// 		this.setData("noyield",false);
		// 	}
		// 	else{
		// 		this.setData("noyield",true);
		// 	}
		// }
		// if (document.readyState === "complete" || document.readyState === "interactive"){
		// 	addPopoverEvent();
		// }
		// else{
		// 	document.addEventListener("DOMContentLoaded", function(event){
		// 		addPopoverEvent(event);
		// 	});
		// }
	},
	didDestory:function(){
		//remove documnet event listener
	},
	actions:{
		selectedItem:function(event,type){
			var target= event.target;
			if(target.tagName == "LYTE-DRAWER-ITEM" && !target.classList.contains('lyteDrawerDisabledItem')){
				var value = target.getAttribute("data-value");
				this.$node.ltProp("selected",value);
			}
		}
	},
	selectedOptionOperation : function(changes){
		var Class = this.$node.ltProp("SelectedClass"),
		close = this.$node.ltProp("CloseOnSelect"),
		layout = this.$node.ltProp("layout"),
		selected = this.$node.ltProp("selected"),previous,parent,target;
		if(layout == "inline"){
			parent =this.$node.querySelector(".lyteDrawerPanel");
		}
		else{
			parent = this.$node.querySelector("lyte-modal").component.actualModalDiv;
		}
		if(parent && parent.querySelectorAll("lyte-drawer-item")){
			previous = parent.querySelector(".lyteDrawerActiveItem");
			if(selected){
				target = parent.querySelector("[data-value ='"+window._lyteUiUtils.escape(selected)+"']")
			}
			if(previous){
				//previous.setAttribute("class","");
				previous.classList.remove("lyteDrawerActiveItem");
				if(Class){
					previous.classList.remove(Class);
				}
			}
			if(target){
				target.classList.add("lyteDrawerActiveItem");
				if(Class){
					//target.setAttribute("class","active "+Class);
					target.classList.add(Class);
				}
				if(changes){
					if(this.getMethods("onSelected")){
						this.executeMethod("onSelected",selected,target,this) ; 
					}
					if(close){
						this.$node.ltProp("show",false);
					}
				}
			}
		}
	},
	selectedoption : function(changes){
		this.selectedOptionOperation(changes);
	}.observes("ltPropSelected"),
	disableOnoptionsOperation : function(){
		var array = this.getData("ltPropDisableOptions");
		var disabledlist,layout = this.$node.ltProp("layout"),parent;
		if(layout == "inline"){
			parent = this.$node.querySelector(".lyteDrawerPanel");
		}
		else{
			parent = this.$node.querySelector("lyte-modal").component.actualModalDiv;
		}
		if(parent && parent.querySelectorAll("lyte-drawer-item")){
			disabledlist = parent.querySelectorAll(".lyteDrawerDisabledItem")
			for(var index = 0 ; index<disabledlist.length;index++){
				disabledlist[index].classList.remove("lyteDrawerDisabledItem");
				//disabledlist[index].setAttribute("class","");
			}
			for(var index = 0 ; index<array.length;index++){
				var item = parent.querySelector("[data-value ='"+window._lyteUiUtils.escape(array[index])+"']");
				if(item){
					item.classList.add("lyteDrawerDisabledItem");
				}
			}
		}
	},
	disableOnoptions:function(){
		this.disableOnoptionsOperation();
	}.observes("ltPropDisableOptions"),
	showChanges:function(){
		var  show  = this.$node.ltProp("show");
		var panel = this.$node.querySelector('.lyteDrawerPanel'),
		layout = this.$node.ltProp("layout");
		panel = $L(panel);
		var position = this.$node.ltProp("position"),
		rtl = _lyteUiUtils.getRTL(),
		seconds =  this.$node.ltProp("animationseconds"),
		component = this.$node.querySelector("lyte-modal"),
		margin = this.getData('marginProperty'),
		displayType = this.$node.ltProp("displayType"),
		panelWidth = this.$node.ltProp("width"),
		tempPosition,result;
		if(this.getData('returnedFalse')){
            this.setData('returnedFalse',false);
            return;
        }
		if(show){
			if(rtl){
				tempPosition = (position == "right")?"left":(position == "left")?"right":"bottom";
			}
			else{
				tempPosition  = position;
			}
			this.setData("currentPosition",tempPosition);
			if(layout == "modal"){
				var offset  = component.ltProp("offset");
				if(tempPosition == "left"){
					component.ltProp("transition",{"animation":"slideFromLeft","duration":seconds});
					offset.left = "0px";
					component.ltProp("offset",offset);
				}
				else if(tempPosition == "right"){
					component.ltProp("transition",{"animation":"slideFromRight","duration":seconds});
					offset.right = "0px";
					component.ltProp("offset",offset);
				}
				else if(position == "bottom"){
					component.ltProp("transition",{"animation":"slideFromBottom","duration":seconds});
					offset.bottom = "0px";
					component.ltProp("offset",offset);
				}
				component.ltProp("show",true);
			}
			else if(layout == "inline"){
				var parent = this.$node.querySelector(".lyteDrawerInlineBody");
				if(tempPosition == "left"){
                    $L(parent).removeClass('lyteDrawerPanelRight').addClass('lyteDrawerPanelLeft');
					this.setData("marginProperty","marginLeft");
				}
				else if(tempPosition == "right"){
                    $L(parent).removeClass('lyteDrawerPanelLeft').addClass('lyteDrawerPanelRight');
					this.setData("marginProperty","marginRight");
				}
				//margin = this.getData("marginProperty");
				if(displayType == "overlapping"){
					var childpanel = this.$node.querySelector('.lyteDrawerContent').querySelector(".lyteDrawerPanel");
					if(childpanel){
						var width = childpanel.getBoundingClientRect().width;
						if(width){
							childpanel.style.width = 30+"px";
						}
					}
				}
				if(this.getMethods("onBeforeShow")){
					result = this.executeMethod("onBeforeShow",this) ; 
				}
				if(result === undefined || result){
					// this.selectedOptionOperation();
					// this.disableOnoptionsOperation();
					// panel.css('width', panelWidth);
					// var width =panel[0].getBoundingClientRect().width;
					// panel.css(margin, width+"px");
					// panel[0].removeEventListener("transitionend",this.transitionEnd,true);
					// panel.css('transition', 'margin '+seconds+'s ease');
					// setTimeout(function() {
					// 	panel.css(margin, '0px');
					// }, 50);
					_LyteDrawer_.push(this.$node);
					if(this.getMethods("onShow")){
						this.executeMethod("onShow",this) ; 
					}
				}
				else{
					this.setData("returnedFalse",true);
					this.$node.ltProp("show",false);
				}
			}
		}
		else if(layout == "inline"){
			if(panel[0].getBoundingClientRect().width){
				if(this.getMethods("onBeforeClose")){
					result = this.executeMethod("onBeforeClose",this) ; 
				}
				if(result === undefined || result){
					if(displayType == "overlapping"){
						var content = this.$node.querySelector('.lyteDrawerContent'),
						childcontent = content.querySelector('.lyteDrawerPanel');
						if(childcontent){
							var tempWidth = childcontent.getBoundingClientRect().width;
							if(tempWidth){
								childcontent.style.width = childcontent.parentElement.parentElement.ltProp("width");
							}
						}
					}
					// var width =panel[0].getBoundingClientRect().width;
					// panel.css('transition', 'margin '+seconds+'s ease');
					// panel.css(margin, -width+"px");
					// panel[0].addEventListener('transitionend',this.transitionEnd,true);
					_LyteDrawer_.pop();
					if(this.getMethods("onClose")){
						this.executeMethod("onClose",this) ; 
					}
				}
				else{
					this.setData("returnedFalse",true);
					this.$node.ltProp("show",true);
				}
			}
		}
		else{
			component.ltProp("show",false);
		}
	}.observes("ltPropShow").on('didConnect'),
	widthUpdate:function(change){	
		var layout = this.$node.ltProp("layout"),
		show = this.$node.ltProp("show");
		if(layout == "inline" && show){
			this.$node.querySelector(".lyteDrawerPanel").style.width = change.newValue;
		}
	}.observes("ltPropWidth"),
		// showObserve:function(){
	// 	this.positionChanges();
	// },
	scrollEvent:function(event){
		console.log("drawerbody");
		if(this.getMethods("onScroll")){
			return this.executeMethod("onScroll",this,event) ; 
		}
	},
	transitionEnd:function(){
		var drawerElem = $L(this);
		drawerElem.css('transition', '');
		drawerElem.css('width', 0);
		drawerElem.css('marginLeft', '');
		drawerElem.css('marginRight','');
	}
	// inlineShowChanges:function(){
	// 	var layout = this.$node.ltProp("layout"),
	// 	displayType = this.$node.ltProp("displayType"),
	// 	panelWidth = this.$node.ltProp("width"),
	// 	seconds =  this.$node.ltProp("animationseconds"),
	// 	margin = this.getData('marginProperty');
	// 	if(layout != "modal"){
	// 		var show = this.$node.ltProp("show");
	// 		var panel = this.$node.querySelector('.lyteDrawerPanel');
	// 		panel = $L(panel);
	// 		if(show){
	// 			if(displayType == "overlapping"){
	// 				var childpanel = this.$node.querySelector('.lyteDrawerContent').querySelector(".lyteDrawerPanel");
	// 				var width = childpanel.getBoundingClientRect().width;
	// 				if(width){
	// 					childpanel.style.width = 30+"px";
	// 				}
	// 			}
	// 			this.SelectedOptions();
	// 			this.disableOnoptionsOperation();
	// 			panel.css('width', panelWidth);
	// 			var width =panel[0].getBoundingClientRect().width;
	// 			panel.css(margin, width+"px");
	// 			panel[0].removeEventListener("transitionend",this.transitionEnd,true);
	// 			panel.css('transition', 'margin '+seconds+'s ease');
	// 			setTimeout(function() {
	// 				panel.css(margin, '0px');
	// 			}, 50);
	// 			_LyteDrawer_.push(this.$node);
	// 		}
	// 		else if(panel[0].getBoundingClientRect().width){
	// 			if(displayType == "overlapping"){
	// 				var content = this.$node.querySelector('.lyteDrawerContent'),
	// 				childcontent = content.querySelector('.lyteDrawerPanel'),tempWidth = childcontent.getBoundingClientRect().width;
	// 				if(tempWidth){
	// 					childcontent.style.width = childcontent.parentElement.parentElement.ltProp("width");
	// 				}
	// 			}
	// 			var width =panel[0].getBoundingClientRect().width;
	// 			panel.css('transition', 'margin '+seconds+'s ease');
	// 			panel.css(margin, -width+"px");
	// 			panel[0].addEventListener('transitionend',this.transitionEnd,true);
	// 			_LyteDrawer_.pop();
	// 		}
	// 	}
	// }.observes("ltPropShow").on("didConnect")
});
// Lyte.createCustomElement( "lyte-drawer-group", {
// 	static : {
// 		"observedAttributes": {
// 			get : function() {
// 				return [ 'label' ];
// 			}
// 		}
// 	},
// 	"attributeChangedCallback": function( attr, oldValue, newValue, namespace ) {
// 		var node, value;

// 		if ( attr == 'label' ) {
//             node = this.querySelector('lyte-drawer-label');
//             value = this.getAttribute('label');
//             if ( node ) {
//                 node.textContent = value;
//             } 
//             else {
//                 node = document.createElement('lyte-drawer-label');
//                 node.textContent = value;
//                 this.insertBefore( node, this.children[ 0 ] );
//             }
//         }
// 	}
// } );
// Lyte.createCustomElement( "lyte-drawer-item", {
// 	static : {
// 		"observedAttributes" : {
// 			get : function() {
// 				return [ 'selected' ];
// 			}
// 		}
// 	},
// 	"attributeChangedCallback": function( attr, oldValue, newValue, namespace ) {
// 		// var node, value;

// 		// if ( attr == 'label' ) {
//         //     node = this.querySelector('lyte-drawer-label');
//         //     value = this.getAttribute('label');
//         //     if ( node ) {
//         //         node.textContent = value;
//         //     } 
//         //     else {
//         //         node = document.createElement('lyte-drop-label');
//         //         node.textContent = value;
//         //         this.insertBefore( node, this.children[ 0 ] );
//         //     }
//         // }
// 	}
// } );
if (document.readyState === "complete" || document.readyState === "interactive"){
    addCloseEvent();
}
else{
    document.addEventListener("DOMContentLoaded", function(event){
        addCloseEvent(event);
    });
}
function  addCloseEvent(event){

	document.addEventListener('click',function(event){
		var ele = event.target;
		while( ele.tagName != "LYTE-DRAWER-BODY" && ele.tagName !="LYTE-DRAWER-FREEZE" && ele.tagName != "LYTE-MODAL-FREEZE" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){
            ele = ele.parentElement;
            if(!ele){
                return
            }
        }
		if(ele.tagName == 'HTML' || ele.tagName == "LYTE-MODAL-FREEZE" || ele.tagName == "LYTE-DRAWER-FREEZE"){
			// for(var i = _LyteDrawer_.length -1 ; i>=0; i--){
			var last = _LyteDrawer_.length-1;
			if(last > -1){
				if(_LyteDrawer_[last].tagName == "LYTE-DRAWER" && _LyteDrawer_[last].ltProp('show') && _LyteDrawer_[last].ltProp("CloseOnOutsideClick")){
					setTimeout(function(){
						if(_LyteDrawer_[last]){
							_LyteDrawer_[last].ltProp('show',false);
						}
					},0);
				}
			}
			// }
		}
	},true);
	document.addEventListener('keydown',function(event){
			event = event || window.event;
            var isEscape = false;
            if ("key" in event) {
                isEscape = (event.key == "Escape" || event.key == "Esc");
            } else {
                isEscape = (event.keyCode == 27);
            }
            if (isEscape) {
				var last = _LyteDrawer_.length-1;
				if(last > -1){
                // for(var i = _LyteDrawer_.length -1 ; i>=0; i--){
					if(_LyteDrawer_[last].tagName == "LYTE-DRAWER" && _LyteDrawer_[last].ltProp('show') && _LyteDrawer_[last].ltProp("CloseOnOutsideClick")){
						setTimeout(function(){
							if(_LyteDrawer_[last]){
								_LyteDrawer_[last].ltProp('show',false);
							}
						},0);
					}
				}
            }
	},true);
}
/**
 * Renders an avatar navigator
 * @component lyte-avatar-navigator
 * @version 3.6.0
 * @methods onSelect, onPrevious, onNext
 */


Lyte.Component.register( 'lyte-avatar-navigator', {
_template:"<template tag-name=\"lyte-avatar-navigator\"> <template is=\"if\" value=\"{{showLeftArrow}}\"><template case=\"true\"> <div class=\"lyteAvatarArrowCont\" onclick=\"{{action('navigatePrevious')}}\"> <template is=\"if\" value=\"{{ltPropIconYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"previousIconYield\"></lyte-yield> </template><template case=\"false\"> <span class=\"{{ltPropPreviousIconClass}}\"></span> </template></template> </div> </template></template> <div class=\"lyteAvatarSetCont\" style=\"height:{{imageHeight}};\" onclick=\"{{action('selectItem',event)}}\"> <template is=\"for\" items=\"{{blocks}}\" item=\"block\" index=\"blockIndex\"> <div class=\"{{block.class}}\" style=\"transform: translate({{concat(block.translate,'px')}});\" ontransitionend=\"{{action('removeClass',event,block)}}\"> <template is=\"for\" items=\"{{block.images}}\" item=\"imageObj\" index=\"imageIndex\"> <template is=\"if\" value=\"{{ltPropAvatarYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"avatarYield\" lyte-image=\"{{imageObj}}\"></lyte-yield> </template><template case=\"false\"> <lyte-avatar-navigator-item lt-prop-image=\"{{imageObj}}\"></lyte-avatar-navigator-item> </template></template> </template> </div> </template> <template is=\"if\" value=\"{{renderDummyImage}}\"><template case=\"true\"> <div class=\"lyteAvatarSet\"> <template is=\"if\" value=\"{{ltPropAvatarYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"avatarYield\" lyte-image=\"{{dummyImage}}\"></lyte-yield> </template><template case=\"false\"> <lyte-avatar-navigator-item lt-prop-image=\"{{dummyImage}}\"></lyte-avatar-navigator-item> </template></template> </div> </template></template> </div> <template is=\"if\" value=\"{{showRightArrow}}\"><template case=\"true\"> <div class=\"lyteAvatarArrowCont\" onclick=\"{{action('navigateNext')}}\"> <template is=\"if\" value=\"{{ltPropIconYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"nextIconYield\"></lyte-yield> </template><template case=\"false\"> <span class=\"{{ltPropNextIconClass}}\"></span> </template></template> </div> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'height:'","imageHeight","';'"]}}}},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'transform: translate('",{"type":"helper","value":{"name":"concat","args":["block.translate","'px'"]}},"');'"]}}}},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}]},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropImages","ltPropUrlValue","ltPropAvatarYield","ltPropIconYield","ltPropImageWidth","ltPropSystemValue","ltPropSelected","ltPropSelectedClass","ltPropPreviousIconClass","ltPropNextIconClass","ltPropAltValue","ltPropAlt","ltPropCyclic","ltPropDisabledList","ltPropTooltipValue","ltPropTooltip","ltPropPreload","blocks","imagesPerBlock","displayIndex","imageHeight","isAnimating","rangeSet","showLeftArrow","showRightArrow"],
	data: function() {
		return {
			/**
			 * @componentProperty {array} ltPropImages
			 * @default []
			 */

			"ltPropImages": Lyte.attr( 'array', { 'default': [] } ),

			/**
			 * @componentProperty {string} ltPropUrlValue
			 * @default image
			 */

			"ltPropUrlValue": Lyte.attr( 'string', { 'default': 'image' } ),

			/**
			 * @componentProperty {boolean} ltPropAvatarYield
			 * @default false
			 */

			"ltPropAvatarYield": Lyte.attr( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {boolean} ltPropIconYield
			 * @default false
			 */

			"ltPropIconYield": Lyte.attr( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {string} ltPropImageWidth=0px
			 */

			"ltPropImageWidth": Lyte.attr( 'string', { 'default': '0px' } ),

			/**
			 * @componentProperty {string} ltPropSystemValue=value
			 */

			"ltPropSystemValue": Lyte.attr( 'string', { 'default': 'value' } ),

			/**
			 * @componentProperty {object} ltPropSelected={}
			 */


			"ltPropSelected": Lyte.attr( 'object', { 'default': {} } ),

			/**
			 * @componentProperty {string} ltPropSelectedClass
			 * @default lyteAvatarSelectedItem
			 */

			"ltPropSelectedClass": Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'selectedClass', 'lyteAvatarSelectedItem' ) } ),

			/**
			 * @componentProperty {string} ltPropPreviousIconClass
			 * @default lyteAvatarPrevIcon
			 */

			"ltPropPreviousIconClass": Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'previousIconClass', 'lyteAvatarPrevIcon' ) } ),

			/**
			 * @componentProperty {string} ltPropNextIconClass
			 * @default lyteAvatarNextIcon
			 */

			"ltPropNextIconClass": Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'nextIconClass', 'lyteAvatarNextIcon' ) } ),

			/**
			 * @componentProperty {string} ltPropAltValue
			 */

			"ltPropAltValue": Lyte.attr( 'string', { 'default': '' } ),

			/**
			 * @componentProperty {string} ltPropAlt
			 */

			"ltPropAlt": Lyte.attr( 'string', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'alt', '' ) } ),

			/**
			 * @componentProperty {boolean} ltPropIconYield
			 * @default false
			 */


			"ltPropCyclic": Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'cyclic', true ) } ),

			/**
			 * @componentProperty {array} ltPropImages
			 * @default []
			 */

			"ltPropDisabledList": Lyte.attr( 'array', { 'default': [] } ),

			/**
			 * @componentProperty {string} ltPropTooltipValue
			 */

			"ltPropTooltipValue": Lyte.attr( 'string', { 'default': '' } ),

			/**
			 * @typedef {object} tooltip
			 * @property {top|left|bottom|right} tooltip=bottom
			 * @property {box|callout} appearance=box
			 * @property {number} margin=5
			 * @property {boolean} keeptooltip=true
			 */
			/**
			 * @componentProperty {tooltip} ltPropTooltip
			 */
			
			"ltPropTooltip": Lyte.attr( 'object', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'tooltip', 
				{ 
   					'position': 'bottom', 
   					'appearance': 'box',
   					'margin': 5,
   					'keeptooltip': true 
   				} )  
   			} ),
				/**
				 * @componentProperty {boolean} ltPropPreload=false
				 */
   			"ltPropPreload": Lyte.attr( 'boolean', { 'default': _lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'preload', false ) } ),


			"blocks": Lyte.attr( 'array', { 'default': [] } ),
			"imagesPerBlock": Lyte.attr( 'number', { 'default': 0 } ),
			"displayIndex": Lyte.attr( 'number' ),
			"imageHeight": Lyte.attr( 'string', { 'default': 0 } ),
			"isAnimating": Lyte.attr( 'boolean', { 'default': false } ),
			"rangeSet": Lyte.attr( 'array', { 'default': [] } ),
			"showLeftArrow": Lyte.attr( 'boolean', { 'default': true } ),
			"showRightArrow": Lyte.attr( 'boolean', { 'default': true } )
		}
	},

	isRTL: function() {
		return _lyteUiUtils.getRTL();
	},

	didDestroy: function() {
		delete this.prevCurBlock;
	},

	getImageWidth: function() {
		var imageWidth = this.getData( 'ltPropImageWidth' );

		return window.parseFloat( imageWidth || 0 );
	},

	init: function() {
		var that = this;

		this.$node.reset = function() {
			var displayIndex, block, imagesPerBlock, images = that.getData( 'ltPropImages' );

			that.animationQueue = [];
			that.setData( 'blocks', [] );
			that.setData( 'rangeSet', [] );
			that.deleteOtherBlocks = false;
			that.curCount = that.totalCount = 0;
			that.setData( 'isAnimating', false );
			that.preventObs = false;
			delete that.prevCurBlock;

			that.setImageDimensions();
			that.setImagesPerBlock();
			displayIndex = that.getData( 'displayIndex' );
			imagesPerBlock = that.getData( 'imagesPerBlock' )

			if( displayIndex + imagesPerBlock > images.length ) {
				displayIndex = images.length - imagesPerBlock;

				if( displayIndex < 0 ) {
					displayIndex = 0;
				}

				that.setData( 'displayIndex', displayIndex );
			}

			that.setContainerWidth();
			block = that.buildImageBlock( displayIndex );
			Lyte.objectUtils( block, 'add', 'translate', 0 );
			that.preloadImages();
		}
	},

	didConnect: function() {
		this.animationQueue = [];
		this.setup();
		this.setSelectedIndex();
	},

	setup: function() {
		var displayIndex, block;

		if( !this.isEmpty() ) {
			this.setImageDataType();
			this.setImageDimensions();
			this.setImagesPerBlock();
			displayIndex = this.setDisplayIndex();
			this.setContainerWidth();
			block = this.buildImageBlock( displayIndex );
			Lyte.objectUtils( block, 'add', 'translate', 0 );
			this.preloadImages();
		}
	},

	toggleNavigationObserver: function() {
		this.toggleNavigation();
	}.observes( 'displayIndex' ),

	toggleNavigation: function() {
		var images = this.getData( 'ltPropImages' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ), shouldEnable,
		cyclic = this.getData( 'ltPropCyclic' ),
		length = images.length,
		displayIndex = this.getData( 'displayIndex' );

		shouldEnable = imagesPerBlock < images.length;

		this.setData( 'showLeftArrow', shouldEnable );
		this.setData( 'showRightArrow', shouldEnable );	

		if( !cyclic && shouldEnable ) {
			if( displayIndex === 0 ) {
				this.setData( 'showLeftArrow', false );
				this.setData( 'showRightArrow', true );
			}
			else if( displayIndex === length - imagesPerBlock ) {
				this.setData( 'showLeftArrow', true );
				this.setData( 'showRightArrow', false );
			}
		}
	},

	isEmpty: function() {
		var images = this.getData( 'ltPropImages' ) || [];

		return images.length === 0;
	},

	setImageDataType: function() {
		var images = this.getData( 'ltPropImages' );

		if( typeof images[ 0 ] === 'string' ) {
			this.setData( 'isString', true );
		}
		else {
			this.setData( 'isString', false );
		}
	},

	setImageDimensions: function() {
		var imageWidth = this.getImageWidth(), item;

		this.setDummyImage();
		item = this.$node.querySelector( 'lyte-avatar-navigator-item' );

		if( imageWidth === 0 ) {
			this.setData( 'ltPropImageWidth', $L( item ).outerWidth( true ) + 'px' );
		}
		
		this.setData( 'imageHeight', $L( item ).outerHeight( true ) + 'px' );
		this.removeDummyImage();
	},

	setDummyImage: function() {
		var images = this.getData( 'ltPropImages' ),
		image = images[ 0 ];

		this.setData( 'dummyImage', image );
		this.setData( 'renderDummyImage', true );
	},

	removeDummyImage: function() {
		this.setData( 'renderDummyImage', false );
	},

	setImagesPerBlock: function() {
		var imageWidth = this.getImageWidth(),
		containerWidth = this.getContainerWidth(), count;

		count = Math.floor( containerWidth / imageWidth );

		this.setData( 'imagesPerBlock', count );
	},

	getContainerWidth: function() {
		var container;

		container = this.getContainer();
		container.style.flex = '1';
		var width = container.getBoundingClientRect().width;
		container.style.flex = 'none';

		return window.parseFloat( width );
	},

	getContainer: function() {
		return this.$node.querySelector( '.lyteAvatarSetCont' );
	},

	setContainerWidth: function() {
		var count = this.getData( 'imagesPerBlock' ),
		imageWidth = this.getImageWidth(),
		container = this.getContainer(),
		roundedWidth;

		roundedWidth = count * imageWidth;
		this.setData( 'ltPropContainerWidth', roundedWidth + 'px' );
		container.style.width = roundedWidth + 'px';
	},

	buildImageBlock: function( index ) {
		if( !this.doesBlockExist( index ) ) {
			return this.createblock( index );
		}
		else {
			return this.getBlock( index );
		}
	},

	doesBlockExist: function( index ) {
		return !!this.getBlock( index );
	},

	getBlock: function( index ) {
		var blocks = this.getData( 'blocks' );

		index = !isNaN( index ) ? index : this.getData( 'displayIndex' );

		for( var i = 0; i < blocks.length; i++ ) {
			if( this.indexInBlock( blocks[ i ], index ) ) {
				return blocks[ i ];
			}
		}
	},

	createblock: function( index, isDisconnected, endIndex ) {
		var images = this.getData( 'ltPropImages' ), rangeInfo, block = {}, arr = [], ret;

		index = !isNaN( index ) ? index : this.getData( 'displayIndex' )

		rangeInfo = this.getRange( index );
		block.startIndex = rangeInfo.startIndex;
		block.endIndex = !isNaN( endIndex ) ? endIndex :rangeInfo.endIndex

		while( index <= block.endIndex ) {
			ret = this.buildImageObject( images[ index ], index );
			arr.push( ret );
			index++;
		}

		block.images = arr;
		block.endIndex = index - 1;
		// block.translate = 0;
		block.class = 'lyteAvatarSet';

		if( !isDisconnected ) {
			this.addNodeToCircularList( block );
		}

		Lyte.arrayUtils( this.getData( 'blocks' ), 'push', block );

		return block;
	},

	getRange: function( start ) {
		var end;

		end = this.getEndIndex( start );

		return {
			startIndex: start,
			endIndex: end
		}
	},

	collapseSet: function() {
		var rangeSet = this.getData( 'rangeSet' );

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( rangeSet[ i + 1 ] && rangeSet[ i ][ 1 ] + 1 === rangeSet[ i + 1 ][ 0 ] ) {
				rangeSet[ i ][ 1 ] = rangeSet[ i + 1 ][ 1 ];
				rangeSet.splice( i + 1, 1 );
				i--;
			}
		}
	},

	createDisconnectedBlock: function( index ) {
		return this.createblock( index, true );
	},

	buildImageObject: function( image, index ) {
		var isString = this.getData( 'isString' ),
		urlValue = this.getData( 'ltPropUrlValue' ),
		systemValue = this.getData( 'ltPropSystemValue' ),
		alt = this.getData( 'ltPropAlt' ),
		tooltipValue = this.getData( 'ltPropTooltipValue' ),
		obj = {};

		if( isString ) {
			obj[ urlValue ] = image;
			obj[ systemValue ] = image;
			obj[ this.getAltValue() ] = alt || '';
			obj.id = image;
		}
		else {
			obj[ urlValue ] = image[ urlValue ];
			obj[ systemValue ] = image[ systemValue ];
			obj[ this.getAltValue() ] = this.getData( 'altValue' ) ? image[ this.getData( 'altValue' ) ] : ( alt || '' );
			obj.id = image[ systemValue ];
		}

		obj.disabled = this.isDisabled( image );
		obj._originalObj = image;
		obj.isSelected = obj[ systemValue ] === this.getSelectedValue();

		if( tooltipValue ) {
			obj[ tooltipValue ] = image[ tooltipValue ];
		}

		return obj;
	},

	isDisabled: function( image ) {
		var systemValue = this.getData( 'ltPropSystemValue' ),
		disabledList = this.getData( 'ltPropDisabledList' );

		for( var i = 0; i < disabledList.length; i++ ) {
			if( image[ systemValue ] === disabledList[ i ][ systemValue ] ) {
				return true;
			}
		}

		return false;
	},

	getAltValue: function() {
		var altValue = this.getData( 'ltPropAltValue' );

		return altValue || 'alt';
	},

	getSelectedValue: function() {
		var selected = this.getData( 'ltPropSelected' ),
		systemValue = this.getData( 'ltPropSystemValue' );

		if( selected ) {
			return selected[ systemValue ];
		}

		return '';
	},

	addNodeToCircularList: function( block ) {
		var index, images = this.getData( 'ltPropImages' );

		index = block.startIndex - 1;

		if( index < 0 ) {
			index = images.length - 1;
		}

		var previous = this.getBlock( index );

		index = block.endIndex + 1;

		if( index >= images.length ) {
			index = 0;
		}

		var next = this.getBlock( index );

		if( previous ) {
			previous.next = block;
			block.previous = previous;
		}

		if( next ) {
			next.previous = block;
			block.next = next;
		}
	},

	setDisplayIndex: function() {
		var sel = this.getData( 'ltPropSelected' ),
		images = this.getData( 'ltPropImages' ),
		systemValue = this.getData( 'ltPropSystemValue' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		index;

		if( $L.isEmptyObject( sel ) ) {
			this.setData( 'displayIndex', 0 );

			return 0;
		}

		if( images.length <= imagesPerBlock ) {
			this.setData( 'displayIndex', 0 );

			return 0;
		}

		for( var i = 0; i < images.length; i++ ) {
			if( images[ i ][ systemValue ] === sel[ systemValue ] ) {
				break;
			}
		}

		index = i - Math.floor( imagesPerBlock / 2 );

		if( index < 0 ) {
			index = 0;
		}
		else if( index + imagesPerBlock > images.length ) {
			index = images.length - imagesPerBlock;
		}

		this.setData( 'displayIndex', index );

		return index;
	},

	// getSelectedNavItem: function( block ) { // this func is not used
	// 	var sel = this.getData( 'ltPropSelected' ),
	// 	systemValue = this.getData( 'ltPropSystemValue' ), node, id, that = this;

	// 	if( $L.isEmptyObject( sel ) ) {
	// 		return ;
	// 	}

	// 	for( var i = 0; i < block.length; i++ ) {
	// 		if( block[ i ][ systemValue ] === sel[ systemValue ] ) {
	// 			break;
	// 		}
	// 	}

	// 	if( !block[ i ] ) {
	// 		return ;
	// 	}

	// 	id = block[ i ].id;
	// 	node = $L( '[data-image-id="' + id + '"]' ).filter( function( index, item ) {
	// 		return item !== that.selectedNavItem;
	// 	} ).get( 0 );

	// 	return node;
	// },

	getPreviousIndex: function( index ) {
		var displayIndex = !isNaN( index ) ? index : this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		images = this.getData( 'ltPropImages' ),
		res;

		if( displayIndex === 0 ) {
			res = images.length - imagesPerBlock;
		}
		else if( displayIndex - imagesPerBlock < 0 ) {
			res = 0;
		}
		else {
			res = displayIndex - imagesPerBlock;
		}

		// This is just a safety check. If imagesPerBlock > images.length and currentDisplayIndex = 0. It can become negative.
		if( res < 0 ) {
			res = 0;
		}

		return res;
	},

	getNextIndex: function( index ) {
		var displayIndex = !isNaN( index ) ? index : this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		res, images = this.getData( 'ltPropImages' );

		if( displayIndex + imagesPerBlock === images.length ) {
			res = 0;
		}
		else if( displayIndex + ( 2 * imagesPerBlock ) >= images.length ) {
			res = images.length - imagesPerBlock;
		}
		else {
			res = displayIndex + imagesPerBlock;
		}

		return res;
	},

	getOutBlocks: function( indexOfFirstOutBlock, next, direction, previous ) {
		var block = this.getBlock( indexOfFirstOutBlock ), res = [], imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isLongMove( direction, next, previous ) ) {
			res.push( block );

			while( ( direction === 'previous' && block.startIndex > previous ) || ( direction === 'next' && 
				block.endIndex < ( previous + imagesPerBlock - 1 )
				&& block.endIndex !== this.getData( 'ltPropImages' ).length - 1
			) ) {
				res.push( block = block[ direction ] );
			}
		}
		else {
			if( this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				// remove all blocks
				res = this.getAllBlocks( direction );
				
				return res;
			}
			else {
				while( block && !this.indexInBlock( block, next ) ) {
					res.push( block );
					block = block[ direction ];
				}
			}
		}

		return res;
		
	},

	getAllBlocks: function( direction ) {
		var blocks = this.getData( 'blocks' ),
		asc = direction === 'previous' ? 1 : -1, res;

		res = blocks.slice( 0 );

		res.sort( function( blockA, blockB ) {
			return blockA.startIndex < blockB.startIndex ? asc : ( asc * -1 );
		} );

		return res;
	},

	isBlockMovingOutAndInSimultaneously: function( previous, next, direction ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isMovingAcrossBoundary( next, direction ) ) {
			// think about 5 images with block count of 3 and displayIndex is 2 and next is clicked - displayIndex 2 moves out and back in
			return ( next >= previous && next < previous + imagesPerBlock ) || ( previous >= next && previous < next + imagesPerBlock );
		}
	},

	findInBlock : function(previous, next, direction, block ){ // used to find the inBlocks for preload
		var block = block ?block :this.getBlock( previous ),
		res = [], imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isLongMove( direction, next, previous ) ) {
			return [];
		}
		else {
			if(this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				res.push(block[direction]);
			}
			else{
				if( this.indexInBlock( block, next ) ) {
					res.push( block );
				}
				else{
					res.push( block[direction] );
					block = block[direction];
				}
		
				while( ( ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
					block = this.getNextBlock( block, 'next' );
					res.push( block );
				}
			}
		}
		
		return res;
	},
	
	getInBlocks: function( previous, next, direction ) {
		var block = this.getBlock( previous ),
		res = [], remaining, imagesPerBlock = this.getData( 'imagesPerBlock' ),
		fnName = direction === 'next' ? 'getNextBlock': 'getPreviousBlock';

		// When long moving, a block can already be present so it doesn't have to be created. But what this does is leave some space because the next might be in the middle of the created block
		if( this.isLongMove( direction, next, previous ) ) {
			res.push( block = this.buildImageBlock( next ) );

			while( ( remaining = ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
				block = this.getNextBlock( block, 'next' );
				res.push( block );
			}
		}
		else {
			if( this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				// delete all the other blocks and keep this newly created block
				this.deleteOtherBlocks = true;
				this.setData( 'rangeSet', [] );
				res.push( this.createDisconnectedBlock( next ) );
			}
			else {
				while( !this.indexInBlock( block, next ) ) {
					block = this[ fnName ]( block, direction );
				}

				res.push( block );

				while( ( remaining = ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
					block = this.getNextBlock( block, 'next' );
					res.push( block );
				}
			}
		}

		return res;
		
	},

	isLongMove: function( direction, next, previous ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );

		return ( direction === 'next' && next > previous + imagesPerBlock ) || ( direction === 'previous' &&  next < previous - imagesPerBlock )
	},

	isMovingToFirstIndex: function( next ) {
		return next === 0;
	},

	isMovingToLastIndex: function( next ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		length = this.getData( 'ltPropImages' ).length;

		return next === length - imagesPerBlock;
	},

	getNextBlock: function( block, direction ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		length = this.getData( 'ltPropImages' ).length,
		startIndex;

		if( block[ direction ] ) {
			return block[ direction ];
		}

		if( block.endIndex + 1 >= length ) {
			startIndex = 0;
		}
		else {
			startIndex = block.endIndex + 1;
		}

		return this.buildImageBlock( startIndex );
	},

	getPreviousBlock: function ( block, direction ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ), length = this.getData( 'ltPropImages' ).length,
		start, res;

		if( block[ direction ] ) {
			return block[ direction ];
		}

		start = this.getStartIndex( block.startIndex - 1 ); 

		return this.buildImageBlock( start );
	},

	getStartIndex: function( end ) {
		var start, imagesPerBlock = this.getData( 'imagesPerBlock' ),
		rangeSet = this.getData( 'rangeSet' ), length = this.getData( 'ltPropImages' ).length;

		if( end === -1 ) {
			end = length - 1;
		}

		// TODO: check if previous block can start at 0 and the current calculated start can also be 0
		start = end + 1 - imagesPerBlock;

		if( start < 0 ) {
			start = 0;
		}

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( end > rangeSet[ i ][ 1 ] && start <= rangeSet[ i ][ 1 ] ) {
				start = rangeSet[ i ][ 1 ] + 1;
				break;
			}
		}

		return start;
	},

	getEndIndex: function( start ) {
		var rangeSet = this.getData( 'rangeSet' ), 
		length = this.getData( 'ltPropImages' ).length,
		end, imagesPerBlock = this.getData( 'imagesPerBlock' );

		end = start + imagesPerBlock - 1;

		if( end >= length ) {
			end = length - 1;
		}

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( start < rangeSet[ i ][ 0 ] && end >= rangeSet[ i ][ 0 ] ) {
				end = rangeSet[ i ][ 0 ] - 1;
				break;
			}
		}

		rangeSet.splice( i, 0, [ start, end ] );
		this.collapseSet();

		return end;
	},

	indexInBlock: function( block, index ) {
		return block.startIndex <= index && block.endIndex >= index;
	},

	slideOut: function( previous, next, blocks, direction ) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		imageWidth = this.getImageWidth(),
		isRTL = this.isRTL(),
		that = this, imagesToMove, offset;

		blocks.forEach( function( block ) {
			that.addAnimationClass( block );

			if( that.isMovingAcrossBoundary( next, direction ) ) {
				imagesToMove = imagesPerBlock ;
			}
			else if( that.isLongMove( direction, next, previous ) ) {
				if( direction === 'previous' && isNaN( imagesToMove ) ) {
					offset = previous - blocks[ 0 ].startIndex;
					imagesToMove = imagesPerBlock + ( offset > 0 ? offset : 0 );
				}
				else if( direction === 'next' && isNaN( imagesToMove ) ) { 
					offset = blocks[ blocks.length - 1 ].endIndex - ( previous + imagesPerBlock - 1 );
					imagesToMove = imagesPerBlock + ( offset > 0 ? offset : 0 );
				}
			}
			else {
				imagesToMove = Math.abs( previous - next );
			}

			imagesToMove = imagesToMove * ( isRTL ? -1 : 1 ) * ( direction === 'previous' ? 1 : -1 );

			that.queueAnimates( block, block.translate + ( imagesToMove * imageWidth ) );			
		} );
	},

	slideIn: function( next, blocks, lastBlock, direction ) {
		var translateValue, imageWidth = this.getImageWidth(),
		that = this, isRTL = this.isRTL();

		blocks.forEach( function( block ) {
			if( lastBlock ) {
				that.positionBlockForAnimation( block, lastBlock, direction );
			}
			
			lastBlock = block;
			that.addAnimationClass( block );
			translateValue = ( block.startIndex - next ) * imageWidth;
			translateValue = translateValue * ( isRTL ? -1 : 1 ); 
			that.queueAnimates( block, translateValue );
		} );

		this.fireAnimations();
	},

	positionBlockForAnimation: function( blockToBePositioned, previousBlock, dir ) {
		var isRTL = this.isRTL(),
		imageWidth = this.getImageWidth(),
		translateValue = previousBlock.translate + ( isRTL && dir === 'next' ? -( this.getBlockLength( previousBlock ) * imageWidth ) : 0 ) ,
		blockLength = this.getBlockLength( ( dir === 'previous' ) ? blockToBePositioned : previousBlock ),
		multiplier = ( ( dir === 'previous' && !isRTL ) ) ? -1 : 1,
		newValue = translateValue + ( isRTL && dir !== 'previous' ? 0 : ( multiplier * ( blockLength * imageWidth ) ) );

		Lyte.objectUtils( blockToBePositioned, 'add', 'translate', newValue );
	},

	addAnimationClass: function( block ) {
		var that = this;

		window.requestAnimationFrame( function() {
			var classList = block.class.trim().split( ' ' );

			classList.push( 'lyteAvatarSlideAnim' );
			classList = classList.join( ' ' );

			Lyte.objectUtils( block, 'add', 'class', classList );
			that.setData( 'isAnimating', true );
		} );
		
	},

	getBlockLength: function( block ) {
		return block.endIndex - block.startIndex + 1;
	},

	removeAnimationClass: function( block ) {
		var classList = block.class.trim().split( ' ' ),
		index = classList.indexOf( 'lyteAvatarSlideAnim' );

		if( !!~index ) {
			classList.splice( index, 1 );
			classList = classList.join( ' ' );
			Lyte.objectUtils( block, 'add', 'class', classList );
		}

		this.setData( 'isAnimating', false );
	},

	removeCommon: function( inBlocks, outBlocks ) {
		for( var i = 0; i < outBlocks.length; i++ ) {
			if( !!~inBlocks.indexOf( outBlocks[ i ] ) ) {
				outBlocks.splice( i, 1 );
				i--;
			}
		}
	},

	queueAnimates: function( block, value ) {
		this.animationQueue.push( { block: block, value: value } );
	},

	fireAnimations: function() {
		var that = this;

		window.requestAnimationFrame( function() {
			window.requestAnimationFrame( function() {
				that.animationQueue.forEach( function( animationObj ) {
					Lyte.objectUtils( animationObj.block, 'add', 'translate', animationObj.value );
				} );

				that.animationQueue = [];
			} );
		} );
		
	},
	removeBlock : function(block){
		var blocks = this.getData("blocks");
		Lyte.arrayUtils(blocks,"removeAt",blocks.indexOf(block),1);
	},	
	getEndIndexForPreload : function(start){
		var imagesPerBlock = this.getData( 'imagesPerBlock' );
		var end;
		var length = this.getData( 'ltPropImages' ).length,
		end = start + imagesPerBlock - 1;

		if( end >= length ) {
			end = length - 1;
		}
		return end;
	},
	availableBlock : function(startIndex,endIndex){ // used to find the particular block 
		var increment = startIndex;
		var block;
		var returnValue=false;
		while(increment <= endIndex){
			block = this.getBlock(increment);
			if(!block){
				break;
			}
			if(block.startIndex === startIndex &&  block.endIndex === endIndex){
				returnValue = block;
				break;
			}
			increment++;
		}
		return returnValue;
	},
	checkConditionBeforeRemove : function(block){ // checking the condition before remove
		var imageWidth = this.getImageWidth(),
		imagesPerBlock = this.getData( 'imagesPerBlock' );
		var max =  imageWidth*(imagesPerBlock);
		var min = -imageWidth*((block.endIndex - block.startIndex)+1);
		if(block.translate  ===  undefined || 
		block.translate >= max || block.translate <= min  ){
			return true;
		}
	},
	getBlockChain : function(blocks,altblock){ //if the inBlock are [[0,1][2,3]] it returns with [0,3]
		if(!blocks.length){
			blocks = [altblock]
		}
		var startIndex=blocks[0].startIndex,endIndex=blocks[0].endIndex;
		for(var index=1;index<blocks.length;index++){
			var block =  blocks[index];
			if(block.startIndex<startIndex){
				startIndex = block.startIndex;
			}
			if(block.endIndex>endIndex){
				endIndex = block.endIndex;
			}
		}
		return{
			startIndex : startIndex,
			endIndex : endIndex
		}
	},
	getEndIndexForPrevBlock : function(blockChain,startIndex,endIndex){
		if(endIndex >= blockChain.startIndex && endIndex <= blockChain.endIndex && startIndex<blockChain.startIndex){
			while(blockChain.startIndex != endIndex){
				--endIndex;
			}
			return --endIndex;
		}
		return endIndex;
	},
	getStartIndexForNextBlock : function(blockChain,startIndex,endIndex){
		if(startIndex >= blockChain.startIndex && startIndex <= blockChain.endIndex && blockChain.endIndex<endIndex){
			while(blockChain.endIndex != startIndex){
				++startIndex;
			}
			return ++startIndex;
		}
		return startIndex;
	},
	getInAndOutBlocks : function(prevCurValue,curValue,direction){
		var blocks = Array.from(this.getData("blocks"));
		var outBlocks= [], inBlocks;
		var prevCurBlock =  direction?this.prevCurBlock[direction]:this.prevCurBlock;
		inBlocks =  this.findInBlock(prevCurValue,curValue,direction,prevCurBlock);
		for(var index=0;index<blocks.length;index++){
			if(inBlocks.indexOf(blocks[index])<0){
				if(this.checkConditionBeforeRemove(blocks[index],direction)){
					this.removeBlock(blocks[index]);
				}
				else{
					outBlocks.push(blocks[index]);
				}
			}
		}
		return {
			outBlocks : outBlocks,
			inBlocks : inBlocks
		}
	},
	connectParentChildBlocks : function(parent,child,direction){
		parent[direction] =  child;
		child.next = parent;
		child.previous =  parent;
	},
	prevBlockisReusable : function(block,inBlocks,direction){
		var prevCurBlock = direction?this.prevCurBlock[direction]:this.prevCurBlock;
		if(block && ((inBlocks.indexOf(block) < 0  && (direction === "previous" && this.isCompleteBlock(block.startIndex,block.endIndex)))
		|| (direction === "next" && block === prevCurBlock))){
			return true;
		}
		return false;
	},
	nextBlockisReusable : function(block,inBlocks,direction){
		var prevCurBlock = direction?this.prevCurBlock[direction]:this.prevCurBlock;
		if(block && ((inBlocks.indexOf(block) < 0  && (direction === "next" && this.isCompleteBlock(block.startIndex,block.endIndex)))
		|| (direction === "previous" && block === prevCurBlock))){
			return true;
		}
		return false;
	},
	isCompleteBlock : function(startIndex,endIndex){
		var imagesPerBlock = this.getData( 'imagesPerBlock' );
		if(endIndex-startIndex === imagesPerBlock-1){
			return true;
		}
		return false;
	},
	setPreviousBlock : function(startIndex,curblock,inBlocks,direction,blockChain){
		var endIndex = this.getEndIndexForPreload(startIndex);
		endIndex = this.getEndIndexForPrevBlock(blockChain,startIndex,endIndex);
		var prevBlock = this.availableBlock(startIndex,endIndex);
		if(this.prevBlockisReusable(prevBlock,inBlocks,direction)){
			this.connectParentChildBlocks(curblock,prevBlock,"previous");
		}
		else{
			var tempBlock;
			this.setData("rangeSet",[]);
			tempBlock = this.createblock( startIndex,true,endIndex);
			direction = direction? direction:"previous";
			this.connectParentChildBlocks(curblock,tempBlock,"previous");
		}
	},
	setNextBlock : function(startIndex,curblock,inBlocks,direction,blockChain){
		var endIndex = this.getEndIndexForPreload(startIndex);
		startIndex = this.getStartIndexForNextBlock(blockChain,startIndex,endIndex);
		var nextBlock = this.availableBlock(startIndex,endIndex);
		if(this.nextBlockisReusable(nextBlock,inBlocks,direction)){
			this.connectParentChildBlocks(curblock,nextBlock,"next");
		}
		else{
			var tempBlock;
			this.setData("rangeSet",[]);
			tempBlock = this.createblock(startIndex,true,endIndex);
			direction = direction?direction: "next";
			this.connectParentChildBlocks(curblock,tempBlock,"next");
		}
	},
	preloadImages: function(prevCurValue,direction) {
		var cur = this.getData( 'displayIndex' ),
		preload = this.getData( 'ltPropPreload' ),
		cyclic = this.getData( 'ltPropCyclic' ),
		next = this.getNextIndex( cur ),
		previous = this.getPreviousIndex( cur ),
		length = this.getData( 'ltPropImages' ).length,
		imagesPerBlock = this.getData( 'imagesPerBlock' ), lastBlock;
		if( length < imagesPerBlock || !preload ) {
			return ;
		}
		var outBlocks=[], inBlocks=[];
		var firstBlock, lastBlock;
		if(direction){ // this check for stop calling in didConnect
			var BlockInfo = this.getInAndOutBlocks(prevCurValue,cur,direction);
			if(BlockInfo.inBlocks.length === 0){
				BlockInfo.inBlocks =  [this.createDisconnectedBlock(cur)];
			}
			outBlocks = BlockInfo.outBlocks;
			inBlocks = BlockInfo.inBlocks;
			firstBlock = inBlocks[0];
			lastBlock = inBlocks[inBlocks.length-1];
		}
		else{
			firstBlock = this.getBlock(cur);
			lastBlock = this.getBlock(cur);
		}
		var blockChain = this.getBlockChain(inBlocks,firstBlock);
		if( (cyclic || ( cur !== 0 && !cyclic ) )) {
			this.setPreviousBlock(previous,firstBlock,inBlocks,direction,blockChain);
		}
		if( cyclic || ( cur !== ( length - imagesPerBlock ) && !cyclic ) ) {
			this.setNextBlock(next,lastBlock,inBlocks,direction,blockChain);
		}
		if( direction === 'previous' ) {
			inBlocks.reverse();
			outBlocks.reverse();
		}
		this.prevCurBlock = {previous:firstBlock,next:lastBlock};
		return{
			inBlocks : inBlocks,
			outBlocks:outBlocks
		}
	},

	removeSelectedClass: function() {
		var sel = this.getData( 'ltPropSelectedClass' );
		var previousItems =  $L("."+sel,this.$node);
		if(previousItems.length) {
			for(var index=0;index<previousItems.length;index++){
				previousItems[index].ltProp( 'selectedClass', '' );
			}
		}
	},

	addSelectedClass: function( navItem ) {
		var sel = this.getData( 'ltPropSelectedClass' );

		if( navItem ) {
			var imageId = navItem.getAttribute("data-image-id");
			var selectedItems = $L("[data-image-id='"+imageId+"']",this.$node);
			for(var index=0;index<selectedItems.length;index++){
				selectedItems[index].ltProp( 'selectedClass', sel );
			}
		}
	},

	toggleSelectedClass: function( oldValue, newValue, preventClassRemove ) {

		// TODO: Is this required?
		if( !preventClassRemove ) {
			this.removeSelectedClass();
		}

		this.addSelectedClass( this.getNavItem( newValue ) );
	},

	getNavItem: function( sel ) {
		var systemValue = this.getData( 'ltPropSystemValue' ),
		val = sel[ systemValue ];

		return this.$node.querySelector( '[data-image-id="' + val + '"]' );
	},

	fireOnSelect: function( event, navItem ) {
		var sel = this.getData( 'ltPropSelected' );

		if( this.getMethods( 'onSelect' ) ) {
			this.executeMethod( 'onSelect', event, sel, navItem );
		}
	},

	fireNavigationCallback: function( event, direction ) {
		if( direction === 'previous' ) {
			if( this.getMethods( 'onPrevious' ) ) {
				this.executeMethod( 'onPrevious', event, this, this.isVisible() );
			}
		}
		else {
			if( this.getMethods( 'onNext' ) ) {
				this.executeMethod( 'onNext', event, this, this.isVisible() );
			}
		}
	},

	isVisible: function() {
		var selIndex = this.selectedIndex,
		displayIndex = this.getData( 'displayIndex' ), 
		imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( !isNaN( selIndex ) ) {
			return selIndex >= displayIndex && selIndex < displayIndex + imagesPerBlock;
		}

		return false;
	},

	isMovingAcrossBoundary: function( next, direction ) {
		return ( direction === 'previous' && this.isMovingToLastIndex( next ) ) || ( direction === 'next' && this.isMovingToFirstIndex( next ) );
	},

	getAnimatingBlocks: function( next, previous, direction, indexOfFirstOutBlock ) {
		var outBlocks, inBlocks;

		outBlocks = this.getOutBlocks( indexOfFirstOutBlock, next, direction, previous );
		inBlocks = this.getInBlocks( previous, next, direction );

		if( direction === 'previous' ) {
			inBlocks.reverse();
			outBlocks.reverse();
		}

		this.removeCommon( inBlocks, outBlocks );

		this.curCount = 0;
		this.totalCount = inBlocks.length + outBlocks.length;

		return {
			outBlocks: outBlocks,
			inBlocks: inBlocks
		}
	},

	animateBlocks: function( next, previous, inBlocks, outBlocks, direction ) {
		var lastBlock = direction === 'previous' ? outBlocks[ 0 ] : outBlocks[ outBlocks.length - 1 ];
		//var preload = this.getData("ltProPreload");

		this.slideIn( next, inBlocks, lastBlock, direction );
		this.slideOut( previous, next, outBlocks, direction );
	},

	selectedObserver: function( change ) {
		this.setSelectedIndex();

		if( this.preventObs ) {
			return ;
		}

		var previous = this.getData( 'displayIndex' ),
		images = this.getData( 'ltPropImages' ),
		next = this.setDisplayIndex(),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		direction, event = {};

		if( images.length > imagesPerBlock ) {
			if( previous > next ) {
				direction = 'previous';
				this.moveToSelected( event, next, previous, direction, previous + imagesPerBlock - 1 );
			}
			else if( previous < next ) {
				direction = 'next';
				this.moveToSelected( event, next, previous, direction, previous );
			}
		}

		this.toggleSelectedClass( change.oldValue, change.newValue );
	}.observes( 'ltPropSelected' ),

	setSelectedIndex: function() {
		var images = this.getData( 'ltPropImages' ) || [],
		sel = this.getData( 'ltPropSelected' ), i;

		if( sel ) {
			for( i = 0; i < images.length; i++ ) {
				if( images[ i ] === sel ) {
					this.selectedIndex = i;
					break;
				}
			}
		}
	},

	moveToSelected: function( event, next, previous, direction, indexOfFirstOutBlock ) {
		var blocksInfo, imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.getData( 'ltPropPreload' ) ) {
			blocksInfo = this.preloadImages( previous, direction );
		}
		else{
			blocksInfo = this.getAnimatingBlocks( next, previous, direction, indexOfFirstOutBlock );
		}

		this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
		this.fireNavigationCallback( event, direction );
	},

	imagesObserver: function() {
		this.animationQueue = [];
		this.setData( 'blocks', [] );
		this.setData( 'rangeSet', [] );
		this.deleteOtherBlocks = false;
		this.curCount = this.totalCount = 0;
		this.setData( 'isAnimating', false );
		this.preventObs = false;
		delete this.prevCurBlock;

		this.setData( 'showLeftArrow', true );
		this.setData( 'showRightArrow', true );
		this.setup();
		this.toggleNavigation();
	}.observes( 'ltPropImages.[]' ),

	actions: {

		// TODO: Think about merging the two navigates into a single function
		navigatePrevious: function( event, nextIndex ) {

			if( this.getData( 'isAnimating' ) ) {
				return ;
			}

			var previous = this.getData( 'displayIndex' ),
			imagesPerBlock = this.getData( 'imagesPerBlock' ), 
			next = this.getPreviousIndex(), blocksInfo, inBlocks, outBlocks, direction = 'previous';

			this.setData( 'displayIndex', next );
			// this.preloadImages(direction);
			if(this.getData("ltPropPreload")){
				blocksInfo = this.preloadImages(previous, direction);
			}
			else{
				blocksInfo = this.getAnimatingBlocks( next, previous, direction, previous + imagesPerBlock - 1 );
			}
			this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
			
			this.fireNavigationCallback( event, direction );

		},

		navigateNext: function( event, nextIndex ) {

			if( this.getData( 'isAnimating' ) ) {
				return ;
			}

			var previous = this.getData( 'displayIndex' ), 
			next = this.getNextIndex(), outBlocks, inBlocks, blocksInfo, direction = 'next';

			this.setData( 'displayIndex', next );
			if(this.getData("ltPropPreload")){
				blocksInfo = this.preloadImages(previous, direction);
			}
			else{
				blocksInfo = this.getAnimatingBlocks( next, previous, direction, previous );
			}
			this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
			this.fireNavigationCallback( event, direction );
		},

		removeClass: function( event, block ) {
			var blocks = this.getData( 'blocks' ), ind;
			var preload = this.getData("ltPropPreload");
			this.removeAnimationClass( block );
			this.curCount++;
			if( !preload && this.deleteOtherBlocks ) {
				if( this.curCount === this.totalCount ) {
					this.curCount = this.totalCount = 0;
					this.deleteOtherBlocks = false;
					Lyte.arrayUtils( blocks, 'removeAt', 0, blocks.length - 1 );
				}
			}
		},

		selectItem: function( event ) {
			var target = event.target,
			navItem = $L( target ).closest( 'lyte-avatar-navigator-item' ).get( 0 ),
			oldValue = this.getData( 'ltPropSelected' ), newValue ;

			if( !navItem ) {
				return ;
			}

			if( navItem.hasAttribute( 'disabled' ) ) {
				return ;
			}

			
			this.preventObs = true;
			this.setData( 'ltPropSelected', newValue = navItem.ltProp( 'image' )._originalObj );
			this.toggleSelectedClass( oldValue, newValue );
			this.preventObs = false;
			this.fireOnSelect( event, navItem );
		}
	}
} );
Lyte.Component.register( 'lyte-avatar-navigator-item', {
_template:"<template tag-name=\"lyte-avatar-navigator-item\"> <img src=\"{{src}}\" onload=\"{{action('hideIcon',event)}}\" title=\"\" alt=\"{{alt}}\" lt-prop-title=\"{{title}}\" lt-prop-tooltip-config=\"{{config}}\"> <div class=\"lyteAvatarLoadingCont\"> <template is=\"if\" value=\"{{ltPropLoadingIconYield}}\"><template case=\"true\"> <lyte-yield yield-name=\"loadingIconYield\"></lyte-yield> </template><template case=\"false\"> <div class=\"{{ltPropLoadingIconClass}}\"></div> </template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropImage","ltPropLoadingIconYield","ltPropLoadingIconClass","ltPropSelectedClass"],
	data: function() {
		return {
			'ltPropImage': Lyte.attr( 'object', {} ),
			'ltPropLoadingIconYield': Lyte.attr( 'boolean', { 'default': false } ),
			'ltPropLoadingIconClass': Lyte.attr( 'string', { 'default': 'lyteAvatarLoading' } ),
			'ltPropSelectedClass': Lyte.attr( 'string', { 'default': '' } )
		};
	},

	imageObserver: function() {
		this.setSelected();
		this.setImageAttributes();
	}.observes( 'ltPropImage' ),

	init: function() {
		this.setParentComponent();
		this.setImageAttributes();
	},

	didConnect: function() {
		this.setSelected();
	},

	addSelectedClass: function() {
		var sel = this.getData( 'ltPropSelectedClass' ),
		imageObj = this.getData( 'ltPropImage' );

		if( sel ) {
			this.$node.classList.add( sel );
			this.selClass = sel;
			imageObj.isSelected = true;
		}
		else {
			this.$node.classList.remove( this.selClass );
			this.selClass = '';
			imageObj.isSelected = false;
		}

	}.observes( 'ltPropSelectedClass' ),

	setParentComponent: function() {
		var parent = $L( this.$node ).closest( 'lyte-avatar-navigator' );

		this.parent = parent.get( 0 );
	},

	getLoadingIcon: function() {

		return this.$node.querySelector( '.lyteAvatarLoadingCont' );
	},

	setSelected: function() {
		var parent = this.parent.component,
		cls = parent.getData( 'ltPropSelectedClass' ),
		imageObj = this.getData( 'ltPropImage' );

		if( imageObj.isSelected ) {
			this.setData( 'ltPropSelectedClass', cls );
		}
	},

	setImageAttributes: function() {
		var parent = this.parent.component, 
		urlValue = parent.getData( 'ltPropUrlValue' ),
		tooltipValue = parent.getData( 'ltPropTooltipValue' ),
		imageObj = this.getData( 'ltPropImage' ) || {},
		isString = parent.getData( 'isString' ),
		id = ( imageObj || {} ).id,
		altValue = parent.getAltValue(),
		disabled = ( imageObj || {} ).disabled,
		config = parent.getData( 'ltPropTooltip' );

		if( imageObj[ urlValue ] ) {
			this.setData( 'src', imageObj[ urlValue ] );
		}

		if( !isNaN( id ) ) {
			this.$node.setAttribute( 'data-image-id', id );
		}

		this.setData( 'alt', imageObj[ altValue ] );

		if( imageObj.disabled ) {
			this.$node.setAttribute( 'disabled', 'true' );
		}

		if( tooltipValue && ( imageObj || {} )[ tooltipValue ] ) {
			this.setData( 'title', imageObj[ tooltipValue ] );
		}

		this.setData( 'config', config ); 
	},

	actions: {
		hideIcon: function( event ) {
			if( !this.$node ) {
				return ;
			}

			var loadingIcon = this.getLoadingIcon();

			loadingIcon.style.display = 'none';
		}
	}
} );
/**
 * This component is used to get hand written inputs and convert them to images
 * @component lyte-signature
 * @utility refresh,clear,downloadAsImage,reset,resetQueue
 * @methods onBeforeDrawSelect,onDrawSelect,onDrawMove,onDrawEnd,onBeforeDownload,onUndoRedoQueueUpdate
 * @version 3.17.0
 */

Lyte.Component.register("lyte-signature", {
_template:"<template tag-name=\"lyte-signature\"> <canvas onmousedown=\"{{action('mousedown',event)}}\" ontouchstart=\"{{action('mousedown',event)}}\" tabindex=\"0\" onkeydown=\"{{action('keydown',event)}}\">Canvas not supported</canvas> <template is=\"if\" value=\"{{expHandlers(ltPropImageUrl,'&amp;&amp;',showImage)}}\"><template case=\"true\"> <img src=\"{{ltPropImageUrl}}\"> </template></template> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropInsertStroke","ltPropInsertLineWidth","ltPropFileName","ltPropDontModifyCurrent","ltPropImageUrl","ltPropUndoRedo","ltPropMode","ltPropEraseStroke","ltPropEraseLineWidth","showImage","undoQueue","redoQueue"],
	data : function(){
		return {
			/**
			 * @componentProperty {string} ltPropInsertStroke='#000000'
			 * @version 3.17.0
			 */			
			ltPropInsertStroke : Lyte.attr( 'string', { default : "#000000" }),
			/**
			 * @componentProperty {number} ltPropInsertLineWidth=1
			 * @version 3.17.0
			 */				
			ltPropInsertLineWidth : Lyte.attr( 'number', { default : 1 }),
			/**
			 * @componentProperty {string} ltPropFileName='sample_sign'
			 * @version 3.17.0
			 */				
			ltPropFileName : Lyte.attr( 'string', { default : "sample_sign" }),
			/**
			 * @componentProperty {boolean} ltPropDontModifyCurrent=false
			 * @version 3.17.0
			 */				
			ltPropDontModifyCurrent : Lyte.attr( 'boolean', { default : false }),
			/**
			 * @componentProperty {string} ltPropImageUrl=''
			 * @version 3.17.0
			 */				
			ltPropImageUrl : Lyte.attr( 'string', { default : "" } ),
			/**
			 * @componentProperty {boolean} ltPropUndoRedo=true
			 * @version 3.17.0
			 */				
			ltPropUndoRedo : Lyte.attr( 'boolean', { default : false } ),
			/**
			 * @componentProperty {Insert | Erase} ltPropMode='Insert'
			 * @version 3.17.0
			 */				
			ltPropMode : Lyte.attr( 'string', { default : 'Insert' } ),
			/**
			 * @componentProperty {string} ltPropEraseStroke='white'
			 * @version 3.17.0
			 */			
			ltPropEraseStroke : Lyte.attr( 'string', { default : "white" }),
			/**
			 * @componentProperty {number} ltPropEraseLineWidth=3
			 * @version 3.17.0
			 */				
			ltPropEraseLineWidth : Lyte.attr( 'number', { default : 5 }),

			showImage :  Lyte.attr( 'boolean', { default : true } ),
			undoQueue : Lyte.attr( 'array', { default : [] } ),
			redoQueue : Lyte.attr( 'array', { default : [] } )
		}		
	},

	lineObs : function( arg ){
		if( this.data.ltPropDontModifyCurrent ){
			return;
		}

		var ctx = this._context,
		obj = {
			ltPropInsertStroke : "strokeStyle",
			ltPropInsertLineWidth : "lineWidth"
		};

		ctx[ obj[ arg.item ] ] = arg.newValue;
		ctx.stroke();
	}.observes( 'ltPropInsertLineWidth', 'ltPropInsertStroke' ),

	didConnect : function(){
		this._canvas = this.$node.children[ 0 ];
		this._context = this._canvas.getContext( '2d' );
		this.set_dimension();

		this.$node.refresh = this.set_dimension.bind( this );
		this.$node.clear = this.clear.bind( this );
		this.$node.downloadAsImage = this.download.bind( this );
		this.$node.reset = this.reset.bind( this );
		this.$node.resetQueue = this.resetQueue.bind( this );

	},

	reset : function(){
		this.setData( 'showImage', true );
		this.set_dimension();
		this.resetQueue();
	},

	resetQueue : function(){
		this.data.undoQueue = [];
		this.data.redoQueue = [];
		this.call_queueUpdate();
	},

	clear : function(){
		var canvas = this._canvas;
		this._context.clearRect( 0, 0, canvas.width, canvas.height );
	},

	download : function(){
		var canvas = this._canvas;
		var a = document.createElement( 'a' );
		a.download = this.data.ltPropFileName;
		a.href = canvas.toDataURL( "image/png" );

		a.style.position = 'absolute';

		if( this.getMethods( 'onBeforeDownload' ) ){
			if( this.executeMethod( 'onBeforeDownload', a, this.$node ) == false ){
				return;
			}
		}
		this.$node.appendChild( a );
		a.click();
		a.remove();
	},

	didDestroy : function(){
		this.remove_events();

		[ '_canvas', '_context', 'refresh', 'clear', 'downloadAsImage', 'reset', 'resetQueue' ].forEach( function( item ){
			delete this[ item ];
		}.bind( this ) );
	},

	set_dimension : function(){
		var canvas = this._canvas,
		_this = this;

		$L.fastdom.measure( function(){
			var bcr = canvas.getBoundingClientRect();

			$L.fastdom.mutate( function(){
				canvas.setAttribute( 'width', bcr.width );
				canvas.setAttribute( 'height', bcr.height );	
				_this.include_image();
			});

		});
	},

	include_image : function(){
		var img = this.$node.querySelector( 'img' );
		if( img ){
			var loadFn = function(){
				var ctx = this._context,
				canvas = this._canvas;
				ctx.drawImage( img, 0, 0, canvas.width, canvas.height );
				this.setData( 'showImage', false );
			}.bind( this );

			if( img.complete ){
				loadFn();
			} else{
				img.onload = loadFn;
			}
		}
	},

	getEvent : function( evt ){
		var touches = evt.touches || [ evt ];

		if( touches.length > 1 ){
			return;
		}

		return touches[ 0 ];
	},

	mousemove : function( ev ){
		var evt = this.getEvent( ev );
		if( !evt ){
			return;
		}
		this._moved = true;
		var coor = this.get_coordinate( evt ),
		ctx = this._context,
		mode = this.data.ltPropMode,
		stroke = this.data[ 'ltProp' + mode + 'Stroke'];

		ctx.lineWidth = this.data[ 'ltProp' + mode + 'LineWidth' ];

		ctx.lineTo( coor.x, coor.y );

		if( stroke ){
			ctx.stroke();
			ctx.strokeStyle = stroke;
		}

		if( this.getMethods( 'onDrawMove' ) ){
			this.executeMethod( 'onDrawMove', ev, this.$node );
		}
		ev.preventDefault();
	},

	remove_events : function(){
		if( this._move ){
			[ { name : 'mousemove', evt : this._move }, { name : 'mouseup', evt : this._up }, { name : 'touchmove', evt : this._move }, { name : 'touchend', evt : this._up } ].forEach( function( item ){
				document.removeEventListener( item.name, item.evt, true );
			}.bind( this ));

			delete this._move;
			delete this._up;
		}
	},

	mouseup : function( evt ){
		this.remove_events();
		if( this._moved && this.data.ltPropUndoRedo ){
			var canvas = this._canvas;
			this.push_to_queue( this._context.getImageData( 0, 0, canvas.width, canvas.height ) );
		}
		if( this.getMethods( 'onDrawEnd' ) ){
			this.executeMethod( 'onDrawEnd', evt, this._moved, this.$node );
		}
		delete this._moved;
	},

	push_to_queue : function( obj ){
		this.data.undoQueue.push( obj );
		this.data.redoQueue.splice( 0 );

		this.call_queueUpdate();
	},

	call_queueUpdate : function(){
		var callback_name = 'onUndoRedoQueueUpdate';
		if( this.getMethods( callback_name ) ){
			this.executeMethod( callback_name, this.data.undoQueue, this.data.redoQueue, this.$node );
		}
	},

	get_coordinate : function( evt ){
		var bcr = this.$node.getBoundingClientRect();
		return{
			x : evt.clientX - bcr.left,
			y : evt.clientY - bcr.top
		};
	},

	undo : function( evt ){
		var undo = this.data.undoQueue,
		redo = this.data.redoQueue;

		var current = undo.pop(),
		last_before = $L( undo ).get( -1 );

		if( current ){
			redo.push( current );
			this.render( last_before, evt );
		}
	},

	redo : function( evt ){
		var redo = this.data.redoQueue,
		current = redo.pop();

		if( current ){
			this.data.undoQueue.push( current );
			this.render( current, evt );
		}

	},

	render : function( to_render, evt ){
		this.clear();
		if( to_render ){
			this._context.putImageData( to_render, 0, 0 );
		}
		evt.preventDefault();
		this.call_queueUpdate();
	},

	actions : {
		mousedown : function( evt ){
			var ev = this.getEvent( evt ),
			namemove = "mousemove",
			nameup = "mouseup";

			if( ev ){
				if( ev != evt ){
					namemove = 'touchmove';
					nameup = 'touchend';
				}
			} else {
				return;
			}

			if( this.getMethods( 'onBeforeDrawSelect' ) ){
				if( this.executeMethod( 'onBeforeDrawSelect', evt, this.$node ) == false ){
					return;
				}
			}

			var coor = this.get_coordinate( ev ),
			ctx = this._context;

			ctx.beginPath();

			ctx.moveTo( coor.x, coor.y );

			this._move = this.mousemove.bind( this );
			this._up = this.mouseup.bind( this );

			document.addEventListener( namemove, this._move, true );
			document.addEventListener( nameup, this._up, true );

			if( this.getMethods( 'onDrawSelect' ) ){
				this.executeMethod( 'onDrawSelect', evt, this.$node );
			}
			if( namemove == 'touchmove' ){
				evt.preventDefault();
			}
		},

		keydown : function( evt ){
			if( this.data.ltPropUndoRedo ){
				var keycode = evt.which || evt.keyCode,
				is_meta = evt.metaKey != void 0 ? evt.metaKey : evt.ctrlKey;

				if( keycode == 90 && is_meta ){
					if( evt.shiftKey ){
						this.redo( evt );
					} else {
						this.undo( evt );
					}
				}
			}
		}
	}
});

/**
 * @syntax nonYielded
 * <lyte-signature></lyte-signature>
 */
Lyte.Component.register( 'lyte-emoji', {
_template:"<template tag-name=\"lyte-emoji\"> <template is=\"if\" value=\"{{ltPropSearch}}\"><template case=\"true\"> <div class=\"lyteEmojiInputElement\"> <lyte-input lt-prop=\"{{stringify(ltPropInput)}}\" lt-prop-type=\"{{ltPropInput.type}}\" lt-prop-close-icon=\"{{ltPropInput.closeIcon}}\" lt-prop-value=\"{{lbind(value)}}\" oninput=\"{{action('input',event)}}\"></lyte-input> </div> </template></template> <div class=\"lyteEmojiWrapper\"> <template is=\"for\" items=\"{{ltPropEmoji}}\" item=\"group\" index=\"grp_index\"> <div class=\"lyteEmojiGroup {{group.name}}\"> <template is=\"for\" items=\"{{group.emojis}}\" item=\"emoji\" index=\"index\"> <span class=\"lyteEmoji\" lt-prop-tooltip-class=\"lyteEmojiTooltip\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-title=\"{{emoji.name}}\" onclick=\"{{action('click',emoji)}}\" value=\"{{emoji.value}}\" encode=\"{{emoji.encode}}\">{{unescape(emoji.encode)}}</span> </template> </div> </template><template is=\"if\" value=\"{{ltPropNoMatchText}}\"><template case=\"true\"> <div class=\"lyteEmojiNoResult {{if(showNoResult,'','lyteEmojiHidden')}}\">{{ltPropNoMatchText}}</div> </template></template> </div> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]},{"type":"attr","position":[3,2]},{"type":"if","position":[3,2],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}}],
_observedAttributes :["ltPropEmoji","ltPropTooltipConfig","ltPropSearch","ltPropCaseSensitive","ltPropDiacritic","ltPropTrim","ltPropMethod","ltPropNoMatchText","ltPropInput","value","showNoResult"],
	data : function(){
		return {
			ltPropEmoji : Lyte.attr( 'array', { default : [{"name":"People","emojis":[{"name":"Grinning","value":"😀","encode":"&#x1f600"},{"name":"Grin","value":"😁","encode":"&#x1f601"},{"name":"Joy","value":"😂","encode":"&#x1f602"},{"name":"Smiley","value":"😃","encode":"&#x1f603"},{"name":"Smile","value":"😄","encode":"&#x1f604"},{"name":"Sweat smile","value":"😅","encode":"&#x1f605"},{"name":"Laughing","value":"😆","encode":"&#x1f606"},{"name":"Wink","value":"😉","encode":"&#x1f609"},{"name":"Blush","value":"😊","encode":"&#x1f60a"},{"name":"Yum","value":"😋","encode":"&#x1f60b"},{"name":"Sunglasses","value":"😎","encode":"&#x1f60e"},{"name":"Heart eyes","value":"😍","encode":"&#x1f60d"},{"name":"Kissing heart","value":"😘","encode":"&#x1f618"},{"name":"Kissing","value":"😗","encode":"&#x1f617"},{"name":"Kissing smiling eyes","value":"😙","encode":"&#x1f619"},{"name":"Kissing closed eyes","value":"😚","encode":"&#x1f61a"},{"name":"Slight smile","value":"🙂","encode":"&#x1f642"},{"name":"Hug","value":"🤗","encode":"&#x1f917"},{"name":"Thinking","value":"🤔","encode":"&#x1f914"},{"name":"Neutral face","value":"😐","encode":"&#x1f610"},{"name":"Expressionless","value":"😑","encode":"&#x1f611"},{"name":"No mouth","value":"😶","encode":"&#x1f636"},{"name":"Rolling eyes","value":"🙄","encode":"&#x1f644"},{"name":"Smirk","value":"😏","encode":"&#x1f60f"},{"name":"Persevere","value":"😣","encode":"&#x1f623"},{"name":"Cry","value":"😢","encode":"&#x1f622"},{"name":"Open mouth","value":"😮","encode":"&#x1f62e"},{"name":"Zipper mouth","value":"🤐","encode":"&#x1f910"},{"name":"Hushed","value":"😯","encode":"&#x1f62f"},{"name":"Sleepy","value":"😪","encode":"&#x1f62a"},{"name":"Tired face","value":"😫","encode":"&#x1f62b"},{"name":"Sleeping","value":"😴","encode":"&#x1f634"},{"name":"Relieved","value":"😌","encode":"&#x1f60c"},{"name":"Stuck out tongue","value":"😛","encode":"&#x1f61b"},{"name":"Stuck out tongue winking eye","value":"😜","encode":"&#x1f61c"},{"name":"Stuck out tongue closed eyes","value":"😝","encode":"&#x1f61d"},{"name":"Unamused","value":"😒","encode":"&#x1f612"},{"name":"Sweat","value":"😓","encode":"&#x1f613"},{"name":"Pensive","value":"😔","encode":"&#x1f614"},{"name":"Confused","value":"😕","encode":"&#x1f615"},{"name":"Upside down face","value":"🙃","encode":"&#x1f643"},{"name":"Money mouth","value":"🤑","encode":"&#x1f911"},{"name":"Astonished","value":"😲","encode":"&#x1f632"},{"name":"Slight frowning","value":"🙁","encode":"&#x1f641"},{"name":"Confounded","value":"😖","encode":"&#x1f616"},{"name":"Disappointed","value":"😞","encode":"&#x1f61e"},{"name":"Worried","value":"😟","encode":"&#x1f61f"},{"name":"Triumph","value":"😤","encode":"&#x1f624"},{"name":"Disappointed relieved","value":"😥","encode":"&#x1f625"},{"name":"Sob","value":"😭","encode":"&#x1f62d"},{"name":"Frowning with open mouth","value":"😦","encode":"&#x1f626"},{"name":"Anguished","value":"😧","encode":"&#x1f627"},{"name":"Fearful","value":"😨","encode":"&#x1f628"},{"name":"Weary","value":"😩","encode":"&#x1f629"},{"name":"Grimacing","value":"😬","encode":"&#x1f62c"},{"name":"Cold sweat","value":"😰","encode":"&#x1f630"},{"name":"Scream","value":"😱","encode":"&#x1f631"},{"name":"Flushed","value":"😳","encode":"&#x1f633"},{"name":"Dizzy face","value":"😵","encode":"&#x1f635"},{"name":"Rage","value":"😡","encode":"&#x1f621"},{"name":"Angry","value":"😠","encode":"&#x1f620"},{"name":"Mask","value":"😷","encode":"&#x1f637"},{"name":"Sick","value":"🤒","encode":"&#x1f912"},{"name":"Head Bandaged","value":"🤕","encode":"&#x1f915"},{"name":"Halo smiling","value":"😇","encode":"&#x1f607"},{"name":"Nerd","value":"🤓","encode":"&#x1f913"},{"name":"Smiling with horns","value":"😈","encode":"&#x1f608"},{"name":"Imp","value":"👿","encode":"&#x1f47f"},{"name":"Japanese ogre","value":"👹","encode":"&#x1f479"},{"name":"Japanese goblin","value":"👺","encode":"&#x1f47a"},{"name":"Skull","value":"💀","encode":"&#x1f480"},{"name":"Ghost","value":"👻","encode":"&#x1f47b"},{"name":"Alien","value":"👽","encode":"&#x1f47d"},{"name":"Robot","value":"🤖","encode":"&#x1f916"},{"name":"Hankey","value":"💩","encode":"&#x1f4a9"},{"name":"Smiley cat","value":"😺","encode":"&#x1f63a"},{"name":"Smile cat","value":"😸","encode":"&#x1f638"},{"name":"Joy cat","value":"😹","encode":"&#x1f639"},{"name":"Heart eyes cat","value":"😻","encode":"&#x1f63b"},{"name":"Smirk cat","value":"😼","encode":"&#x1f63c"},{"name":"Kissing cat","value":"😽","encode":"&#x1f63d"},{"name":"Scream cat","value":"🙀","encode":"&#x1f640"},{"name":"Crying cat face","value":"😿","encode":"&#x1f63f"},{"name":"Pouting cat","value":"😾","encode":"&#x1f63e"},{"name":"Baby","value":"👶","encode":"&#x1f476"},{"name":"Girl","value":"👧","encode":"&#x1f467"},{"name":"Boy","value":"👦","encode":"&#x1f466"},{"name":"Woman","value":"👩","encode":"&#x1f469"},{"name":"Man","value":"👨","encode":"&#x1f468"},{"name":"Older woman","value":"👵","encode":"&#x1f475"},{"name":"Older man","value":"👴","encode":"&#x1f474"},{"name":"Man with gua pi mao","value":"👲","encode":"&#x1f472"},{"name":"Man with turban","value":"👳","encode":"&#x1f473"},{"name":"Person with blond hair","value":"👱","encode":"&#x1f471"},{"name":"Person Shrugging","value":"🤷","encode":"&#x1f937"},{"name":"Cop","value":"👮","encode":"&#x1f46e"},{"name":"Construction worker","value":"👷","encode":"&#x1f477"},{"name":"Guardsman","value":"💂","encode":"&#x1f482"},{"name":"Detective","value":"🕵","encode":"&#x1f575"},{"name":"Bride","value":"👰","encode":"&#x1f470"},{"name":"Princess","value":"👸","encode":"&#x1f478"},{"name":"Santa","value":"🎅","encode":"&#x1f385"},{"name":"Angel","value":"👼","encode":"&#x1f47c"},{"name":"Bow","value":"🙇","encode":"&#x1f647"},{"name":"Information desk person","value":"💁","encode":"&#x1f481"},{"name":"No good","value":"🙅","encode":"&#x1f645"},{"name":"Ok woman","value":"🙆","encode":"&#x1f646"},{"name":"Raising hand","value":"🙋","encode":"&#x1f64b"},{"name":"Person with pouting face","value":"🙎","encode":"&#x1f64e"},{"name":"Person frowning","value":"🙍","encode":"&#x1f64d"},{"name":"Haircut","value":"💇","encode":"&#x1f487"},{"name":"Massage","value":"💆","encode":"&#x1f486"},{"name":"Nail care","value":"💅","encode":"&#x1f485"},{"name":"Dancer","value":"💃","encode":"&#x1f483"},{"name":"Dancers","value":"👯","encode":"&#x1f46f"},{"name":"Levitating","value":"🕴","encode":"&#x1f574"},{"name":"Walking","value":"🚶","encode":"&#x1f6b6"},{"name":"Runner","value":"🏃","encode":"&#x1f3c3"},{"name":"Couple","value":"👫","encode":"&#x1f46b"},{"name":"Boys","value":"👬","encode":"&#x1f46c"},{"name":"Girls","value":"👭","encode":"&#x1f46d"},{"name":"Couple kiss","value":"💏","encode":"&#x1f48f"},{"name":"Couple with heart","value":"💑","encode":"&#x1f491"},{"name":"Family: Couple with son","value":"👪","encode":"&#x1f46a"},{"name":"See no evil","value":"🙈","encode":"&#x1f648"},{"name":"Hear no evil","value":"🙉","encode":"&#x1f649"},{"name":"Speak no evil","value":"🙊","encode":"&#x1f64a"},{"name":"Fire","value":"🔥","encode":"&#x1f525"},{"name":"Glowing star","value":"🌟","encode":"&#x1f31f"},{"name":"Droplet","value":"💧","encode":"&#x1f4a7"},{"name":"Top hat","value":"🎩","encode":"&#x1f3a9"},{"name":"Crown","value":"👑","encode":"&#x1f451"},{"name":"Women's hat","value":"👒","encode":"&#x1f452"},{"name":"Athletic shoe","value":"👟","encode":"&#x1f45f"},{"name":"Man's shoe","value":"👞","encode":"&#x1f45e"},{"name":"Sandal","value":"👡","encode":"&#x1f461"},{"name":"High heel","value":"👠","encode":"&#x1f460"},{"name":"Boot","value":"👢","encode":"&#x1f462"},{"name":"Shirt","value":"👕","encode":"&#x1f455"},{"name":"Necktie","value":"👔","encode":"&#x1f454"},{"name":"Women's wear","value":"👚","encode":"&#x1f45a"},{"name":"Dress","value":"👗","encode":"&#x1f457"},{"name":"Running shirt with sash","value":"🎽","encode":"&#x1f3bd"},{"name":"Jeans","value":"👖","encode":"&#x1f456"},{"name":"Kimono","value":"👘","encode":"&#x1f458"},{"name":"Bikini","value":"👙","encode":"&#x1f459"},{"name":"Briefcase","value":"💼","encode":"&#x1f4bc"},{"name":"Handbag","value":"👜","encode":"&#x1f45c"},{"name":"Pouch","value":"👝","encode":"&#x1f45d"},{"name":"Purse","value":"👛","encode":"&#x1f45b"},{"name":"Eyeglasses","value":"👓","encode":"&#x1f453"},{"name":"Ribbon","value":"🎀","encode":"&#x1f380"},{"name":"Closed umbrella","value":"🌂","encode":"&#x1f302"},{"name":"Gem","value":"💎","encode":"&#x1f48e"},{"name":"Speech balloon","value":"💬","encode":"&#x1f4ac"},{"name":"Open hands","value":"👐","encode":"&#x1f450"},{"name":"Raised hands","value":"🙌","encode":"&#x1f64c"},{"name":"Clap","value":"👏","encode":"&#x1f44f"},{"name":"Thumbs up","value":"👍","encode":"&#x1f44d"},{"name":"Thumbs down","value":"👎","encode":"&#x1f44e"},{"name":"Oncoming first","value":"👊","encode":"&#x1f44a"},{"name":"Sign of horns","value":"🤘","encode":"&#x1f918"},{"name":"Ok hand","value":"👌","encode":"&#x1f44c"},{"name":"Point left","value":"👈","encode":"&#x1f448"},{"name":"Point right","value":"👉","encode":"&#x1f449"},{"name":"Point up","value":"👆","encode":"&#x1f446"},{"name":"Point down","value":"👇","encode":"&#x1f447"},{"name":"Middle finger","value":"🖕","encode":"&#x1f595"},{"name":"Raised hand","value":"✋","encode":"&#x270b"},{"name":"Splayed fingers","value":"🖐","encode":"&#x1f590"},{"name":"Crossed fingers","value":"🤞","encode":"&#x1f91e"},{"name":"Vulcan Salute","value":"🖖","encode":"&#x1f596"},{"name":"Wave","value":"👋","encode":"&#x1f44b"},{"name":"Muscle","value":"💪","encode":"&#x1f4aa"},{"name":"Pray","value":"🙏","encode":"&#x1f64f"},{"name":"Ring","value":"💍","encode":"&#x1f48d"},{"name":"Lipstick","value":"💄","encode":"&#x1f484"},{"name":"Kiss","value":"💋","encode":"&#x1f48b"},{"name":"Lips","value":"👄","encode":"&#x1f444"},{"name":"Tongue","value":"👅","encode":"&#x1f445"},{"name":"Ear","value":"👂","encode":"&#x1f442"},{"name":"Nose","value":"👃","encode":"&#x1f443"},{"name":"Footprints","value":"👣","encode":"&#x1f463"},{"name":"Eye","value":"👁","encode":"&#x1f441"},{"name":"Eyes","value":"👀","encode":"&#x1f440"},{"name":"Speaking Head","value":"🗣","encode":"&#x1f5e3"},{"name":"Bust in silhouette","value":"👤","encode":"&#x1f464"},{"name":"Busts in silhouette","value":"👥","encode":"&#x1f465"}]},{"name":"Nature","emojis":[{"name":"Dog","value":"🐶","encode":"&#x1f436"},{"name":"Wolf","value":"🐺","encode":"&#x1f43a"},{"name":"Hamster","value":"🐹","encode":"&#x1f439"},{"name":"Rabbit","value":"🐰","encode":"&#x1f430"},{"name":"Frog","value":"🐸","encode":"&#x1f438"},{"name":"Tiger","value":"🐯","encode":"&#x1f42f"},{"name":"Koala","value":"🐨","encode":"&#x1f428"},{"name":"Bear","value":"🐻","encode":"&#x1f43b"},{"name":"Pig","value":"🐷","encode":"&#x1f437"},{"name":"Pig nose","value":"🐽","encode":"&#x1f43d"},{"name":"Boar","value":"🐗","encode":"&#x1f417"},{"name":"Monkey","value":"🐒","encode":"&#x1f412"},{"name":"Horse","value":"🐴","encode":"&#x1f434"},{"name":"Sheep","value":"🐑","encode":"&#x1f411"},{"name":"Elephant","value":"🐘","encode":"&#x1f418"},{"name":"Panda face","value":"🐼","encode":"&#x1f43c"},{"name":"Penguin","value":"🐧","encode":"&#x1f427"},{"name":"Bird","value":"🐦","encode":"&#x1f426"},{"name":"Baby chick","value":"🐤","encode":"&#x1f424"},{"name":"Hatched chick","value":"🐥","encode":"&#x1f425"},{"name":"Hatching chick","value":"🐣","encode":"&#x1f423"},{"name":"Chicken","value":"🐔","encode":"&#x1f414"},{"name":"Snake","value":"🐍","encode":"&#x1f40d"},{"name":"Turtle","value":"🐢","encode":"&#x1f422"},{"name":"Bug","value":"🐛","encode":"&#x1f41b"},{"name":"Bee","value":"🐝","encode":"&#x1f41d"},{"name":"Ant","value":"🐜","encode":"&#x1f41c"},{"name":"Beetle","value":"🐞","encode":"&#x1f41e"},{"name":"Snail","value":"🐌","encode":"&#x1f40c"},{"name":"Octopus","value":"🐙","encode":"&#x1f419"},{"name":"Shell","value":"🐚","encode":"&#x1f41a"},{"name":"Tropical fish","value":"🐠","encode":"&#x1f420"},{"name":"Fish","value":"🐟","encode":"&#x1f41f"},{"name":"Dolphin","value":"🐬","encode":"&#x1f42c"},{"name":"Whale","value":"🐳","encode":"&#x1f433"},{"name":"Racehorse","value":"🐎","encode":"&#x1f40e"},{"name":"Dragon face","value":"🐲","encode":"&#x1f432"},{"name":"Blowfish","value":"🐡","encode":"&#x1f421"},{"name":"Camel","value":"🐫","encode":"&#x1f42b"},{"name":"Poodle","value":"🐩","encode":"&#x1f429"},{"name":"Feet","value":"🐾","encode":"&#x1f43e"},{"name":"Bouquet","value":"💐","encode":"&#x1f490"},{"name":"Cherry blossom","value":"🌸","encode":"&#x1f338"},{"name":"Tulip","value":"🌷","encode":"&#x1f337"},{"name":"Four leaf clover","value":"🍀","encode":"&#x1f340"},{"name":"Rose","value":"🌹","encode":"&#x1f339"},{"name":"Sunflower","value":"🌻","encode":"&#x1f33b"},{"name":"Hibiscus","value":"🌺","encode":"&#x1f33a"},{"name":"Maple leaf","value":"🍁","encode":"&#x1f341"},{"name":"Leaves","value":"🍃","encode":"&#x1f343"},{"name":"Fallen leaf","value":"🍂","encode":"&#x1f342"},{"name":"Herb","value":"🌿","encode":"&#x1f33f"},{"name":"Ear of rice","value":"🌾","encode":"&#x1f33e"},{"name":"Mushroom","value":"🍄","encode":"&#x1f344"},{"name":"Cactus","value":"🌵","encode":"&#x1f335"},{"name":"Palm tree","value":"🌴","encode":"&#x1f334"},{"name":"Chestnut","value":"🌰","encode":"&#x1f330"},{"name":"Seedling","value":"🌱","encode":"&#x1f331"},{"name":"Blossom","value":"🌼","encode":"&#x1f33c"},{"name":"New moon","value":"🌑","encode":"&#x1f311"},{"name":"First quarter moon","value":"🌓","encode":"&#x1f313"},{"name":"Moon","value":"🌔","encode":"&#x1f314"},{"name":"Full moon","value":"🌕","encode":"&#x1f315"},{"name":"First quarter moon with face","value":"🌛","encode":"&#x1f31b"},{"name":"Crescent moon","value":"🌙","encode":"&#x1f319"},{"name":"Earth asia","value":"🌏","encode":"&#x1f30f"},{"name":"Volcano","value":"🌋","encode":"&#x1f30b"},{"name":"Milky way","value":"🌌","encode":"&#x1f30c"},{"name":"Stars","value":"🌠","encode":"&#x1f320"},{"name":"Partly sunny","value":"⛅","encode":"&#x26c5"},{"name":"Snowman","value":"⛄","encode":"&#x26c4"},{"name":"Cyclone","value":"🌀","encode":"&#x1f300"},{"name":"Foggy","value":"🌁","encode":"&#x1f301"},{"name":"Rainbow","value":"🌈","encode":"&#x1f308"},{"name":"Ocean","value":"🌊","encode":"&#x1f30a"}]},{"name":"Objects","emojis":[{"name":"Bamboo","value":"🎍","encode":"&#x1f38d"},{"name":"Dolls","value":"🎎","encode":"&#x1f38e"},{"name":"School satchel","value":"🎒","encode":"&#x1f392"},{"name":"Graduation Cap","value":"🎓","encode":"&#x1f393"},{"name":"Carp Streamer","value":"🎏","encode":"&#x1f38f"},{"name":"Fireworks","value":"🎆","encode":"&#x1f386"},{"name":"Sparkler","value":"🎇","encode":"&#x1f387"},{"name":"Wind chime","value":"🎐","encode":"&#x1f390"},{"name":"Rice scene","value":"🎑","encode":"&#x1f391"},{"name":"Jack o lantern","value":"🎃","encode":"&#x1f383"},{"name":"Christmas tree","value":"🎄","encode":"&#x1f384"},{"name":"Gift","value":"🎁","encode":"&#x1f381"},{"name":"Tanabata tree","value":"🎋","encode":"&#x1f38b"},{"name":"Tada","value":"🎉","encode":"&#x1f389"},{"name":"Confetti ball","value":"🎊","encode":"&#x1f38a"},{"name":"Balloon","value":"🎈","encode":"&#x1f388"},{"name":"Crossed flags","value":"🎌","encode":"&#x1f38c"},{"name":"Crystal ball","value":"🔮","encode":"&#x1f52e"},{"name":"Movie camera","value":"🎥","encode":"&#x1f3a5"},{"name":"Camera","value":"📷","encode":"&#x1f4f7"},{"name":"Video camera","value":"📹","encode":"&#x1f4f9"},{"name":"Vhs","value":"📼","encode":"&#x1f4fc"},{"name":"Cd","value":"💿","encode":"&#x1f4bf"},{"name":"Dvd","value":"📀","encode":"&#x1f4c0"},{"name":"Minidisc","value":"💽","encode":"&#x1f4bd"},{"name":"Floppy disk","value":"💾","encode":"&#x1f4be"},{"name":"Computer","value":"💻","encode":"&#x1f4bb"},{"name":"iPhone","value":"📱","encode":"&#x1f4f1"},{"name":"Telephone receiver","value":"📞","encode":"&#x1f4de"},{"name":"Pager","value":"📟","encode":"&#x1f4df"},{"name":"Fax","value":"📠","encode":"&#x1f4e0"},{"name":"Satellite","value":"📡","encode":"&#x1f4e1"},{"name":"Tv","value":"📺","encode":"&#x1f4fa"},{"name":"Radio","value":"📻","encode":"&#x1f4fb"},{"name":"Loud sound","value":"🔊","encode":"&#x1f50a"},{"name":"Bell","value":"🔔","encode":"&#x1f514"},{"name":"Loudspeaker","value":"📢","encode":"&#x1f4e2"},{"name":"Mega","value":"📣","encode":"&#x1f4e3"},{"name":"Hourglass flowing sand","value":"⏳","encode":"&#x23f3"},{"name":"Alarm clock","value":"⏰","encode":"&#x23f0"},{"name":"Unlock","value":"🔓","encode":"&#x1f513"},{"name":"Lock","value":"🔒","encode":"&#x1f512"},{"name":"Lock with ink pen","value":"🔏","encode":"&#x1f50f"},{"name":"Closed lock with key","value":"🔐","encode":"&#x1f510"},{"name":"Key","value":"🔑","encode":"&#x1f511"},{"name":"Right magnifying glass","value":"🔎","encode":"&#x1f50e"},{"name":"Bulb","value":"💡","encode":"&#x1f4a1"},{"name":"Flashlight","value":"🔦","encode":"&#x1f526"},{"name":"Electric plug","value":"🔌","encode":"&#x1f50c"},{"name":"Battery","value":"🔋","encode":"&#x1f50b"},{"name":"Left magnifying glass","value":"🔍","encode":"&#x1f50d"},{"name":"Bath","value":"🛀","encode":"&#x1f6c0"},{"name":"Toilet","value":"🚽","encode":"&#x1f6bd"},{"name":"Wrench","value":"🔧","encode":"&#x1f527"},{"name":"Nut and bolt","value":"🔩","encode":"&#x1f529"},{"name":"Hammer","value":"🔨","encode":"&#x1f528"},{"name":"Door","value":"🚪","encode":"&#x1f6aa"},{"name":"Smoking","value":"🚬","encode":"&#x1f6ac"},{"name":"Bomb","value":"💣","encode":"&#x1f4a3"},{"name":"Gun","value":"🔫","encode":"&#x1f52b"},{"name":"Hocho","value":"🔪","encode":"&#x1f52a"},{"name":"Pill","value":"💊","encode":"&#x1f48a"},{"name":"Syringe","value":"💉","encode":"&#x1f489"},{"name":"Moneybag","value":"💰","encode":"&#x1f4b0"},{"name":"Yen","value":"💴","encode":"&#x1f4b4"},{"name":"Dollar","value":"💵","encode":"&#x1f4b5"},{"name":"Credit card","value":"💳","encode":"&#x1f4b3"},{"name":"Money with wings","value":"💸","encode":"&#x1f4b8"},{"name":"Calling","value":"📲","encode":"&#x1f4f2"},{"name":"E mail","value":"📧","encode":"&#x1f4e7"},{"name":"Inbox tray","value":"📥","encode":"&#x1f4e5"},{"name":"Outbox tray","value":"📤","encode":"&#x1f4e4"},{"name":"Envelope with arrow","value":"📩","encode":"&#x1f4e9"},{"name":"Incoming envelope","value":"📨","encode":"&#x1f4e8"},{"name":"Mailbox","value":"📫","encode":"&#x1f4eb"},{"name":"Mailbox closed","value":"📪","encode":"&#x1f4ea"},{"name":"Postbox","value":"📮","encode":"&#x1f4ee"},{"name":"Package","value":"📦","encode":"&#x1f4e6"},{"name":"Memo","value":"📝","encode":"&#x1f4dd"},{"name":"Page facing up","value":"📄","encode":"&#x1f4c4"},{"name":"Page with curl","value":"📃","encode":"&#x1f4c3"},{"name":"Bookmark tabs","value":"📑","encode":"&#x1f4d1"},{"name":"Bar chart","value":"📊","encode":"&#x1f4ca"},{"name":"Chart with upwards trend","value":"📈","encode":"&#x1f4c8"},{"name":"Chart with downwards trend","value":"📉","encode":"&#x1f4c9"},{"name":"Scroll","value":"📜","encode":"&#x1f4dc"},{"name":"Clipboard","value":"📋","encode":"&#x1f4cb"},{"name":"Tear off Calendar","value":"📅","encode":"&#x1f4c5"},{"name":"Calendar","value":"📆","encode":"&#x1f4c6"},{"name":"Card index","value":"📇","encode":"&#x1f4c7"},{"name":"File folder","value":"📁","encode":"&#x1f4c1"},{"name":"Open file folder","value":"📂","encode":"&#x1f4c2"},{"name":"Pushpin","value":"📌","encode":"&#x1f4cc"},{"name":"Paperclip","value":"📎","encode":"&#x1f4ce"},{"name":"Straight ruler","value":"📏","encode":"&#x1f4cf"},{"name":"Triangular ruler","value":"📐","encode":"&#x1f4d0"},{"name":"Closed book","value":"📕","encode":"&#x1f4d5"},{"name":"Green book","value":"📗","encode":"&#x1f4d7"},{"name":"Blue book","value":"📘","encode":"&#x1f4d8"},{"name":"Orange book","value":"📙","encode":"&#x1f4d9"},{"name":"Notebook","value":"📓","encode":"&#x1f4d3"},{"name":"Notebook with decorative cover","value":"📔","encode":"&#x1f4d4"},{"name":"Ledger","value":"📒","encode":"&#x1f4d2"},{"name":"Books","value":"📚","encode":"&#x1f4da"},{"name":"Book","value":"📖","encode":"&#x1f4d6"},{"name":"Bookmark","value":"🔖","encode":"&#x1f516"},{"name":"Newspaper","value":"📰","encode":"&#x1f4f0"},{"name":"Artist Palette","value":"🎨","encode":"&#x1f3a8"},{"name":"Clapper","value":"🎬","encode":"&#x1f3ac"},{"name":"Microphone","value":"🎤","encode":"&#x1f3a4"},{"name":"Headphones","value":"🎧","encode":"&#x1f3a7"},{"name":"Musical score","value":"🎼","encode":"&#x1f3bc"},{"name":"Musical note","value":"🎵","encode":"&#x1f3b5"},{"name":"Notes","value":"🎶","encode":"&#x1f3b6"},{"name":"Musical keyboard","value":"🎹","encode":"&#x1f3b9"},{"name":"Violin","value":"🎻","encode":"&#x1f3bb"},{"name":"Trumpet","value":"🎺","encode":"&#x1f3ba"},{"name":"Saxophone","value":"🎷","encode":"&#x1f3b7"},{"name":"Guitar","value":"🎸","encode":"&#x1f3b8"},{"name":"Space invader","value":"👾","encode":"&#x1f47e"},{"name":"Video game","value":"🎮","encode":"&#x1f3ae"},{"name":"Flower playing cards","value":"🎴","encode":"&#x1f3b4"},{"name":"Game die","value":"🎲","encode":"&#x1f3b2"},{"name":"Dart","value":"🎯","encode":"&#x1f3af"},{"name":"Football","value":"🏈","encode":"&#x1f3c8"},{"name":"Basketball","value":"🏀","encode":"&#x1f3c0"},{"name":"Soccer","value":"⚽","encode":"&#x26bd"},{"name":"Baseball","value":"⚾","encode":"&#x26be"},{"name":"Tennis","value":"🎾","encode":"&#x1f3be"},{"name":"8ball","value":"🎱","encode":"&#x1f3b1"},{"name":"Bowling","value":"🎳","encode":"&#x1f3b3"},{"name":"Golf","value":"⛳","encode":"&#x26f3"},{"name":"Checkered flag","value":"🏁","encode":"&#x1f3c1"},{"name":"Trophy","value":"🏆","encode":"&#x1f3c6"},{"name":"Ski","value":"🎿","encode":"&#x1f3bf"},{"name":"Snowboarder","value":"🏂","encode":"&#x1f3c2"},{"name":"Swimmer","value":"🏊","encode":"&#x1f3ca"},{"name":"Surfer","value":"🏄","encode":"&#x1f3c4"},{"name":"Fishing pole and fish","value":"🎣","encode":"&#x1f3a3"},{"name":"Tea","value":"🍵","encode":"&#x1f375"},{"name":"Sake","value":"🍶","encode":"&#x1f376"},{"name":"Beer","value":"🍺","encode":"&#x1f37a"},{"name":"Beers","value":"🍻","encode":"&#x1f37b"},{"name":"Cocktail","value":"🍸","encode":"&#x1f378"},{"name":"Tropical drink","value":"🍹","encode":"&#x1f379"},{"name":"Wine glass","value":"🍷","encode":"&#x1f377"},{"name":"Fork and knife","value":"🍴","encode":"&#x1f374"},{"name":"Pizza","value":"🍕","encode":"&#x1f355"},{"name":"Hamburger","value":"🍔","encode":"&#x1f354"},{"name":"Fries","value":"🍟","encode":"&#x1f35f"},{"name":"Poultry leg","value":"🍗","encode":"&#x1f357"},{"name":"Meat on bone","value":"🍖","encode":"&#x1f356"},{"name":"Spaghetti","value":"🍝","encode":"&#x1f35d"},{"name":"Curry","value":"🍛","encode":"&#x1f35b"},{"name":"Fried shrimp","value":"🍤","encode":"&#x1f364"},{"name":"Bento","value":"🍱","encode":"&#x1f371"},{"name":"Sushi","value":"🍣","encode":"&#x1f363"},{"name":"Fish cake","value":"🍥","encode":"&#x1f365"},{"name":"Rice ball","value":"🍙","encode":"&#x1f359"},{"name":"Rice cracker","value":"🍘","encode":"&#x1f358"},{"name":"Rice","value":"🍚","encode":"&#x1f35a"},{"name":"Ramen","value":"🍜","encode":"&#x1f35c"},{"name":"Stew","value":"🍲","encode":"&#x1f372"},{"name":"Oden","value":"🍢","encode":"&#x1f362"},{"name":"Dango","value":"🍡","encode":"&#x1f361"},{"name":"Egg","value":"🍳","encode":"&#x1f373"},{"name":"Bread","value":"🍞","encode":"&#x1f35e"},{"name":"Doughnut","value":"🍩","encode":"&#x1f369"},{"name":"Custard","value":"🍮","encode":"&#x1f36e"},{"name":"Soft Ice cream","value":"🍦","encode":"&#x1f366"},{"name":"Ice cream","value":"🍨","encode":"&#x1f368"},{"name":"Shaved ice","value":"🍧","encode":"&#x1f367"},{"name":"Birthday Cake","value":"🎂","encode":"&#x1f382"},{"name":"Cake","value":"🍰","encode":"&#x1f370"},{"name":"Cookie","value":"🍪","encode":"&#x1f36a"},{"name":"Chocolate bar","value":"🍫","encode":"&#x1f36b"},{"name":"Candy","value":"🍬","encode":"&#x1f36c"},{"name":"Lollipop","value":"🍭","encode":"&#x1f36d"},{"name":"Honey pot","value":"🍯","encode":"&#x1f36f"},{"name":"Apple","value":"🍎","encode":"&#x1f34e"},{"name":"Green apple","value":"🍏","encode":"&#x1f34f"},{"name":"Tangerine","value":"🍊","encode":"&#x1f34a"},{"name":"Cherries","value":"🍒","encode":"&#x1f352"},{"name":"Grapes","value":"🍇","encode":"&#x1f347"},{"name":"Watermelon","value":"🍉","encode":"&#x1f349"},{"name":"Strawberry","value":"🍓","encode":"&#x1f353"},{"name":"Peach","value":"🍑","encode":"&#x1f351"},{"name":"Melon","value":"🍈","encode":"&#x1f348"},{"name":"Banana","value":"🍌","encode":"&#x1f34c"},{"name":"Pineapple","value":"🍍","encode":"&#x1f34d"},{"name":"Sweet potato","value":"🍠","encode":"&#x1f360"},{"name":"Eggplant","value":"🍆","encode":"&#x1f346"},{"name":"Tomato","value":"🍅","encode":"&#x1f345"},{"name":"Corn","value":"🌽","encode":"&#x1f33d"}]},{"name":"Places","emojis":[{"name":"House","value":"🏠","encode":"&#x1f3e0"},{"name":"House with garden","value":"🏡","encode":"&#x1f3e1"},{"name":"School","value":"🏫","encode":"&#x1f3eb"},{"name":"Office","value":"🏢","encode":"&#x1f3e2"},{"name":"Post office","value":"🏣","encode":"&#x1f3e3"},{"name":"Hospital","value":"🏥","encode":"&#x1f3e5"},{"name":"Bank","value":"🏦","encode":"&#x1f3e6"},{"name":"Convenience store","value":"🏪","encode":"&#x1f3ea"},{"name":"Love hotel","value":"🏩","encode":"&#x1f3e9"},{"name":"Hotel","value":"🏨","encode":"&#x1f3e8"},{"name":"Wedding","value":"💒","encode":"&#x1f492"},{"name":"Church","value":"⛪","encode":"&#x26ea"},{"name":"Department store","value":"🏬","encode":"&#x1f3ec"},{"name":"City sunrise","value":"🌇","encode":"&#x1f307"},{"name":"City sunset","value":"🌆","encode":"&#x1f306"},{"name":"Japanese castle","value":"🏯","encode":"&#x1f3ef"},{"name":"European castle","value":"🏰","encode":"&#x1f3f0"},{"name":"Tent","value":"⛺","encode":"&#x26fa"},{"name":"Factory","value":"🏭","encode":"&#x1f3ed"},{"name":"Tokyo tower","value":"🗼","encode":"&#x1f5fc"},{"name":"Japan","value":"🗾","encode":"&#x1f5fe"},{"name":"Mount fuji","value":"🗻","encode":"&#x1f5fb"},{"name":"Sunrise over mountains","value":"🌄","encode":"&#x1f304"},{"name":"Sunrise","value":"🌅","encode":"&#x1f305"},{"name":"Night with stars","value":"🌃","encode":"&#x1f303"},{"name":"Statue of liberty","value":"🗽","encode":"&#x1f5fd"},{"name":"Bridge at night","value":"🌉","encode":"&#x1f309"},{"name":"Carousel horse","value":"🎠","encode":"&#x1f3a0"},{"name":"Ferris wheel","value":"🎡","encode":"&#x1f3a1"},{"name":"Fountain","value":"⛲","encode":"&#x26f2"},{"name":"Roller coaster","value":"🎢","encode":"&#x1f3a2"},{"name":"Ship","value":"🚢","encode":"&#x1f6a2"},{"name":"Boat","value":"⛵","encode":"&#x26f5"},{"name":"Speedboat","value":"🚤","encode":"&#x1f6a4"},{"name":"Rocket","value":"🚀","encode":"&#x1f680"},{"name":"Seat","value":"💺","encode":"&#x1f4ba"},{"name":"Station","value":"🚉","encode":"&#x1f689"},{"name":"High speed train","value":"🚄","encode":"&#x1f684"},{"name":"Bullet train","value":"🚅","encode":"&#x1f685"},{"name":"Metro","value":"🚇","encode":"&#x1f687"},{"name":"Railway car","value":"🚃","encode":"&#x1f683"},{"name":"Bus","value":"🚌","encode":"&#x1f68c"},{"name":"Blue car","value":"🚙","encode":"&#x1f699"},{"name":"Car","value":"🚗","encode":"&#x1f697"},{"name":"Taxi","value":"🚕","encode":"&#x1f695"},{"name":"Truck","value":"🚚","encode":"&#x1f69a"},{"name":"Rotating light","value":"🚨","encode":"&#x1f6a8"},{"name":"Police car","value":"🚓","encode":"&#x1f693"},{"name":"Fire engine","value":"🚒","encode":"&#x1f692"},{"name":"Ambulance","value":"🚑","encode":"&#x1f691"},{"name":"Bike","value":"🚲","encode":"&#x1f6b2"},{"name":"Barber Pole","value":"💈","encode":"&#x1f488"},{"name":"Bus stop","value":"🚏","encode":"&#x1f68f"},{"name":"Ticket","value":"🎫","encode":"&#x1f3ab"},{"name":"Traffic light","value":"🚥","encode":"&#x1f6a5"},{"name":"Construction","value":"🚧","encode":"&#x1f6a7"},{"name":"Beginner","value":"🔰","encode":"&#x1f530"},{"name":"Fuelpump","value":"⛽","encode":"&#x26fd"},{"name":"Izakaya lantern","value":"🏮","encode":"&#x1f3ee"},{"name":"Slot machine","value":"🎰","encode":"&#x1f3b0"},{"name":"Moyai","value":"🗿","encode":"&#x1f5ff"},{"name":"Circus tent","value":"🎪","encode":"&#x1f3aa"},{"name":"Performing arts","value":"🎭","encode":"&#x1f3ad"},{"name":"Round pushpin","value":"📍","encode":"&#x1f4cd"},{"name":"Triangular flag on post","value":"🚩","encode":"&#x1f6a9"}]},{"name":"Symbols","emojis":[{"name":"Red heart","value":"❤️","encode":"&#x2764&#xfe0f"},{"name":"Yellow heart","value":"💛","encode":"&#x1f49b"},{"name":"Blue heart","value":"💙","encode":"&#x1f499"},{"name":"Purple heart","value":"💜","encode":"&#x1f49c"},{"name":"Green heart","value":"💚","encode":"&#x1f49a"},{"name":"Broken heart","value":"💔","encode":"&#x1f494"},{"name":"Heart exclamation","value":"❣️","encode":"&#x2763&#xfe0f"},{"name":"Two hearts","value":"💕","encode":"&#x1f495"},{"name":"Revolving hearts","value":"💞","encode":"&#x1f49e"},{"name":"Heartbeat","value":"💓","encode":"&#x1f493"},{"name":"Heartpulse","value":"💗","encode":"&#x1f497"},{"name":"Sparkling heart","value":"💖","encode":"&#x1f496"},{"name":"Cupid","value":"💘","encode":"&#x1f498"},{"name":"Gift heart","value":"💝","encode":"&#x1f49d"},{"name":"Heart decoration","value":"💟","encode":"&#x1f49f"},{"name":"Love letter","value":"💌","encode":"&#x1f48c"},{"name":"Dizzy","value":"💫","encode":"&#x1f4ab"},{"name":"Boom","value":"💥","encode":"&#x1f4a5"},{"name":"Anger","value":"💢","encode":"&#x1f4a2"},{"name":"Sweat drops","value":"💦","encode":"&#x1f4a6"},{"name":"Zzz","value":"💤","encode":"&#x1f4a4"},{"name":"Dash","value":"💨","encode":"&#x1f4a8"},{"name":"Hole","value":"🕳️","encode":"&#x1f573&#xfe0f"},{"name":"Peace symbol","value":"☮️","encode":"&#x262e&#xfe0f"},{"name":"Latin cross","value":"✝️","encode":"&#x271d&#xfe0f"},{"name":"Crescent and star","value":"☪️","encode":"&#x262a&#xfe0f"},{"name":"Om","value":"🕉️","encode":"&#x1f549&#xfe0f"},{"name":"Wheel of dharma","value":"☸️","encode":"&#x2638&#xfe0f"},{"name":"Star of david","value":"✡️","encode":"&#x2721&#xfe0f"},{"name":"Star with middle point","value":"🔯","encode":"&#x1f52f"},{"name":"Menorah","value":"🕎","encode":"&#x1f54e"},{"name":"Yin yang","value":"☯️","encode":"&#x262f&#xfe0f"},{"name":"Orthodox cross","value":"☦️","encode":"&#x2626&#xfe0f"},{"name":"Place of worship","value":"🛐","encode":"&#x1f6d0"},{"name":"Ophiuchus","value":"⛎","encode":"&#x26ce"},{"name":"Aries","value":"♈","encode":"&#x2648"},{"name":"Taurus","value":"♉","encode":"&#x2649"},{"name":"Gemini","value":"♊","encode":"&#x264a"},{"name":"Cancer","value":"♋","encode":"&#x264b"},{"name":"Leo","value":"♌","encode":"&#x264c"},{"name":"Virgo","value":"♍","encode":"&#x264d"},{"name":"Libra","value":"♎","encode":"&#x264e"},{"name":"Scorpius","value":"♏","encode":"&#x264f"},{"name":"Sagittarius","value":"♐","encode":"&#x2650"},{"name":"Capricorn","value":"♑","encode":"&#x2651"},{"name":"Aquarius","value":"♒","encode":"&#x2652"},{"name":"Pisces","value":"♓","encode":"&#x2653"},{"name":"Squared id","value":"🆔","encode":"&#x1f194"},{"name":"Atom","value":"⚛️","encode":"&#x269b&#xfe0f"},{"name":"Japanese vacancy button","value":"🈳","encode":"&#x1f233"},{"name":"Japanese discount button","value":"🈹","encode":"&#x1f239"},{"name":"Radioactive","value":"☢️","encode":"&#x2622&#xfe0f"},{"name":"Biohazard","value":"☣️","encode":"&#x2623&#xfe0f"},{"name":"Japanese not free of charge button","value":"🈶","encode":"&#x1f236"},{"name":"Japanese free of charge button","value":"🈚","encode":"&#x1f21a"},{"name":"Japanese application button","value":"🈸","encode":"&#x1f238"},{"name":"Japanese open for business button","value":"🈺","encode":"&#x1f23a"},{"name":"Japanese monthly amount","value":"🈷️","encode":"&#x1f237&#xfe0f"},{"name":"Eight pointed star","value":"✴️","encode":"&#x2734&#xfe0f"},{"name":"Vs button","value":"🆚","encode":"&#x1f19a"},{"name":"Japanese acceptable button","value":"🉑","encode":"&#x1f251"},{"name":"White flower","value":"💮","encode":"&#x1f4ae"},{"name":"Japanese bargain button","value":"🉐","encode":"&#x1f250"},{"name":"Japanese secret button","value":"㊙️","encode":"&#x3299&#xfe0f"},{"name":"Japanese congratulations button","value":"㊗️","encode":"&#x3297&#xfe0f"},{"name":"Japanese passing grade button","value":"🈴","encode":"&#x1f234"},{"name":"Japanese no vacancy button","value":"🈵","encode":"&#x1f235"},{"name":"Japanese prohibited button","value":"🈲","encode":"&#x1f232"},{"name":"Baby symbol","value":"🚼","encode":"&#x1f6bc"},{"name":"A group blood","value":"🅰️","encode":"&#x1f170&#xfe0f"},{"name":"B group blood","value":"🅱️","encode":"&#x1f171&#xfe0f"},{"name":"O group blood","value":"🅾️","encode":"&#x1f17e&#xfe0f"},{"name":"Cl button","value":"🆑","encode":"&#x1f191"},{"name":"Sos button","value":"🆘","encode":"&#x1f198"},{"name":"No entry","value":"⛔","encode":"&#x26d4"},{"name":"Name badge","value":"📛","encode":"&#x1f4db"},{"name":"Heavy circle","value":"⭕","encode":"&#x2b55"},{"name":"Prohibited","value":"🚫","encode":"&#x1f6ab"},{"name":"Muted","value":"🔇","encode":"&#x1f507"},{"name":"Bell with slash","value":"🔕","encode":"&#x1f515"},{"name":"No smoking","value":"🚭","encode":"&#x1f6ad"},{"name":"No pedestrains","value":"🚷","encode":"&#x1f6b7"},{"name":"No littering","value":"🚯","encode":"&#x1f6af"},{"name":"No bicycle","value":"🚳","encode":"&#x1f6b3"},{"name":"Non potable water","value":"🚱","encode":"&#x1f6b1"},{"name":"No one under 18","value":"🔞","encode":"&#x1f51e"},{"name":"No mobile phones","value":"📵","encode":"&#x1f4f5"},{"name":"Exclamation mark","value":"❗","encode":"&#x2757"},{"name":"White exclamation mark","value":"❕","encode":"&#x2755"},{"name":"Question mark","value":"❓","encode":"&#x2753"},{"name":"White question mark","value":"❔","encode":"&#x2754"},{"name":"Hundred points","value":"💯","encode":"&#x1f4af"},{"name":"Dim button","value":"🔅","encode":"&#x1f505"},{"name":"Bright button","value":"🔆","encode":"&#x1f506"},{"name":"Trident","value":"🔱","encode":"&#x1f531"},{"name":"Fleur de lis","value":"⚜️","encode":"&#x269c&#xfe0f"},{"name":"Part alternation mark","value":"〽️","encode":"&#x303d&#xfe0f"},{"name":"Warning","value":"⚠️","encode":"&#x26a0&#xfe0f"},{"name":"Children crossing","value":"🚸","encode":"&#x1f6b8"},{"name":"Japanese beginner button","value":"🔰","encode":"&#x1f530"},{"name":"Recycling","value":"♻️","encode":"&#x267b&#xfe0f"},{"name":"Japanese reserved button","value":"🈯","encode":"&#x1f22f"},{"name":"Chart increasing with yen","value":"💹","encode":"&#x1f4b9"},{"name":"Sparkle","value":"❇️","encode":"&#x2747&#xfe0f"},{"name":"Eight spoked asterisk","value":"✳️","encode":"&#x2733&#xfe0f"},{"name":"White heavy check mark","value":"✅","encode":"&#x2705"},{"name":"Cross mark","value":"❌","encode":"&#x274c"},{"name":"Diamond with dot","value":"💠","encode":"&#x1f4a0"},{"name":"Globe with meridians","value":"🌐","encode":"&#x1f310"},{"name":"Circled m","value":"Ⓜ️","encode":"&#x24c2&#xfe0f"},{"name":"Japanese service charge button","value":"🈂️","encode":"&#x1f202&#xfe0f"},{"name":"Double curly loop","value":"➿","encode":"&#x27bf"},{"name":"Passport control","value":"🛂","encode":"&#x1f6c2"},{"name":"Customs","value":"🛃","encode":"&#x1f6c3"},{"name":"Baggage claim","value":"🛄","encode":"&#x1f6c4"},{"name":"Left luggage","value":"🛅","encode":"&#x1f6c5"},{"name":"Wheel chair","value":"♿","encode":"&#x267f"},{"name":"Water closet","value":"🚾","encode":"&#x1f6be"},{"name":"P button","value":"🅿️","encode":"&#x1f17f&#xfe0f"},{"name":"Potable water","value":"🚰","encode":"&#x1f6b0"},{"name":"Men room","value":"🚹","encode":"&#x1f6b9"},{"name":"Women room","value":"🚺","encode":"&#x1f6ba"},{"name":"Restroom","value":"🚻","encode":"&#x1f6bb"},{"name":"Litter in bin","value":"🚮","encode":"&#x1f6ae"},{"name":"Antenna bars","value":"📶","encode":"&#x1f4f6"},{"name":"Japanese here button","value":"🈁","encode":"&#x1f201"},{"name":"Ng button","value":"🆖","encode":"&#x1f196"},{"name":"Ok button","value":"🆗","encode":"&#x1f197"},{"name":"Up button","value":"🆙","encode":"&#x1f199"},{"name":"Cool button","value":"🆒","encode":"&#x1f192"},{"name":"New button","value":"🆕","encode":"&#x1f195"},{"name":"Free button","value":"🆓","encode":"&#x1f193"},{"name":"Input number","value":"🔢","encode":"&#x1f522"},{"name":"Pause button","value":"⏸️","encode":"&#x23f8&#xfe0f"},{"name":"Pause or play button","value":"⏯️","encode":"&#x23ef&#xfe0f"},{"name":"Stop button","value":"⏹️","encode":"&#x23f9&#xfe0f"},{"name":"Record button","value":"⏺","encode":"&#x23fa"},{"name":"Next track button","value":"⏭️","encode":"&#x23ed&#xfe0f"},{"name":"Last track button","value":"⏮️","encode":"&#x23ee&#xfe0f"},{"name":"Fast forward","value":"⏩","encode":"&#x23e9"},{"name":"Fast reverse","value":"⏪","encode":"&#x23ea"},{"name":"Shuffle tracks button","value":"🔀","encode":"&#x1f500"},{"name":"Repeat button","value":"🔁","encode":"&#x1f501"},{"name":"Repeat once button","value":"🔂","encode":"&#x1f502"},{"name":"Reverse button","value":"◀️","encode":"&#x25c0&#xfe0f"},{"name":"Fast up button","value":"⏫","encode":"&#x23eb"},{"name":"Fast down button","value":"⏬","encode":"&#x23ec"},{"name":"Right arrow","value":"➡️","encode":"&#x27a1&#xfe0f"},{"name":"Left arrow","value":"⬅️","encode":"&#x2b05&#xfe0f"},{"name":"Up arrow","value":"⬆️","encode":"&#x2b06&#xfe0f"},{"name":"Down arrow","value":"⬇️","encode":"&#x2b07&#xfe0f"},{"name":"Up right arrow","value":"↗️","encode":"&#x2197&#xfe0f"},{"name":"Down left arrow","value":"↙️","encode":"&#x2199&#xfe0f"},{"name":"Counter clockwise arrows","value":"🔄","encode":"&#x1f504"},{"name":"Left arrow curving right","value":"↪️","encode":"&#x21aa&#xfe0f"},{"name":"Right arrow curving left","value":"↩️","encode":"&#x21a9&#xfe0f"},{"name":"Right arrow curving up","value":"⤴️","encode":"&#x2934&#xfe0f"},{"name":"Right arrow curving down","value":"⤵️","encode":"&#x2935&#xfe0f"},{"name":"Input latin letters","value":"🔤","encode":"&#x1f524"},{"name":"Input latin lowercase","value":"🔡","encode":"&#x1f521"},{"name":"Input latin uppercase","value":"🔠","encode":"&#x1f520"},{"name":"Input symbols","value":"🔣","encode":"&#x1f523"},{"name":"Play button","value":"▶️","encode":"&#x25b6&#xfe0f"},{"name":"Eject button","value":"⏏️","encode":"&#x23cf&#xfe0f"},{"name":"Down right arrow","value":"↘️","encode":"&#x2198&#xfe0f"},{"name":"Up left arrow","value":"↖️","encode":"&#x2196&#xfe0f"},{"name":"Clockwise vertical arrows","value":"🔃","encode":"&#x1f503"},{"name":"On arrow","value":"🔛","encode":"&#x1f51b"},{"name":"Top arrow","value":"🔝","encode":"&#x1f51d"},{"name":"Soon arrow","value":"🔜","encode":"&#x1f51c"},{"name":"Ballot box with check","value":"☑️","encode":"&#x2611&#xfe0f"},{"name":"End arrow","value":"🔚","encode":"&#x1f51a"},{"name":"Back arrow","value":"🔙","encode":"&#x1f519"},{"name":"Wavy dash","value":"〰️","encode":"&#x3030&#xfe0f"},{"name":"Curly loop","value":"➰","encode":"&#x27b0"},{"name":"Heavy check mark","value":"✔️","encode":"&#x2714&#xfe0f"},{"name":"Heavy dollar sign","value":"💲","encode":"&#x1f4b2"},{"name":"Currency exchange","value":"💱","encode":"&#x1f4b1"},{"name":"Heavy plus sign","value":"➕","encode":"&#x2795"},{"name":"Heavy minus sign","value":"➖","encode":"&#x2796"},{"name":"Heavy multiplication sign","value":"✖️","encode":"&#x2716&#xfe0f"},{"name":"Heavy division sign","value":"➗","encode":"&#x2797"},{"name":"Copyright","value":"©️","encode":"&#xa9&#xfe0f"},{"name":"Registered","value":"®️","encode":"&#xae&#xfe0f"},{"name":"Trade mark","value":"™️","encode":"&#x2122&#xfe0f"},{"name":"Radio button","value":"🔘","encode":"&#x1f518"},{"name":"White circle","value":"⚪","encode":"&#x26aa"},{"name":"Black circle","value":"⚫","encode":"&#x26ab"},{"name":"Red circle","value":"🔴","encode":"&#x1f534"},{"name":"Blue circle","value":"🔵","encode":"&#x1f535"},{"name":"Small orange diamond","value":"🔸","encode":"&#x1f538"},{"name":"Small blue diamond","value":"🔹","encode":"&#x1f539"},{"name":"Large orange diamond","value":"🔶","encode":"&#x1f536"},{"name":"Large blue diamond","value":"🔷","encode":"&#x1f537"},{"name":"Red triangle pointed up","value":"🔺","encode":"&#x1f53a"},{"name":"Red triangle pointed down","value":"🔻","encode":"&#x1f53b"},{"name":"Upwards button","value":"🔼","encode":"&#x1f53c"},{"name":"Downwards button","value":"🔽","encode":"&#x1f53d"},{"name":"Black medium small square","value":"◾","encode":"&#x25fe"},{"name":"White medium small square","value":"◽","encode":"&#x25fd"},{"name":"Black large square","value":"⬛","encode":"&#x2b1b"},{"name":"White large square","value":"⬜","encode":"&#x2b1c"},{"name":"Black medium square","value":"◼️","encode":"&#x25fc&#xfe0f"},{"name":"White medium square","value":"◻️","encode":"&#x25fb&#xfe0f"},{"name":"Black small square","value":"▪️","encode":"&#x25aa&#xfe0f"},{"name":"White small square","value":"▫️","encode":"&#x25ab&#xfe0f"},{"name":"Black square button","value":"🔳","encode":"&#x1f533"},{"name":"White square button","value":"🔲","encode":"&#x1f532"},{"name":"Twelve o clock","value":"🕛","encode":"&#x1f55b"},{"name":"Twelve thirty","value":"🕧","encode":"&#x1f567"},{"name":"One o clock","value":"🕐","encode":"&#x1f550"},{"name":"One thirty","value":"🕜","encode":"&#x1f55c"},{"name":"Two o clock","value":"🕑","encode":"&#x1f551"},{"name":"Two thirty","value":"🕝","encode":"&#x1f55d"},{"name":"Three o clock","value":"🕒","encode":"&#x1f552"},{"name":"Three thirty","value":"🕞","encode":"&#x1f55e"},{"name":"Four o clock","value":"🕓","encode":"&#x1f553"},{"name":"Four thirty","value":"🕟","encode":"&#x1f55f"},{"name":"Five o clock","value":"🕔","encode":"&#x1f554"},{"name":"Five thirty","value":"🕠","encode":"&#x1f560"},{"name":"Six o clock","value":"🕕","encode":"&#x1f555"},{"name":"Six thirty","value":"🕡","encode":"&#x1f561"},{"name":"Seven o clock","value":"🕖","encode":"&#x1f556"},{"name":"Seven thirty","value":"🕢","encode":"&#x1f562"},{"name":"Eight o clock","value":"🕗","encode":"&#x1f557"},{"name":"Eight thirty","value":"🕣","encode":"&#x1f563"},{"name":"Nine o clock","value":"🕘","encode":"&#x1f558"},{"name":"Nine thirty","value":"🕤","encode":"&#x1f564"},{"name":"Ten o clock","value":"🕙","encode":"&#x1f559"},{"name":"Ten thirty","value":"🕥","encode":"&#x1f565"},{"name":"Eleven o clock","value":"🕚","encode":"&#x1f55a"},{"name":"Eleven thirty","value":"🕦","encode":"&#x1f566"}]}] } ),
			ltPropTooltipConfig : Lyte.attr( 'string', { default : '{}' } ),
			ltPropSearch : Lyte.attr( 'boolean', { default : true } ),
			ltPropCaseSensitive : Lyte.attr( 'boolean',{ default : false }),
			ltPropDiacritic : Lyte.attr( 'boolean', { default : false }),
			ltPropTrim : Lyte.attr( 'boolean', { default : false } ),
			ltPropMethod : Lyte.attr( 'string', { default : "indexOf" }),
			ltPropNoMatchText : Lyte.attr( 'string', { default : "No results matched your search" }),

			ltPropInput : Lyte.attr( 'object', { default : { type : "search", placeholder : "Search Emoji", closeIcon : true, appearance : "box" } } ),


			// system 
			value : Lyte.attr( 'string', { default : '' }),
			showNoResult : Lyte.attr( 'boolean', { default : false })
		}
	},

	actions : {
		click : function( obj ){
			var cb = 'onEmojiSelect';
			if( this.getMethods( cb ) ){
				this.executeMethod( cb, obj );
			}
		},

		input : function( evt ){
			this.$node.resetValue( evt.target.value );
		}
	},

	value_obs : function( arg ){
		this.perfromSearch( arg.newValue );
	}.observes( 'value' ),

	didConnect : function(){

		if( this.data.ltPropSearch ){
			this.$node.resetValue = function( value ){
				// reset actual scrollbale element;
				this.$node.scrollTop = 0;
				this.setData( 'value', value || "" );
			}.bind( this );
		}
	},

	perfromSearch : function( value ){
		var wrapper = $L( '.lyteEmojiWrapper', this.$node ).get( 0 ),
		cls_name = 'lyteEmojiHidden',
		case_sen = this.data.ltPropCaseSensitive,
		dia = this.data.ltPropDiacritic,
		method = this.data.ltPropMethod,
		trim = this.data.ltPropTrim,
		_this = this,
		outer_count = 0,
		_child = wrapper.children,

		fn = function( value ){
			if( !case_sen ){
				value = value.toLowerCase();
			}

			if( dia ){
				value = _lyteUiUtils.convert_diacritics( value );
			} 

			if( trim ){
				value = value.trim();
			}

			return value;
		}

		value = fn( value );

		this.data.ltPropEmoji.forEach( function( item, index ){
			var grp = _child[ index ],
			count = 0,
			grp_child = grp.children,
			to_hide;

			item.emojis.forEach( function( emoji, e_index ){
				var $emoji = $L( grp_child[ e_index ] ),
				e_value = fn( emoji.name ),
				prop = 'remove';

				if( _this.isNot( e_value, value, method ) ){
					prop = 'add';
					count++;
				} 

				$emoji[ prop + 'Class' ]( cls_name );
			});

			to_hide = count == grp_child.length;

			$L( grp )[ ( to_hide ? 'add' : 'remove' ) + 'Class' ]( cls_name );
			
			to_hide ? outer_count++ : 0;
		});

		this.setData( 'showNoResult', _child.length - 1 == outer_count );
	},

	isNot : function( e_value, value, method ){

		if( e_value[ method ] ){
			return e_value[ method ]( value ) == -1;
		}

		var index = e_value.indexOf( value );

		if( method == 'startsWith' ){
			return index != 0;
		}

		var len = value.length;

		return ( index + len ) != len;
	}
});
Lyte.Component.register("lyte-voicenote", {
_template:"<template tag-name=\"lyte-voicenote\"> <span class=\"lyteVoiceNotePausePlayIcon {{state}}\" onclick=\"{{action('toggle')}}\"></span> <template is=\"if\" value=\"{{ltPropVolCtrlEnabled}}\"><template case=\"true\"> <div class=\"lyteVoiceNoteVolumeController\"> <span class=\"lyteVoiceNoteVolumeIcon\" onclick=\"{{action('onMute')}}\"></span> <div class=\"lyteVoiceNoteVolumeSlider\"> <lyte-multislider lt-prop-max=\"1\" lt-prop-fill-color=\"#ddd\" lt-prop-height=\"5px\" lt-prop-yield=\"true\" lt-prop-width=\"60px\" lt-prop-handler=\"lyteCircle\" lt-prop-value=\"[ { &quot;value&quot; : {{ltPropVolume}}, &quot;min&quot; : 0, &quot;max&quot; : 1 } ]\" on-change=\"{{method('setVolume')}}\" lt-prop-color=\"[&quot;#61A6E8&quot; ]\"></lyte-multislider> </div> </div> </template></template> <audio onpause=\"{{action('pause')}}\" onplay=\"{{action('play')}}\" onvolumechange=\"{{action('changeVolume',event)}}\" onloadedmetadata=\"{{action('meta',event)}}\" ontimeupdate=\"{{action('update',event)}}\"> <source src=\"{{ltPropSrc}}\" type=\"audio/mpeg\"> </audio> <div class=\"lyteVoiceNoteProgress\" tabindex=\"0\" onkeydown=\"{{action('keydown',event)}}\" onclick=\"{{action('progressClick',event)}}\"> <span class=\"lyteVoiceNoteCompletion\"></span> <span class=\"lyteVoiceNoteHandler\" lt-prop-tooltip-class=\"lyteVoiceNoteTooltip\" onmousedown=\"{{action('mousedown',event)}}\" lt-prop-title=\"{{elapsedTime}}\" lt-prop-tooltip-config=\"{&quot;showdelay&quot;:500,&quot;hidedelay&quot; : 500, &quot;position&quot; : &quot;bottom&quot;}\"></span> </div> <time class=\"lyteVoiceNoteElapsedTime\" datetime=\"{{elapsedFormat}}\">{{elapsedTime}}</time> <time class=\"lyteVoiceNoteDurationSpan\" datetime=\"{{datetimeFormat}}\">{{duration}}</time> </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3,1]},{"type":"componentDynamic","position":[1,3,1]}]}},"default":{}},{"type":"attr","position":[5]},{"type":"attr","position":[5,1]},{"type":"attr","position":[7]},{"type":"attr","position":[7,3]},{"type":"attr","position":[9]},{"type":"text","position":[9,0]},{"type":"attr","position":[11]},{"type":"text","position":[11,0]}],
_observedAttributes :["ltPropSrc","ltPropVolCtrlEnabled","ltPropVolume","state","duration","datetimeFormat","elapsedTime","elapsedFormat"],

	didConnect : function(){
		this._audio = this.$node.querySelector( "audio" );
		this._hander = this.$node.getElementsByClassName( "lyteVoiceNoteHandler" )[ 0 ];
		this._completion = this._hander.previousElementSibling;
		this._defaultVolume = 0.5;
		if(this.getData("ltPropVolCtrlEnabled"))
		{
			this._slider = this.$node.querySelector( ".lyteVoiceNoteVolumeSlider").firstElementChild;
			this._volIcon = this.$node.querySelector('.lyteVoiceNoteVolumeIcon');
		}
	},

	didDestroy : function(){
		delete this._audio;
		delete this._hander;
		delete this._completion;
		delete this._defaultVolume;
		delete this._slider;
		delete this._volIcon;
	},

	left : function(){
		return _lyteUiUtils.getRTL() ? "right" : "left";
	},

	data : function(){
		return {
			ltPropSrc : Lyte.attr( "string" ),
			ltPropVolCtrlEnabled : Lyte.attr( "boolean", { default : false}),
			ltPropVolume : Lyte.attr( "number", { default : 1}),
			// system data

			state : Lyte.attr( "string", { default : "paused" } ),
			duration : Lyte.attr( "string", { default : "0.00" } ),
			datetimeFormat : Lyte.attr( "string", { default : "" } ),
			elapsedTime : Lyte.attr( "string", { default : "" } ),
			elapsedFormat : Lyte.attr( "string", { default : "" } )
		}		
	},
	// init: function(){
	// 	this.setData("ltPropVolume","1");
	// },
	read_duration : function( sec_check ){
		var abs = Math.round( sec_check ),
		secs = abs % 60,
		mins_check = parseInt( abs / 60 ),
		mins = mins_check % 60,
		hrs = parseInt( mins_check / 60 );

		return{
			sec : secs,
			min : mins,
			hr : hrs
		};
	},

	display_format : function( arg, obj ){
		var str = '';

		[ 'hr', 'min', 'sec' ].forEach( function( item ){
			var _value = arg[ item ];
			if( _value ){
				str += ( _value + ( obj[ item ] || '.' ) );
			}
		});

		str = str.replace( /\.$/, '' );

		if( !obj.hr ){
			if( str.indexOf( '.' ) == -1 ){
				str = "0." + str;
			}
		}

		return str;
	},

	update_time : function( evt ){
		var elem = evt.target,
		bcr = this._bcr || elem.getBoundingClientRect(),
		left = this.left(),
		width = bcr.width,
		diff = Math.min( Math.abs( evt.clientX - bcr[ left ] ), width ),
		audio = this._audio,
		duration = audio.duration;

		audio.currentTime = Math.max( 0, Math.min( duration - 1, ( duration * ( diff / width ) ).toFixed( 2 ) ) ); 
	},

	mousemove : function( ev ){
		var touches = ev.touches || [],
		length = touches.length,
		evt = touches[ 0 ] || ev;

		if( length > 1 ){
			return;
		}

		if( length ){
			ev.preventDefault();
		}

		var bcr = this._bcr,
		clientX = Math.min( Math.max( bcr.left, evt.clientX ), bcr.right ),
		node = this._hander,
		tooltip = node.tooltip;

		if( tooltip && tooltip.refresh ){
            tooltip.refresh( { clientX : evt.clientX }, tooltip.tooltipSpan );
        }

		this.update_time( { clientX : clientX } );

	},

	mouseup : function( evt ){

		var isTch = ( evt.touches || [] ).length;

		this.bind_evt( 'removeEventListener', isTch );
		if( this._downstate ){
			this.play();
		}

		delete this._move;
		delete this._up;
		delete this._bcr;
		delete this._downstate;
	},

	bind_evt : function( fn, isTch ){
		var doc = document;

		doc[ fn ]( isTch ? 'touchmove' : 'mousemove', this._move, true );
		doc[ fn ]( isTch ? 'touchend' : 'mouseup', this._up, true );
	},

	set_format : function( time, name1, name2 ){
		var format = this.read_duration( time );

		this.setData( name1, this.display_format( format, {} ) );
		this.setData( name2, "PT" + this.display_format( format, { hr : "H", min : "M", sec : "S" } ) );
	},

	play : function(){
		var audio = this._audio,
		_this = this,
		fn = function(){
			delete _this._happening;
			var final = _this._final,
			cb = 'onPlay';
			_this.getMethods( cb ) && _this.executeMethod( cb, _this.$node );

			if( final ){
				delete _this._final;
				_this[ final ]();
			}
		};

		if( this._happening ){
			this._final = 'play';
		} else if( audio.paused ){
			this._happening = true;
			audio.play().then( fn ).catch( fn );
		}
	},

	pause : function(){
		if( this._happening ){
			this._final = 'pause';
		} else {
			this._audio.pause();
			var cb = 'onPause';
			this.getMethods( cb ) && this.executeMethod( cb, this.$node );
		}
	},


	actions : {

		keydown : function( evt ){
			var keycode = evt.which || evt.keyCode,
			audio = this._audio,
			duration = audio.duration,
			currentTime = audio.currentTime;

			if( !/^3(7|9)$/.test( keycode ) ){
				return;
			}

			evt.preventDefault();

			this._state = !audio.paused;

			this.pause();

			audio.currentTime = Math.max( 0, Math.min( duration - 1, currentTime + ( 5 * ( keycode == 37 ? -1 : 1 ) ) ) );
		},

		pause : function(){
			this.setData( "state", "paused" );
			return false;
		},

		play : function(){
			this.setData( "state", "" );
			return false;
		},

		mousedown : function( ev ){

			var touches = ev.touches || [],
			length = touches.length,
			isTch = length != 0,
			evt = touches[ 0 ] || ev,
			audio = this._audio;

			if( length > 1 ){
				return;
			}

			if( this._downstate = !audio.paused ){
				this.pause();
			}

			this._move = this.mousemove.bind( this );
			this._up = this.mouseup.bind( this );
			this._bcr = evt.target.parentNode.getBoundingClientRect();

			this.bind_evt( "addEventListener", isTch );
			ev.preventDefault();

		},

		progressClick : function( evt ){
			var elem = evt.target;
			if( elem == this._hander ){
				return;
			}
			var audio = this._audio;

			this._state = !audio.paused;

			this.pause();

			this.update_time( evt );
		},

		meta : function( evt ){
			var audio = this._audio;
			if( !audio ){
				return false;
			}
			var duration = audio.duration;
			this.set_format( duration, 'duration', 'datetimeFormat' );

			return false;
		},

		toggle : function(){
			var audio = this._audio,
			fn = "pause";

			if( audio.paused ){
				fn = "play";
			}

			this[ fn ]();
			return false;
		},

		update : function( evt ){
			var audio = this._audio,
			time = audio.currentTime,
			duration = audio.duration,
			handle = this._hander,
			tooltip = handle.tooltip;

			if( isNaN( duration ) ){
				return;
			}

			if( tooltip && tooltip.refresh ){
				tooltip.refresh( {}, tooltip.tooltipSpan );
			}

			handle.style[ this.left() ] = this._completion.style.width = ( time / duration * 100 ) + '%';

			$L( this.$node )[ ( audio.ended ? 'add' : "remove" ) + "Class" ]( "lyteVoiceNoteCompleted" );

			if( this._state ){
				this.play();
			}
			delete this._state;

			this.set_format( time, 'elapsedTime', 'elapsedFormat' );

			this.getMethods('onProgress') && this.executeMethod( 'onProgress', audio, time, duration, evt,this.$node);
		},

		onMute : function(){
			var audio = this._audio;

			audio.muted = !audio.muted
		},

		changeVolume : function( evt )
		{
			var audio = this._audio;

			if(audio.volume > 0 && this._volIcon.classList.contains('lyteVoiceNoteMuteIcon') )
			{
				this._volIcon.classList.remove('lyteVoiceNoteMuteIcon');
				audio.muted = false;
				this.setData("ltPropVolume",audio.volume);
			}
			else if(!audio.muted && audio.volume == 0)
			{
				audio.volume = this._defaultVolume;
				this.setData("ltPropVolume",this._defaultVolume);
			}
			else if(audio.muted)
			{
				this._volIcon.classList.add('lyteVoiceNoteMuteIcon');
				this.setData("ltPropVolume",0);
			}

			this.getMethods('onVolumeChange') && this.executeMethod( 'onVolumeChange', audio, evt ,this.$node);
		}

	},
	methods : {
		setVolume : function (  handlerIndex , currentValue, event, MultiSliderElement  ) 
		{
			var audio = this._audio;
			
			if(currentValue.value == 0)
			{
				audio.muted = true;	
			}
			audio.volume = currentValue.value;
		}
	}
});
 ;(function(windows){
 	
 	lyteDomObj.prototype.placement = function( config ) {
		var elem = this.get(0);
		appendElement( config , elem );
		if( config.originElement ) {
			alignWithOriginElement( config , elem );						
		}else{
			alignWithWindow( config , elem );
		}			
	}

	function alterElementPosition( alterposition , elem ){
		if( alterposition ){
			elem.style.left = elem.offsetLeft + alterposition.left + 'px';
			elem.style.top = elem.offsetTop + alterposition.top + 'px';
		}
	}
			
	function appendElement( config , elem ){
		var appendto;
		elem.style.position = 'absolute';
		if( config.appendTo ){
			appendto = document.querySelector( config.appendTo );
			if( appendto == undefined ){
				appendto = $L('body').get(0);
			}
		}else{
			appendto = document.getElementsByTagName('body')[0];
		}
			appendto.appendChild(elem);
	}

	function alignRight( origin_elem , elem ){
		var actualposition = origin_elem.getBoundingClientRect().right;
		if( isWindowLeftExceeded( actualposition , elem ) ){
			elem.style.left = actualposition + "px";
		}else{
			elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + "px";
		}
		FixElementTop( origin_elem , elem);
	}
			
	function alignLeft( origin_elem , elem ){
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		if( canElementFitLeft( leftBoundary ) ){
			elem.style.left = leftBoundary + "px";
		}else{
			elem.style.left = origin_elem.getBoundingClientRect().right + "px";
		}
		FixElementTop( origin_elem , elem);

	}
	
	function alignTop( origin_elem , elem ){
		var topBoundary =  origin_elem.offsetTop - elem.offsetHeight;
		fixElementLeft( origin_elem , elem );
		if( canElementFitAbove( topBoundary ) ){
			elem.style.top = topBoundary + 'px';
		}else{
			elem.style.top = origin_elem.getBoundingClientRect().bottom + 'px';
		}

	}
	
	function alignBottom( origin_elem , elem ){
		var actual_top = origin_elem.getBoundingClientRect().bottom;
		fixElementLeft( origin_elem , elem );
		if( isWindowTopExceeded( actual_top , elem ) ){
			elem.style.top = actual_top + 'px';
		}else{
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
	}

	function alignBottomRight( origin_elem , elem ){
		var topBoundary = origin_elem.offsetTop - elem.offsetHeight;
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		var actual_left = origin_elem.getBoundingClientRect().right;
		var actual_top = origin_elem.getBoundingClientRect().bottom;
		if( isWindowTopExceeded( actual_top , elem ) || !canElementFitAbove( topBoundary ) ) {
			elem.style.top = actual_top + 'px';
		}
		else {
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
		if( isWindowLeftExceeded( actual_left , elem ) || !canElementFitLeft( leftBoundary ) ){
			elem.style.left = actual_left + 'px';
		}else{
			elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + 'px';
		}
	}

	function alignTopRight( origin_elem , elem ){
		var topBoundary = origin_elem.offsetTop - elem.offsetHeight;
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		var left = origin_elem.getBoundingClientRect().right;
		var top = origin_elem.getBoundingClientRect().bottom;
		if( canElementFitAbove( topBoundary ) || !isWindowTopExceeded( top , elem ) ){
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
		else{
			elem.style.top = top + 'px';
		}
		if( isWindowLeftExceeded( left , elem ) || !canElementFitLeft( leftBoundary ) ){
			elem.style.left = left + 'px';
		}
		else{
			elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + 'px';
		}
	}
	
	function alignTopLeft( origin_elem , elem ){
		
		var topBoundary = origin_elem.offsetTop - elem.offsetHeight;
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		var left = origin_elem.getBoundingClientRect().right;
		var top = origin_elem.getBoundingClientRect().bottom;
		if( canElementFitAbove( topBoundary ) || !isWindowTopExceeded( top , elem ) ){
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
		else{
			elem.style.top = top + 'px';
		}
		if( !isWindowLeftExceeded( left , elem ) || canElementFitLeft( leftBoundary ) ){
			elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + 'px';
		}else{
			elem.style.left = origin_elem.getBoundingClientRect().right + 'px';
		}
	}
	
	function alignBottomLeft( origin_elem , elem ){
		
		var topBoundary = origin_elem.offsetTop - elem.offsetHeight;
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		var actual_left = origin_elem.getBoundingClientRect().right;
		var actual_top = origin_elem.getBoundingClientRect().bottom;
		if( isWindowTopExceeded( actual_top , elem ) || !canElementFitAbove( topBoundary ) ) {
			elem.style.top = actual_top + 'px';
		}
		else {
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
		if( !isWindowLeftExceeded( actual_left , elem ) || canElementFitLeft( leftBoundary ) ){
			elem.style.left = leftBoundary + 'px';
		}else{
			elem.style.left = actual_left + 'px';
		}
	}

	function alignTopCenter( origin_elem , elem ){
		var topBoundary =  origin_elem.offsetTop - elem.offsetHeight;
		elem.style.left = origin_elem.offsetLeft + origin_elem.offsetWidth/2 - elem.offsetWidth/2 + "px";
		if( canElementFitAbove( topBoundary ) ){
			elem.style.top = topBoundary + 'px';
		}else{
			elem.style.top = origin_elem.getBoundingClientRect().bottom + 'px';
		}
	}
	
	function alignBottomCenter( origin_elem , elem ){
		var actual_top =  origin_elem.getBoundingClientRect().bottom;
		elem.style.left = origin_elem.offsetLeft + origin_elem.offsetWidth/2 - elem.offsetWidth/2 + "px";
		if( isWindowTopExceeded( actual_top , elem ) ){
			elem.style.top = actual_top + 'px';
		}else{
			elem.style.top = origin_elem.offsetTop - elem.offsetHeight + 'px';
		}
	}
	
	function alignCenterRight( origin_elem , elem ){
		var actual_left =  origin_elem.getBoundingClientRect().right;
		if( isWindowLeftExceeded( actual_left , elem ) ){
			elem.style.left = actual_left + "px";
		}else{
			elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + "px";
		}
		FixElementTopCenter( origin_elem , elem );

	}
	function alignCenter( origin_elem , elem ){
		var center = origin_elem.offsetLeft + origin_elem.offsetWidth/2 ;
		if( isWindowLeftExceeded( center , elem )){
			elem.style.left = center + 'px'; 
		}else{
			elem.style.left = origin_elem.offsetLeft + origin_elem.offsetWidth/2 - elem.offsetWidth + 'px';
		}
		FixElementTopCenter( origin_elem , elem );
	}
	
	function alignCenterLeft( origin_elem , elem ){
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		if( canElementFitLeft( leftBoundary ) ){
			elem.style.left = leftBoundary + "px";
		}else{
			elem.style.left = origin_elem.getBoundingClientRect().right + "px";
		}
		FixElementTopCenter( origin_elem , elem );
	}
	
	function FixElementTopCenter( origin_elem , elem ){
		var top = origin_elem.offsetTop + origin_elem.offsetHeight/2; 
		if( !isWindowTopExceeded( top , elem ) ){
			elem.style.top = top - elem.offsetHeight + "px";
		}else{
			elem.style.top = top + "px";
		}
	}
	
	function canElementFitAbove( topBoundary ){
		if( topBoundary >= 0 ){
			return true;
		}
		else{
			return false;
		}
	} 
			
	function canElementFitLeft( leftBoundary ){
		if( leftBoundary >= 0 ){
			return true;
		}
		else{
			return false;
		}
	}
	
	function isWindowTopExceeded( position , elem ){
		
		if( ( position + elem.offsetHeight ) < window.innerHeight ){
			return true;
		}
		else{
			return false;
		}

	}
	
	function isWindowLeftExceeded( position , elem ){
		
		if( ( position + elem.offsetWidth ) < window.innerWidth ){
			return true;	
		}
		else{
			return false;
		}
	}	
	
	
	function placeAtBottom( origin_elem , elem ){
		elem.style.top = origin_elem.offsetHeight + origin_elem.offsetTop - elem.offsetHeight + "px"; 
	}

	function placeAtTop( origin_elem , elem ){
		elem.style.top = origin_elem.getBoundingClientRect().top + "px";
	}
	
	function FixElementTop( origin_elem ,elem){
		if( !isWindowTopExceeded( origin_elem.offsetTop , elem ) ){
				placeAtBottom( origin_elem , elem );
		}else{
				placeAtTop( origin_elem , elem );
		}
	}
	
	function alignWithOriginElement( config , elem ){
		var body = $L( "body" ).get(0);
		if( getComputedStyle(body).direction == 'rtl'){
			Changedirection( config );
		}
		if( config.alignment ){
			alignWithLeftTop( config , elem );
		}else{
			alignWithPosition( config , elem );
		}
		alterElementPosition( config.alterposition , elem );
	}
	
	function alignWithLeftTop( config , elem ){
		var origin_elem = $L( config.originElement ).get(0);
		var elem_left = config.alignment.left;
		var elem_top = config.alignment.top;
		switch(elem_top){
			case 'top':
				if( !elem_left ){
					alignTop( origin_elem , elem );
				}
				else if( elem_left == 'left' ){
					alignTopLeft( origin_elem , elem );
				}
				else if( elem_left == 'right'){
					alignTopRight( origin_elem , elem );
				}
				else{
					alignTopCenter( origin_elem , elem ); 
				}
				break;
			case 'bottom':
				if( !elem_left ){
					alignBottom( origin_elem , elem );
				}
				else if( elem_left == 'left' ){
					alignBottomLeft( origin_elem , elem );
				}
				else if( elem_left == 'right'){
					alignBottomRight( origin_elem , elem );
				}
				else{
					alignBottomCenter( origin_elem , elem ); 
				}
				break;
			case 'center':
				if( !elem_left ){
					alignCenter( origin_elem , elem );
				}
				else if( elem_left == 'left' ){
					alignCenterLeft( origin_elem , elem );
				}
				else if( elem_left == 'right'){
					alignCenterRight( origin_elem , elem );
				}
				else{
					alignCenter( origin_elem , elem );				
				}
				break;
			default :
				switch(elem_left){
					case 'left':
						alignLeft( origin_elem , elem );
						break;
					case 'right':
						alignRight( origin_elem , elem );
						break;
					case 'center':
						alignCenter( origin_elem , elem );
						break;
					default :
						alignBottom( origin_elem , elem );
						break;
				}
		}
	}
	
	function alignWithPosition( config , elem ){
		var origin_elem = $L( config.originElement ).get(0);
		switch ( config.position ) {
			case 'right':
				alignRight( origin_elem , elem );
				break;
			case 'left':
				alignLeft( origin_elem , elem );
				break;
			case 'top':
				alignTop( origin_elem , elem );
				break;
			case 'bottomright':
				alignBottomRight( origin_elem , elem );						
				break;
			case 'bottomleft':
				alignBottomLeft( origin_elem , elem );			
				break;
			case 'topright':
				alignTopRight( origin_elem , elem );
				break;
			case 'topleft':
				alignTopLeft( origin_elem , elem );
				break;
			case 'bottom':
			default :
				alignBottom( origin_elem , elem );
				break;
		}
	}
	
	function alignWithWindow( config , elem ){
		var offset = config.offset ? config.offset : {};
		
		if(isoffset( offset ) ){
			if( isRtl() ){
				offset.left = window.innerWidth - offset.left.match(/(\d+)/)[0] - elem.offsetWidth + 'px';
			}
			setTopLeft( offset , elem );
		}else{
			elem.style.left = ( window.innerWidth/2 - elem.offsetWidth/2 )  + 'px';
			elem.style.top = ( window.innerHeight/2 - elem.offsetHeight/2 )  + 'px';	
		}
	}
	function Changedirection( config ){
		if(config.alignment){
			if( config.alignment.left == 'right' ){
				config.alignment.left = 'left';
			}else if( config.alignment.left == 'left' ){
				config.alignment.left = 'right';
			}
		}else{
			if( config.position == 'left' ){
				config.position = 'right';
			}else if( config.position == 'topleft' ){
				config.position = 'topright';
			}else if( config.position == 'bottomleft' ){
				config.position = 'bottomright';
			}else if( config.position == 'right' ){
				config.position = 'right';
			}else if( config.position == 'topright' ){
				config.position = 'topleft';
			}else if( config.position == 'bottomright' ){
				config.position = 'bottomleft';
			}
		}
	}
	function fixElementLeft( origin_elem , elem ){
		var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
		if( !isWindowLeftExceeded( origin_elem.offsetLeft , elem ) ){
			elem.style.left = window.innerWidth - elem.offsetWidth + 'px';
		}else{
			elem.style.left = origin_elem.offsetLeft + 'px';
		}
	}
	function isRtl(){
		var body = $L('body').get(0);
		if(getComputedStyle(body).direction == 'rtl'){
			return true;
		}
		else{
			return false;
		}
	}
	function setTopLeft( offset , elem ){
		var left = offset.left ? offset.left : '0px';
		var top = offset.top ? offset.top : '0px';
		elem.style.left = left;
		elem.style.top = top;
	}
	function isoffset( offset ){
		if(offset.left  || offset.top ){
			return true;
		}
		else{
			return false;
		}
	}
})(window);



( function() { 

	var wrapped = [];
	var $u = function(obj){
		if (obj instanceof $u) return obj;
    	if (!(this instanceof $u)) return new $u(obj);
		this.wrapped = obj;
	};
	var result = function(instance, obj) {
    	return instance._chain ? $u(obj).chain() : obj;
  	};
  	
  	$u.some = function( list , predicate ){

  		if(predicate  != null){
  			predicate = formatIteratee(predicate);
		}
  		if(!Array.isArray(list)){
  			for(var key in list){
  				var currentVal = list[key];
  				if(!predicate){
  					if(currentVal){
  						return true;
  					}
  				}else if(predicate(currentVal)){
  					return true;
  				}
  			}
  		}else{
  			var length = list.length;
			for (var index = 0 ; index < length ; index++){
  				var currentVal = list[ index ];
  				if(!predicate){
  					if(currentVal){
  						return true;
  					}
  				}else if(predicate(currentVal)){
  					return true;
  				}
  			}
		}
  		
  		return false;
  	}


  	$u.every = function( list , predicate ){
  		
  		if(predicate  != null){
  			predicate = formatIteratee(predicate);
		}
  		if(!Array.isArray(list)){
  			for(var key in list){
  				var currentVal = list[key];
  				if(!predicate){
  					if(!currentVal){
  						return false;
  					}
  				}else if(!predicate(currentVal)){
  					return false;
  				}
  			}
  		}else{
  			var length = list.length;
			for (var index = 0 ; index < length ; index++){
  				var currentVal = list[ index ];
  				if(!predicate){
  					if(!currentVal){
  						return false;
  					}
  				}else if(!predicate(currentVal)){
  					return false;
  				}
  			}
		}
  		
  		return true;

  	}

  	$u.contains = function( list , val ){
  		return includes( list , val );
  	}


	$u.mixin = function( object ){
		
		var keys = Object.keys( object );
		keys.forEach(function(key){
			var func_name = key;
			var func =$u[func_name]= object[ func_name ];
      		$u.prototype[ func_name ] = function() {
        		var args = [this.wrapped];
        		Array.prototype.push.apply(args,arguments);
        		return  result( this , func.apply($u, args) );
			}
		});
	}
	$u.prototype.value=function(){
		return this.wrapped;
	}
	$u.difference = function(){
		
			var length = arguments.length;
		
		var newArray=[];
		
		var array = arguments[0];
		for(var index=0 ,len = array.length; index < len ; index++){
			var val = array[ index ];
			var isContains = false;
			for(var i= 1 ; i < length && Array.isArray(arguments[i]) ; i++){
				if(arguments[i].indexOf(val) !== -1){
					isContains = true;
					break;
				}
			}
			if(!isContains){
				newArray.push(val);
			}	
		}
		return newArray;
		
		

	}
	var Form_array = function( arg ){
		var array =[];
		Array.prototype.push.apply(array,arg);
		return array;
	}
	$u.removeFromArray = function (array , removeitems){
		var newArray = [];
		
		for (var i = 0,length= array.length; i < length; i++) {
			var val = array[ i ];
			if(!includes(removeitems,val)){
				newArray.push(val);
			}
		}
		return newArray;
	}
	var includes = function( list , val ){
		list = list || [];
		if(Array.isArray(list)){
			return list.indexOf(val) >= 0 ? true : false;
		}else{
			return $u.some( list , function(item){ return item === val; })
		}
		
	}
	$u.groupBy = function( list , iteratee ){
			
		iteratee = formatIteratee(iteratee);
		return list.reduce(function( set , val) {
			var key = iteratee( val );
	   		(set[key] = Array.isArray(set[ key ]) ? set[key] : []);
	   		set[key].push(val);
	    	return set;
	  	},{});
	}
	$u.indexBy = function( list , iteratee ){
		iteratee = formatIteratee(iteratee);
		return list.reduce(function( set , val ){
			var key = iteratee(val);
			set[ key ] = val;
			return set;
		},{});
	}
	$u.chain = function(obj){
		
		var instance = $u(obj);
    	instance._chain = true;
    	
		return instance;
	}

	$u.findWhere = function( list , properties ){
		var keys = Object.keys(properties);
		var flag = true;
		var result = undefined;
		for ( val in list){
			val = list[val]
			for(var i = 0 ; i < keys.length ; i++){
				var key = keys[i];
				if(val[key] !== properties[key]){
					flag = false;
					break;
				}
			}
			if(flag){
				result = val;
				break
			}
			flag = true; 
		}
		return result;
	}
	$u.intersection = function(){
		
		var start = 1 , intersec = [];
		intersec= arguments[0] || [];
		
		var result = [];
		var length = arguments.length ;
		var flag = true;
		var argument = arguments;
		var that = $u;
		var result = intersec . filter(function (val) {
			
			for(var index = start ; index < length ; index++){
				var array = argument[index];
				var check = includes( array , val );
				if( !check && flag ){
					flag = false;
					break;
				}
			}
			if(flag){
				return true;
			}
			flag = true;
		});
		
		return result;
	}
	$u.defaults =function( obj ){
		var length = arguments.length ;
		var argument = {} ;
		argument = obj || {};
		if( argument ){
			for(var i = 1 ; i < length ; i++){
				for(var key in arguments[i]){
					if( !argument.hasOwnProperty(key) || argument[key] === undefined ){
						argument[key] = arguments[i][key];
					}
				}
			}
		}
		return argument;
	}
	$u.negate = function( func ){
		return function(){
			return !func.apply( this , arguments );
		}
	}
	$u.omit = function( object ){
		var omit ;
		var iteratee ;
		if(typeof arguments[1] != 'function'){
			var keys = [];
			keys = Form_array(arguments);
			keys.shift();
			iteratee = function(value , key){
				return !includes(keys,key);
			}
		}else{
			iteratee = $u.negate(arguments[1]);
		}	
		return $u.pick(arguments[0] , iteratee);
	}
	$u.pick_array = function ( obj , pick , key ){
		var that = $u;
		for(var index =0 ,length=key.length; index < length ; index++){
			var val = key[index];
			if( Array.isArray(val)){
				that.pick_array( obj , pick , val );
			}else if(obj.hasOwnProperty(val)){
				pick[val] = obj[val];
			}
		}
		
		return pick;
	}
	$u.pick =function ( obj ){
		var pick = {};
		var length = arguments.length;
		var iteratee;

		if(typeof(arguments[1]) != 'function'){
			for(var i = 1 ; i < length ; i++ ){
				var key = arguments[i];
				if( !Array.isArray(key) ){
					if(obj[key])
						pick[key] = obj[key];
				}else {
					pick = $u.pick_array( obj , pick , key );
				}
			}
		}else{
			iteratee = (arguments[1]);
			for( var key in obj ){
				if(iteratee( obj[key] , key , obj )){
					pick[key] = obj[key];
				}
			}
		}
		return pick;
	}
	$u.extend = function(obj){
		if(obj){
			for(var index = 1; index < arguments.length ; index++){
				var object = arguments[index];
				var keys = Object.getOwnPropertyNames(object);
				keys.forEach(function(key){
					obj[key] = object[key];
				});
			}
			return obj;
		}else{
			return undefined;
		}
	}
	
	$u.isString = function(obj){
		if(typeof obj == "string"){
			return true;
		}else if(typeof obj == "object"){
			var type = toString(obj);
			return  type === "[object String]";
		}else{
			return false;
		}
	}

	$u.isEmpty = function( list ){
		
		if(  Array.isArray( list )){
			if(list.length > 0){
				return false;
			}
		}else if( list && typeof list == 'object' ){
			if(Object.getOwnPropertyNames( list ).length > 0){
				return false;
			}
		}else if(list){
			return false;
		}
		return true;
	}
	$u.clone = function( object ){
		var type = typeof object;

	    if (! (type === 'function' || type === 'object' && !!object ))
		 	return object;
	    if(Array.isArray( object ) ){
	    	return object.slice() 
	    }else{
	    	newObj = {};
			for(var key in object){
				newObj[key] = object[key];
			}
			return newObj;
	    }
	}
	$u.map = function(list , iteratee ){
		iteratee = formatIteratee(iteratee);
		var arr = [];
		for(var index = 0 ; index < list.length ; index++ ){
			arr.push(iteratee(list[index]));
		}
		return arr;
	}
	var flatten = function(input ,depth,output){
		var output = output || [];
		if(!depth && depth !== 0){
			depth = Infinity;
		}else if(depth <= 0){
			return output.concat(input);
		}
		var index = output.length;
		for(var i = 0; i < input.length ; i++){
			var val= input[i];
			if(Array.isArray(val)){
				if(depth > 1){
					flatten(val,depth-1,output);
					index = output.length;
				}else{
					var j = 0 , length = val.length;
					while( j < length ) output[ index++ ] = val[ j++ ];
				}
				
			}else{
				output[ index++ ] = val;
			}
		}
		return output;
	}
	var toString = function( obj ){
		return ({}).toString.call(obj);
	}
	$u.union = function(){
				
		var length = arguments.length;
		var unionArray = arguments[ 0 ];
		if(toString(unionArray) === '[object Arguments]'){
			var result = [];
			for(var union_index = 0 ,len = unionArray.length ; union_index < len ; union_index++   ){
				result[union_index] = unionArray[union_index];
			}
			unionArray = result;
		}

		for(var index = 1 ; index < length ; index++ ){
			var array = arguments[ index ];
			for (var i =  0 , len = array.length; i < len ; i++) {
				var val = array[ i ];
				if(!includes(unionArray,val)){
					unionArray.push(val);
				}
			}
		}
		return unionArray;
		
	}
	$u.uniq = function(array , iteratee){

		var uniqArray = [];
		if(!array && !array.length){
			return [];
		}
		var seen = [] ;
		var index = -1;
		
		if(iteratee != null){
			var iteratee = formatIteratee(iteratee);
			
		}else{
			seen = uniqArray;
		}
		var length = array.length;
		loop:
		for( ++index ; index< length ; index++){
			var val = array[index];
			var iter_val = iteratee ? iteratee(val) : val;
			var seen_len = seen.length;
			while(seen_len--){
				if(seen[seen_len] === iter_val){
					continue loop;
				}
			}
			if(iteratee){
				seen.push(iter_val);
			}
			uniqArray.push(val);
		}
		
		return uniqArray;
	}
	$u.chunk = function(array,length){
		
		var chunkedArray = [],chunks = [];
		array.forEach(function(val){
			if(chunks.length < length){
				chunks.push(val);
			}
			if( (chunks.length == length && length != 0) ){
				chunkedArray.push(chunks);
				chunks = [];
			}
		});
		if(chunks.length){
			chunkedArray.push(chunks);
		}
		return chunkedArray;
	}
	$u.isEqual = function(object1,object2,NonEnumerable){
		
		NonEnumerable = NonEnumerable === false ? false : true;
		if(object1 === object2){ return true; }
		if(typeof object1 !== typeof object2) return false;
		if (object1 == null || object2 == null) return object1 === object2;
		var className = toString(object1);
		if(className ==='[object RegExp]' || className ==='[object String]') {
	       	return '' + object1 === '' + object2;
	    }else if(className === '[object Number]'){
	       	if (+object1 !== +object1) return +object2 !== +object1;
	      		return +object1 === 0 ? 1 / +object1 === 1 / object2 : +object1 === +object2;
	    }else if( className === '[object Date]' || className ==='[object Boolean]'){
	        return +object1 === +object2;
	    }else if(typeof(object1) == 'object' && typeof(object2) == 'object'){
			if(Array.isArray(object1) != Array.isArray(object2)){
				return false;
			}else if(Array.isArray(object1) && Array.isArray(object2)){
				return $u.checkArrayEquality(object1,object2,NonEnumerable);
			}else {
				return $u.checkObjectEquality(object1,object2,NonEnumerable);
			}
		}else if(typeof object1 != typeof object2 ){
			return false;
		}
		return true;
	}
	$u.checkArrayEquality = function(array1,array2,NonEnumerable){
		var flag = true;
		if(array1.length == array2.length){
			var len = array1.length;
			for( var i = 0 ; i < len ; i++ ){
				if(typeof(array1[i]) != typeof(array2[i])){
					return false;
				}
				else if(typeof(array1[i]) == 'object' ){
					flag = $u.isEqual(array1[i],array2[i],NonEnumerable);
				}
				else if(array1[i] !== array2[i]){
					return false;
				}
				if(flag == false){
					return flag;
				}
			}
		}
		else {
			return false;
		}
		return flag;
	}

	$u.checkObjectEquality = function( obj1 , obj2 ,NonEnumerable){
			
		if(NonEnumerable){
			var obj2_key = Object.getOwnPropertyNames(obj2);
			var keys = Object.getOwnPropertyNames(obj1);
		}else{
			var obj2_key = Object.keys(obj2);
			var keys = Object.keys(obj1);	
		}
		var  len = keys.length , flag = true;

		if(keys.length != obj2_key.length){
			return false;
		}
		for(var i =0 ; i < len ; i++){
			var key = keys[i];
			if(typeof(obj1[key]) != typeof(obj2[key]) ){
				return false;
			}
			else if(typeof(obj1[key]) == 'object'){
				flag = $u.isEqual(obj1[key] , obj2[key] , NonEnumerable);
			}
			else if( obj1[key] !== obj2[key] ){
				return false;
			}
			if(flag == false){
				return flag;
			}
		}
		
		return flag;
	}
	$u.invert = function(input){
		var keys = Object.keys(input);
		var newObj = {};
		keys.forEach(function(val){
			newObj[input[val]] = val;
		});
		return newObj;
	}
	$u.without = function(){
		
		var len = arguments.length , argument = [] ;
		for(var i = 1 ; i < len ; i++ ){
			argument.push(arguments[i]);
		}
		var first_arg = Form_array(arguments[0]);
		return $u.removeFromArray( first_arg || [] , argument);
	}
	$u.max = function(list,iteratee){

		list = list || [];
		var maxVal = list[0] , flag = false;
		iteratee = formatIteratee(iteratee);
		var iter_max = iteratee(maxVal);
		for(var index = 0;index < list.length ;index ++){
			var val = list[index];
			var iter_val = iteratee(val);
			if(  ( iter_val > iter_max ) || isNaN(iter_max) && !isNaN(iter_val) ){
				maxVal = val;
				iter_max = iteratee(maxVal);
				flag = true;
			}
		}
		if(!flag && isNaN(iter_max)){
			return -Infinity;
		}
		return maxVal;
	}
	$u.min = function(list,iteratee){
		list =list || [];
		var minVal = list[0] , flag = false;
		iteratee = formatIteratee(iteratee);
		var iter_min = iteratee(minVal);
		for(var index = 0; index < list.length ; index++){
			var val = list[index];
			var iter_val = iteratee(val);
			if(  ( iter_val < iter_min ) || isNaN(iter_min) && !isNaN(iter_val) ){
				minVal = val;
				iter_min = iteratee(minVal)
				flag = true;
			}
		}
		if(!flag && isNaN(iter_min)){
			return Infinity;
		}
		return minVal;
	}
	var partition = function( arr ,  low ,  high , iteratee ){ 
        var pivot = arr[high];  
        var i = (low-1); 
        for (var j=low; j<high; j++) 
        { 
            if (iteratee(arr[j] )< iteratee(pivot)) 
            { 
                i++; 
                var temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
            } 
        } 
        var temp = arr[i+1]; 
        arr[i+1] = arr[high]; 
        arr[high] = temp; 
  
        return i+1; 
    } 
 
   	var sort = function( arr ,  low ,  high , iteratee ){ 
        if (low < high){ 
            var pi = partition( arr, low , high , iteratee ); 
            sort( arr , low , pi-1 , iteratee ); 
            sort( arr , pi+1 , high , iteratee ); 
        }
        return arr; 
    } 
	$u.sortBy = function(list,iteratee){
		iteratee = formatIteratee(iteratee);
		return sort( list , 0 , list.length-1 , iteratee );
	}
	var formatIteratee = function(iteratee){
		
		var type = typeof iteratee;
		if(iteratee == undefined || type == "function"){
			return iteratee||function(val){return val;};
		}else if(type  == "string" || type  == "number"){
			var key = iteratee ;
			iteratee = function(val){return val[key]};
		}else if(Array.isArray(iteratee)){
			var deep = iteratee;
			iteratee = function( val ){
				for(var index=0 ; index < deep.length && val != undefined ; index++){
					val = val[deep[index]];
				}
				return val;
			}
		}else {
			var compareobj = iteratee;
			iteratee = function( obj ){
				var keys =  Object.getOwnPropertyNames( compareobj );
				var key = keys[ 0 ]; 
				for(var i = 0 ; i < keys.length ;key = keys[ ++i ]){
					if( obj[ key ] !== compareobj[ key ] ){
						return false;
					}
				}
				return true;
			}
		}
		
		return iteratee;
	}
	$u.replace = function(accented){
		var str;
		/*var map = {
        	
        	'a' : 'ā|á|à|ã|â|À|Á|Ã|Â|Ā',
        	'c' : 'ç|Ç|ĉ|Ĉ|Ć|ć|Ĉ|ĉ|Ċ|ċ|Č|č',
        	'd' : 'Ḍ|Ḏ|ḍ|ḏ|Ď|ď|Đ|đ|Ḍ',
        	'e' : 'ē|é|è|ê|É|È|Ê|Ē',
        	'g' : 'Ĝ|ĝ|Ğ|ğ|Ġ|ġ|Ģ|ģ',
        	'h' : 'Ḥ|H̱|H̤|Ḫ|ḥ|ẖ|h̤|ḫ|Ĥ|ĥ|Ħ|ħ',
        	'i' : 'í|ì|î|ī|Í|Ì|Î|Ī',
        	'j' : 'ĵ|j̄|Ĵ|J̄',
        	'k' : 'ḵ|Ḵ',
        	'l' : 'l̥|ḻ|ḷ|L̥|Ḻ|Ḷ| l̥̄|  L̥̄',
        	'm' : 'ṃ|ṁ|m̐|m̆|Ṃ|Ṁ|M̐|M̆',
        	'n' : 'Ñ|Ṇ|Ṅ|Ṉ|N̆|ñ|ṇ|ṅ|ṉ|n̆',
        	'o' : 'ó|ò|ô|ö|õ|ō|Ö|Ō|Ó|Ò|Ô|Õ',
  			'r' : 'Ṛ|Ṟ|R̥| R̥̄|R̆|ṛ|ṟ|r̥|  r̥̄|r̆',
  			's' : 'Ś|Ṣ|Ṣ|S̤|S̱|§|ś|ṣ|s̤|s̱|§',
  			't' : 'ṭ|ṯ|Ṭ|Ṯ',
         	'u' : 'ú|ù|û|ü|ū|Ú|Ù|Û|Ü|Ū',
        	'y' : 'ý|ÿ|Ý',
        	'z' : 'ž|ż|ẓ|ẕ|ź|Ž|Ż|Ẓ|Ẕ|Ź',
        	'kh': 'k͟h|K͟H',
        	'ae' : 'Æ|æ'
		};
    	for (var pattern in map) {
        	accented = accented.replace( new RegExp( map[pattern] , 'gi'), pattern);
    	};*/
    	str = accented.normalize("NFKD").replace(/[\u0300-\u036f]/g, "");
    	//str = str.replace(/"Æ"/g,"AE");
    	return str;
	}
	$u.highlight = function( string , search , callback ){
		var Reg = new RegExp( search , "gi");
		calback = generatecallback( callback ); 
		string = string.replace(Reg,function(str,pos){
			var highlight = string.slice(pos,pos+search.length);
			return calback(highlight);
		});
		return string;
	}
	
	var generatecallback = function( callback ){

		if(typeof callback === "string" ){
			var tag_name = callback;
			callback = function(str){
				return "<"+tag_name+">" + str + "</" + tag_name + ">"; 
			}
		}
		callback = callback ||  function(str){
				return "<span>" + str + "</span>"; 
			};
		return callback;
	}
	$u.mixin($u);
	window.$u = $u;
})() 


/*
	Optimized by reading the values first and then writting
	Added - 27/07/2014 - documentation not done yet
		1. Added draggable + sortable compatibility - Drag any draggable element to sort it with a list of sortable elements and sort it with them
		2. Added helper options - can be string or any function
		3. Added connectToSortable options
		4. Added onBeforeStop callback - return false to exit
	Date - 28/08/2018
  	1. Added method to destroy draggable.

*/

;(function( window ) {

	if(lyteDomObj){	
		lyteDomObj.prototype.manageDraggable = {
			init : false,
			draggedEle : null,
			isRestricted : function(restrict,element){
				restrict = restrict instanceof Array ? restrict : restrict.split(",");
				for(var i = 0; i<restrict.length; i++){
					var elements = document.querySelectorAll(restrict[i]);
					for(var j = 0; j < elements.length; j++){
						if(element.isEqualNode(elements[i])){
							return true;
						}
					}
				}
				return false;
			},

			destroy : function(element){
				if(!(element.classList.contains('draggable-element')) && !(element.classList.contains('draggable-helper'))){
					console.info("ALERT! - U have already destroyed its draggable behaviour.");
					return;
				}
				if(element.classList.contains('draggable-handle-element')){
					element.classList.remove('draggable-handle-element')
					element.removeEventListener('mousedown',element._draggableData.__mousedown);
					element.removeEventListener('touchstart',element._draggableData.__mousedown, true);
					element._draggableData = null;
				}
				else{
					var handleElems = element.querySelectorAll('.draggable-handle-element');
					for(var i = 0; i<handleElems.length; i++){
						handleElems[i].classList.remove('draggable-handle-element')
						handleElems[i].removeEventListener('mousedown',handleElems[i]._draggableData.__mousedown);
						handleElems[i].removeEventListener('touchstart',handleElems[i]._draggableData.__mousedown, true);
						handleElems[i]._draggableData = null;
					}
				}
				element.classList.remove('draggable-element','draggable-helper');
				element._mousedown = undefined;
			}

		};
		
		lyteDomObj.prototype.draggable = function(object) {
			var manageDraggable = lyteDomObj.prototype.manageDraggable;
			var managerDD = lyteDomObj.prototype.managerDD;
			if(!manageDraggable.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector ||
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				manageDraggable.init = true;
			}

			if(typeof object === "string" && object === "destroy"){
				if(this.length > 1){
					var elemArray = this;
					for(var i = 0; i<elemArray.length; i++){
						manageDraggable.destroy(elemArray[i]);
					}
				}
				else{
					manageDraggable.destroy(this[0]);
				}
				return;
			}

			var data = object ? object : {};

			if(this.length > 1){
				var elemArray = this;
				for(var i = 0; i<elemArray.length; i++){
					$L(elemArray[i]).draggable(Object.assign({},data));
				}
				return;
			}
			//Parent Element
			if(data.restrict && manageDraggable.isRestricted(data.restrict,this[0])){
				return;
			}
			data._element = this[0];
			$L(data._element).addClass('draggable-element');

			var _handleElement;
			var _initialPos = {};
			var _offset = [0,0];
			var _marginTop = 0;
			var _marginLeft = 0;
			var _placeholder;
			var _sortableElemClass;
			var _positionedPlceholder = false;
			var _requestId1;
			var _animationFrameFired1;
			var _elemBelow;
			var droppablePlace;
			var returnVal;
			var prevDimension = null;
			var _maxScrollHeight;
			var _maxScrollWidth;
			var _scrollTop;
			var _scrollLeft;
			var _requestId2;
			var _animationFrameFired2;
			//Data initialization
			data.placeholder = data.placeholder ? data.placeholder : "lyteDraggablePlaceholder";
			data.containment = (data.containment === undefined) ? document : $L(data.containment)[0];
			data.orientation = (data.orientation === undefined) ? "default" : data.orientation;
			data.handle = (data.handle === undefined) ? this[0] : data.handle;
			data.restrict = data.restrict === undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
			data.helper = data.helper ? data.helper : "original";
			data.connectToSortable = data.connectToSortable ? data.connectToSortable : null;
			data.cursorAt = data.cursorAt;
			data.disabled = data.disabled ? data.disabled : "lyteDraggableDisabledPlaceholder";
			data.appendTo = data.appendTo && data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent";
			data.bubbles = data.bubbles === undefined ? true : data.bubbles;
			data.scrollDivX = data.scrollDivX ? (typeof data.scrollDivX == "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX) : undefined;
			data.scrollDivY = data.scrollDivY ? (typeof data.scrollDivY == "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY) : undefined;
			data.scrollSpeed = data.scrollSpeed ? parseInt(data.scrollSpeed) : 10;

			if(data.scrollSpeed < 1){
				data.scrollSpeed = 1;
			}

			function mouseDownEvent(event){
				// console.log(event.type, event.target);
				// event.preventDefault();
				// console.log("calling mousedown from draggable");
				//Disable right click on the sortable elements to avoid unwanted behaviour
				if(event.which == 3){
					return;
				}
				var _handleElement = event.target.closest('.draggable-handle-element');
				manageDraggable.draggedEle = _handleElement;
				if(_handleElement){
					if(!_handleElement._draggableData.bubbles){
						event.stopPropagation();
					}
					var data = _handleElement._draggableData;
					var elem = data._element;
					var elemOffset = elem.getBoundingClientRect();
					var cs = window.getComputedStyle(elem);
					var width = elemOffset.width;
					var height = elemOffset.height;
					data._offParent = elem.offsetParent;
					data._parent = elem.parentElement;
					var returnVal = true;

					//Callback fired
					if(data.onStart){
						returnVal = onStart(data, event);
					}
					if(!returnVal){
						return;
					}

					_initialPos = {
						x : elem.offsetLeft,
						y : elem.offsetTop,
						pos : $L(elem).css('position')
					};
					if(data.cursorAt){
						_offset = [
							data.cursorAt.left,
							data.cursorAt.top
						];
					}
					else{
						if(event.type == "mousedown"){
							_offset = [
								event.clientX - elemOffset.left,
								event.clientY - elemOffset.top
							];
						}
						else if(event.type == "touchstart"){
							_offset = [
								event.touches[0].clientX - elemOffset.left,
								event.touches[0].clientY - elemOffset.top
							];
						}
					}
					// if(event.type == "mousedown"){
					// 	_offset = [
					// 		event.clientX - elemOffset.left,
					// 		event.clientY - elemOffset.top
					// 	];
					// }
					if(event.type == "touchstart"){
						// _offset = [
						// 	event.touches[0].clientX - elemOffset.left,
						// 	event.touches[0].clientY - elemOffset.top
						// ];

						//Binding touch events
						document.addEventListener('touchmove',mouseMoveEvent, true);
						document.addEventListener('touchend',mouseUpEvent, true);
						data._element.classList.add('stopDefaultMove');
					}
					
					if(cs.marginTop){
						_marginTop = cs.marginTop;
					}
					if(cs.marginLeft){
						_marginLeft = cs.marginLeft;
					}
					// var parent = elem.offsetParent;


					if(data.scrollDivY && window.getComputedStyle(data.scrollDivY).position == "relative" && data.scrollDivY.contains(elem)){
						data._isRelativeY = true;
					}
					else{
						data._isRelativeY = false;
					}

					if(data.scrollDivX && window.getComputedStyle(data.scrollDivX).position == "relative" && data.scrollDivX.contains(elem)){
						data._isRelativeX = true;
					}
					else{
						data._isRelativeX = false;
					}

					data._isDown = true;
					data._initialPos = _initialPos;
					data._offset = _offset;
					data._marginLeft = _marginLeft;
					data._marginTop = _marginTop;
					$L(_handleElement).addClass('selected-element');
					
					//Set the current element for manager to manage draggables and droppables
					if(typeof managerDD !== "undefined"){
						managerDD._current = data._element;
					}
					if(event.type == "mousedown"){
						document.addEventListener('mousemove',mouseMoveEvent);
						document.addEventListener('mouseup',mouseUpEvent);
						if(getOS() === "Windows"){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
							manageDraggable.mouseMoveTriggered = true;
						}
					}
				}
				else{
					_handleElement = null;
				}
				// console.log(event.target, "selected");
			}

			var mouseMoveEvent = function(event){
				// console.log(event.type, event.target);
				
				// console.log("calling mousemove from draggable");
				if(getOS() === "Windows" && manageDraggable.mouseMoveTriggered){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
					manageDraggable.mouseMoveTriggered = false;
					return;
				}
				if(manageDraggable.draggedEle && $L(manageDraggable.draggedEle).hasClass("selected-element") && manageDraggable.draggedEle._draggableData._isDown){
					_handleElement = manageDraggable.draggedEle;

				}
				else{
					_handleElement = null;
					return;
				}
				// var target = event.target;
				// while(target && target != document){
				// 	if($L(target).hasClass("selected-element")){
				// 		_handleElement = target;
				// 		break;
				// 	}
				// 	target = target.parentElement;
				// }
				if(_handleElement){
					// console.log(event.target, "moving");
					var data = _handleElement._draggableData;
					if(data && data._isDown){
						event.preventDefault();
						if(typeof document.body.style.MozUserSelect!="undefined"){
							document.body.style.MozUserSelect = "none";
						}
						var elem = data._element;
						_offset = data._offset;
						_marginLeft = data._marginLeft;
						_marginTop = data._marginTop;
						var orientation = data.orientation;
						var parent = data._offParent;
						var elemOffset = elem.getBoundingClientRect();
						var parentOffset = parent.getBoundingClientRect();
						var scrollLeftValue = 0;
						if(data.scrollDivY && data._isRelativeY){
							_scrollTop = data.scrollDivY.scrollTop;
						}
						else{
							_scrollTop = 0;
						}
						if(data.scrollDivX && data._isRelativeX){
							_scrollLeft = data.scrollDivX.scrollLeft;
							if(_lyteUiUtils.getRTL() && !_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome" && data._isRelativeX){
								_scrollLeft -= (data._maxScrollWidth ? data._maxScrollWidth : (data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth));
							}
						}
						else{
							_scrollLeft = 0;
						}
						if(data._isRelative){
							scrollLeftValue = _scrollLeft;
						}

						if(!data._isMoved){
							
							var cs = window.getComputedStyle(elem);
				            var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
				                                     (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
				            var borderDimensionX = ((cs.borderLeft ? parseFloat(cs.borderLeft) : 0) +
				                                     (cs.borderRight ? parseFloat(cs.borderRight) : 0));
							if(typeof data.helper == "string"){
								if(data.helper == "clone"){
									var helper = elem.cloneNode(true);
									_lyteUiUtils.insertAfter(elem,helper);
									$L(elem).removeClass('selected-element');
									if(!($L(helper).hasClass('draggable-handle-element'))){
										$L(helper).addClass('draggable-handle-element');
									}
									helper._draggableData = Object.assign({},data);
									data = helper._draggableData;
									data._element = data.handle = helper;
									_handleElement = helper;
									elem = helper;
									elem.addEventListener("mousedown",mouseDownEvent);
									if(data.connectToSortable){
										data._prevTop = event.clientY;
									}
								}
							}
							else{
								var helper = data.helper(elem);
								if(helper){
									helper._callee = elem;
									$L(elem).removeClass('selected-element');
									if(!($L(helper).hasClass('draggable-handle-element'))){
										$L(helper).addClass('draggable-handle-element');
									}
									if(!($L(helper).hasClass('selected-element'))){
										$L(helper).addClass('selected-element');
									}
									$L(helper).addClass('draggable-helper');
									helper._draggableData = Object.assign({},data);
									data = helper._draggableData;
									data._element = data.handle = helper;
									manageDraggable.draggedEle = _handleElement = helper;

									//Appends the helper to the provided element
									if(data.appendTo == "parent"){
										data._parent.appendChild(helper);
									}
									else{
										data.appendTo.appendChild(helper);
									}
									elem = helper;
									elem.addEventListener("mousedown",mouseDownEvent);
									if(data.connectToSortable){
										data._prevTop = event.clientY;
									}
									parent = data._offParent = elem.offsetParent;
									parentOffset = parent.getBoundingClientRect();
								}
							}
							if(typeof managerDD != "undefined"){
								managerDD._current = elem;
							}

							data = elem._draggableData || _handleElement._draggableData;
							
							//Create placeholder and append it to the DOM
							if(data.connectToSortable){
								_placeholder = elem.cloneNode(true);
								_placeholder._callee = elem;
								$L(_placeholder).removeClass('selected-element');
								_placeholder.innerHTML = "";
								$L(_placeholder).attr('id','lyteDraggableDummy');
								$L(_placeholder).addClass(data.placeholder);
								_placeholder.style.boxSizing = "border-box";
								// if(cs.boxSizing == "border-box"){
									_placeholder.style.width = elemOffset.width + "px";
									_placeholder.style.height = elemOffset.height + "px";
								// }
								// else{
								// 	_placeholder.style.width = calculateWidth(elem)/*(elemOffset.width - borderDimensionX)*/ + "px";
								// 	_placeholder.style.height = calculateHeight(elem)/*(elemOffset.height - borderDimensionY)*/ + "px"; 
								// }
								_placeholder.style.padding = "0px";
								elem.classList.add('lyteSortableDisablePE');
							}
							elem.style.top = elemOffset.top - parentOffset.top /*- parseInt(cellSpacing)*/ - parseInt(_marginTop) + _scrollTop + 'px';
							elem.style.left = elemOffset.left - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
							elem.style.zIndex = 200000;
							if(cs.boxSizing == "border-box"){
								elem.style.width = elemOffset.width /*- borderDimensionX */+'px';
								elem.style.height = elemOffset.height /*- borderDimensionY*/ +'px';
							}
							else{
								elem.style.width = calculateWidth(elem) /*elemOffset.width - borderDimensionX*/ +'px';
								elem.style.height = calculateHeight(elem) /*elemOffset.height - borderDimensionY*/ +'px';
							}
							elem.style.position = "absolute";
							if(data.onDragStart){
								onDragStart(data,_handleElement,_placeholder,event);
							}
							if(data.scrollDivY){
								_maxScrollHeight = data.scrollDivY.scrollHeight - data.scrollDivY.offsetHeight;
							}
							if(data.scrollDivX){
								_maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth;
								data._maxScrollWidth = _maxScrollWidth;
							}
							if(data.cursorAt && _lyteUiUtils.getRTL()){
								var offset = data.cursorAt,
				                    newOffset = {};
				                for(key in offset){
				                    if(key == "left"){
				                        newOffset.left = data._element.offsetWidth - offset[key];
				                    }
				                    else{
				                        newOffset[key] = offset[key];
				                    }
				                }
				                data._preCursorAt = Object.assign({},data.cursorAt);
				                data.cursorAt = newOffset;
				                _offset = data._offset = [
										                	data.cursorAt.left,
										                	data.cursorAt.top
										                ];
							}
						}
						else{
							if(data._placeholder){
								_placeholder = data._placeholder;
							}
							if(data._positionedPlceholder){
								_positionedPlceholder = data._positionedPlceholder;
							}
						}

						if(event.type == "mousemove"){
							data._mousePosition = {
								x : event.clientX,
								y : event.clientY
							};
						}
						else if(event.type == "touchmove"){
							data.touchTarget = event.touches;
							data._mousePosition = {
								x : event.touches[0].clientX,
								y : event.touches[0].clientY
							};
						}
						var returnVal = true;
						//Callback fired
						if(data.onDrag){
							returnVal = onDrag(data,_handleElement,event);
						}
						if(returnVal){
							if(orientation === "vertical"){
								elem.style.top = data._mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop + 'px';
							}
							else if(orientation === "horizontal"){
								elem.style.left = data._mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
							}
							else if(orientation === "default"){
								// if(data.cursorAt){
								// 	elem.style.left = data._mousePosition.x - (data.cursorAt.left ? data.cursorAt.left : _offset[0]) - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
								// 	elem.style.top = data._mousePosition.y - (data.cursorAt.top ? data.cursorAt.top : _offset[1]) - parentOffset.top - parseInt(_marginTop) + _scrollTop + 'px';
								// }
								// else{
									elem.style.left = data._mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
									elem.style.top = data._mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop + 'px';
								// }

								elemOffset = elem.getBoundingClientRect();
								if(data.scrollDivY){
									var scrollDivOffset = data.scrollDivY.getBoundingClientRect();
									if((elemOffset.left <= scrollDivOffset.right) && (elemOffset.right >= scrollDivOffset.left)){
										_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,data.scrollDivY,scrollDivOffset,_maxScrollHeight,data._isRelativeY,data._mousePosition,_offset,parentOffset));
										_animationFrameFired1 = true;
									}
								}

								//Animation Frame fired for horizontal scrolling
								if(data.scrollDivX){
									var scrollDivOffset = data.scrollDivX.getBoundingClientRect();
									if(elemOffset.left <= scrollDivOffset.right || elemOffset.right >= scrollDivOffset.left){
										_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,_maxScrollWidth,data._mousePosition,_offset,parentOffset,data._isRelativeX));
										_animationFrameFired2 = true; 
									}
								}

								if(data.connectToSortable){
									var sortableData = $L(data.connectToSortable).length ? $L(data.connectToSortable)[0]._sortableParentData : null;
									_sortableElemClass = sortableData.sortableElemClass;
									// if(_positionedPlceholder){
									// 	var scrollDiv = findScrollDiv(_placeholder);
									// 	var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : null;
									// 	if(scrollDiv && (elemOffset.left <= scrollDivOffset.right) && (elemOffset.right >= scrollDivOffset.left)){
									// 		_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset));
									// 		_animationFrameFired1 = true;
									// 	}
									// }

									//Find the below element over which the sortable element is being dragged
									// elem.style.display = "none";
									_elemBelow = document.elementFromPoint(data._mousePosition.x,data._mousePosition.y);
									// elem.style.display = "";
									
									//check isOver sortable list
									lyteDomObj.prototype.manageSortable.isOver(event,data,true);

									if(!_elemBelow){
										return;
									}

									//Find the closest sortable element to sort with
									droppablePlace = _elemBelow.closest('.'+_sortableElemClass);
									// if(document.getElementById('lyteDraggableDummy')){
									// 	document.getElementById('lyteDraggableDummy').style.display = "";
									// }

									if(droppablePlace && droppablePlace.parentElement._sortableParentData.droppable /* && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)*/){
										
										if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,data._mousePosition) && checkForBetween(_elemBelow,data._mousePosition,elem/*,isRelativeY,scrollDiv*/)){
											// $L(_elemBelow).append(_placeholder);
											_lyteUiUtils.appendChild(_elemBelow,_placeholder);
											_placeholder.style.display = "";
											_positionedPlceholder = true;
										}
										else{
											if(elem.getBoundingClientRect().top <= droppablePlace.getBoundingClientRect().top){
												_lyteUiUtils.insertBefore(droppablePlace,_placeholder);
												_placeholder.style.display = "";
												_positionedPlceholder = true;
											}
											else if(elem.getBoundingClientRect().bottom > droppablePlace.getBoundingClientRect().bottom){
												_lyteUiUtils.insertAfter(droppablePlace,_placeholder);
												_placeholder.style.display = "";
												_positionedPlceholder = true;
											}
										}
									}
									else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,data._mousePosition) && checkForBetween(_elemBelow,data._mousePosition,elem/*,isRelativeY,scrollDiv*/)){
										// $L(_elemBelow).append(_placeholder);
										_lyteUiUtils.appendChild(_elemBelow,_placeholder);
										_placeholder.style.display = "";
										_positionedPlceholder = true;
									}
									else{
										if(!checkPlaceholderBelow(_elemBelow) && !($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data))){
											// console.log("placeholder set to false");
											if(document.getElementById('lyteDraggableDummy')){
												document.getElementById('lyteDraggableDummy').style.display = "none";
											}
											_positionedPlceholder = false;
										}
									}

									if(_positionedPlceholder){
										if(!data.onPlaceholder || checkValidDroppable(data,_placeholder)){
											if($L(_placeholder).hasClass(data.disabled)){
												$L(_placeholder).removeClass(data.disabled);
											}
											$L(_placeholder).addClass(data.placeholder);
										}
										else{
											if($L(_placeholder).hasClass(data.placeholder)){
												$L(_placeholder).removeClass(data.placeholder);
											}
											$L(_placeholder).addClass(data.disabled);
										}
									}
									
									// else{
									// 	console.log("checkParentDroppable",checkParentDroppable(_elemBelow,data._parentElem,_sortableElem,data.connectedWith));
									// 	console.log("checkForIntersect",checkForIntersect(_elemBelow,_mousePosition));
									// 	console.log("came here",_elemBelow);
									// }
									data._placeholder = _placeholder;
									data._positionedPlceholder = _positionedPlceholder;
								}
							}
						}
						
						//Check for any droppable element and if present execute its drag function
						if(typeof managerDD !== "undefined"){
							managerDD._drag(event);
						}
						data._isMoved = true;
					}
				}
			}

			var mouseUpEvent = function(event){
				// console.log(event.type, event.target);
				// console.log("calling mouseup from draggable");
				// event.preventDefault();
				// _handleElement = event.target.closest('.selected-element') ? event.target.closest('.selected-element') : document.querySelector('.selected-element');
				// var target = event.target;
				// _handleElement = null;
				// while(target && target != document){
				// 	if($L(target).hasClass("selected-element")){
				// 		_handleElement = target;
				// 		break;
				// 	}
				// 	target = target.parentElement;
				// }
				//Unbind mouseup and mousemove
				if(event.type == "mouseup"){
					document.removeEventListener('mousemove',mouseMoveEvent);
					document.removeEventListener('mouseup',mouseUpEvent);
				}
				//Unbinding touch events
				if(event.type == "touchend"){
					document.removeEventListener('touchmove',mouseMoveEvent, true);
					document.removeEventListener('touchend',mouseUpEvent, true);
				}

				if(manageDraggable.draggedEle && $L(manageDraggable.draggedEle).hasClass("selected-element") && manageDraggable.draggedEle._draggableData._isDown){
					_handleElement = manageDraggable.draggedEle;
				}
				else{
					_handleElement = null;
					return;
				}
				if(_handleElement){
					var data = _handleElement._draggableData;
					// if(event.type == "touchend"){
					// 	if(data._element.classList.contains('stopDefaultMove')){
					// 		data._element.classList.remove('stopDefaultMove');
					// 	}
					// }
					if(data.cursorAt && _lyteUiUtils.getRTL()){
						data.cursorAt = Object.assign({},data._preCursorAt);
		                data._preCursorAt = undefined;
		                
					}
					if(data.connectToSortable && lyteDomObj.prototype.manageSortable.prevSortable){
						lyteDomObj.prototype.manageSortable.prevSortable = false;
					}
					_placeholder = data._placeholder;
					if(data && data._isDown){
						data._isDown = false;
						var elem = data._element;
						if(data._isMoved){
							var placed = false;
							data._isMoved = false;
							_initialPos = data._initialPos;
							_marginTop = parseInt(data._marginTop);
							_marginLeft = parseInt(data._marginLeft);
							
							var returnVal = true;
							if(data.onBeforeStop){
								returnVal = onBeforeStop(data,event);
							}
							if(!returnVal){
								if(data.helper != "original"){
									elem.remove();
									if(document.getElementById('lyteDraggableDummy')){
										_placeholder.remove();
									}
									manageDraggable.draggedEle = null;
									return;
								}
								if(_initialPos.pos === "absolute"){
									elem.style.left = _initialPos.x + "px";
									elem.style.top = _initialPos.y + "px";
								}
								else{
									elem.style.left = "";
									elem.style.top = "";
									elem.style.position = "";
								}
								data._positionedPlceholder = false;
							}
							else{
								if(data.connectToSortable && data._positionedPlceholder){
									var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
									var elementData = sibling ? sibling._sortableChildData : _placeholder.parentElement._sortableParentData;
									// $L(_placeholder).replace(_div);
									_lyteUiUtils.replaceWith(_placeholder, elem);
									
									_placeholder = null;
									elem._sortableChildData = elementData;
									elem.removeEventListener('mousedown',mouseDownEvent);
									removeStyle(elem);
									placed = true;
								}
							}
							
							//Check for any droppable element & if present execute its drop function
							if(typeof managerDD !== "undefined"){
								managerDD._drop(event);
								managerDD._current = null;
								if(data.currDroppable && data.currDroppable._droppableData){
									data.currDroppable._droppableData.entered = false
									data.currDroppable = null;
								}
							}

							//Callback fired
							if(data.onStop){
								returnVal = onStop(data, event);
							}

							if(!returnVal){
								if(data.helper != "original" && !placed){
									elem.remove();
									if(document.getElementById('lyteDraggableDummy')){
										_placeholder.remove();
									}
									manageDraggable.draggedEle = null;
									return;
								}
								if(_initialPos.pos === "absolute"){
									elem.style.left = _initialPos.x + "px";
									elem.style.top = _initialPos.y + "px";
								}
								else{
									elem.style.left = "";
									elem.style.top = "";
									elem.style.position = "";
								}
							}

						}
						elem.style.zIndex = "";
						$L(_handleElement).removeClass('selected-element');

					}
					data.touchTarget = null;
					_handleElement = null;
					if(document.getElementById('lyteDraggableDummy')){
						document.getElementById('lyteDraggableDummy').remove();
						if(_placeholder){
							_placeholder = null;
						}
					}
				}
				var elements = event.target.ownerDocument.querySelectorAll(".selected-element");
				var draggableDummy = event.target.ownerDocument.querySelectorAll(".lyteDraggableDummy");
				for(var i = 0; i < elements.length; i++){
					var elem = elements[i],
						data = elem._draggableData;
					if(data.cursorAt && data._preCursorAt && _lyteUiUtils.getRTL()){
						data.cursorAt = Object.assign({},data._preCursorAt);
						data._preCursorAt = undefined;
					}
					if(data._placeholder){
						data._placeholder = null;
						data._positionedPlceholder = false;
					}
					data._isDown = false;
					data._isMoved = false;
					$L(elem).removeClass('selected-element');
					// $L(elem).removeClass('stopDefaultMove');
				}
				for(var i = 0; i < draggableDummy; i++){
					draggableDummy[i].remove();
				}

				manageDraggable.draggedEle = null;
			}

			/*---------------Callbacks Start--------------*/
			var onReady = function(data){
				data.onReady(data._element);
			}

			var onStart = function(data, event){
				returnVal = data.onStart(data._element, event);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onDragStart = function(data,_handleElement,_placeholder,event){
				data.onDragStart(data._element,_handleElement,_placeholder,event);
			}

			var onDrag = function(data, _handleElement,event){
				returnVal = data.onDrag(data._element,_handleElement,event);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onBeforeStop = function(data,event){
				returnVal = data.onBeforeStop(data._element,data._placeholder,data._positionedPlceholder ? data._placeholder.parentElement : null,event,getIndex(data, "onBeforeStop"));
				return (returnVal == undefined) ? true : returnVal;
			}

			var checkValidDroppable = function(data,placeholder){
				var returnVal = data.onPlaceholder(data._element,placeholder, data._element.parentElement, placeholder ? placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onStop = function(data,event){
				data._element.style.display = "none";
				if(event.type == "mouseup"){
					_elemBelow = document.elementFromPoint(event.clientX, event.clientY);
				}
				else if(event.type == "touchend"){
					_elemBelow = document.elementFromPoint(data.touchTarget[0].clientX,data.touchTarget[0].clientY);
				}
				data._element.style.display = "";
				returnVal = data.onStop(data._element, data._positionedPlceholder ? data._element.parentElement : null, _elemBelow,event,getIndex(data, "onStop"));
				return (returnVal === undefined) ? true : returnVal;
			}
			/*---------------Callbacks End--------------*/

			
			//Bind events
			data.__mousedown = mouseDownEvent;
			data.__mousemove = mouseMoveEvent;
			data.__mouseup = mouseUpEvent;
			if(!data._element._mousedown){
				if(typeof data.handle !== "string" && data.handle.length){
					data.handle.forEach(function(item){
						var ele = $L(item, data._element)[0];
						ele._draggableData = data;
						$L(ele).addClass('draggable-handle-element');
						ele.addEventListener('mousedown',data.__mousedown);
						ele.addEventListener('touchstart',data.__mousedown, true);
					});
				}
				else{
					data.handle._draggableData = data; 
					$L(data.handle).addClass('draggable-handle-element');
					data.handle.addEventListener('mousedown',data.__mousedown);
					data.handle.addEventListener('touchstart',data.__mousedown, true);
				}
				data._element._mousedown = true;
			}
			
			

			//Callback fired
			if(data.onReady){
				onReady(data);
			}

			var checkParentDroppable = function(_elemBelow,data){
				if(_elemBelow.matches(data.connectToSortable) && _elemBelow._sortableParentData.droppable){
					return true;
				}
				return false;
			}

			var calculateHeight = function(element) {
				var cs = getComputedStyle(element);

				var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

				var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

				// Element height minus padding and border
				var elementHeight = element.offsetHeight - paddingY - borderY;
				return elementHeight;
			};

			var calculateWidth = function(element) {
				var cs = getComputedStyle(element);

				var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);

				var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

				// Element width minus padding and border
				var elementWidth = element.offsetWidth - paddingX - borderX;
				return elementWidth;
			};

			var callForScrollY = function(data,scrollDiv,parentOffset,_maxScrollHeight,isRelativeY,_mousePosition,_offset,parent){
				var divOffset = data._element.getBoundingClientRect();
				// var diff = data._placeholder.parentElement.offsetTop - scrollDiv.offsetTop + 5;
				var scrollTop = scrollDiv.scrollTop;
				// console.log("Scroll Y getting called",_maxScrollHeight,"    scrollTop",scrollTop);
				
				if((divOffset.top - parseInt(data._marginTop) <= parentOffset.top /*+ diff*/) && (scrollTop > 0)){
					if(isRelativeY){
						data._element.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= data.scrollSpeed ? data.scrollSpeed : _maxScrollHeight - scrollTop) + scrollTop + "px";
					}
					scrollDiv.scrollTop -= data.scrollSpeed;
				}
				else if((divOffset.bottom >= (parentOffset.bottom - 3)) && (scrollTop < _maxScrollHeight)){
					if(_maxScrollHeight - scrollTop > data.scrollSpeed){
						if(isRelativeY){
							data._element.style.top = _mousePosition.y - _offset[1] - parent.top + data.scrollSpeed + scrollTop + "px";
						}
						scrollDiv.scrollTop += data.scrollSpeed;
					}
					else{
						if(isRelativeY){
							data._element.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop + scrollTop + "px";
						}
						scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
					}
				}
				else{
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
					return;
				}
				_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,isRelativeY,_mousePosition,_offset,parent));
				
			};

			var callForScrollX = function(data,parentOffset,_maxScrollWidth,_mousePosition,_offset,parent,isRelative){
				var divOffset = data._element.getBoundingClientRect();
				_scrollLeft = data.scrollDivX.scrollLeft;
				// _maxScrollWidth = data._maxScrollWidth;
				// console.log("Scroll X getting called",_maxScrollWidth,"   scrollleft",_scrollLeft);
				if( !_lyteUiUtils.getRTL() || (!_lyteUiUtils.isNegativeScroll() && _lyteUiUtils.getRTL() && detectBrowser() == "chrome" && !isRelative)){
					if((divOffset.right >= parentOffset.right - 2) && (_scrollLeft < _maxScrollWidth)){
						if((_maxScrollWidth - _scrollLeft) >= data.scrollSpeed){
							data.scrollDivX.scrollLeft += data.scrollSpeed;
							if(isRelative){
								data._element.style.left = _mousePosition.x - _offset[0] - parent.left + data.scrollSpeed + _scrollLeft + "px";
							}
						}
						else{
							data.scrollDivX.scrollLeft += (data.scrollSpeed - (_maxScrollWidth - _scrollLeft));
							if(isRelative){
								data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (data.scrollSpeed - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
							}
						}
					}
					else if((divOffset.left <= parentOffset.left + 2) && (_scrollLeft > 0)){
						if(isRelative){
							data._element.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) > data.scrollSpeed ? data.scrollSpeed : (data.scrollSpeed - (_maxScrollWidth - _scrollLeft))) + _scrollLeft + "px";
						}
						data.scrollDivX.scrollLeft -= data.scrollSpeed;
					}
					else{
						cancelAnimationFrame(_requestId2);
						_animationFrameFired2 = false;
						_requestId2 = null;
						return;
					}
				}
				else{
					if(!_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome" && isRelative){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft < _maxScrollWidth)){
							if((_maxScrollWidth - _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative){
									data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + (_scrollLeft - _maxScrollWidth) + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
								if(isRelative){
									data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft > 0)){
							if(isRelative){
								data._element.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) + 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if((_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome") || detectBrowser() == "firefox" || detectBrowser() == "safari"){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft < 0)){
							if((_maxScrollWidth + _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative){
									data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth + _scrollLeft));
								if(isRelative){
									data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft > -(_maxScrollWidth))){
							if(isRelative){
								data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (_scrollLeft - 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if(detectBrowser() == "ie" || detectBrowser() == "edge"){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft > 0)){
							if(_scrollLeft >= 5){
								data.scrollDivX.scrollLeft -= 5;
								// if(isRelative){
								// 	data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
								// }
							}
							else{
								data.scrollDivX.scrollLeft -= _scrollLeft;
								// if(isRelative){
								// 	data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
								// }
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft < _maxScrollWidth)){
							if(isRelative){
								data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (-_scrollLeft) - 5 + "px";
							}
							data.scrollDivX.scrollLeft += 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}

				}
				_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,parentOffset,_maxScrollWidth,_mousePosition,_offset,parent,isRelative)); 
			};

			var detectBrowser = function(){
				//Check if browser is IE11
			    if (navigator.userAgent.search("rv:11") >= 0) {
			        return "ie";
			    }
			    //Check if browser is Edge
			    if (navigator.userAgent.search("Edge") >= 0) {
			        return "edge";
			    }
			    //Check if browser is Chrome || Opera
			    else if (navigator.userAgent.search("Chrome") >= 0) {
			        return "chrome";
			    }
			    //Check if browser is Firefox 
			    else if (navigator.userAgent.search("Firefox") >= 0) {
			        return "firefox";
			    }
			    //Check if browser is Safari
			    else if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
			        return "safari";
			    }
			};

			var checkForIntersect = function(parentElem,mP){
				var cs = window.getComputedStyle(parentElem);
				var offset = parentElem.getBoundingClientRect();
				// console.log("cs",cs);
				// console.log("offset",offset);
				// console.log("_mousePosition",mP.x,mP.y);
				if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
					return true;
				}
				return false; 
			};

			var checkForBetween = function(parentElem,mP,div){
				var childrens = parentElem.children;
				var templateTags = 0;
				var childElem = [];
				for(var i = 0;i<childrens.length;i++){
					if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy"){
						childElem.push(childrens[i]);
					}
					else{
						templateTags++;
					}
				}
				if(templateTags == childrens.length){
					return true;
				}
				else if(div.getBoundingClientRect().top > (childElem[childElem.length - 1].getBoundingClientRect().bottom/* + (isRelativeY ? scrollDiv.scrollTop : 0)*/)){
					return true;
				}
				return false;
			};


			var findPreviousElem = function(elem){
				while(elem.previousElementSibling){
					elem = elem.previousElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var findNextElem = function(elem){
				while(elem.nextElementSibling){
					elem = elem.nextElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var removeStyle = function(elem){
				elem.style.left = "";
				elem.style.top = "";
				elem.style.zIndex = "";
				elem.style.position = "";
				$L(elem).addClass("sortable-element "+elem._sortableChildData.sortableElemClass);
				elem.classList.remove('draggable-handle-element','draggable-element');
			};

			var findScrollDiv = function(elem){
				var parent = elem.parentElement;
				while(elem.parentElement){
					elem = elem.parentElement;
					if(parent.scrollHeight > elem.clientHeight && !(elem.style.overflow && elem.style.overflow == 'hidden')){
						return elem;
					}
				}
				return null;
			};

			var checkPlaceholderBelow = function(elem){
				while(elem){
					if(elem.id && elem.id === "lyteDraggableDummy"){
						return true;
					}
					elem = elem.parentElement;
				}
				return false;
			};

			var isNotRestricted = function(data,targetElem){
				for(var i = 0; i<data.restrict.length ; i++){
					if(targetElem.matches(data.restrict[i])){
						return false;
					}
				}
				return true;
			};

			var getIndex = function(data, fnName){
				if(data.connectToSortable && data._positionedPlceholder){
					var elem,parent;
					if(fnName === "onBeforeStop"){
						elem = data._placeholder;
						parent = data._placeholder.parentElement;
					}
					if(fnName === "onStop"){
						elem = data._element;
						parent = data._element.parentElement;
					}
					if(parent._sortableParentData.omitRestricted){
					var siblings = Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
						for(var y = 0; y<siblings.length; y++){
	                        if(!isNotRestricted(data,siblings[y])){
	                            siblings.splice(y,1);
	                            --y;
	                        }
	                    }
	                    return siblings.indexOf(elem);
					}
					else{
						return Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } ).indexOf(elem);
					}

				}
				return -1;
			};

			var getOS = function() {
				var userAgent = window.navigator.userAgent,
				    platform = window.navigator.platform,
				    macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
				    windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],
				    iosPlatforms = ['iPhone', 'iPad', 'iPod'],
				    os = null;

				if (macosPlatforms.indexOf(platform) !== -1) {
				    os = 'Mac OS';
				} else if (iosPlatforms.indexOf(platform) !== -1) {
				    os = 'iOS';
				} else if (windowsPlatforms.indexOf(platform) !== -1) {
				    os = 'Windows';
				} else if (/Android/.test(userAgent)) {
				    os = 'Android';
				} else if (!os && /Linux/.test(platform)) {
				    os = 'Linux';
				}

				return os;
			};

			return this;

		}
	}

})( window );
/*------------------------   NOTES   ------------------------*/
/*
  
*/


;(function( window ) {

	var lyteCaretHelper = {
		isPlainObject : function(obj){
			if (typeof obj == 'object' && obj !== null) {
				if (typeof Object.getPrototypeOf == 'function') {	// If Object.getPrototypeOf supported, use it
					var proto = Object.getPrototypeOf(obj);
					return proto === Object.prototype || proto === null;
				}
				// Otherwise, use internal class
			    // This should be reliable as if getPrototypeOf not supported, is pre-ES5
				return Object.prototype.toString.call(obj) == '[object Object]';
			}
			return false;
		},

		contentEditable : function(inputElem){
			return !!(inputElem.contentEditable && inputElem.contentEditable === 'true');
		}
	}

	if(lyteDomObj){	
		
		lyteDomObj.prototype.caret = function(query,value,iframe) {
			var settings;

			var InputFn = function(){
				return{
					contentEditable : false,
					getIEPos : function(){
						var endRange, inputElem, len, msg, pos, range, textRange;
					    inputElem = settings.element;
					    range = settings.document.selection.createRange();
					    pos = 0;
					    if (range && range.parentElement() === inputElem) {
					    	msg = inputElem.value.replace(/\r\n/g, "\n");
					    	len = msg.length;
					    	textRange = inputElem.createTextRange();
					    	textRange.moveToBookmark(range.getBookmark());
					    	endRange = inputElem.createTextRange();
					    	endRange.collapse(false);
					    	if (textRange.compareEndPoints("StartToEnd", endRange) > -1) {
					    		pos = len;
					    	}
					    	else{
					    		pos = -textRange.moveStart("character", -len);
					    	}
					    }
					    return pos;
					},

					getPos : function() {
						if (settings.document.selection) {
							return this.getIEPos();
						} else {
							return settings.element.selectionStart;
						}
					},

					setPos : function(pos){
						var inputElem, range;
					    inputElem = settings.element;
					    if (settings.document.selection) {
					    	range = inputElem.createTextRange();
    						range.move("character", pos);
    						range.select();
					    } else if (inputElem.setSelectionRange) {
					    	inputElem.setSelectionRange(pos, pos);
					    }
					    return inputElem;
					},

					getIEOffset : function(pos){
						var h, textRange, x, y;
					    textRange = settings.element.createTextRange();
					    pos || (pos = this.getPos());
					    textRange.move('character', pos);
					    x = textRange.boundingLeft;
					    y = textRange.boundingTop;
					    h = textRange.boundingHeight;
					    return {
    						left: x,
    						top: y,
    						height: h
    					};
					},

					getOffset : function(pos){
						var inputElem, offset, position;
					    inputElem = settings.element;
					    if (settings.document.selection) {
					    	offset = this.getIEOffset(pos);
					    	offset.top += $L(settings.window).scrollTop() + settings.domObj.scrollTop();
					    	return offset;
					    } else {
					    	offset = settings.domObj.offset();
    						position = this.getPosition(pos);
    						return offset = {
    							left: offset.left + position.left - settings.domObj.scrollLeft(),
    							top: offset.top + position.top - settings.domObj.scrollTop(),
    							height: position.height
    						};
					    }
					},

					getPosition : function(pos){
						var inputElem, startString, endString, html, cloneObj;
					    inputElem = settings.element;
					    if (pos === undefined) {
					    	pos = this.getPos();
					    }
					    startString = settings.domObj.val().slice(0, pos);
					    endString = settings.domObj.val().slice(pos);
					    cloneObj = new Clone();
					    return cloneObj.createClone(this.createHTML(startString,endString)).getPosition();
					},

					getIEPosition : function(pos) {
					    var h, inputOffset, offset, x, y;
					    offset = this.getIEOffset(pos);
					    inputOffset = settings.domObj.offset();
					    x = offset.left - inputOffset.left;
					    y = offset.top - inputOffset.top;
					    h = offset.height;
					    return {
					    	left: x,
					    	top: y,
					    	height: h
					    };
					},

					createHTML : function(startString, endString){
						return ("<span style='position: relative; display: inline;'>" + this.htmlEncode(startString) + "</span>"+
								"<span id='caret' style='position: relative; display: inline;'>|</span>" +
								"<span style='position: relative; display: inline;'>" + this.htmlEncode(endString) + "</span>");
					},

					htmlEncode : function(value) {	//To replace special characters, break and space iwth their respective tags
				    	value = value.replace(/<|>|`|"|&/g, '?').replace(/\r\n|\r|\n/g, "<br/>");
				    	if (/firefox/i.test(navigator.userAgent)) {
					        value = value.replace(/\s/g, '&nbsp;');
					    }
					    return value;
				    }
				};
			};

			var Clone = function(){
				return{
					css_attr : ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontWeight", "height", "letterSpacing", "lineHeight", "marginBottom", "marginLeft", "marginRight", "marginTop", "outlineWidth", "overflow", "overflowX", "overflowY", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "textAlign", "textOverflow", "textTransform", "whiteSpace", "wordBreak", "wordWrap","wordSpacing"],

					copyCss : function() {
					    var css;
					    css = {
					    	position: 'absolute',
					    	left: -9999,
					    	top: 0,
					    	zIndex: -20000
					    };
					    if (settings.domObj.prop('tagName') === 'TEXTAREA') {
					    	this.css_attr.push('width');
					    }
					    $L(this.css_attr).each(function(i, p) {
					    	return css[p] = settings.domObj.css(p);
					    });
					    return css;
					},

					createClone : function(html){
						this.clone = $L('<div></div>');
					    this.clone.css(this.copyCss());
					    this.clone.html(html);
					    _lyteUiUtils.insertAfter(settings.element,this.clone[0]);
					    return this;
					},

					getPosition : function() {
					    var flag, pos, rect;
					    flag = this.clone.find("#caret");
					    pos = flag.position();
					    rect = {
					    	left: pos.left,
					    	top: pos.top,
					    	height: flag.height()
					    };
					    this.clone[0].remove();
					    return rect;
					}
				};
			};

			var EditableFn = function(){
				return{
					contentEditable : true,
					setPos : function(pos) {
						var offset, found, result, fun, sel = settings.window.getSelection();
						if(sel){
							offset = 0;
							found = false;
							fun = function(pos, parent){
								var node, range, i, len, childNodes, result;
						        childNodes = parent.childNodes;
						        result = [];
						        for (i = 0, len = childNodes.length; i < len; i++) {
						        	node = childNodes[i];
							        if (found) {
							            break;
							        }
							        if (node.nodeType === 3) {
							            if (offset + node.length >= pos) {
							            	found = true;
							            	range = settings.document.createRange();
							            	range.setStart(node, pos - offset);
							            	sel.removeAllRanges();
							            	sel.addRange(range);
							            	break;
							            } else {
							            	result.push(offset += node.length);
							            }
							        } else {
							            result.push(fun(pos, node));
							        }
						        }
						        return result;
							}
							result = fun.call(this,pos,settings.element);
						}
						return settings.element;
					},

					getIEPosition : function() {
					    return this.getPosition();
					},

					/*
						* get the caret offset 
						* subtract the content editable element's offset from that will give the position.
					*/
					getPosition : function() {
					    var inputElemffset, offset;
					    offset = this.getOffset();
					    inputElemffset = settings.domObj.offset();
					    offset.left -= inputElemffset.left;
					    offset.top -= inputElemffset.top;
					    return offset;
					},

					getIEPos : function() {
					    var preCaretTextRange, textRange;
					    textRange = settings.document.selection.createRange();
					    preCaretTextRange = settings.document.body.createTextRange();
					    preCaretTextRange.moveToElementText(settings.element);
					    preCaretTextRange.setEndPoint("EndToEnd", textRange);
					    return preCaretTextRange.text.length;
					},

					/*
						* if range available
							* clone range
							* make cloned range to contain the contents of the contentEditable element
							* set the end of the cloned range to the value of the endContainer's end offset (ie. caret position)
							* get the cloned range's string length which will be the position of the caret
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
						* else its IE browser and call the respective getPos method.
					*/
					getPos : function() {
					    var clonedRange, pos, range;
					    if (range = this.getRange()) {
					    	clonedRange = range.cloneRange();
					    	clonedRange.selectNodeContents(settings.element);
					    	clonedRange.setEnd(range.endContainer, range.endOffset);
					    	pos = clonedRange.toString().length;
					    	clonedRange.detach();
					    	return pos;
					    } else if (settings.document.selection) {
					    	return this.getIEPos();
					    }
					},

					getIEOffset : function() {
					    var range, rect;
					    range = settings.document.selection.createRange().duplicate();
					    range.moveStart("character", -1);
					    rect = range.getBoundingClientRect();
					    return {
					    	height: rect.bottom - rect.top,
					    	left: rect.left,
					    	top: rect.top
					    };
					},

					/*
						* get the range Object - fragment of document that can contain nodes and parts of text nodes
						* if (caret is not at the strating position ie. 0)
							* clone the range object and set its start (=> start = end-1) and end
							* calculate the client rect of the clone
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
						* else if (caret position == 0)
							* clone the range object
							* create a text node with pipe character('|') and insert it in the range node.
							* select the created node and calculate the client rect.
							* remove the created node 
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
					*/
					getOffset : function(pos) {
					    var clonedRange, offset, range, rect, shadowCaret;
					    if (settings.window.getSelection && (range = this.getRange())) {
					    	if (range.endOffset - 1 > 0 && range.endContainer !== settings.element) {
						        clonedRange = range.cloneRange();
						        clonedRange.setStart(range.endContainer, range.endOffset - 1);
						        clonedRange.setEnd(range.endContainer, range.endOffset);
						        rect = clonedRange.getBoundingClientRect();
						        offset = {
						          height: rect.height,
						          left: rect.left + rect.width,
						          top: rect.top
						        };
						        clonedRange.detach();
					    	}
					    	if (!offset || (offset != null ? offset.height : undefined) === 0) {
						        clonedRange = range.cloneRange();
						        shadowCaret = settings.document.createTextNode("|");
						        clonedRange.insertNode(shadowCaret);
						        clonedRange.selectNode(shadowCaret);
						        rect = clonedRange.getBoundingClientRect();
						        offset = {
						          height: rect.height,
						          left: rect.left,
						          top: rect.top
						        };
						        shadowCaret.remove();
						        clonedRange.detach();
					    	}
					    } else if (settings.document.selection) {
					    	offset = this.getIEOffset();
					    }
					    if (offset) {
					    	offset.top += $L(settings.window).scrollTop();
					    	offset.left += $L(settings.window).scrollLeft();
					    }
					    return offset;
					},

					/*
						* if window.getSelection available
							* get the selection object and return the range object from that
						* else return null
					*/
					getRange : function() {
					    var sel;
					    if (!settings.window.getSelection) {
					      return;
					    }
					    sel = settings.window.getSelection();
					    if (sel.rangeCount > 0) {
					      return sel.getRangeAt(0);
					    } else {
					      return null;
					    }
					}
				};
			};

			var setContextBy = function(mode){
				if (!!mode) {
					var iframe = mode != null ? mode.iframe : undefined;
					var fWindow = iframe.contentWindow;
					return{
						iframe : iframe,
						window : fWindow,
						document : iframe.contentDocument || fWindow.document
					}
				} else {
					return{
						iframe : undefined,
						window : window,
						document : document
					}
				}
			};

			if(lyteCaretHelper.isPlainObject(value)){
				settings = setContextBy(value);
				value = undefined;
			}
			else{
				settings = setContextBy(iframe);
			}
			if(this[0].tagName == "LYTE-INPUT"){
				if(this[0].ltProp('type') == "textarea"){
					settings.element = this[0].querySelector('textarea');
				}
				if(this[0].ltProp('type') == "text"){
					settings.element = this[0].querySelector('text');
				}
				settings.domObj = $L(settings.element);
			}
			else{
				settings.element = this[0];
				settings.domObj = this;
			}
			
			var executableObj = lyteCaretHelper.contentEditable(this[0]) ? new EditableFn() : new InputFn();

			if(query === "pos"){
				if (value || value === 0) {
			    	return executableObj.setPos(value);
			    } else {
			    	return executableObj.getPos();
			    }
			} else if(query === "position"){
				if (settings.document.selection) {
			    	return executableObj.getIEPosition(value);
			    } else {
			    	return executableObj.getPosition(value);
			    }
			}else if(query === "offset"){
				var offset;
			    offset = executableObj.getOffset(value);
			    return offset;
			} else{
				console.error("Sorry! The method ",query," doesn\'t match the predefined set of methods. Kindly check.");
				return null;
			}

	    	return this;
		}
		
	}

})( window );

;(function(){

  if(lyteDomObj){

    lyteDomObj.prototype.cropper = function(aRD){

      if( (aRD === "destroy") || (aRD === "Destroy")){

        var userImage = this[0];
        var userImageParent = userImage.parentElement
        var cropperWrapperDiv = $L(userImageParent).find('.lyteCropArea')[0];

        userImageParent.removeChild(cropperWrapperDiv);
        $L(userImage).data('cropper' , {})
        userImage.style.display = "block";

      } else {
        if(aRD){
          if(!aRD.type){
            aRD.type = 'default'
          }
        }
        if(aRD.type === 'default'){

                        /*
                          * getBoundingClientRect function
                        */
                        function getBCR(elem){
                          return elem.getBoundingClientRect();
                        }

                        /*
                          * Cropper global variables
                        */

                        // Parent image variables

                        var imageTag = this[0],imageData,naturalAR = 1,cropperDiv = imageTag.parentElement,aspectRatio = 'n:n',aspectDiff = 1,imageType,aR = aRD,initialRotateAngle;
                        var useExif = false;

                        if(aRD){
                          if(aRD.useExif){
                            useExif = aRD.useExif;
                          }
                        }

                        var beforeRender = function(){};
                        var afterRender = function(){};

                        if(aRD){
                          if(aRD.beforeRender){
                            beforeRender = aRD.beforeRender;
                          }
                          if(aRD.afterRender){
                            afterRender = aRD.afterRender;
                          }
                        }


                        var exifRotate=0,gotRotateData = false,exifRotateY = 0;
                        var imageOrientation = '';


                        function getImageExif(){
                          if($L.exif){
                            $L.exif({
                                target : imageTag,
                                getData : function(obj){
                    							imageTag = obj.target;
                    							if(getComputedStyle(imageTag).imageOrientation !== "from-image"){
                    								var rValue = obj.exifdata.Orientation;
                    								switch(rValue) {
                                      case 1 :
                                        exifRotate = 0;
                    										break;
                    									case 2 :
                                        exifRotate = 0;
                                        exifRotateY = 180;
                    										break;
                    									case 3 :
                                        exifRotate = 180;
                    										break;
                    									case 4 :
                                        exifRotate = 180;
                                        exifRotateY = 180;
                    										break;
                    									case 5 :
                                        exifRotate = 270;
                                        exifRotateY = 180;
                    										break;
                    									case 6 :
                                        exifRotate = 90;
                    										break;
                    									case 7 :
                                        exifRotate = 90;
                                        exifRotateY = 180;
                    										break;
                    									case 8 :
                                        exifRotate = 270;
                                        break;
                    						        }
                                        beforeRender(obj.exifdata.Orientation);
                                        gotRotateData = true;
                                        if(gotRotateData){
                                          loadCropper();
                                          if($L(imageTag).data('cropper')){
                                            initialRotateAngle = $L(imageTag).data('cropper').angle;
                                            exifRotateY = $L(imageTag).data('cropper').exifAngle;
                                          } else {
                                            initialRotateAngle = exifRotate;
                                          }
                                          imageTag.style.display = "none";
                                          constructor();
                                          afterRender();
                                        }
                    							}
                    						}
                            })
                          }
                        }






                        // if($L(imageTag).data('cropper')){
                        //   initialRotateAngle = $L(imageTag).data('cropper').angle;
                        // } else {
                        //   if(aRD.angle){
                        //     initialRotateAngle = aRD.angle;
                        //   } else {
                        //     initialRotateAngle = 0;
                        //   }
                        //
                        // }

                        if(!aR) {

                          aR = {
                            'aspectRatio' : 'n:n'
                          }

                        }

                        // Cropper variables

                        var cropArea , box , fixedDiv , opacityDiv , cropper , divImage , displayArea , displayImageDiv,topEdge , bottomEdge , leftEdge , rightEdge , topRightCorner , bottomRightCorner , topLeftCorner , bottomLeftCorner,mainImage , fixedImage , divImageImg , displayImage,cropVerGrid1 , cropVerGrid2 , cropVerGrid3 , cropHorGrid1 , cropHorGrid2 , cropHorGrid3,cropperParent,modalDets,topSpan , bottomSpan , leftSpan , rightSpan,cropData = {},cropStart = function(){},cropDrag = function(){} , onSet = function(){} , cropEnd = function(){};

                        // Cropper Dimension variables

                        var leastHeight , leastWidth , maxHeight , maxWidth;


                        // imageData = getBCR(imageTag);
                        // imageTag.style.display = "none";
                        // imageTag.addEventListener('load' , loadCropper);

                        /*
                          * Re create cropper
                        */


                        if(cropperDiv.querySelectorAll('.lyteCropArea').length !==0 ){
                          var element = cropperDiv.querySelectorAll('.lyteCropArea')[0];
                          exifRotateY = $L(imageTag).data('cropper').exifAngle;
                          if($L(imageTag).data('cropper')){
                            initialRotateAngle = $L(imageTag).data('cropper').angle;
                            exifRotateY = $L(imageTag).data('cropper').exifAngle;
                          } else {
                            initialRotateAngle = exifRotate;
                          }
                          cropperDiv.removeChild(element);
                          imageTag.style.display = "block";
                          imageData = getBCR(imageTag);
                        }


                        function loadCropper(){
                          if((imageTag.complete)&&(cropperDiv.querySelectorAll('.lyteCropArea').length ===0)){
                            imageData = getBCR(imageTag);
                            imageTag.style.display = "none";
                          }
                          imageTag.removeEventListener('load' , loadCropper);
                        }


                        /*
                          * Cropper element Creation
                        */

                        // Creating cropper elements

                        function createCropperElements(){

                          cropArea = document.createElement("DIV");
                          box = document.createElement("DIV");
                          fixedDiv = document.createElement("DIV");
                          opacityDiv = document.createElement("DIV");
                          divImage = document.createElement("DIV")
                          cropper = document.createElement("DIV");
                          topEdge = document.createElement("DIV");
                          bottomEdge = document.createElement("DIV");
                          leftEdge = document.createElement("DIV");
                          rightEdge = document.createElement("DIV");
                          topRightCorner = document.createElement("DIV");
                          topLeftCorner = document.createElement("DIV");
                          bottomRightCorner = document.createElement("DIV");
                          bottomLeftCorner = document.createElement("DIV");
                          cropVerGrid1 = document.createElement("SPAN");
                          cropVerGrid2 = document.createElement("SPAN");
                          cropHorGrid1 = document.createElement("SPAN");
                          cropHorGrid2 = document.createElement("SPAN");
                          topSpan = document.createElement("SPAN");
                          bottomSpan = document.createElement("SPAN");
                          leftSpan = document.createElement("SPAN");
                          rightSpan = document.createElement("SPAN");
                          mainImage = document.createElement("IMG")
                          fixedImage = document.createElement("IMG")
                          divImageImg = document.createElement("IMG");

                        }

                        // Appending cropper elements to dom

                        function appendCropperElements(){

                          createCropperElements();

                          cropperParent = imageTag.parentElement;

                          cropperParent.appendChild(cropArea);
                          cropArea.appendChild(box);
                          box.appendChild(fixedDiv);
                          fixedDiv.appendChild(fixedImage);
                          box.appendChild(opacityDiv);
                          box.appendChild(cropper);
                          cropper.appendChild(topEdge);
                          topEdge.appendChild(topSpan);
                          cropper.appendChild(bottomEdge);
                          bottomEdge.appendChild(bottomSpan)
                          cropper.appendChild(leftEdge);
                          leftEdge.appendChild(leftSpan)
                          cropper.appendChild(rightEdge);
                          rightEdge.appendChild(rightSpan);
                          cropper.appendChild(topRightCorner);
                          cropper.appendChild(topLeftCorner);
                          cropper.appendChild(bottomLeftCorner);
                          cropper.appendChild(bottomRightCorner);
                          cropper.appendChild(cropVerGrid1);
                          cropper.appendChild(cropVerGrid2);
                          cropper.appendChild(cropHorGrid1);
                          cropper.appendChild(cropHorGrid2);
                          cropper.appendChild(divImage);
                          divImage.appendChild(divImageImg);

                        }

                        // Setting class for cropper elements

                        function setClassAttribute(){

                          appendCropperElements();

                          cropArea.setAttribute("class" , "lyteCropArea");
                          mainImage.setAttribute("class" , "lyteCropMainImage");
                          box.setAttribute("class" , "lyteCropBox");
                          fixedDiv.setAttribute("class" , "lyteCropFixedDiv");
                          fixedImage.setAttribute("class" , "lyteCropFixedImage");
                          opacityDiv.setAttribute("class" , "lyteCropOpacityDiv");
                          cropper.setAttribute("class" , "lyteCropCropper");
                          cropVerGrid1.setAttribute("class" , "lytecropVerGrid1");
                          cropVerGrid2.setAttribute("class" , "lytecropVerGrid2");
                          cropHorGrid1.setAttribute("class" , "lytecropHorGrid1");
                          cropHorGrid2.setAttribute("class" , "lytecropHorGrid2");
                          topEdge.setAttribute("class" , "lyteCropTopEdge");
                          topSpan.setAttribute("class" , "lyteCropTopSpan");
                          bottomEdge.setAttribute("class" , "lyteCropBottomEdge");
                          bottomSpan.setAttribute("class" , "lyteCropBottomSpan");
                          leftEdge.setAttribute("class" , "lyteCropLeftEdge");
                          leftSpan.setAttribute("class" , "lyteCropLeftSpan");
                          rightEdge.setAttribute("class" , "lyteCropRightEdge");
                          rightSpan.setAttribute("class" , "lyteCropRightSpan");
                          topRightCorner.setAttribute("class" , "lyteCropTopRightCorner");
                          topLeftCorner.setAttribute("class" , "lyteCropTopLeftCorner");
                          bottomRightCorner.setAttribute("class" , "lyteCropBottomRightCorner");
                          bottomLeftCorner.setAttribute("class" , "lyteCropBottomLeftCorner");
                          divImage.setAttribute("class" , "lyteCropDivImage");
                          divImageImg.setAttribute("class" , "lyteCropDivImageImg");

                        }


                        /*
                          * Constructing cropper and assigning global values
                        */

                        function constructor(){

                          if(aR){

                            aspectRatio = aR.aspectRatio;

                          }

                          if(aR.cropStart){
                              cropStart = aR.cropStart;
                          }
                          if(aR.cropDrag){
                              cropDrag = aR.cropDrag;
                          }
                          if(aR.onSet){
                              onSet = aR.onSet;
                          }
                          if(aR.cropEnd){
                              cropEnd = aR.cropEnd;
                          }

                          switch (aspectRatio) {
                            case 'n:n': aspectDiff = undefined; break;
                            case '1:1': aspectDiff = 1/1; break;
                            case '2:3': aspectDiff = 2/3; break;
                            case '3:2': aspectDiff = 3/2; break;
                            case '4:3': aspectDiff = 4/3; break;
                            case '3:4': aspectDiff = 3/4; break;
                            case '16:9': aspectDiff = 16/9; break;
                            case '9:16': aspectDiff = 9/16; break;
                          }

                          naturalAR = imageTag.naturalWidth / imageTag.naturalHeight;

                          if(imageTag.naturalWidth > imageTag.naturalHeight){
                            imageType = 'landscape';
                          } else if(imageTag.naturalWidth <= imageTag.naturalHeight){
                            imageType = 'portrait';
                          }

                          setClassAttribute();

                          setCropperValues();

                          setMinAndMaxDim();

                          setCropperData();

                        }

                        /*
                          * Setting up cropper
                        */

                        // Setting least and max hwight and width

                        function setMinAndMaxDim(){

                          switch (aspectRatio) {
                            case 'n:n': getMinDim(1);getMaxDim(1); break;
                            case '1:1': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '2:3': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '3:2': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '4:3': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '3:4': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '16:9': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '9:16': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                          }

                        }

                        function getMinDim(diff){

                            if(aR.minSize){
                              leastWidth = aR.minSize;
                              leastHeight = aR.minSize / diff;
                            } else {
                              leastWidth = 15;
                              leastHeight = 15 / diff;
                            }


                        }

                        function getMaxDim(diff){

                          var fixedImageData = getBCR(fixedImage);

                          if(imageType === 'landscape'){

                            if(aR.maxSize){
                                if(aR.maxSize > fixedImageData.width){
                                  maxHeight = fixedImageData.height;
                                  maxWidth = fixedImageData.height * diff;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = fixedImageData.height;
                                    maxWidth = fixedImageData.width;
                                  }
                                } else {
                                  maxWidth = aR.maxSize;
                                  maxHeight = aR.maxSize / diff;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = aR.maxSize;
                                    maxWidth = aR.maxSize;
                                  }
                                }
                            } else {
                              maxHeight = fixedImageData.height;
                              maxWidth = fixedImageData.height * diff;
                              if(aspectRatio === "n:n"){
                                maxHeight = fixedImageData.height;
                                maxWidth = fixedImageData.width;
                              }
                            }

                          } else if(imageType === 'portrait'){

                            if(aR.maxSize){
                                if(aR.maxSize > fixedImageData.height){
                                  maxHeight = fixedImageData.width / diff;
                                  maxWidth = fixedImageData.width;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = fixedImageData.height;
                                    maxWidth = fixedImageData.width;
                                  }
                                } else {
                                  maxWidth = aR.maxSize * diff;
                                  maxHeight = aR.maxSize;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = aR.maxSize;
                                    maxWidth = aR.maxSize;
                                  }
                                }
                            } else {
                              maxHeight = fixedImageData.width / diff;
                              maxWidth = fixedImageData.width;
                              if(aspectRatio === "n:n"){
                                maxHeight = fixedImageData.height;
                                maxWidth = fixedImageData.width;
                              }
                            }
                          }

                        }

                        // Initial cropper values

                        function setInitialValues(){

                          var initialValue = {};


                          fixedImage.src = mainImage.src = divImageImg.src = imageTag.src;

                          initialValue.cropperWidth = getInitialWidth(aspectDiff);
                          initialValue.cropperHeight = getInitialHeight(aspectDiff);

                          return initialValue;

                        }

                        function getInitialWidth(diff){

                          var initialWidth;

                          if(aR.selection){

                            if(aR.selection.size){

                              initialWidth = parseFloat(aR.selection.size);

                              if(aR.maxSize){
                                if(parseFloat(aR.maxSize) < parseFloat(aR.selection.size)){
                                  initialWidth = parseFloat(aR.maxSize);
                                }
                              }
                              if(aR.minSize){
                                if(parseFloat(aR.minSize) > parseFloat(aR.selection.size)){
                                  initialWidth = parseFloat(aR.minSize);
                                }

                              }

                            } else {

                              initialValue = widthHeightCal().width;

                            }

                          } else {

                            if(aspectRatio === 'n:n'){
                              initialWidth = getBCR(fixedImage).width;
                            } else {
                              initialWidth = widthHeightCal().width;
                            }

                          }

                          return initialWidth;

                        }

                        function getInitialHeight(diff){

                          if(aspectRatio === 'n:n'){
                            diff = 1;
                          }

                          var initialHeight;

                          if(aR.selection){



                            if(aR.selection.size){

                              initialHeight = parseFloat(aR.selection.size) / diff;

                              if(aR.maxSize){
                                if(parseFloat(aR.maxSize) < parseFloat(aR.selection.size)){
                                  initialHeight = parseFloat(aR.maxSize) / diff;
                                }
                              }
                              if(aR.minSize){
                                if(parseFloat(aR.minSize) > parseFloat(aR.selection.size)){
                                  initialHeight = parseFloat(aR.minSize) / diff;
                                }
                              }

                            } else {

                              initialHeight = widthHeightCal().height;

                            }


                          } else {

                            if(aspectRatio === "n:n"){
                              initialHeight = getBCR(fixedImage).height;
                            } else {
                              initialHeight = widthHeightCal().height;
                            }

                          }

                          return initialHeight;

                        }

                        function widthHeightCal(){

                          var value = {};

                          if(imageType === "landscape"){

                            value.width = getBCR(fixedImage).height * aspectDiff
                            value.height = getBCR(fixedImage).height;

                          } else {

                            value.width = getBCR(fixedImage).width;
                            value.height = getBCR(fixedImage).width / aspectDiff;

                          }

                          if(value.width > getBCR(fixedImage).width){

                            value.width = getBCR(fixedImage).width;
                            value.height = getBCR(fixedImage).width / aspectDiff;

                          }

                          if(value.height > getBCR(fixedImage).height){

                            value.height = getBCR(fixedImage).height;
                            value.width = getBCR(fixedImage).height * aspectDiff;

                          }

                          return value

                        }

                        function getImageValues(){
                          var value = {};
                          switch (imageType) {
                            case 'landscape':
                            value.imageWidth = getBCR(cropperParent).width;
                            value.imageHeight = getBCR(cropperParent).width / naturalAR;
                            break;
                            case 'portrait':
                            value.imageWidth = getBCR(cropperParent).height * naturalAR;
                            value.imageHeight = getBCR(cropperParent).height;
                            break;
                          }

                          return value;

                        }


                        function getImageXY(){

                          var value = {};

                          if(imageType === 'landscape'){
                            value.imageTop = (getBCR(cropperParent).height - getBCR(fixedImage).height)/2;
                            value.imageLeft = 0;
                          } else {
                            value.imageTop = 0;
                            if(_lyteUiUtils.getRTL()){
                              value.imageLeft = "-"+(getBCR(cropperParent).width - getBCR(fixedImage).width)/2;
                            }else {
                              value.imageLeft = (getBCR(cropperParent).width - getBCR(fixedImage).width)/2;
                            }
                          }

                          return value;

                        }

                        function getCropperXY(){

                          var value = {};

                          if(aR.selection){

                            if(aR.selection.top){
                              value.cropperTop = cropperMaxXY().top;
                            } else {
                              value.cropperTop = getDefaultTopLeft().cropperTop;
                            }
                            if(aR.selection.left){
                              value.cropperLeft = cropperMaxXY().left;
                            } else {
                              value.cropperLeft = getDefaultTopLeft().cropperLeft;
                            }


                          } else {
                            value.cropperLeft = getDefaultTopLeft().cropperLeft;
                            value.cropperTop = getDefaultTopLeft().cropperTop;
                          }

                          return value;

                        }


                        function cropperMaxXY(){

                          var value = {};

                          if((parseFloat(aR.selection.top)+getBCR(cropper).height) > getBCR(opacityDiv).bottom){
                            value.top = getBCR(opacityDiv).height - getBCR(cropper).height;
                          } else {
                            value.top = parseFloat(aR.selection.top);
                          }
                          if((parseFloat(aR.selection.left)+getBCR(cropper).width) > getBCR(opacityDiv).right){
                            value.left = getBCR(opacityDiv).width - getBCR(cropper).width;
                          } else {
                            value.left = parseFloat(aR.selection.left);
                          }

                          return value;

                        }

                        function getDefaultTopLeft(){

                          var value = {};


                          if(imageType === 'portrait'){
                            value.cropperTop = (getBCR(opacityDiv).height - getBCR(cropper).height)/2;
                            value.cropperLeft = (getBCR(fixedImage).width - getBCR(cropper).width)/2;
                          } else {
                            value.cropperTop = (getBCR(opacityDiv).height - getBCR(cropper).height)/2;
                            value.cropperLeft = (getBCR(fixedImage).width - getBCR(cropper).width)/2;
                          }

                          return value;

                        }

                        function setCropperValues(){

                          var initialImageData = getImageValues();

                          fixedImage.style.height = initialImageData.imageHeight + "px";
                          fixedImage.style.width = initialImageData.imageWidth + "px";

                          divImageImg.style.height = initialImageData.imageHeight + "px";
                          divImageImg.style.width = initialImageData.imageWidth + "px";

                          cropArea.style.height = getBCR(fixedImage).height + "px";
                          cropArea.style.width = getBCR(fixedImage).width + "px";

                          var initialImageXY = getImageXY()

                          cropArea.style.left = initialImageXY.imageLeft + "px";
                          cropArea.style.top = initialImageXY.imageTop + "px";

                          var initialCropperData = setInitialValues();

                          cropper.style.height = initialCropperData.cropperHeight + "px";
                          cropper.style.width = initialCropperData.cropperWidth + "px";

                          var initialCropperXY = getCropperXY();

                          cropper.style.top = initialCropperXY.cropperTop + "px";
                          cropper.style.left = initialCropperXY.cropperLeft + "px";

                          divImageImg.style.left = - initialCropperXY.cropperLeft + "px";
                          divImageImg.style.top = - initialCropperXY.cropperTop + "px";

                          box.style.overflow = "unset";


                          var angle;
                          if(initialRotateAngle===90 || initialRotateAngle === 270){
                            var cropperDim = getBCR(cropper);
                            var cropAreaDim = getBCR(cropArea);
                            var imageDim = getBCR(fixedImage);
                            angle = initialRotateAngle;
                            var prevAng = initialRotateAngle - 90;
                            if(angle){
                              prevAng = initialRotateAngle - 90;
                              angle = initialRotateAngle;
                              if(angle >= 360){
                                angle = 0;
                              }
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            } else {
                              var angle = 90;
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            }
                            aspectDiff = 1/aspectDiff;
                            if(imageType === "landscape"){
                              imageType = "portrait";
                            } else {
                              imageType = "landscape";
                            }
                            setMinAndMaxDim();
                            positionCropper(cropperDim , cropAreaDim , imageDim , angle , prevAng);
                            // setMinAndMaxDim();
                          }
                          if((initialRotateAngle===180)||(initialRotateAngle === 0)){
                            angle = initialRotateAngle;
                            if(angle===0){
                              prevAng = initialRotateAngle - 90;
                              angle = initialRotateAngle;
                              if(angle >= 360){
                                angle = 0;
                              }
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            } else {
                              // var angle = 90;
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            }
                          }

                          setCropperData();

                          cropper.addEventListener("mousedown" , cropImage);

                        }

                        if((getComputedStyle(imageTag).imageOrientation !== 'from-image')&&(useExif)){

                          getImageExif();

                        } else {
                          beforeRender();
                          loadCropper();
                          constructor();
                          afterRender();
                        }


                        function cropImage(event){

                          cropStart();

                          cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 1;

                          opacityDiv.style.opacity = "0.6";

                          event.preventDefault();

                          var todo;
                          if((event.target.className === "lyteCropDivImageImg")||(event.target.className === "lyteCropDivImage")){
                            todo = "parent";
                          } else {
                            todo = "child"
                          }


                          var topEdge           =  $L('.lyteCropTopEdge')[0],
                              rightEdge         =  $L('.lyteCropRightEdge')[0],
                              bottomEdge        =  $L('.lyteCropBottomEdge')[0],
                              leftEdge          =  $L('.lyteCropLeftEdge')[0],
                              topRightCorner    =  $L('.lyteCropTopRightCorner')[0],
                              bottomRightCorner =  $L('.lyteCropBottomRightCorner')[0],
                              bottomLeftCorner  =  $L('.lyteCropBottomLeftCorner')[0],
                              topLeftCorner     =  $L('.lyteCropTopLeftCorner')[0];


                          switch(todo){

                            case "parent" :

                              if((event.target.className === 'lyteCropDivImage')||(event.target.className === 'lyteCropDivImageImg')){

                                var cropperMoveData = getBCR(cropper),
                                    opacityDivMoveData = getBCR(opacityDiv),
                                    cropAreaMoveData = getBCR(cropArea),
                                    boxMoveData = getBCR(box),
                                    fixedImageMoveData = getBCR(fixedImage),
                                    previousClientX = event.clientX,
                                    previousClientY = event.clientY,
                                    finalLeft = opacityDivMoveData.left - cropAreaMoveData.left,
                                    finalRight = opacityDivMoveData.right - cropperMoveData.width - boxMoveData.left,
                                    finalTop = opacityDivMoveData.top - cropAreaMoveData.top,
                                    finalBottom = ((cropAreaMoveData.bottom - (cropAreaMoveData.bottom - opacityDivMoveData.bottom) - cropperMoveData.height)-(window.innerHeight - cropAreaMoveData.bottom));


                                function removeCropMoveEvent(){

                                  opacityDiv.style.opacity = "";
                                  cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 0;
                                  document.removeEventListener("mousemove" , moveCropper);
                                  document.removeEventListener("mouseup" , removeCropMoveEvent);
                                  document.removeEventListener("mousedown" , moveCropper);

                                  setCropperData();

                                  onSet();


                                }


                                function moveCropper(event){
                                  cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 1;

                                  event.preventDefault();

                                  var evX = event.clientX;
                                  var evY = event.clientY;

                                  if(((cropperMoveData.top+(evY-previousClientY) - cropAreaMoveData.top)+cropAreaMoveData.top)>opacityDivMoveData.top){
                                    cropper.style.top = (cropperMoveData.top+(evY-previousClientY) - cropAreaMoveData.top)+"px";
                                  } else {
                                    cropper.style.top = finalTop +"px";
                                  }
                                  if(((cropperMoveData.left+(evX-previousClientX) - cropAreaMoveData.left)+cropAreaMoveData.left)>opacityDivMoveData.left){
                                    cropper.style.left = ((cropperMoveData.left+(evX - previousClientX))-cropAreaMoveData.left) + "px";
                                  } else {
                                    cropper.style.left = finalLeft + "px";
                                  }
                                  if(!(((cropperMoveData.right+(evX-previousClientX) - cropAreaMoveData.right)+cropAreaMoveData.right)<opacityDivMoveData.right)){
                                    cropper.style.left = finalRight +"px";
                                  }
                                  if(!(((cropperMoveData.bottom+(evY-previousClientY) - cropAreaMoveData.bottom)+cropAreaMoveData.bottom)<opacityDivMoveData.bottom)){
                                    cropper.style.top = opacityDivMoveData.bottom - cropperMoveData.height - cropAreaMoveData.top + "px";
                                  }

                                  var fixedImageTransform = fixedImage.style.transform;
                                  fixedImage.style.transform = 'rotate(0deg)';
                                  divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                  divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                  fixedImage.style.transform = fixedImageTransform;

                                  setCropperData();

                                }


                                document.addEventListener("mousemove" , moveCropper);
                                document.addEventListener("mouseup" , removeCropMoveEvent);

                              }

                            break;


                            case "child" :

                            {
                              var cropperData = getBCR(cropper),
                                  cropperLeft = cropperData.left,
                                  cropperTop = cropperData.top,
                                  cropperWidth = cropperData.width,
                                  cropperHeight = cropperData.height,
                                  cropperRight = cropperData.right,
                                  cropperBottom = cropperData.bottom,
                                  opacityDivData = getBCR(opacityDiv),
                                  opacityDivTop = opacityDivData.top,
                                  opacityDivLeft = opacityDivData.left,
                                  opacityDivWidth = opacityDivData.width,
                                  opacityDivHeight = opacityDivData.height,
                                  opacityDivBottom = opacityDivData.bottom,
                                  opacityDivRight = opacityDivData.right,
                                  cropAreaData = getBCR(cropArea),
                                  cropAreaTop = cropAreaData.top,
                                  cropAreaLeft = cropAreaData.left,
                                  cropAreaWidth = cropAreaData.width,
                                  cropAreaHeight = cropAreaData.height,
                                  cropAreaRight = cropAreaData.right,
                                  cropAreaBottom = cropAreaData.bottom,
                                  boxData = getBCR(box),
                                  boxHeight = boxData.height,
                                  boxWidth = boxData.width,
                                  boxLeft = boxData.left,
                                  boxTop = boxData.top,
                                  fixedImageData = getBCR(fixedImage),
                                  fixedImageLeft = fixedImageData.left,
                                  fixedImageTop = fixedImageData.top,
                                  fixedImageWidth = fixedImageData.width,
                                  fixedImageheight = fixedImageData.height,
                                  previousClientX = event.clientX,
                                  previousClientY = event.clientY,
                                  midHeight       = (cropperData.top + (cropperData.height / 2)) - cropAreaData.top,
                                  midWidth        = (cropperData.left + (cropperData.width / 2)) - cropAreaData.left,
                                  finalLeft       = opacityDivData.left - cropAreaData.left,
                                  finalTop        = opacityDivData.top - cropAreaData.top,
                                  finalRight      = opacityDivData.right - cropperData.width - boxData.left,
                                  tempWidth ,
                                  tempHeight,
                                  todoC;
                              if (event.target.className === "") {
                                todoC = event.target.parentElement.className;
                              } else {
                                todoC = event.target.className;
                              }


                              function removeResizeEvent(){
                                opacityDiv.style.opacity = "";
                                cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 0;
                                document.removeEventListener("mousemove" , resizeCropper);
                                document.removeEventListener("mouseup" , removeResizeEvent);
                                setCropperData();

                                cropEnd();

                              }


                              function resizeCropper(event){

                                setCropperData();

                                cropDrag();

                                var cropperNewTop , cropperNewLeft , cropperNewWidth , cropperNewHeight , cropperNewRight , cropperNewBottom,evX = event.clientX,evY = event.clientY,presentClientX = event.clientX,presentClientY = event.clientY,cropperDummyData = getBCR(cropper);

                                function upDCropperDD(){
                                  cropperDummyData = getBCR(cropper);
                                }

                                switch(todoC){

                                  case "lyteCropLeftEdge":

                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewLeft = 0; cropperNewWidth = 0; cropperNewHeight= 0;

                                  if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                    if(evX > opacityDivLeft){
                                      cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                      cropperNewHeight  = (cropperWidth - (presentClientX - previousClientX))/aspectDiff + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) + ((presentClientX - previousClientX)/aspectDiff)/2) + "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(evX-6 <= opacityDivLeft){
                                      if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.top < opacityDivTop)){
                                        cropperNewTop = (opacityDivBottom - (((opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff) + (opacityDivBottom - (midHeight + ((opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff)/2)))) + "px";
                                        cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                        $L(cropper).css({'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      cropperNewWidth = cropperRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.bottom >= opacityDivBottom){
                                      cropperNewTop = opacityDivBottom - cropperDummyData.height - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.top <= opacityDivTop){
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.bottom >= opacityDivBottom)&&(cropperDummyData.top <= opacityDivTop)){
                                      cropperNewLeft = cropperRight - ((opacityDivBottom - opacityDivTop)*aspectDiff) - cropAreaLeft + "px";
                                      cropperNewWidth = (opacityDivBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = opacityDivBottom - opacityDivTop + "px";
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }

                                  }else if(((cropperWidth - (evX - previousClientX))<=leastWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                      cropperNewTop     = (midHeight - (leastHeight/2)) + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }else if(((cropperWidth - (evX+6 - previousClientX))>=maxWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = (cropperWidth - (presentClientX - previousClientX))/aspectDiff;
                                      var checkWidth = cropperWidth - (presentClientX - previousClientX);
                                      var checkLeft = ((cropperLeft - cropAreaLeft) + (evX - previousClientX));
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evX+6 <= opacityDivLeft)&&((cropperRight - opacityDivLeft)>=maxWidth))){
                                        cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                        upDCropperDD();
                                        // if(imageType === "landscape"){
                                          cropperNewTop     = (midHeight - (maxHeight/2));
                                          if(cropperNewTop < 0){
                                            cropperNewTop = 0 ;
                                          }
                                          if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                            cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          }
                                        // } else {
                                        //   cropperNewLeft     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                    } else {

                                      if(maxWidth!=fixedImageWidth){
                                        cropperNewLeft =  cropperRight - maxWidth - opacityDivLeft;
                                        cropperNewWidth   = maxWidth +"px";
                                      } else {
                                        cropperNewLeft = 0;
                                        cropperNewWidth   = cropperRight - opacityDivLeft +"px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }
                                  break;

                                  case "lyteCropTopEdge":

                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewLeft = 0; cropperNewWidth = 0; cropperNewHeight= 0;

                                  if (((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)) {
                                    if(evY > opacityDivTop+6){
                                      cropperNewWidth = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                      cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + ((evY - previousClientY)*aspectDiff)/2) + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(evY-6 <= opacityDivTop){
                                      if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                        cropperNewLeft = (opacityDivRight - (((cropperBottom - opacityDivTop)*aspectDiff) + (opacityDivRight-(midWidth+(((cropperBottom - opacityDivTop)*aspectDiff)/2))))) + "px";
                                        cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                        $L(cropper).css({'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                      cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.left <= opacityDivLeft){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.right >= opacityDivRight){
                                      cropperNewLeft = opacityDivRight - cropperDummyData.width - cropAreaLeft+ "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.right >= opacityDivRight)&&(cropperDummyData.left <= opacityDivLeft)){
                                      cropperNewWidth = opacityDivRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivRight - opacityDivLeft)/aspectDiff + "px";
                                      cropperNewTop = (cropperBottom - ((opacityDivRight - opacityDivLeft)/aspectDiff)) - cropAreaTop + "px";
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperHeight - (evY - previousClientY))<=leastHeight) {
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                      cropperNewLeft    = (midWidth - (leastWidth/2)) + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                  }else if(((cropperHeight - (evY - previousClientY))>=maxHeight)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = cropperHeight - (evY - previousClientY);
                                      var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                      var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))){
                                        cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                        upDCropperDD();
                                        // if(imageType === "landscape"){
                                          cropperNewLeft     = (midWidth - (maxWidth/2));
                                          if(cropperNewLeft < 0){
                                            cropperNewLeft = 0 ;
                                          }
                                          if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                            cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                          }
                                        // } else {
                                        //   cropperNewLeft     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                    } else {

                                      if(maxHeight!=fixedImageheight){
                                        cropperNewTop =  cropperBottom - maxHeight - opacityDivTop;
                                        cropperNewHeight   = maxHeight +"px";
                                      } else {
                                        cropperNewTop = 0;
                                        cropperNewHeight   = cropperBottom - opacityDivTop +"px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                  }
                                  break;


                                  case "lyteCropRightEdge":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;

                                  if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth)&&((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                    if(presentClientX < opacityDivRight){
                                      cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                      cropperNewHeight  = (cropperWidth + (presentClientX - previousClientX))/aspectDiff + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) - ((presentClientX - previousClientX)/aspectDiff)/2) + "px";
                                      cropperNewRight   = ((cropperRight - cropAreaRight) - (presentClientX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'right' : cropperNewRight})
                                    }
                                    if(presentClientX >= opacityDivRight){
                                      cropperNewTop = midHeight - (((opacityDivRight - cropperLeft)/aspectDiff) / 2) + "px";
                                      cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                      cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.bottom >= opacityDivBottom){
                                      cropperNewTop = opacityDivBottom - cropperDummyData.height - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.top <= opacityDivTop){
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.bottom >= opacityDivBottom)&&(cropperDummyData.top <= opacityDivTop)){
                                      cropperNewLeft = cropperLeft - cropAreaLeft + "px";
                                      cropperNewWidth = (opacityDivBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = (opacityDivBottom - opacityDivTop) + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperWidth + (presentClientX - previousClientX))<=leastWidth){
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewTop     = (midHeight - (leastHeight/2)) + "px";
                                      cropperNewWidth   = leastWidth + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                    } else {
                                      cropperNewWidth   = leastWidth + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }else if(((cropperWidth + (evX - previousClientX))>=maxWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = (cropperWidth + (presentClientX - previousClientX))/aspectDiff;
                                      var checkWidth = cropperWidth + (presentClientX - previousClientX);
                                      if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&(cropperLeft <= (opacityDivRight - maxWidth))){
                                        // if(imageType === "portrait"){
                                          cropperNewTop     = (midHeight - (maxHeight/2));
                                          if(cropperNewTop < 0){
                                            cropperNewTop = 0 ;
                                          }
                                          if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                            cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          }
                                        // } else {
                                        //   cropperNewTop     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                      }
                                    } else {
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth   = maxWidth +"px";
                                      } else {
                                        cropperNewWidth   = opacityDivRight - cropperLeft +"px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }
                                  break;

                                  case "lyteCropBottomEdge":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewWidth   = (cropperHeight + (presentClientY - previousClientY))*aspectDiff + "px";
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) - ((presentClientY - previousClientY)*aspectDiff)/2) + "px";
                                      cropperNewBottom  = ((cropperBottom - cropAreaBottom) - (presentClientY - previousClientY))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'bottom' : cropperNewBottom})
                                    }
                                    if(evY >= opacityDivBottom){
                                      cropperNewLeft = midWidth - (((opacityDivBottom - cropperTop)*aspectDiff) / 2) + "px";
                                      cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                      cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.left <= opacityDivLeft){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.right >= opacityDivRight){
                                      cropperNewLeft = opacityDivRight - cropperDummyData.width - cropAreaLeft+ "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.right >= opacityDivRight)&&(cropperDummyData.left <= opacityDivLeft)){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      cropperNewWidth = opacityDivRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivRight - opacityDivLeft)/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<=leastHeight) {
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewLeft    = (midWidth - (leastWidth/2)) + "px";
                                      cropperNewWidth   = leastWidth + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if(((cropperHeight + (evY - previousClientY))>=maxHeight)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = cropperHeight + (evY - previousClientY);
                                      var checkWidth = (cropperHeight + (presentClientY - previousClientY))*aspectDiff;
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&(cropperTop <= (opacityDivBottom - maxHeight))){
                                        // if(imageType === "landscape"){
                                          cropperNewLeft = (midWidth - (maxWidth/2));
                                          if(cropperNewLeft < 0){
                                            cropperNewLeft = 0 ;
                                          }
                                          if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                            cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                          }
                                        // } else {
                                        //   cropperNewLeft  = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                      }
                                    } else {
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight   = maxHeight +"px";
                                      } else {
                                        cropperNewHeight   = opacityDivBottom - cropperTop +"px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                  break;

                                  case "lyteCropTopRightCorner":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(aspectRatio === "n:n"){
                                    if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth) && ((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                      if(presentClientX < opacityDivRight){
                                        cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                        $L(cropper).css({'width' : cropperNewWidth})
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    } else if((cropperWidth + (presentClientX - previousClientX))<leastWidth){
                                      if(presentClientX <= cropperLeft){
                                          cropperNewWidth = leastWidth + "px";
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    } else if((cropperWidth + (presentClientX - previousClientX))>maxWidth) {
                                      if(presentClientX >= opacityDivRight){
                                        if(maxWidth != fixedImageWidth){
                                          cropperNewWidth = maxWidth + "px";
                                        } else {
                                          cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                        }
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    }
                                    if(((cropperHeight - (presentClientY - previousClientY))>=leastHeight) && ((cropperHeight - (presentClientY - previousClientY))<=maxHeight)){
                                      if(presentClientY > opacityDivTop){
                                        cropperNewTop = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                        cropperNewHeight   = cropperHeight - (presentClientY - previousClientY) + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))<leastHeight){
                                      if(presentClientY > cropperBottom){
                                          cropperNewHeight = leastHeight + "px";
                                          cropperNewTop = cropperBottom - leastHeight - opacityDivTop + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))>maxHeight) {
                                      if(presentClientY <= opacityDivTop){
                                        if(maxHeight != fixedImageheight){
                                          cropperNewTop = cropperBottom - maxHeight - opacityDivTop + "px";
                                          cropperNewHeight   = maxHeight + "px";
                                        } else {
                                          cropperNewTop = (opacityDivTop - fixedImageTop) + "px";
                                          cropperNewHeight   = (cropperBottom - opacityDivTop) + "px";
                                        }
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }
                                  } else {
                                      if (((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)) {
                                        if(evY >= opacityDivTop+5){
                                          cropperNewWidth   = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                          cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                          cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                          cropperNewRight   = ((cropperRight - cropAreaRight) - (evX - previousClientX))+ "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'right' : cropperNewRight})
                                        }
                                        upDCropperDD();
                                        if(evY < (opacityDivTop+5)){
                                          if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                            cropperNewTop = opacityDivTop - cropAreaTop  + "px";
                                          }
                                          cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                          cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                        }
                                        upDCropperDD();
                                       if(cropperDummyData.right >= opacityDivRight){
                                         cropperNewTop = (cropperBottom - ((opacityDivRight - cropperLeft)/aspectDiff)) - cropAreaTop + "px";
                                         cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                         cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                         $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                       }
                                     } else if((cropperHeight - (evY - previousClientY))<=leastHeight) {
                                          cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                      }
                                      else if((cropperHeight - (evY - previousClientY))>=maxHeight) {
                                        var checkHeight = cropperHeight - (evY - previousClientY);
                                        var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                        var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                        if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))&&(cropperLeft <= (opacityDivRight - maxWidth))){
                                          cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                          // if(imageType === "landscape"){
                                            cropperNewLeft     = (midWidth - (maxWidth/2));
                                            if(cropperNewLeft < 0){
                                              cropperNewLeft = 0 ;
                                            }
                                            if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                              cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                            }
                                          // } else {
                                          //   cropperNewLeft     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                        }
                                      }
                                  }
                                  break;

                                  case "lyteCropTopLeftCorner":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(aspectRatio === "n:n"){
                                    upDCropperDD();
                                    if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                      if(evX > opacityDivLeft){
                                        cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                        cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))<leastWidth){
                                      if(presentClientX > cropperRight){
                                          cropperNewWidth = leastWidth + "px";
                                          cropperNewLeft = cropperRight - leastWidth - opacityDivLeft + "px";
                                        $L(cropper).css({'width' : cropperNewWidth , 'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))>maxWidth){
                                      if(evX <= opacityDivLeft){
                                        if(maxWidth != fixedImageWidth){
                                          cropperNewWidth   = maxWidth + "px";
                                          cropperNewLeft    = cropperRight - maxWidth - opacityDivLeft + "px";
                                        } else {
                                          cropperNewWidth   = (cropperRight - opacityDivLeft) + "px";
                                          cropperNewLeft    = (opacityDivLeft - fixedImageLeft) + "px";
                                        }
                                        $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                      }
                                    }
                                    if(((cropperHeight - (presentClientY - previousClientY))>=leastHeight) && ((cropperHeight - (presentClientY - previousClientY))<=maxHeight)){
                                      if(presentClientY > opacityDivTop){
                                        cropperNewTop = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                        cropperNewHeight   = cropperHeight - (presentClientY - previousClientY) + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }else if((cropperHeight - (presentClientY - previousClientY))<leastHeight){
                                      if(presentClientY > cropperBottom){
                                          cropperNewHeight = leastHeight + "px";
                                          cropperNewTop = cropperBottom - leastHeight - opacityDivTop + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))>maxHeight){
                                      if(presentClientY <= opacityDivTop){
                                        if(maxHeight != fixedImageheight){
                                          cropperNewTop = cropperBottom - maxHeight - opacityDivTop + "px";
                                          cropperNewHeight   = maxHeight + "px";
                                        } else {
                                          cropperNewTop = (opacityDivTop - fixedImageTop) + "px";
                                          cropperNewHeight   = (cropperBottom - opacityDivTop) + "px";
                                        }
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }
                                  } else {
                                      if(((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)){
                                        if(evY >= opacityDivTop+5){
                                          cropperNewWidth = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                          cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                          cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                          cropperNewLeft    = ((cropperLeft - cropAreaLeft) + ((evY - previousClientY)*aspectDiff)) + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                        upDCropperDD();
                                        if(evY-6 <= opacityDivTop){
                                          if((!(cropperDummyData.height > opacityDivHeight))||(!(cropperDummyData.width > opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                            cropperNewLeft = (opacityDivRight - (((cropperBottom - opacityDivTop)*aspectDiff) + (opacityDivRight - cropperRight))) - cropAreaLeft + "px";
                                            cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                          }
                                          cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                          cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                        upDCropperDD();
                                        if(cropperDummyData.left <= opacityDivLeft){
                                          cropperNewTop = (cropperBottom - ((cropperRight - opacityDivLeft)/aspectDiff)) - cropAreaTop + "px";
                                          cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                          cropperNewWidth = cropperRight - opacityDivLeft + "px";
                                          cropperNewHeight = (cropperRight - opacityDivLeft)/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                      }else if((cropperHeight - (evY - previousClientY))<=leastHeight){
                                        if(!(aspectRatio === "n:n")){
                                          cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                          cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                      }else if((cropperHeight - (evY - previousClientY))>=maxHeight) {
                                        var checkHeight = cropperHeight - (evY - previousClientY);
                                        var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                        var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                        if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))&&(cropperRight - opacityDivLeft >= maxWidth)){
                                          cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                          // if(imageType === "landscape"){
                                            cropperNewLeft     = (midWidth - (maxWidth/2));
                                            if(cropperNewLeft < 0){
                                              cropperNewLeft = 0 ;
                                            }
                                            if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                              cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                            }
                                          // } else {
                                          //   cropperNewLeft     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                        }
                                      }
                                    }
                                break;
                                case "lyteCropBottomRightCorner":
                                upDCropperDD();

                                cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                if(aspectRatio === "n:n"){
                                  upDCropperDD();
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<leastHeight){
                                    if(presentClientY < cropperTop){
                                        cropperNewHeight = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  } else if((cropperHeight + (evY - previousClientY))>maxHeight) {
                                    if(evY >= opacityDivBottom){
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight = maxHeight + "px";
                                      } else {
                                        cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                  if(((cropperWidth + (evX - previousClientX))>=leastWidth)&&((cropperWidth + (evX - previousClientX))<=maxWidth)){
                                    if(evX < opacityDivRight){
                                      cropperNewWidth  = cropperWidth + (evX - previousClientX) + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }else if((cropperWidth + (evX - previousClientX))<leastWidth){
                                    if(presentClientX <= cropperLeft){
                                        cropperNewWidth = leastWidth + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  } else if((cropperWidth + (evX - previousClientX))>maxWidth){
                                    if(evX >= opacityDivRight){
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth = maxWidth + "px";
                                      } else {
                                        cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }
                                } else {
                                    if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth)&&((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                        if(presentClientX < opacityDivRight){
                                          cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                          cropperNewHeight  = (cropperWidth + (presentClientX - previousClientX))/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                        upDCropperDD();
                                        if((cropperDummyData.right >= opacityDivRight-5)&&(presentClientX >= opacityDivRight-5)){
                                          cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                          cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                        upDCropperDD();
                                        if(cropperDummyData.bottom >= opacityDivBottom){
                                          cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                          cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                      }else if((cropperWidth + (presentClientX - previousClientX))<=leastWidth){
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                      }else if((cropperWidth + (presentClientX - previousClientX))>=maxWidth){
                                        var checkHeight = (cropperWidth + (presentClientX - previousClientX))/aspectDiff;
                                        var checkWidth = cropperWidth + (presentClientX - previousClientX);
                                        if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&(opacityDivBottom - cropperTop >= maxHeight)&&(opacityDivRight - cropperLeft >= maxWidth)){
                                          // // cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                          // if(imageType === "portrait"){
                                          //   // cropperNewTop     = (midHeight - (maxHeight/2));
                                          //   if(cropperNewTop < 0){
                                          //     // cropperNewTop = 0 ;
                                          //   }
                                          //   if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                          //     // cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          //   }
                                          // } else {
                                          //   //cropperNewTop     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                      }
                                  }
                                break;
                                case "lyteCropBottomLeftCorner":
                                upDCropperDD();

                                cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                if(aspectRatio === "n:n"){
                                  upDCropperDD();
                                  if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                    if(evX > opacityDivLeft){
                                      cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperWidth - (evX - previousClientX))<leastWidth){
                                    if(presentClientX > cropperRight){
                                        cropperNewWidth = leastWidth + "px";
                                        cropperNewLeft = cropperRight - leastWidth - opacityDivLeft + "px";
                                      $L(cropper).css({'width' : cropperNewWidth , 'left' : cropperNewLeft})
                                    }
                                  } else if((cropperWidth - (evX - previousClientX))>maxWidth){
                                    if(evX <= opacityDivLeft){
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth   = maxWidth + "px";
                                        cropperNewLeft    = cropperRight - maxWidth - opacityDivLeft + "px";
                                      } else {
                                        cropperNewWidth   = (cropperRight - opacityDivLeft) + "px";
                                        cropperNewLeft    = (opacityDivLeft - fixedImageLeft) + "px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<leastHeight){
                                    if(presentClientY < cropperTop){
                                        cropperNewHeight = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  } else if((cropperHeight + (evY - previousClientY))>maxHeight){
                                    if(evY >= opacityDivBottom){
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight = maxHeight + "px";
                                      } else {
                                        cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                } else {
                                      if(((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)){
                                      if(evX > opacityDivLeft){
                                        cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                        cropperNewHeight  = (cropperWidth - (presentClientX - previousClientX))/aspectDiff + "px";
                                        cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                      upDCropperDD();
                                      if(evX-6 <= opacityDivLeft+2){
                                        if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                          cropperNewLeft = opacityDivLeft - cropAreaLeft  + "px";
                                        }
                                        cropperNewWidth = (cropperRight - opacityDivLeft) + "px";
                                        cropperNewHeight = (cropperRight - opacityDivLeft)/aspectDiff + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                      upDCropperDD();
                                      if(cropperDummyData.bottom >= opacityDivBottom){
                                        cropperNewHeight = (opacityDivBottom - cropperTop) + "px";
                                        cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                        cropperNewLeft = opacityDivRight - (((opacityDivBottom - cropperTop)*aspectDiff) + (opacityDivRight - cropperRight)) - cropAreaLeft + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))<=leastWidth){
                                      if(!(aspectRatio === "n:n")){
                                        cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                        cropperNewWidth   = leastWidth + "px";
                                        cropperNewHeight  = leastHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                    }
                                    else if((cropperWidth - (evX - previousClientX))>=maxWidth){
                                      if(!(aspectRatio === "n:n")){
                                        var checkHeight = (cropperWidth - (presentClientX - previousClientX))/aspectDiff;
                                        var checkWidth = cropperWidth - (presentClientX - previousClientX);
                                        var checkLeft = ((cropperLeft - cropAreaLeft) + (evX - previousClientX));
                                        if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&((evX-6 < opacityDivLeft)&&((cropperRight - opacityDivLeft)>=maxWidth))&&(opacityDivBottom - cropperTop >= maxHeight)){
                                          cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                          // if(imageType === "portrait"){
                                          //   // cropperNewTop     = (midHeight - (maxHeight/2));
                                          //   if(cropperNewTop < 0){
                                          //     // cropperNewTop = 0 ;
                                          //   }
                                          //   if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                          //     // cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          //   }
                                          // } else {
                                          //   //cropperNewTop     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                        }
                                      }
                                    }
                                  }
                                break;
                                }
                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;
                                setCropperData();
                              }
                              document.addEventListener("mousemove" , resizeCropper);
                              document.addEventListener("mouseup" , removeResizeEvent);
                            }

                            break;
                          }
                        }


                        function positionCropper(cropperDim , cropAreaDim , imageDim , ang1 , prevAng){

                              var ang = fixedImage.style.transform.match(/-?\d+/g)[0];

                              var angCheck = parseInt(ang);
                              var angCheck1 = angCheck;
                              angCheck = Math.abs(angCheck);

                              if((angCheck === 90) || (angCheck === 270)){

                              if(imageData.height<imageData.width){
                                fixedImage.style.width = divImageImg.style.width = getBCR(cropperDiv).height + "px";
                                fixedImage.style.height = divImageImg.style.height ="auto";
                                cropArea.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.top = "0px";
                                cropArea.style.width = getBCR(fixedImage).width + "px";
                                var absLeft = Math.abs(getBCR(cropArea).left - getBCR(fixedImage).left);
                                if(_lyteUiUtils.getRTL()){
                                  cropArea.style.left = "-"+((getBCR(cropperDiv).width - getBCR(cropArea).width)/2) + "px";
                                  fixedImage.style.left = -absLeft + "px";
                                } else{
                                  cropArea.style.left = ((getBCR(cropperDiv).width - getBCR(cropArea).width)/2) + "px";
                                  fixedImage.style.left = -absLeft + "px";
                                }
                              } else if(imageData.height>imageData.width){
                                fixedImage.style.width = divImageImg.style.width = "auto"
                                fixedImage.style.height = divImageImg.style.height = getBCR(cropperDiv).width + "px";
                                cropArea.style.width = getBCR(cropperDiv).width + "px";
                                cropArea.style.left = "0px";
                                cropArea.style.height = getBCR(fixedImage).height + "px";
                                cropArea.style.top = ((getBCR(cropperDiv).height - getBCR(cropArea).height)/2) + "px";
                                var x = Math.abs(getBCR(cropArea).left - getBCR(fixedImage).left);
                                if(_lyteUiUtils){
                                  fixedImage.style.left = x + "px";
                                }else{
                                  fixedImage.style.left = x + "px";
                                }
                              }

                              fixedImage.style.top = (getBCR(cropArea).top - getBCR(fixedImage).top) + "px";

                              setMinAndMaxDim();

                              if(aspectRatio !== 'n:n'){
                                leastHeight = 15*(getBCR(cropArea).height/cropAreaDim.width);
                                leastWidth = leastHeight*aspectDiff;
                              } else {
                                leastHeight = 15*(getBCR(cropArea).height/cropAreaDim.width);
                                leastWidth = leastHeight;
                              }

                              var cropperWidth = (cropperDim.height*getBCR(cropArea).width) / cropAreaDim.height;
                              var cropperHeight = (cropperDim.width*getBCR(cropArea).height) / cropAreaDim.width;
                              var newCropperWidth = cropperWidth;
                              var newCropperHeight = cropperHeight;
                              if((leastWidth > cropperWidth)&&(aspectRatio != "n:n")) {
                                newCropperWidth = leastWidth;
                                newCropperHeight = newCropperWidth/aspectDiff;
                              }
                              if((leastHeight > cropperHeight)&&(aspectRatio != "n:n")) {
                                newCropperHeight = leastHeight;
                                newCropperWidth = newCropperHeight*aspectDiff;
                              }
                              cropper.style.width = newCropperWidth + "px";
                              cropper.style.height = newCropperHeight + "px";


                              if((angCheck1 === -90)||(angCheck1 === -270)){
                                cropper.style.left = (((cropperDim.top - cropAreaDim.top) * getBCR(cropArea).width)/cropAreaDim.height) + "px";
                                cropper.style.top = ((getBCR(cropArea).height) - ((((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + getBCR(cropper).height) ) + "px";
                              }
                              if((angCheck1 === 90) || (angCheck1 === 270)){
                                cropper.style.top = (((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + "px";
                                cropper.style.left = (getBCR(cropArea).width - ( getBCR(cropper).width + (((cropperDim.top - cropAreaDim.top)* getBCR(cropArea).width)/cropAreaDim.height))) + "px";
                              }



                            } else {

                              if(imageData.height<imageData.width){
                                fixedImage.style.width = divImageImg.style.width = getBCR(cropperDiv).width + "px";
                                fixedImage.style.height = divImageImg.style.height = "auto";
                                cropArea.style.width = getBCR(cropperDiv).width + "px";
                                cropArea.style.left = "0px";
                                cropArea.style.right = "";
                                cropArea.style.height = getBCR(fixedImage).height + "px";
                                cropArea.style.top = (getBCR(cropperDiv).height - getBCR(cropArea).height)/2 + "px";
                                fixedImage.style.left = (getBCR(cropArea).width - getBCR(fixedImage).width)/2 + "px";
                              } else {
                                fixedImage.style.width = divImageImg.style.width = "auto";
                                fixedImage.style.height = divImageImg.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.top = "0px";
                                cropArea.style.width = getBCR(fixedImage).width + "px";
                                if(_lyteUiUtils.getRTL()){
                                  cropArea.style.left = "-"+(getBCR(cropperDiv).width - getBCR(cropArea).width)/2 + "px";
                                }else{
                                  cropArea.style.left = (getBCR(cropperDiv).width - getBCR(cropArea).width)/2 + "px";
                                }
                                fixedImage.style.left = (getBCR(cropArea).width - getBCR(fixedImage).width)/2 + "px";
                              }



                              fixedImage.style.top = (getBCR(box).height - getBCR(fixedImage).height)/2 + "px";

                              setMinAndMaxDim();

                              var cropperWidth = (cropperDim.height*getBCR(cropArea).width) / cropAreaDim.height;
                              var cropperHeight = (cropperDim.width*getBCR(cropArea).height) / cropAreaDim.width;
                              var newCropperWidth = cropperWidth;
                              var newCropperHeight = cropperHeight;
                              if((leastHeight > cropperHeight)&&(aspectRatio != "n:n")) {
                                newCropperHeight = leastHeight;
                                newCropperWidth = newCropperHeight * aspectDiff;
                              }
                              cropper.style.width = newCropperWidth + "px";
                              cropper.style.height = newCropperHeight + "px";

                              if((angCheck1 === -180)){
                                cropper.style.top = ((getBCR(cropArea).height) - ((((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + getBCR(cropper).height) ) + "px";
                                cropper.style.left = (((cropperDim.top - cropAreaDim.top) * getBCR(cropArea).width)/cropAreaDim.height) + "px";
                              }
                              if((angCheck1 === 0)||(angCheck1 === 180)){
                                cropper.style.top = (((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + "px";
                                cropper.style.left = (getBCR(cropArea).width - ( getBCR(cropper).width + (((cropperDim.top - cropAreaDim.top)* getBCR(cropArea).width)/cropAreaDim.height))) + "px";
                              }
                            }

                            var fixedImageTransform = fixedImage.style.transform;
                            fixedImage.style.transform = 'rotate(0deg)';
                            divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                            divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                            fixedImage.style.transform = fixedImageTransform;

                            }




                        function setCropperData(){

                          var cropperData = getBCR(cropper);

                          cropData.cropperDimensions = {
                            'top' : cropper.offsetTop,
                            'left' : cropper.offsetLeft,
                            'width' : cropperData.width,
                            'height' : cropperData.height
                          }
                          cropData.imageDimension = imageData;



                          function getImageResolution(){

                            var resoluWidth , resoluHeight;

                            var image = $L('.lyteCropDivImageImg')[0];

                            var widthScaleFactor = image.naturalWidth / image.getBoundingClientRect().width;
                            var heightScaleFactor = image.naturalHeight / image.getBoundingClientRect().height;
                            if((cropData.angle === 90) || (cropData.angle === 270)){
                              widthScaleFactor = image.naturalHeight / image.getBoundingClientRect().width;
                              heightScaleFactor = image.naturalWidth / image.getBoundingClientRect().height;
                            }




                            resoluWidth = cropper.getBoundingClientRect().width * widthScaleFactor;
                            resoluHeight = cropper.getBoundingClientRect().height * heightScaleFactor;

                            return { "width" : resoluWidth , "height" : resoluHeight }

                          }

                          cropData.resolution = getImageResolution();

                          cropData.rotate = function(){
                                var cropperDim = getBCR(cropper);
                                var cropAreaDim = getBCR(cropArea);
                                var imageDim = getBCR(fixedImage);
                                var angle;
                                var o = fixedImage.style.transform;
                                var prevAng;
                                if(o){
                                  angle = o.match(/-?\d+/g);
                                  prevAng = angle[0];
                                  angle = parseInt(angle[0]) + 90;
                                  if(angle >= 360){
                                    angle = 0;
                                  }
                                  fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                  divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                } else {
                                  var angle = 90;
                                  fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                  divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                }
                                initialRotateAngle = angle;
                                // if(cropData.angle === undefined){
                                  // cropData.angle = angle;
                                // } else {
                                cropData.angle = angle;
                                // }
                                aspectDiff = 1/aspectDiff;
                                if(imageType === "landscape"){
                                  imageType = "portrait";
                                } else {
                                  imageType = "landscape";
                                }
                                positionCropper(cropperDim , cropAreaDim , imageDim , angle , prevAng);
                                setCropperData();
                              };


                              cropData.getCroppedImage = function(){
                                var image = $L('.lyteCropDivImageImg')[0];
                                var cropperData = getBCR(cropper);
                                var cropperAreaData = getBCR(cropArea);
                                var divImageData = getBCR(divImageImg);

                                var scaleFactor = image.naturalWidth / cropperData.width;

                                function scaleIt(img , scaleFactor){

                                  var c1 = document.createElement('CANVAS');
                                  var ctx = c1.getContext('2d');
                                  c1.style.background = "#eee";


                                  var o = fixedImage.style.transform;
                                  var angle = 0;
                                  if(o){
                                    angle = o.match(/-?\d+/g);
                                    angle = parseInt(angle[0]);
                                  }
                                  if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                                    divImageImg.style.transform = 'rotate(0deg) rotateY(' +exifRotateY+'deg)';
                                  }
                                  var cw;
                                  var ch;
                                  var cx = cropperAreaData.left - cropperData.left;
                                  var cy = cropperAreaData.top - cropperData.top;

                                  if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                                    c1.width = Math.round(cropperData.width * (img.naturalWidth / divImageData.width));
                                    c1.height = Math.round(cropperData.height * (img.naturalHeight / divImageData.height));
                                    cw = img.naturalWidth;
                                    ch = img.naturalHeight;
                                  } else {
                                    c1.height = Math.round(cropperData.height * (img.naturalWidth / divImageData.height));
                                    c1.width = Math.round(cropperData.width * (img.naturalHeight / divImageData.width));
                                    ch = img.naturalWidth;
                                    cw = img.naturalHeight;
                                  }
                                  cx = cx * (cw / divImageData.width)
                                  cy = cy * (ch / divImageData.height)
                                  divImageImg.style.transform = o;



                                  if((angle !== 0)||(exifRotateY===180)){

                                    ctx.save();
                                    if((Math.abs(angle)%90 === 0)&&(!((Math.abs(angle) === 180)||(Math.abs(angle) === 360)))){
                                      var cW = img.naturalWidth;
                                      var cH = img.naturalHeight;
                                    }
                                    var halfWidth = cw / 2;
                                    var halfHeight = ch / 2;

                                    if(((Math.abs(angle)%90 === 0)&&(angle!=0))&&(!((Math.abs(angle) === 180)||(Math.abs(angle) === 360)))){

                                      ctx.translate( cx+halfWidth , cy+halfHeight);
                                      ctx.rotate(angle * (Math.PI/180));
                                      if(exifRotateY === 180){
                                        ctx.scale(-1, 1);
                                      }
                                      ctx.drawImage(image, -halfHeight, -halfWidth, ch, cw);
                                    } else {
                                      ctx.translate( cx+cw/2 , cy+ch/2);
                                      ctx.rotate(angle * (Math.PI/180));
                                      if(exifRotateY === 180){
                                        ctx.scale(-1, 1);
                                      }
                                      ctx.drawImage(image,-cw/2,-ch/2,cw,ch);
                                    }
                                    ctx.restore();
                                  } else {
                                    ctx.drawImage(img , cx , cy , cw , ch);
                                  }

                                  function convertCanvasToImage(cc) {
                                    var image = new Image();
                                    image.src = cc.toDataURL("image/jpeg");
                                    return image;
                                  }

                                  // return convertCanvasToImage(c1);
                                  return c1;

                                }

                                return scaleIt(image , scaleFactor);


                              }

                              cropData.changeByHeight = function(val){

                                var retObj = {}

                                var cropperData = getBCR(cropper);
                                var opacityDivData = getBCR(opacityDiv)

                                var newHeight = parseFloat(val);

                                if(!(newHeight + getBCR(cropper).top <= getBCR(opacityDiv).bottom)){
                                  newHeight = getBCR(opacityDiv).bottom - getBCR(cropper).top;
                                }

                                var newTop;

                                var leftMid = getBCR(cropper).left + getBCR(cropper).width/2 - getBCR(opacityDiv).left;


                                if(newHeight>=maxHeight){
                                  newHeight = maxHeight;
                                }
                                if(newHeight<=leastHeight){
                                  newHeight = leastHeight;
                                }

                                var newWidth = newHeight*aspectDiff;

                                if(cropperData.top + newHeight >= opacityDivData.bottom ){
                                  newTop = opacityDivData.bottom - newHeight - opacityDivData.top;
                                  $L(cropper).css({'top' : newTop})
                                }

                                var cropperNewLeft = leftMid - newWidth/2;

                                if(cropperNewLeft >= 0){
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }
                                if(cropperNewLeft+newWidth >= getBCR(opacityDiv).right - getBCR(opacityDiv).left){
                                  cropperNewLeft = getBCR(opacityDiv).right - newWidth - getBCR(opacityDiv).left;
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }

                                if(aspectRatio !== 'n:n'){
                                  $L(cropper).css({'width' : newWidth,'height' : newHeight})
                                } else {
                                  newWidth = getBCR(cropper).width;
                                  $L(cropper).css({'height' : newHeight})
                                }

                                if(val === 'NaN'){
                                    newWidth = leastWidth;
                                    newHeight = leastHeight;
                                }

                                retObj = {'cropperWidth' : newWidth , 'cropperHeight' : newHeight};

                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;

                                setCropperData();

                                return retObj;

                              }


                              cropData.changeByWidth = function(val){

                                var retObj = {};

                                var newWidth = parseFloat(val);

                                if(!(newWidth + getBCR(cropper).left <= getBCR(opacityDiv).right)){
                                  newWidth = getBCR(opacityDiv).right - getBCR(cropper).left;
                                }

                                var newLeft;
                                var cropperData = getBCR(cropper);
                                var opacityDivData = getBCR(opacityDiv);

                                var topMid = getBCR(cropper).top + getBCR(cropper).height/2 - getBCR(opacityDiv).top;

                                if(newWidth>=maxWidth){
                                  newWidth = maxWidth;
                                }
                                if(newWidth<=leastWidth){
                                  newWidth = leastWidth;
                                }

                                var newHeight = newWidth/aspectDiff;

                                if(cropperData.left + newWidth >= opacityDivData.right ){
                                  newLeft = opacityDivData.right - newWidth - opacityDivData.left;
                                  $L(cropper).css({'left' : newLeft})
                                }

                                var cropperNewTop = topMid - newHeight/2;

                                if(cropperNewTop >= 0){
                                  $L(cropper).css({'top' : cropperNewTop})
                                }

                                if(cropperNewTop+newHeight >= getBCR(opacityDiv).bottom - getBCR(opacityDiv).top){
                                  cropperNewTop = getBCR(opacityDiv).bottom - newHeight - getBCR(opacityDiv).top;
                                  $L(cropper).css({'top' : cropperNewTop})
                                }


                                if(aspectRatio !== 'n:n'){
                                  $L(cropper).css({'width' : newWidth,'height' : newHeight})
                                } else {
                                  newHeight = getBCR(cropper).height;
                                  $L(cropper).css({'width' : newWidth})
                                }

                                if(val === 'NaN'){
                                    newWidth = leastWidth;
                                    newHeight = leastHeight;
                                }

                                retObj = {'cropperWidth' : newWidth , 'cropperHeight' : newHeight};

                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;

                                setCropperData();

                                return retObj;

                              }

                              cropData.deleteCropper = function(){

                                cropperDiv.removeChild(cropArea)
                                imageTag.style.display = 'block'

                              }

                              cropData.swapAspectRatio = function(){

                                aspectDiff = 1/aspectDiff

                                setMinAndMaxDim();

                                var cropperOldHeight = getBCR(cropper).height;
                                var cropperOldWidth = getBCR(cropper).width;
                                var cropperNewTop ;
                                var cropperNewLeft;
                                var topMid = getBCR(cropper).height/2 + getBCR(cropper).top;
                                var leftMid = getBCR(cropper).width/2 + getBCR(cropper).left;

                                var cropperNewWidth;
                                var cropperNewHeight;



                                if(getBCR(cropper).top + cropperOldWidth > getBCR(opacityDiv).bottom){
                                  cropperNewTop = getBCR(opacityDiv).bottom - cropperOldWidth - getBCR(opacityDiv).top;
                                  $L(cropper).css({'top' : cropperNewTop})
                                } else {
                                  cropperNewTop = topMid - (getBCR(cropper).width/2) - getBCR(opacityDiv).top;
                                  if(cropperNewTop <= 0){
                                    cropperNewTop = 0;
                                  }
                                  $L(cropper).css({'top' : cropperNewTop})
                                }
                                if(getBCR(cropper).left + cropperOldHeight > getBCR(opacityDiv).right){
                                  cropperNewLeft = getBCR(opacityDiv).right - cropperOldHeight - getBCR(opacityDiv).left;
                                  $L(cropper).css({'left' : cropperNewLeft})
                                } else {
                                  cropperNewLeft = leftMid - (getBCR(cropper).height/2) - getBCR(opacityDiv).left;
                                  if(cropperNewLeft <= 0 ){
                                    cropperNewLeft = 0;
                                  }
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }

                                $L(cropper).css({'width' : cropperOldHeight,'height' : cropperOldWidth})

                                if(cropperOldWidth >= getBCR(fixedImage).height){
                                  cropperNewWidth = getBCR(fixedImage).height * aspectDiff;
                                  cropperNewHeight = getBCR(fixedImage).height ;
                                  cropperNewLeft = (getBCR(fixedImage).width - cropperNewWidth)/2;
                                  $L(cropper).css({'height' : cropperNewHeight , 'width' : cropperNewWidth , 'top' : 0 , 'left' : cropperNewLeft});
                                }
                                if(cropperOldHeight >= getBCR(fixedImage).width){
                                  cropperNewWidth = getBCR(fixedImage).width;
                                  cropperNewHeight = getBCR(fixedImage).width / aspectDiff;
                                  cropperNewTop = (getBCR(fixedImage).height - cropperNewHeight)/2;
                                  $L(cropper).css({'height' : cropperNewHeight , 'width' : cropperNewWidth , 'left' : 0 , 'top' : cropperNewTop});
                                }


                                var fixedImageTransform = fixedImage.style.transform ;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform+ 'rotateY('+exifRotateY+')';

                                setCropperData();

                              }

                              cropData.angle = initialRotateAngle;
                              cropData.exifAngle = exifRotateY;

                          $L(imageTag).data('cropper' , cropData);
                        }
        } else if(aRD.type === 'DP'){


            var mainImage = this[0];
            var mainImageDimension = mainImage.getBoundingClientRect()
            mainImage.style.display = 'none';
            var imageParent = mainImage.parentElement;
            var imageParentDimension = imageParent.getBoundingClientRect()
            var imageType;
            var inImageDimension;
            var cropData = {}
            var initialImageValue;

            if(!aRD){
              aRD = {}
            }

            if(!aRD.cropperSize){
              aRD.cropperSize = 300
            }

            var mainArea,backImage,frontImage,visualArea,freezeDiv


            if(mainImageDimension.height < mainImageDimension.width){
              imageType = "landscape";
            } else {
              imageType = "portrait";
            }

            var generateDiv = function(){

              mainArea = document.createElement('DIV');
              freezeDiv = document.createElement('DIV');
              backImage = document.createElement('IMG');
              visualArea = document.createElement('DIV');
              frontImage = document.createElement('IMG');


              backImage.src = frontImage.src = mainImage.src

              mainArea.setAttribute('class' , 'lytePSParent')
              freezeDiv.setAttribute('class' , 'lytePSFreezeLayer')
              backImage.setAttribute('class' , 'lytePSBackImage')
              visualArea.setAttribute('class' , 'lytePSvisualArea')
              frontImage.setAttribute('class' , 'lytePSFrontImage')

              if(imageType === "landscape"){
                backImage.style.height = aRD.cropperSize + "px";
                frontImage.style.height = aRD.cropperSize + "px";
              } else {
                backImage.style.width = aRD.cropperSize + "px";
                frontImage.style.width = aRD.cropperSize + "px";
              }


              appendFunction()
              setDimensions()

            }

            var appendFunction = function(){

              mainArea.appendChild(backImage)
              mainArea.appendChild(freezeDiv)
              visualArea.appendChild(frontImage)
              mainArea.appendChild(visualArea)
              imageParent.appendChild(mainArea)

              inImageDimension = backImage.getBoundingClientRect()

            }

            var setDimensions = function(){

              visualArea.style.width = visualArea.style.height = aRD.cropperSize + "px"

              visualArea.style.top = (imageParentDimension.height/2 - aRD.cropperSize/2) + "px";
              visualArea.style.left = (imageParentDimension.width/2 - aRD.cropperSize/2) + "px";
              if(imageType === "landscape"){
                backImage.style.top = (imageParentDimension.height/2 - aRD.cropperSize/2)+ "px";
                backImage.style.left = (imageParentDimension.width - inImageDimension.width)/2 + "px";
              } else {
                backImage.style.top = (imageParentDimension.height - inImageDimension.height)/2 + "px";
                backImage.style.left = (imageParentDimension.width/2 - aRD.cropperSize/2) + "px";
              }
              frontImage.style.left = (backImage.getBoundingClientRect().left - visualArea.getBoundingClientRect().left) + "px"
              frontImage.style.top = (backImage.getBoundingClientRect().top - visualArea.getBoundingClientRect().top) + "px"


              initialImageValue = backImage.getBoundingClientRect()


              imageParent.addEventListener('mousedown' , psMouseDown)


            }

            var bst , bsl
            var preY , preX

            var psMouseDown = function(eve){
              if($L(eve.target).hasClass('lytePSvisualArea')){

                imageParent.addEventListener('mousemove' , psMoveImage)
                imageParent.addEventListener('mouseup' , remPsFun)

                bst = backImage.getBoundingClientRect().top - imageParent.getBoundingClientRect().top
                bsl = backImage.getBoundingClientRect().left - imageParent.getBoundingClientRect().left
                preY = eve.clientY
                preX = eve.clientX

              }
            }

            var psMoveImage = function(eve){

              var mFT = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (bst - (preY - eve.clientY)))
              var mBT = (bst - (preY - eve.clientY))
              var mFL = (((bsl - (preX - eve.clientX)))-(imageParentDimension.width/2 - aRD.cropperSize/2))
              var mBL = (bsl - (preX - eve.clientX))

              if(mBL <= (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)){
                backImage.style.left = (bsl - (preX - eve.clientX)) + "px"
                frontImage.style.left = (((bsl - (preX - eve.clientX)))-(imageParentDimension.width/2 - aRD.cropperSize/2)) + "px"
              } else {
                backImage.style.left = (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) + "px"
                frontImage.style.left = ((visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) - (imageParentDimension.width/2 - aRD.cropperSize/2)) + "px";
              }


              if(
                (mBL + backImage.getBoundingClientRect().width) < ((visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) + visualArea.getBoundingClientRect().width )
              ){

                backImage.style.left = -1*((backImage.getBoundingClientRect().width - visualArea.getBoundingClientRect().width) - (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)) + "px"
                frontImage.style.left = (-1*((backImage.getBoundingClientRect().width - visualArea.getBoundingClientRect().width) - (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)) - (imageParentDimension.width/2 - aRD.cropperSize/2)) + "px";

              }



              if(mBT <= (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)){
                backImage.style.top = (bst - (preY - eve.clientY)) + "px"
                frontImage.style.top = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (bst - (preY - eve.clientY))) + "px"
              } else {
                backImage.style.top = (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top) + "px"
                frontImage.style.top = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) + "px"
              }

              if(
                (mBT + backImage.getBoundingClientRect().height) < ((visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top) + visualArea.getBoundingClientRect().height )
              ){

                backImage.style.top = -1*((backImage.getBoundingClientRect().height - visualArea.getBoundingClientRect().height) - (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) + "px"
                frontImage.style.top = (-1*((backImage.getBoundingClientRect().height - visualArea.getBoundingClientRect().height) - (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) - (imageParentDimension.height/2 - aRD.cropperSize/2)) + "px";

              }


            }

            var remPsFun = function(eve){

              imageParent.removeEventListener('mousemove' , psMoveImage)
              imageParent.removeEventListener('mouseup' , remPsFun)

            }

            generateDiv();

            cropData.zoomImage = function(percent) {
              var scaleValue = (percent / 100) + 1;
              var iamgeParentDimension = imageParent.getBoundingClientRect();

              var backImageCurrentTop = parseFloat(backImage.style.top);
              var backImageCurrentLeft = parseFloat(backImage.style.left);
              var backImageCurrentDimension = backImage.getBoundingClientRect();
              var backImageCurrentHeight = backImageCurrentDimension.height;
              var backImageCurrentWidth = backImageCurrentDimension.width;
              var backImageCurrentRight = backImageCurrentLeft + backImageCurrentWidth;
              var backImageCurrentBottom = backImageCurrentTop + backImageCurrentHeight;

              var cropperDimension = visualArea.getBoundingClientRect();
              var cropperTop = cropperDimension.top - iamgeParentDimension.top;
              var cropperLeft = cropperDimension.left - iamgeParentDimension.left;
              var cropperRight = cropperLeft + cropperDimension.width;
              var cropperBottom = cropperTop + cropperDimension.height;

              var LeftGapBetweenImageAndCropper = cropperLeft - backImageCurrentLeft;
              var rightGapBetweenImageAndCropper = backImageCurrentRight - cropperRight;
              var topGapBetweenImageAndCropper = cropperTop - backImageCurrentTop;
              var BottomGapBetweenImageAndCropper = backImageCurrentBottom - cropperBottom;

              var imageHeightNew = initialImageValue.height*scaleValue;
              var imageWidthNew = initialImageValue.width*scaleValue;

              var oldTotalHorizontalGap = backImageCurrentWidth - cropperDimension.width;
              var oldTotalVerticalGap = backImageCurrentHeight - cropperDimension.height;
              var newTotalHorizontalGap = imageWidthNew - cropperDimension.width;
              var newTotalVerticalGap = imageHeightNew - cropperDimension.height;

              var imageHeightDiff = imageHeightNew - backImageCurrentHeight;
              var imageWidthDiff = imageWidthNew - backImageCurrentWidth;

              var newLeftGapBetweenImageAndCropper = (LeftGapBetweenImageAndCropper/ oldTotalHorizontalGap) * newTotalHorizontalGap;
              var newTopGapBetweenImageAndCropper = (topGapBetweenImageAndCropper / oldTotalVerticalGap) * newTotalVerticalGap;

              var backImageTopNew, backImageLeftNew;
              if((LeftGapBetweenImageAndCropper == rightGapBetweenImageAndCropper) && (topGapBetweenImageAndCropper == BottomGapBetweenImageAndCropper)) {
                  backImageLeftNew = backImageCurrentLeft - (imageWidthDiff / 2);
                  backImageTopNew = backImageCurrentTop - (imageHeightDiff / 2);
              }
              else if(LeftGapBetweenImageAndCropper == rightGapBetweenImageAndCropper) {
                  backImageTopNew = cropperTop - newTopGapBetweenImageAndCropper;
                  backImageLeftNew = backImageCurrentLeft - (imageWidthDiff / 2);
              }
              else if(topGapBetweenImageAndCropper == BottomGapBetweenImageAndCropper) {
                  backImageTopNew = backImageCurrentTop - (imageHeightDiff / 2);
                  backImageLeftNew = cropperLeft - newLeftGapBetweenImageAndCropper;
              }
              else {
                  backImageTopNew = cropperTop - newTopGapBetweenImageAndCropper;
                  backImageLeftNew = cropperLeft - newLeftGapBetweenImageAndCropper;
              }

              if(imageType === "landscape"){
                  backImage.style.height = imageHeightNew + "px";
                  frontImage.style.height = imageHeightNew + "px";
              } else {
                  backImage.style.width = imageWidthNew + "px";
                  frontImage.style.width = imageWidthNew + "px";
              }

              backImage.style.top = backImageTopNew + "px";
              frontImage.style.top = (backImageTopNew - cropperTop) + "px";
              backImage.style.left = backImageLeftNew + "px";
              frontImage.style.left = (backImageLeftNew - cropperLeft) + "px"
          }
          cropData.getCroppedImage = function(){
            var image = frontImage;
            var cropperData = visualArea.getBoundingClientRect();
            var mainAreaData = mainArea.getBoundingClientRect();
            var divImageData = frontImage.getBoundingClientRect();

            var scaleFactor = image.naturalWidth / cropperData.width;

            function scaleIt(img , scaleFactor){

              var c1 = document.createElement('CANVAS');
              var ctx = c1.getContext('2d');
              c1.style.background = "#eee";


              var o = backImage.style.transform;
              var angle = 0;
              if(o){
                angle = o.match(/-?\d+/g);
                angle = parseInt(angle[0]);
              }
              var cw;
              var ch;
              var cx = divImageData.left - cropperData.left;
              var cy = divImageData.top - cropperData.top;

              if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                c1.width = Math.round(cropperData.width * (image.naturalWidth / divImageData.width));
                c1.height = Math.round(cropperData.height * (image.naturalHeight / divImageData.height));
                cw = image.naturalWidth;
                ch = image.naturalHeight;
              } else {
                c1.height = Math.round(cropperData.height * (image.naturalWidth / divImageData.height));
                c1.width = Math.round(cropperData.width * (image.naturalHeight / divImageData.width));
                ch = image.naturalWidth;
                cw = image.naturalHeight;
              }
              cx = cx * (cw / divImageData.width)
              cy = cy * (ch / divImageData.height)
              frontImage.style.transform = o;

              ctx.drawImage(image , cx , cy , cw , ch);

              // return convertCanvasToImage(c1);
              return c1;

            }

            return scaleIt(image , scaleFactor);


          }

            $L(mainImage).data('lyteCrop' , cropData);
        }
      }

    }
  }
}());

/*
	Optimized by reading the values first and then writting
	Date - 28/08/2018
  	1. Added method to destroy droppable.
*/

;(function( window ) {

	if(lyteDomObj){	

		//This object synchronizes the draggable elements with the droppable elements
		//It contains the current object which is being dragged in the _current attribute
		//It also contains all the droppables available in the page inside the _droppables array attribute
		lyteDomObj.prototype.managerDD = {
			init : false,
			_current : null,
			_droppables : [],
			_checkAcceptable : function(draggable,acceptables){
				if(typeof acceptables !== "string"){
					if(acceptables.length === 0){
						return true;
					}
					else{
						for(var i = 0 ; i < acceptables.length ;i++){
							if(draggable.matches(acceptables[i])){
								return true;
							}
						}
					}
				}
				return false;
			},

			_isNotRejected : function(draggable, rejectSelectors){
				if(typeof rejectSelectors !== "string"){
					if(rejectSelectors.length === 0){
						return true;
					}
					else{
						for(var i = 0 ; i < rejectSelectors.length ;i++){
							if(draggable.matches(rejectSelectors[i])){
								return false;
							}
						}
						return true;
					}
				}
				return false;
			},

			_isOverAxis : function( x, reference, size ) {
				return ( x >= reference ) && ( x < ( reference + size ) );
			},
			_checkIntersects : function(event,draggable,droppable,toleranceMode){
				var managerDD = lyteDomObj.prototype.managerDD;
				var draggableOffset = draggable.getBoundingClientRect(),
					droppableOffset = droppable.getBoundingClientRect(),
					x1 = draggableOffset.left,
					y1 = draggableOffset.top,
					x2 = x1 + draggableOffset.width,
					y2 = y1 + draggableOffset.height,
					l = droppableOffset.left,
					t = droppableOffset.top,
					r = l + droppableOffset.width,
					b = t + droppableOffset.height;

				//If draggable and droppable elements are not from same window -
				//Calculate from their dimensions w.r.t top level window.
				if(draggable.ownerDocument.defaultView != droppable.ownerDocument.defaultView){
					//For draggable
					var currentWin = draggable.ownerDocument.defaultView || draggable.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						x1 = x1 + frameElementOffset.left;
						x2 = x2 + frameElementOffset.left;
						y1 = y1 + frameElementOffset.top;
						y2 = y2 + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
					//For droppable
					currentWin = droppable.ownerDocument.defaultView || droppable.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						l = l + frameElementOffset.left;
						r = r + frameElementOffset.left;
						t = t + frameElementOffset.top;
						b = b + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
				}

				switch ( toleranceMode ) {
				case "fit":
					return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
				case "intersect":
					return ( l < x1 + ( draggableOffset.width / 2 ) && // Right Half
						x2 - ( draggableOffset.width / 2 ) < r && // Left Half
						t < y1 + ( draggableOffset.height / 2 ) && // Bottom Half
						y2 - ( draggableOffset.height / 2 ) < b ); // Top Half
				case "pointer":
					if(event.type == "mousemove" || event.type == "mouseup"){
						return managerDD._isOverAxis( event.clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( event.clientX, l, droppableOffset.width );
					}
					if(event.type == "touchmove" || event.type == "touchend"){
						return managerDD._isOverAxis( event.changedTouches[0].clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( event.changedTouches[0].clientX, l, droppableOffset.width );
					}
				case "touch":
					return (
						( y1 >= t && y1 <= b ) || // Top edge touching
						( y2 >= t && y2 <= b ) || // Bottom edge touching
						( y1 < t && y2 > b ) // Surrounded vertically
					) && (
						( x1 >= l && x1 <= r ) || // Left edge touching
						( x2 >= l && x2 <= r ) || // Right edge touching
						( x1 < l && x2 > r ) // Surrounded horizontally
					);
				default:
					return false;
				}
			},
			_drag : function(event){
				var managerDD = lyteDomObj.prototype.managerDD;
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){
					
					var data = droppables[i]._droppableData;

					//Checks if the droppable is disabled or not
					//Also checks whether the draggable can be accepted by the droppable
					//And the draggable and droppable are not same element and doesnt have parent child relationship
					if(!data.disabled && !(managerDD._isRelated(draggable, droppables[i])) && managerDD._checkAcceptable(draggable,data.accept) && managerDD._isNotRejected(draggable,data.reject)){

						//Checks if the draggable intersects the droppable
						if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance)){
							if(!data.entered){
								var prevDroppable = draggable._draggableData.currDroppable;
								if(prevDroppable && prevDroppable != droppables[i]){
									var prevDroppableData = prevDroppable._droppableData;
									if(prevDroppableData.onLeave){
										prevDroppableData.onLeave(draggable,prevDroppable);
									}
									if(prevDroppableData.hoverClass && $L(prevDroppable).hasClass(prevDroppableData.hoverClass)){
										$L(prevDroppable).removeClass(prevDroppableData.hoverClass);
									}
									if(prevDroppableData.activeClass && !$L(prevDroppable).hasClass(prevDroppableData.activeClass)){
										$L(prevDroppable).addClass(prevDroppableData.activeClass);
									}
									prevDroppableData.entered = false;
								}
								if(data.onEnter){
									data.onEnter(draggable,droppables[i]);
								}
								data.entered = true;
								draggable._draggableData.currDroppable = droppables[i];
							}
							if(data.onDrag){
								data.onDrag(draggable,droppables[i],event);
							}
							if(data.hoverClass && !$L(droppables[i]).hasClass(data.hoverClass)){
								this.removeHoverClass(droppables[i],data.hoverClass);
								if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
									$L(droppables[i]).removeClass(data.activeClass);
								}
								$L(droppables[i]).addClass(data.hoverClass);
								if(data.onHover){
									data.onHover(draggable,droppables[i]);
								}
							}
							break;
						}
						else{
							if(data.entered){
								var prevDroppable = draggable._draggableData.currDroppable,
									prevDroppableData = prevDroppable._droppableData;
								if(prevDroppableData.onLeave){
									prevDroppableData.onLeave(draggable,prevDroppable);
								}
								if(prevDroppableData.hoverClass && $L(prevDroppable).hasClass(prevDroppableData.hoverClass)){
									$L(prevDroppable).removeClass(prevDroppableData.hoverClass);
								}
								if(prevDroppableData.activeClass && !$L(prevDroppable).hasClass(prevDroppableData.activeClass)){
									$L(prevDroppable).addClass(prevDroppableData.activeClass);
								}
								prevDroppableData.entered = false;
								draggable._draggableData.currDroppable = null;
							}
						}
					}
				}
			},
			_drop : function(event){
				var managerDD = lyteDomObj.prototype.managerDD;
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){
					if(!(managerDD._isRelated(draggable, droppables[i]))){
						var data = droppables[i]._droppableData;
						if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
							$L(droppables[i]).removeClass(data.activeClass);
						}
						if(data.hoverClass && $L(droppables[i]).hasClass(data.hoverClass)){
							$L(droppables[i]).removeClass(data.hoverClass);
						}
						if(!data.disabled && managerDD._checkAcceptable(draggable,data.accept)){
							if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance)){
								if(data.onDrop){
									data.onDrop(draggable,droppables[i]);
								}
								break;
							}
						}
					}
				}
			},
			_isRestricted : function(restrict,element){
				restrict = restrict instanceof Array ? restrict : restrict.split(",");
				for(var i = 0; i<restrict.length; i++){
					var elements = document.querySelectorAll(restrict[i]);
					for(var j = 0; j < elements.length; j++){
						if(element.isEqualNode(elements[i])){
							return true;
						}
					}
				}
				return false;
			},

			_isRelated : function(draggable, droppable){
				if(draggable.isEqualNode(droppable) || draggable.contains(droppable)){
					return true;
				}
				return false;
			},
			sort : function(){
				var droppables = this._droppables,
				lastItem = droppables[droppables.length - 1],
				lastItemOffset = lastItem.getBoundingClientRect();
				for(var i = 0; i < droppables.length - 1; i++){
					var elemOffset = droppables[i].getBoundingClientRect();
					if(lastItemOffset.height < elemOffset.height || lastItemOffset.width < elemOffset.width){
						droppables.splice(droppables.indexOf(lastItem),1);
						droppables.splice(i,0,lastItem);
						return;
					}
				}
			},

			destroy : function(element){
				var managerDD = lyteDomObj.prototype.managerDD;
				if(!(element.classList.contains('droppable-element'))){
					console.info("ALERT! - U have already destroyed its droppable behaviour.");
					return;
				}
				if(managerDD._droppables.indexOf(element) !== -1){
					managerDD._droppables.splice(managerDD._droppables.indexOf(element),1);
				}
				if(element._droppableData.registerFromParent || element._droppableData.registerToParent){
					var currentWin = window;
					managerDD.deleteDroppable(element, currentWin, "up");
					managerDD.deleteDroppable(element, currentWin, "down");
				}
				if (element._droppableData) {
					element._droppableData = null;
				}
				element.classList.remove('droppable-element');
			},

			sortDroppables : function(droppableEle){
				var managerDD = lyteDomObj.prototype.managerDD;
				var data = droppableEle._droppableData;
				if(data.sortCallback) {
					data.sortCallback(this._droppables);
				}else{
					managerDD.sort();
				}
				
			},

			removeHoverClass : function(current,className){
				var droppables = this._droppables;
				for(var i = 0; i<droppables.length; i++){
					if(!(droppables[i].isEqualNode(current)) && droppables[i].classList.contains(className)){
						droppables[i].classList.remove(className);
					} 
				}
			},

			deleteDroppable : function(element,currentWin,direction){
				var managerDD = lyteDomObj.prototype.managerDD;
				if(direction == "up"){
					while(currentWin.parent){
						currentWin = currentWin.parent;
						if(currentWin && currentWin.lyteDomObj){
							var winManagerDD = currentWin.lyteDomObj.prototype.managerDD;
							if(winManagerDD && winManagerDD._droppables.indexOf(element) !== -1){
								winManagerDD._droppables.splice(winManagerDD._droppables.indexOf(element),1);
							}
						}
						if(currentWin.parent == currentWin.top){
							break;
						}
					}
				}
				if(direction == "down"){
					var iframes = currentWin.document.documentElement.querySelectorAll('iframe');
					if(iframes){
						for(var i = 0; i<iframes.length ; i++){
							var win = iframes[i].contentWindow;
							if(win && win.lyteDomObj){
								var winManagerDD = win.lyteDomObj.prototype.managerDD;
								if(winManagerDD && winManagerDD._droppables.indexOf(element) !== -1){
									winManagerDD._droppables.splice(winManagerDD._droppables.indexOf(element),1);
									winManagerDD.deleteDroppable(element, win, "down");
								}
							}
						}
					}
				}
			},

			setProperty : function(element, properties){
				var managerDD = lyteDomObj.prototype.managerDD;
				if(!element){
					console.error('Element whose droppable property will be updated is undefined');
					return;
				}
				if(!(element.classList.contains('droppable-element'))){
					console.error('Element whose droppable property will be updated is not a droppable element');
					return;
				}
				if(managerDD.isEmpty(properties)){
					console.error('Droppable properties to be updated is not specified');
					return;
				}

				for(var prop in properties) {
				    element._droppableData[prop] = properties[prop];
				}
			},

			isEmpty : function(properties){
				if(!properties){
					return true;
				}
				for(var prop in properties) {
				    if(properties.hasOwnProperty(prop)) {
				    	return false;
				    }
				}

				return JSON.stringify(properties) === JSON.stringify({});
			}
		};


		//It initializes the droppable funcionality and stores it in the managerDD._droppables array 
		lyteDomObj.prototype.droppable = function(object, properties) {
			var managerDD = lyteDomObj.prototype.managerDD;
			if(!managerDD.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				managerDD.init = true;
			}

			if(!managerDD.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				managerDD.init = true;
			}

			if(typeof object === "string"){
				if(object === "destroy"){
					if(this.length > 1){
						var elemArray = this;
						for(var i=0; i<elemArray.length; i++){
							managerDD.destroy(elemArray[i]);
						}
					}
					else{
						managerDD.destroy(this[0]);
					}
				}
				else if(object === "option"){
					if(this.length > 1){
						var elemArray = this;
						for(var i=0; i<elemArray.length; i++){
							managerDD.setProperty(elemArray[i], properties);
						}
					}
					else{
						managerDD.setProperty(this[0], properties);
					}
				}

				else if(object === "sort"){
					var currentDroppables = managerDD._droppables;
					if(currentDroppables.length > 0){
						managerDD._droppables = [];
						managerDD._droppables.push(currentDroppables[0]);
						for(var i = 1; i < currentDroppables.length; i++){
							managerDD._droppables.push(currentDroppables[i]);
							managerDD.sortDroppables(currentDroppables[i]);
						}
					}

					var element = this[0];
					if(element._droppableData && element._droppableData.registerToParent){
						var currentWin = window,
							winManagerDD;
						while(currentWin.parent){
							currentWin = currentWin.parent;
							if(currentWin && currentWin.lyteDomObj){
								winManagerDD = currentWin.lyteDomObj.prototype.managerDD;
								if(winManagerDD){
									currentDroppables = winManagerDD._droppables;
									if(currentDroppables.length > 0){
										winManagerDD._droppables = [];
										winManagerDD._droppables.push(currentDroppables[0]);
										for(var i = 1; i < currentDroppables.length; i++){
											winManagerDD._droppables.push(currentDroppables[i]);
											winManagerDD.sortDroppables(currentDroppables[i]);
										}
									}
								}
							}
							if(currentWin.parent == currentWin.top){
								break;
							}
						}
					}
					if(element._droppableData && element._droppableData.registerFromParent){
						var currentWin = window,
							parentWindow = window, pwinManagerDD, cwinManagerDD;
						while(parentWindow.parent){
							parentWindow = parentWindow.parent;
							if(parentWindow && parentWindow.lyteDomObj){
								pwinManagerDD = parentWindow.lyteDomObj.prototype.managerDD;
								if(pwinManagerDD){
									var droppables = pwinManagerDD._droppables;
									for(var i = 0; i<droppables.length ; i++){
										if(currentWin && currentWin.lyteDomObj){
											cwinManagerDD = currentWin.lyteDomObj.prototype.managerDD;
											currentDroppables = cwinManagerDD._droppables;
											if(currentDroppables.length > 0){
												cwinManagerDD._droppables = [];
												cwinManagerDD._droppables.push(currentDroppables[0]);
												for(var i = 1; i < currentDroppables.length; i++){
													cwinManagerDD._droppables.push(currentDroppables[i]);
													cwinManagerDD.sortDroppables(currentDroppables[i]);
												}
											}
										}
									}
								}
							}
							if(parentWindow.parent == parentWindow.top){
								break;
							}
						}
					}
				}
				
				return;
			}

			var data = object ? object : {};

			if(this.length > 1){
				var elemArray = this;
				for(var i = 0; i<elemArray.length; i++){
					$L(elemArray[i]).droppable(Object.assign({},data));
				}
				return;
			}

			if(data.restrict && managerDD._isRestricted(data.restrict, this[0])){
				return;
			}

			//Parent Element
			var droppableEle;
			data._element = droppableEle = this[0];
			$L(data._element).addClass('droppable-element');
			data.entered = false;
			data.activeClass = data.activeClass ? data.activeClass : false; 
			data.accept = data.accept ? data.accept : [];
			data.disabled = (data.disabled === true) ? data.disabled : false;
			data.hoverClass = data.hoverClass ? data.hoverClass : false;
			data.tolerance = (data.tolerance === "fit" || data.tolerance === "intersect" || data.tolerance === "pointer" || data.tolerance === "touch") ? data.tolerance : "intersect";
			data.registerToParent = data.registerToParent;
			data.reject = data.reject ? data.reject : [],
			droppableEle._droppableData = data;

			if(managerDD._droppables.indexOf(droppableEle) == -1){
				// managerDD._droppables.splice(managerDD._droppables.indexOf(droppableEle),1);
				managerDD._droppables.push(droppableEle);
				if(managerDD._droppables.length > 1 && data.sortDroppables){
					managerDD.sortDroppables(droppableEle);
				}
			}
			

			//Incase of nested iframes if user wants the droppables to be available to the parent window context
			if(data.registerToParent){
				var currentWin = window,
					winManagerDD;
				while(currentWin.parent){
					currentWin = currentWin.parent;
					if(currentWin && currentWin.lyteDomObj){
						winManagerDD = currentWin.lyteDomObj.prototype.managerDD;
						if(winManagerDD){
							winManagerDD._droppables.push(droppableEle);
							if(winManagerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
								winManagerDD.sortDroppables(droppableEle);
							}
						}
					}
					if(currentWin.parent == currentWin.top){
						break;
					}
				}
			}

			//Incase the user wants all the droppables from its parent
			if(data.registerFromParent){
				var currentWin = window,
					parentWindow = window, pwinManagerDD, cwinManagerDD;
				while(parentWindow.parent){
					parentWindow = parentWindow.parent;
					if(parentWindow && parentWindow.lyteDomObj){
						pwinManagerDD = parentWindow.lyteDomObj.prototype.managerDD;
						if(pwinManagerDD){
							var droppables = pwinManagerDD._droppables;
							for(var i = 0; i<droppables.length ; i++){
								if(currentWin && currentWin.lyteDomObj){
									cwinManagerDD = currentWin.lyteDomObj.prototype.managerDD;
									if(cwinManagerDD._droppables.indexOf(droppables[i]) == -1){
										cwinManagerDD._droppables.push(droppables[i]);
										if(cwinManagerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
											cwinManagerDD.sortDroppables(droppables[i]);
										}
									}
								}
							}
						}
					}
					if(parentWindow.parent == parentWindow.top){
						break;
					}
				}
			} 

			droppableEle = null;
			if(data.onReady){
				data.onReady(this[0]);
			}

			return this;
		}

	}

})( window );

( function() {
	var empty = function() {},
	ignore = [];

	/* constructor */
	function reqQueue( obj ) {
		this.queue = [];
		this.total = 0;
		this.sequential = ( obj || {} ).hasOwnProperty( 'sequential' ) ? obj.sequential : true;

		this.success = {};
		this.error = {};
		this.complete = {};
		this.order = [];


		return this;
	}

	/* private functions */
	function generateID( reqQ ) {
		return reqQ.total++;
	}

	function makeRequestWhenAjax( obj, reqQ, id ) {
		var success = obj.success || empty,
		complete = obj.complete || empty,
		error = obj.error || empty,
		beforeSend = obj.beforeSend,
		prom, copy = {};

		prom = new Promise( function( res, rej ) {

			$L.extend( copy, obj );

			copy.complete = function() {
				if( !reqQ.sequential ) {
					complete.apply( this, arguments );
				}
				else if( nextInQueue( reqQ ) === id ) {
					complete.apply( this, arguments );
					reqQ.order.shift();
					flush( reqQ );
				}
				else {
					reqQ.complete[ id ] = {
						fn: complete,
						context: this,
						args: arguments
					}
				}
			}

			copy.success = function() {
				if( !reqQ.sequential || nextInQueue( reqQ ) === id ) {
					success.apply( this, arguments );
				}
				else {
					reqQ.success[ id ] = {
						fn: success,
						context: this,
						args: arguments
					};
				}	

				res( {
					statusText: arguments[ 1 ],
					id: id,
					options: obj,
					lXHR: arguments[ 2 ],
					data: arguments[ 0 ],
					passed: true
				} );
			}

			copy.error = function() {
				if( !reqQ.sequential || nextInQueue( reqQ ) === id ) {
					error.apply( this, arguments );
				}
				else {
					reqQ.error[ id ] =  {
						fn: error,
						context: this,
						args: arguments
					};
				}

				rej( {
					id: id,
					options: obj,
					lXHR: arguments[ 0 ],
					statusText: arguments[ 1 ],
					error: error,
					passed: false
				} );
			}

			copy.beforeSend = function() {
				var ret;

				if( beforeSend ) {
					ret = beforeSend.apply( this, arguments );

					if( ret === false ) {
						ignore.push( id );
						rej( {
							id: id,
							options: obj,
							lXHR: arguments[ 0 ],
							passed: false
						} );
					}

					return ret;
				}
			}


			$L.ajax( copy );	
		} );

		return prom;
	}


	
	function nextInQueue( reqQ ) {
		var next = ( reqQ.order || [] )[ 0 ];

		if( !!~ignore.indexOf( next ) ) {
			reqQ.order.shift();

			next = nextInQueue( reqQ );
		}

		return next;
	}

	function flush( reqQ ) {
		var arr = [ 'success', 'error', 'complete' ],
		next, obj, cb, args, context, empty;

		while( ( next = nextInQueue( reqQ ) ) ) {
			empty = true;

			arr.forEach( function( item ) {
				empty = $L.isEmptyObject( obj = reqQ[ item ][ next ] || {} ) && empty;
				context = obj.context;
				args = obj.args;
				cb = obj.fn;

				if( cb ) {
					cb.apply( context, args );
				}
			} );

			if( empty ) {
				break;
			}

			reqQ.order.shift();
		}

	}

	function findType( obj ) {
		var type = 'Object';

		if( obj instanceof Promise ) {
			type = 'Promise'
		}

		return type;
	}

	function disableSequentialFlag( reqQ ) {
		reqQ.sequential = false;
	}


	function processResults( res, rej, results ) {
		var failed = [],
		success = [];

		// Reset ignores
		ignore = [];

		results.forEach( function( item ) {
			var isSuccess = item.passed;

			if( isSuccess ) {
				success.push( item );
			}
			else {
				failed.push( item );
			}
		} );

		if( failed.length === 0 ) {
			res( {
				success: success,
				failure: failed
			} );
		}
		else {
			rej( {
				success: success,
				failure: failed
			} );
		}
	}


	function setCallbacksWhenPromise( promise, id ) {
		var wrapper = new Promise( function( res, rej ) {
			
			promise.then( function() {
				res( {
					data: arguments,
					passed: true,
					id: id
				} );
			}, function() {
				rej( {
					data: arguments,
					passed: false,
					id: id
				} );
			} );
		} );
		

		return wrapper;
	}

	/* public functions */
	reqQueue.prototype.initiate = function() {
		var queue = this.queue,
		obj, opts, id, prom = [], ret, type;

		while( obj = queue.shift() ) {
			opts = obj.options;
			id = obj.id;
			type = obj.type

			this.order.push( id );

			if( type === 'Object' ) {
				prom.push( makeRequestWhenAjax( opts, this, id ) );	
			}
			else {
				disableSequentialFlag( this );
				prom.push( setCallbacksWhenPromise( opts, id ) );
			}
		}

		ret = new Promise( function( res, rej ) {
			Promise.all( 
				prom.map( function( p ) {
					return p.catch( function( e ) {
						return e;
					} );
				} )
			).then( processResults.bind( this, res, rej ) );
		} );

		this.queue = [];

		return ret;
		
	}

	reqQueue.prototype.add = function( obj ) {
		var id, that = this;

		if( Array.isArray( obj ) ) {
			return obj.map( function( item ) {
				return that.add( item );
			} );
		}
		else {
			id = generateID( this );

			this.queue.push( {
				id: id,
				options: obj,
				type: findType( obj )
			} );

			return id;	
		}		
	}


	reqQueue.prototype.removeAll = function() {
		var queue = this.queue;

		this.remove( 
			queue.map( function( item ) {
				return item.id;
			} ) 
		);
	}

	reqQueue.prototype.remove = function( id ) {
		var queue = this.queue,
		ind, that = this;

		id = Array.isArray( id ) ? id : [ id ];

		this.queue = queue.filter( function( item ) {
			var ind = id.indexOf( item.id ),
			present = !!~ind;

			return !present;
			
		} );		
	}

	$L.reqQueue = function( obj ) {
		var reqQ = new reqQueue( obj );

		return reqQ;
	}
} )();


;( function() {
    if( lyteDomObj ) {
        var uA = navigator.userAgent, isSaf =  { uA : uA, isUbuntu : /ubuntu/ig.test( uA ), isIpad : /ipad/ig.test( uA ) , safari : /safari/ig.test( uA ), isIE11Lyte : /rv:11/ig.test( uA ), isEdgeLyte : /Edge/ig.test( uA ),  mode : {}, chrome  : !!window.chrome , firefox : /firefox/ig.test( uA ) };
        function appendDiv( className, obj, dir ) {
            var div = document.createElement( 'div' ), innerDiv;
            div.className = className;
            div._scrolldiv = this;
            div.style.visibility = 'hidden';
            innerDiv = document.createElement( 'div' );
            innerDiv.classList.add( 'lyteScrollDiv' );
            if( obj.handlerClass ) {
                innerDiv.classList.add( obj.handlerClass );
            }
            if( obj.containerClass ) {
                div.classList.add( obj.containerClass )
            }
            div.appendChild(innerDiv);
            if( dir ) {
                innerDiv._direction = dir;
                if( obj.horizontalContainerClass ){
                    div.classList.add( obj.horizontalContainerClass );
                }
                if( obj.horizontalHandlerClass ) {
                    innerDiv.classList.add( obj.horizontalHandlerClass );
                }
                this._horiDiv = div;
            } else {
                if( obj.verticalContainerClass  ) {
                    div.classList.add( obj.verticalContainerClass );
                }
                if( obj.verticalHandlerClass ){
                    innerDiv.classList.add( obj.verticalHandlerClass );
                }
                this._vertDiv = div;
            }
            this.parentElement.appendChild( div )
            div.addEventListener( 'click', outerDivClick, true );
            innerDiv.addEventListener( 'mousedown', innerDivClick );
            if( !this._infiniteScroll ){        
                innerDiv.addEventListener( 'touchstart', innerDivClick );       
            }
            return div;
        }   

        function set( elem, prop, val ) {
            if( elem.style[ prop ] != val ){
                elem.style[ prop ] = val
            }
        }

        function checkscrollable( evt ){
            evt = evt || { target : this };
            var target = evt.target.correspondingElement || evt.target, ret;
            while( target && target != this ) {
                if( target.classList.contains( 'preventWheel' ) ) {
                    ret = true;
                    break;
                }
                target = target.parentElement
            }
            return ret
        }

        function check( flag, elem, obj, mode, evt ){
            var fg;
            evt = evt || {},

            fn = function( elem ){
                set( elem, 'visibility', 'hidden' );
                elem.classList.remove( 'visible' );
            };

            if( !flag.scroll ) {
                var is_showon_scroll = this._scrollData.showOn == 'scroll';
                if( !( [ 'mouseenter', 'touchstart' ].indexOf( evt.type ) != -1 && is_showon_scroll ) ){
                    this._enableScroll = !flag.frm_reset
                    if( elem && ( !is_showon_scroll || !flag.frm_reset ) ) {
                        clearTimeout( elem._entertimeout );
                        clearTimeout( elem._leavetimeout );
                        delete elem._entertimeout; delete elem._leavetimeout;
                        if( !flag.scrollbar ){
                            if( evt.type == "touchstart" ){
                                elem._entertimeout = setTimeout( set.bind( this, elem, 'visibility', 'visible' ), 150 );
                            } else {
                                set( elem, 'visibility', 'visible' );
                            }
                            elem.classList.add( 'visible' );
                            updatePos.call( this, mode, undefined, {}, obj );
                        } else{
                            fn( elem );
                        }
                    }
                }
                fg = true
            } else {
                if( elem ) {
                   fn( elem );
                }
            }
            return fg
        }

        function initialWheel( evt ){
            this.removeEventListener( 'wheel', initialWheel, true )
            if( !this.classList.contains( 'eventBinded' ) ){
                mouseenter.call( this, { type : 'mouseenter' } )
            }
            evt.preventDefault()
        }

        function format_bcr( bcr ){
            var obj = {};
            [ 'x', 'y', 'bottom', 'height', 'top', 'width', 'left', 'right' ].forEach( function( item ){
                obj[ item ] = Math.round( bcr[ item ] );
            });
            return obj;
        }

        function mouseenter( evt, frm_reset ) {
            // console.log( evt.target, evt.type, evt.currentTarget );
            if( this.classList.contains( 'eventBinded' ) && evt != true ){
                return
            }
            if( evt.type == 'mouseenter' && this._prtmseenr ){
                return;
            }
            var flag, obj = { scrollLeft : this.scrollLeft, scrollTop : this.scrollTop, scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };
            this._wheelObj = obj
            if( this.classList.contains( 'lyteTableScroll' ) ){
                forTable.call( this, obj )
            }
            this._direction = getComputedStyle(  this ).direction;
            obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
            obj.horbcr = this._horiDiv ?  this._horiDiv.getBoundingClientRect() : {}
            flag = check.call( this, fitForScroll.call( this, true, obj, frm_reset ), this._vertDiv, obj, true, evt )
            flag = check.call( this, fitForScroll.call( this, false, obj, frm_reset ), this._horiDiv, obj, false, evt ) || flag
            if( flag && evt ) {
                this._mouseleave = this._mouseleave || mouseleave.bind( this.parentElement );
                if( evt.type == "touchstart" ) {
                   if( evt.touches.length == 1 ){
                        clearTimeout( this._tchtime );
                        document.addEventListener( 'touchcancel', this._mouseleave, true )
                    } else {
                        return;
                    }
                } else {
                    this.addEventListener( 'wheel', wheelEvent, true );
                    this.addEventListener('keydown', keydownFunc, true);
                    if( this._scrollData.showOn == 'scroll' ){
                        this.addEventListener( 'mousemove', hideScrollbar, true );
                    }
                }
                this._allowTouch = true;
                document.addEventListener( 'touchend', this._mouseleave, true )
                this.classList.add( 'eventBinded' )
                this._tabindex = this._tabindex == undefined ? this.tabIndex : this._tabindex;
                if(this.tabIndex == -1){
                    this.tabIndex = 0;
                }
            }
        } 

        function keydownFunc( evt ) {
            if( evt.target != this ){
                return
            }
            var keyCode = evt.keyCode, obj = { scrollLeft : this.scrollLeft, scrollTop : this.scrollTop, scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };
            if([37, 38, 39, 40].indexOf(keyCode) != -1){
                var step = this._scrollData.keyStep, pos, mode, meta = evt.metaKey || evt.ctrlKey, dir = this._direction;
                if( keyCode == 38 ){
                    pos = meta ? ( -obj.scrollTop ) : -step
                    mode = true
                } else if( keyCode == 40 ){
                    pos = meta ? ( obj.scrollHeight - obj.scrollTop ) : step
                    mode = true
                }else if( keyCode == 39 ){
                    if( dir == 'rtl' ) {
                        var val; 
                        if( isSaf.isIE11Lyte || isSaf.isEdgeLyte ) {
                            val = obj.scrollWidth - obj.scrollLeft;
                        } else if( isSaf.firefox || isSaf.safari ) {
                            val = -obj.scrollLeft;
                        } else {
                            val =  obj.scrollWidth - obj.bcr.width;
                        }
                        pos = meta ? ( val ) : step
                    } else {
                        pos = meta ? ( obj.scrollWidth - obj.bcr.width ) : step
                    }
                } else {
                    if( dir == 'rtl' && ( isSaf.firefox || isSaf.safari ) ) {
                        pos = meta ? ( obj.bcr.width - obj.scrollWidth ) : -step;
                    } else {
                        pos = meta ? ( -obj.scrollLeft ) : -step
                    }
                }
                if( pos != 0 && shouldPrevent.call( this, obj, mode, pos ) ){
                    this[ mode ? 'scrollTop' : 'scrollLeft' ] += pos;
                    scroll.call( this, evt )
                    evt.preventDefault()
                }
            }
        }

        function mouseleave( evt ){
            evt = evt || {};
            if( ( evt.relatedTarget && this.contains( evt.relatedTarget ) ) || document._scrollmouseup ){
                return
            }
            if( evt.type == 'touchend' ) {     
                var tar = evt.target.correspondingElement || evt.target;        
                if( tar && tar.classList.contains( 'lyteScrollContainer' ) ) {      
                    return;     
                }       
            }
            var bars = $L( this ).children( '.lyteScrollContainer' ), scrlDiv = this._scrolldiv;
            if( bars.length ) {
                for(  var i = 0; i < bars.length; i++ ) {
                    clearTimeout( bars[ i ]._entertimeout );
                    clearTimeout( bars[ i ]._leavetimeout );
                    delete bars[ i ]._entertimeout;
                    delete bars[ i ]._leavetimeout;

                    bars[ i ].classList.remove( 'visible' )
                    if( evt.type == 'touchend' ){
                        bars[ i ]._leavetimeout = setTimeout( set.bind( this, bars[ i ], 'visibility', 'hidden'), 150 )
                    } else {
                        bars[ i ].style.visibility = 'hidden';
                    }
                }
                if( evt.type == 'mouseleave' ) {
                    scrlDiv.removeEventListener('wheel', wheelEvent, true);
                    scrlDiv.removeEventListener('keydown', keydownFunc, true);
                    scrlDiv.removeEventListener( 'mousemove', hideScrollbar, true );
                    scrlDiv.addEventListener( 'wheel', initialWheel, true );
                } else if( evt.type == 'touchend' || evt.type == "touchcancel" ) {
                    scrlDiv._prtmseenr = true;
                    scrlDiv._tchtime = setTimeout( function(){
                        delete scrlDiv._prtmseenr;
                    }, 500 )
                    document.removeEventListener( 'touchcancel', scrlDiv._mouseleave, true )
                }
                if( evt.type ){
                    document.removeEventListener( 'touchend', scrlDiv._mouseleave, true )
                    delete scrlDiv._allowTouch;
                    scrlDiv.classList.remove( 'eventBinded' );
                    // scrlDiv.tabIndex = this._scrolldiv._tabindex;
                    // delete scrlDiv._tabindex;
                     delete scrlDiv._wheelObj;
                    delete scrlDiv._prevPosY; delete scrlDiv._mouseleave;
                    delete scrlDiv._prevPosX; delete scrlDiv._wheelEvt;
                }
                delete this._scrolldiv._enableScroll;
            }
        }

        function outerDivClick( evt ) {
            if( !this.classList.contains( 'visible' ) ){
                return
            }
            var isTch = evt.type == "touchmove";       
            if( isTch ) {       
                if( evt.touches.length > 1 ){       
                    return;     
                } else {        
                    evt.preventDefault();       
                    evt = evt.touches[ 0 ]      
                }       
            }       
            var elem = this._scrolldiv, mode, inn = this.children[ 0 ], outBcr = this.getBoundingClientRect(), inBcr = inn.getBoundingClientRect(),
            obj = { scrollLeft : elem.scrollLeft, scrollTop : elem.scrollTop, scrollWidth : elem.scrollWidth, scrollHeight : elem.scrollHeight, bcr : elem.getBoundingClientRect() },
            hgt = 'width', top1 = 'left', sT = 'scrollLeft', sH = 'scrollWidth', bt = 'right', cY = 'clientX';
            if( this.classList.contains( 'lyteTableScroll' ) && !obj.$nodeClient ){
                forTable.call( this, obj )
            }
            obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
            obj.horbcr = this._vertDiv ?  this._horiDiv.getBoundingClientRect() : {}
            if(!inn._direction){
                mode = true;
                hgt = 'height', top1 = 'top', sT = 'scrollTop', sH = 'scrollHeight', bt = 'bottom', cY = 'clientY';
            }
            var scramt = evt.type != 'click' ? ( evt[ cY ] - ( this.prev || evt[ cY ] ) ) : ( evt[ cY ] - ( inBcr[ top1 ] + inBcr[ hgt ] / 2 ) ), newsL;
            newsL = ( scramt / ( obj.bcr[ hgt ] + obj.bcr[ top1 ] - outBcr[ top1 ] ) * obj[ sH ] )
            elem[ sT ] += ( newsL ) ;
            scroll.call( elem, evt );
            this.prev = evt[ cY ];
        }

        function innerDivClick( evt ) {
           var isTch = evt.type == "touchstart";
            document._scrollmousemove = outerDivClick.bind( this.parentNode );
            document._scrollmouseup = mouseup.bind( this.parentNode );
            document.addEventListener( isTch ? 'touchmove' : 'mousemove', document._scrollmousemove, true );
            document.addEventListener( isTch ? 'touchend' : 'mouseup', document._scrollmouseup, true );
            evt.preventDefault();
            evt.stopPropagation();
        }

        function mouseup( evt ) {
            var isTch = evt.type == "touchend";
            document.removeEventListener( isTch ? 'touchmove' : 'mousemove', document._scrollmousemove, true )
            document.removeEventListener( isTch ? 'touchend' : 'mouseup', document._scrollmouseup, true )
            delete document._scrollmousemove;
            delete document._scrollmouseup; delete this.prev;
            if( !this._scrolldiv.contains( evt.target.correspondingElement || evt.target ) && this._scrolldiv._scrollData.showOn != 'always' ){
                mouseleave.call( this._scrolldiv.parentElement, { type : 'mouseleave' } )
            }
        }

        function mousedown( evt ) {
            if( document._scrollmouseup ) {
                return
            }
            document._scrollmouseup = mouseup.bind( this.parentElement );
            document.addEventListener( 'mouseup', document._scrollmouseup, true )
        }

        function fitForScroll( mode, obj, frm_reset ) {
            var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv,
            scrolldata = this._scrollData,
            margin = scrolldata.scrollYMarginOffset;

            if( !mode ) {
                sL = 'scrollLeft', sW = 'scrollWidth', wd = 'width';
                margin = scrolldata.scrollXMarginOffset;
            }
            if( obj[ sL ] + obj.bcr[ wd ] >= obj[ sW ] && obj[ sL ] == 0 ){
                if( elem && elem.classList.contains( 'visible' ) ) {
                    check.call( this, { scroll : true, scrollbar : true }, elem )
                }
                return {
                    scroll : true,
                    scrollbar : true,
                    frm_reset : frm_reset
                }
            }

            return{
                scroll : false,
                scrollbar : ( obj[ sW ] - obj.bcr[ wd ] ) <= margin,
                frm_reset : frm_reset
            }
        }

        function wheelEvent( evt ){
             if( checkscrollable.call( this, evt ) ) {
                    return
                }
            if( evt.type == 'touchmove' ) { 
                if( this._allowTouch && evt.touches.length == 1 ) {
                    var curr = evt.touches[ 0 ];
                    wheelEvent1.call( this, evt, [ (this._prevPosX || curr.clientX ) - curr.clientX,  ( this._prevPosY || curr.clientY ) - curr.clientY ] )
                    this._prevPosY = curr.clientY;
                    this._prevPosX = curr.clientX;
                }
            } else {   
                wheelEvent1.call( this, evt )
            }
        }

        function shouldPrevent( obj, mode, val ){
            var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv;
            if( !mode ) {
                sL = 'scrollLeft' , sW = 'scrollWidth', wd = 'width';
            }
            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && Math.round( -obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) ){
                return false
            } else if( !mode && isSaf.firefox && this._direction == 'rtl' && ( val < 0 && obj[ sL ] == 0 ) ){
                return true
            } else if( ( val < 0 && obj[ sL ] == 0 ) && !( val < 0 && isSaf.safari && this._direction == 'rtl' && obj[ sL ] == 0 ) ){
                return false;
            }
            return true
        }

        function getWheel( evt ) {
            var data = this._scrollData, min = data.min, max = data.max,
            fact1 = data.wheelSpeed, fact = fact1, uA = isSaf.uA.toLowerCase(), inf = this._infiniteScroll, ie = isSaf.isIE11Lyte;
            if( ( uA.indexOf('edge') != -1 || (( uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1)) ) && this._direction == 'rtl' ){
                fact1 *= -1
            }
            // if( evt.shiftKey ) {
            //     fact1 *= -1; fact *= -1; 
            // }
            var x, y, delta = evt.deltaMode && evt.deltaMode == 1;
            if( evt.deltaX > 0 ) {
                x = Math.max( delta ? ( evt.deltaX * 6 ) :  evt.deltaX, (inf ? 0 : 4 ) )
            } else if( evt.deltaX < 0 ) {
                x = Math.min( inf ? 0 : -4, delta ? ( evt.deltaX * 6 ) : evt.deltaX )
            }
            if( evt.deltaY > 0 ) {
                y = Math.min( max, Math.max( delta ? ( evt.deltaY * 6 ) : evt.deltaY, inf ? 0 : 4 ), ie ? 20 : Infinity )
            } else if( evt.deltaY < 0 ) {
                y = Math.max( min, Math.min( inf ? 0 : -4, delta ? ( evt.deltaY * 6 ) : evt.deltaY ), ie ? -20 : -Infinity )
            }
            return [ x * fact1, y * fact ]
        }

        function nestedScroll( evt, ret ){  
            var target = evt.target;
            while( target != this ) {
                var sT = target.scrollTop,
                sH = target.scrollHeight,
                oH = target.offsetHeight,
                compsty = window.getComputedStyle( target ),
                isMatch = ( /scroll|auto/i.test( compsty.overflowY ) || ( target.classList.contains( 'lyteScrollBar' ) && /hidden/i.test( compsty.overflowY  ) ) );


                if( oH < sH  ){
                    if( ret ){
                        if( oH + sT < sH && isMatch ){
                            return true;
                        }
                    } else {
                        if( sT && isMatch ){
                            return true;
                        }
                    }
                }
                target = target.parentNode;
            }
        }

        function wheelEvent1( evt, tch ) {
            var ret = tch || getWheel.call( this, evt );
            var a = ret[ 0 ] || 0, b = ret[ 1 ] || 0, mode = false, obj = this._wheelObj || {} , fit, stpre, isTable = this.classList.contains( 'lyteTableScroll' ); 
            if( Math.abs( tch ? a : ( evt.deltaX || 0 ) ) < Math.abs( tch ? b : ( evt.deltaY || 0 ) ) ) {
                mode = true
            }
            if( this._scrollData.nested && mode && nestedScroll.call( this, evt, b > 0 ) ){
                return;
            }

            if( this._scrollData.showOn == 'scroll' ){
                if( !this._enableScroll ){
                    mouseenter.call( this, true )
                    evt.preventDefault();
                    return
                }
                clearTimeout( this._scrollplugin )  
                this._scrollplugin = setTimeout(mouseleave.bind( this.parentElement, {} ), this._scrollData.tOut )
            }

            if( this._scrollEnd ) {
                obj= { scrollLeft : this.scrollLeft, scrollTop : this.scrollTop, scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };
                this._wheelObj = obj
                if( this.classList.contains( 'lyteTableScroll' ) ){
                    forTable.call( this, obj )
                }
            }
            if( this._wheelObj ){
                fit = fitForScroll.call( this, mode, obj );
                if(( fit.scroll && mode /*&& b > 0*/ && (  !this._vertDiv || ( this._vertDiv && !this._vertDiv.classList.contains( 'visible' ) ) ) ) || ( fit.scroll && !mode /*&& a < 0*/ && ( !this._horiDiv || ( this._horiDiv && !this._horiDiv.classList.contains( 'visible' ) ) ) ) ){
                    return
                }
                stpre = shouldPrevent.call( this, obj, mode, mode ? b : a ); 
                if( this._infiniteScroll || stpre ){
                     evt.preventDefault();
                    if( !stpre && isTable && mode ) {
                        this.comp.scrollTable.call( this.comp, { yScroll : b }, this._wheelObj )
                    }
                } else{
                    if( this._scrollData.preventOnEnd ){
                        evt.preventDefault();
                    }
                    return
                }
            }
            if( mode ) {
                if( isSaf.isIE11Lyte ) {
                    if( this._wheelObj ){
                        this._wheelObj.scrollTop = Math.max( Math.min( this._wheelObj.scrollTop + b, this._wheelObj.scrollHeight - this._wheelObj.bcr.height ), 0 )
                        if(  isTable ) {
                            evt.yScroll = b;
                            this.comp.scroll.call( this, evt )
                        }
                        this.scrollTop += b;
                    } 
                } else if( !isSaf.isIE11Lyte ) {
                    this.scrollTop += b;
                }
            } else {
                 if( isSaf.isIE11Lyte ) {
                    if( this._wheelObj ) {
                        this._wheelObj.scrollLeft = Math.max( Math.min( this._wheelObj.scrollLeft + a, this._wheelObj.scrollWidth - this._wheelObj.bcr.width ), 0 )
                        if(  isTable ) {
                            evt.xScroll = a;
                            this.comp.scroll.call( this, evt )
                        }
                        this.scrollLeft += a;
                    }
                } else {
                   this.scrollLeft += a; 
                }
             }   
            if( isSaf.safari || isSaf.isIE11Lyte || isSaf.isIpad ) {
                    this._alive = true;
                    clearTimeout( this._alivetime )
                    this._alivetime = setTimeout( function(){
                       delete this._alive; delete this._alivetime; 
                    }.bind( this ), 16 )
                this._scrollFun.call( this, evt )
            }


            // if( this.comp ){
            //     clearTimeout( this._overlay.time );
            //     !this._overlay.classList.contains( 'lytescrolling' ) && this._overlay.classList.add( 'lytescrolling' );
            //     this._overlay.time = setTimeout( function(){
            //         this._overlay.classList.remove( 'lytescrolling' );
            //         delete this._overlay.time;
            //     }.bind( this ), 250 ) 
            // }
        }

        function scroll( evt ) {
            var a, b, issafIE = isSaf.isIE11Lyte || isSaf.safari || isSaf.isIpad, isIe = isSaf.isIE11Lyte ;
            if( issafIE && evt && evt.type == 'scroll' && ( this._alive && !evt._byFunc ) ) {
                trigEvt.call( this, isSaf.mode.a, isSaf.mode.b, this._wheelObj || { bcr : {} }, evt )
            } else{
                var obj= { scrollLeft : this.scrollLeft, scrollTop : this.scrollTop, scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };
                this._wheelObj = obj
                if( this.classList.contains( 'lyteTableScroll' ) ){
                    forTable.call( this, obj )
                }
                if( this.prevScrlLeft != obj.scrollLeft ) {
                    a = obj.scrollLeft - ( this.prevScrlLeft || 0 );
                    b = 0;
                    updatePos.call( this, false, a , evt, obj )
                } 
                if( this.prevScrlTop!= obj.scrollTop ) {
                    b = obj.scrollTop - ( this.prevScrlTop || 0 );
                    a = 0;
                    updatePos.call( this, true, b , evt, obj )
                }
                isSaf.mode.b = b; isSaf.mode.a = a;
                if( !isIe || ( issafIE && ( !this._alive || evt._byFunc ) ) ) {
                   if(  this.classList.contains( 'lyteTableScroll' ) ) {
                        this.comp.scroll.call( this, evt )
                    }
                }
            }
        }

         function hideScrollbar( evt ) {
            clearTimeout( this._scrollplugin )  
            this._scrollplugin = setTimeout(mouseleave.bind( this.parentElement), 500 )
        }

        function forTable( obj ) {
            var component =  this.comp, headerList = component.$node.getElementsByTagName( 'lyte-th' )
            if( this._infiniteScroll ){
                obj.$nodeClient = this.parentElement.getBoundingClientRect();
                var dummy =  this.getElementsByClassName( 'lytePreventInfiniteScroll' );
                obj.neglected = [];
                for( var m = 0; m < dummy.length; m++ ) {
                    if( /*isVisible( dummy[ m ] )*/ !dummy[ m ].classList.contains( 'lyteHidden' ) ) {
                        obj.neglected.push( dummy[ m ] );
                    }
                }

                obj.compNeg = dummy;
                if( this.comp._top != undefined ) {
                    obj.topElem = [];
                    var body = this.getElementsByTagName( 'lyte-tbody' )[ 0 ],
                    another = body.getElementsByTagName( 'lyte-tr' );
                    for( var n = 0; n < another.length; n++ ) {
                        if( !another[ n ].classList.contains( 'dummy' ) ) {
                            obj.topElem.push( another[ n ] );
                        }
                    }
                    obj.topElem = obj.topElem[ this.comp._top + obj.compNeg.length ]
                    obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};
                    obj.bottmElem = body.querySelector( 'lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length ) ) + ')' );
                    obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}
                    obj.tbody = body
                    obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};
                }
            }
            obj.scrollDivClient = obj.bcr;
            for(var k = 0; k < headerList.length; k++)
                {
                    headerList[k].property = headerList[k].getBoundingClientRect();
                    headerList[k].order = k
                }
            obj.calculated = true;  
        }

        function trigEvt( a, b, obj, evt ) {
            delete this._scrollEnd; 
            if( ( ( Math.ceil( obj.scrollLeft + obj.bcr.width + this._scrollData.offset.x ) >= obj.scrollWidth ) && !( this._direction == 'rtl' && isSaf.chrome ) ) || ( ( isSaf.firefox || isSaf.safari ) && this._direction == 'rtl' && ( Math.ceil( -obj.scrollLeft + obj.bcr.width + this._scrollData.offset.x ) >= obj.scrollWidth ) ) || ( this._direction == 'rtl' && isSaf.chrome &&  obj.scrollLeft == this._scrollData.offset.x ) ) {
                evt.horiScrollEnd = true;
            }
            if( Math.ceil( obj.scrollTop + obj.bcr.height + this._scrollData.offset.y ) >= obj.scrollHeight ) {
                this._scrollEnd = evt.vertScrollEnd = true;
            }
            evt.yScroll = b; evt.xScroll = a;
            evt._byPlugin = true;
            this._wheelObj = obj;
        }

        function updatePos( mode, a, evt, obj ) {
            if( parseInt( Math.abs( a ) )  == 0 || ( mode && !this._vertDiv ) || ( !mode && !this._horiDiv ) ){
                return
            }
            var out = this[ mode ? '_vertDiv' : '_horiDiv'  ], railBcr = obj[ mode ? 'vertbcr' : 'horbcr' ] || out.getBoundingClientRect(), inn = out.children[ 0 ];
            var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', lt = 'top', direction = this._direction ;
            if( !mode ) {
                sL = 'scrollLeft' , sW = 'scrollWidth', wd = 'width', lt = 'left';
            }
            var rt = ( obj.bcr[ wd ] - ( railBcr[ lt ] - obj.bcr[ lt ] ) ) / obj[ sW ], trt = obj[ sL ] / obj[ sW ], mL = this._scrollData.minLength, minLength = mL ? ( mL != 'auto' ? mL : 0 ) : 0.1 * obj.bcr[ wd ];
            set( inn, wd, Math.max( rt * obj.bcr[ wd ], minLength ).toFixed( 3 )+ 'px' ) 
            if( direction == 'rtl' &&  inn._direction ) {
                if( ( isSaf.safari && (  _lyteUiUtils.isNegativeScroll() || !window.chrome ) ) || isSaf.firefox ) {
                    set( inn, 'transform', 'translateX(' + ( ( obj[ sL ] / obj[ sW ] * 100 )  * obj.bcr[ wd ] / parseFloat( Math.max( rt * obj.bcr[ wd ], minLength ).toFixed( 3 ) ) ) + '%)' )
                } else {
                    set( inn, 'transform', 'translateX(' + ( ( -( obj[ sW ] - obj.bcr[ wd ] - obj[ sL ] ) / obj[ sW ] * 100 ) * obj.bcr[ wd ] / parseFloat( Math.max( rt * obj.bcr[ wd ], minLength ).toFixed( 3 ) ) ) + '%)' )
                } 
            } else{
                set( inn, 'transform', ( mode ? 'translateY' : 'translateX' ) + '(' + trt * ( obj.bcr[ wd ] - ( railBcr[ lt ] - obj.bcr[ lt ] ) - ( Math.max( 0, minLength - rt * obj.bcr[ wd ] ) ) ) + 'px)' )
            }
            this.prevScrlLeft = obj.scrollLeft; this.prevScrlTop = obj.scrollTop;
            if( evt.type ){
                trigEvt.call( this, mode ? 0 : a, mode ? a : 0, obj, evt )
            }
        }

        function removeScroll(){
            var elements = this;
            for( var i = 0; i < elements.length; i++ ) {
                var elem = elements[ i ], wrap = elem.parentElement;
                if( !wrap ){
                    continue;
                }
                if( elem._scrollData ) {
                    delete elem._scrollData;
                }
                var scrollDivs = wrap.querySelectorAll( 'div.lyteScrollContainer' );
                for(var k = 0; k < scrollDivs.length; k++){
                    if( scrollDivs[k].parentElement == wrap ) {
                        delete scrollDivs[ k ]._entertimeout;
                        delete scrollDivs[ k ]._leavetimeout;
                        wrap.removeChild(scrollDivs[k]);
                    }
                }
                elem.classList.remove( 'lyteScrollBar', 'eventBinded' );
                elem.removeEventListener( 'mouseenter', mouseenter, true );
                elem.removeEventListener( 'wheel', initialWheel, true );
                elem.removeEventListener( 'touchstart', mouseenter, true )
                wrap.removeEventListener( 'mouseleave', mouseleave, true );
                elem.removeEventListener( 'mousedown', mousedown );
                elem.removeEventListener( 'touchmove', wheelEvent, { passive : false } )
                elem.removeEventListener( 'scroll', scroll, true );
                clearTimeout( elem._tchtime );
                if( elem._mouseleave ){
                    document.removeEventListener( 'touchcancel', elem._mouseleave, true );
                    document.removeEventListener( 'touchend', elem._mouseleave, true );
                }
                delete elem._wheelObj; delete elem._vertDiv; delete elem._horiDiv;
                delete elem._scrollFun; delete elem._alivetime; delete elem._alive; delete elem._wheelObj;
                delete elem.resetScrollbar; delete wrap._scrolldiv; delete elem._tchtime;
                delete elem._allowTouch;
                elem.classList.remove( 'eventBinded' );
                elem.tabIndex = elem._tabindex;
                delete elem._tabindex; delete elem._wheelObj;
                delete elem._prevPosY; delete elem._mouseleave;
                delete elem._prevPosX; delete elem._wheelEvt;
            }
            return this;
        }

        function destroy(){
            $L( '.lyteScrollBar' ).scroll( 'destroy' );
            window.removeEventListener('scroll', globalscroll, true ); 
            return this; 
        }

        function reset(){
            var elements = this;
            for( var i = 0; i < elements.length; i++ ){
                if( elements[ i ]._scrollData ){
                    elements[ i ].resetScrollbar( true, true );
                }
            }
            return this;
        }

        lyteDomObj.prototype.removeScroll = function(){
            // console.warn( 'removeScroll deprecated. Use scroll("destroy") instead' );
            return removeScroll.call( this );
        }

        lyteDomObj.prototype.scroll = function( obj ) {
            if( obj && obj.constructor == String ){
                if( obj == "destroy" ){
                    return removeScroll.call( this );
                } else if( obj == "destroyScroll" ){
                    destroy.call( this );
                } else if( obj == "reset" ){
                    reset.call( this );
                }
                return;
            }

            var fn = function( obj, name, _default ){
                var value = obj[ name ];
                if( value == void 0 ){
                    value = _default;
                }
                obj[ name ] = value;
            };

            obj = obj || {};
            obj.showOn = obj.showOn || 'hover';
            obj.keyStep = obj.keyStep || 30;
            obj.wheelSpeed = obj.wheelSpeed || 1;
            // its a major change. to ensure same behaviour of normal scroll and to overcome issue in browser zoomed state changed this to false
            fn( obj, 'preventOnEnd', false );
            obj.offset = obj.offset || { x : 0, y : 0 };
            obj.tOut = obj.scrollTimeout || 500;
            obj.nested = obj.nested || false;
            obj.min = obj.min || -Infinity;
            obj.max = obj.max || Infinity;
            fn( obj, 'scrollYMarginOffset', 5 );
            fn( obj, 'scrollXMarginOffset', 5 );
            if( obj.preventXScroll ){
                obj.preventHorizontal = true; 
            }
            if( obj.preventYScroll ){
                obj.preventVertical = true;
            }
            var elements = this;

            for( var i = 0; i < elements.length; i++ ) {
                var elem =  elements[ i ], vertDiv, horiDiv, wrp = elem.parentElement;
                set( wrp, 'position', 'relative' );
                if( elem._scrollData ) {
                    $L( elem ).removeScroll()
                }
                elem.resetScrollbar = mouseenter.bind( elements[ i ] );
                wrp._scrolldiv = elem;
                elem._scrollData = obj;
                if( !obj.preventVertical ) {
                    vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerY', obj )
                    if(obj.verticalPosition == 'left'){
                        vertDiv.classList.add('left');
                    }
                }
                if( !obj.preventHorizontal ) {
                    vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerX', obj, true )
                    if(obj.horizontalPosition == 'top'){
                        vertDiv.classList.add('top');
                    }
                }
                if(isSaf.firefox ){
                        elem.scrollLeft = 0;
                        elem.scrollTop = 0;
                  } 
                elem.addEventListener( 'mouseenter', mouseenter, true )
                elem.addEventListener( 'touchstart', mouseenter, true )
                elem.addEventListener( 'touchmove', wheelEvent, { passive : false } )
                elem.addEventListener( 'mousedown', mousedown );
                elem.addEventListener( 'wheel', initialWheel, true );
                if( obj.showOn != 'always' ){
                    wrp.addEventListener( 'mouseleave', mouseleave, true )
                } else {
                    setTimeout( mouseenter.bind( elements[ i ] ), 100, {} )
                }
                elem.classList.add( 'lyteScrollBar' )
                elem._scrollFun = scroll;
            }
          return this;
        }

        lyteDomObj.prototype.destroyLyteScroll = function(){
            // console.warn( 'destroyLyteScroll deprecated. Use scroll("destroyScroll") instead' );
            return destroy.call( this );  
        }

        lyteDomObj.prototype.resetScrollbar = function(){
            // console.warn( 'resetScrollbar deprecated. Use scroll("reset") instead' );
            return reset.call( this );
        }

        function globalscroll( evt ){
            var el = evt.target.correspondingElement || evt.target;
            if( el != document && el != document.body && el._scrollFun ) {
                el._scrollFun.call( el, evt );
            }
            if( evt._byFunc ) {
                evt.preventDefault();
                evt.stopPropagation();
                evt.stopImmediatePropagation();
            }
        }
        window.addEventListener('scroll', globalscroll, true ); 
    }
} )( window );
;(function(){
    if( lyteDomObj ){

      function getScope( elem, scope ){
          var data = elem._searchPluginData;
          scope = data.dynamicScope ? data.dynamicScope( elem ) : scope;
          if( data.checkFromParent ){
            scope = elem.parentNode;
          }
          return scope;
      }

       function keyUpBind( event ){
           if([37,13,38,39,40,91,27,16,18].indexOf(event.keyCode) > -1){ 
             return
           }
           var element = this;
           var data = element._searchPluginData;
           clearTimeout(this.timeout); 
           clearTimeout( this._iptime );
           this.timeout = setTimeout( pressFunc.bind( this ), 100, event );
        }

        function inputBind( event ){
           clearTimeout( this._iptime );
           this._iptime = setTimeout( pressFunc.bind( this ), 250, event );
        }

        function pressFunc( event ){
            var element = this;
            event = event || {};
            var data = this._searchPluginData,
            ret = findingList.call(this,event),
            searchList = ret[0],
            targetList = ret[1],
            searchComp = ret[2],
            related = ret[ 3 ],
            casesen  = data.caseSensitive,
            minLength = data.minLength ? data.minLength : 0,
            method = data.method ? data.method : 'contains',
            keyCode = event.keyCode || event.which,
            val = fNcase( casesen, element.tagName == 'LYTE-INPUT' ? element.querySelector( 'input,textarea' ).value : element.value, data.trim ),
            visibleList = [], flag, comp = data.component, hiddenList = [];

            if( data.diacritic ){
               val = _lyteUiUtils.convert_diacritics( val );
            }

            if(val.length >= minLength || keyCode == 8 || keyCode == 46 )
              { 
                if(val.length)
                    {
                      for( var i = 0; i < searchList.length; i++ ) { 
                          var str = fNcase( casesen, searchList[i].trim() );
                          if( switchfun( method, val, str ) ) {
                              visibleList.push( searchComp[i] );
                          } else {
                             hiddenList.push( searchComp[ i ] );
                          }   
                      }
                    }
                 else
                    {
                      visibleList = Array.apply( Array, searchComp );
                    }   
                if( data.onSearch && data.onSearch( visibleList, event , val ) == false ){
                  return;
                }
                 for(var i = 0; i < searchList.length; i++)
                     {  
                         var str = fNcase( casesen, searchList[i].trim() ), val = val;
                         additionalHand.call( this, targetList[i], switchfun( method, val, str ) , val )   
                     } 
                if( !/tree|accordion/.test( comp ) ) {
                    for( var i = 0; i < related.length; i++ ) {
                        if( related[ i ].querySelectorAll( data.target || data.search ).length == related[ i ].querySelectorAll( '.lyteSearchHidden' ).length ) {
                            related[ i ].classList.add( 'lyteSearchHidden' );
                        } else {
                            related[ i ].classList.remove( 'lyteSearchHidden' );
                        }
                     }
                } else if( comp == 'accordion' ){
                    $L.fastdom.measure( accfilter.bind( this, visibleList, hiddenList, val ) )
                } else if( comp == "tree" ){
                   $L.fastdom.measure( treefilter.bind( this, visibleList, hiddenList, val ) )
                }
            }                 
        }

        function arrayFrom( nodeList ){
            var arrayList = [];
            for(var i = 0; i < nodeList.length; i++)
              {
                arrayList.push(nodeList[i]);
              }
            return arrayList.slice(); 
        }

        function fNcase( bool, value, trim ){
           if( !bool ){
              value = value.toLowerCase();
           }
           if( trim ){
              value = value.trim();
           }
           return value;
        }

        function switchfun( method, val, str ){
          var check;
          switch( method )
            {
              case 'contains' : {
                  check = str.indexOf( val ) >= 0
                  break;    
               }
               case 'startsWith' : {
                    check = str.indexOf( val ) == 0; 
                    break;
               }
               case 'endsWith' : {
                    var ind = str.lastIndexOf( val );
                    if( ind != -1 ){
                      check = ( ind  + val.length ) == str.length;
                    }
                    break;
               }
            }
            return check;
        }

        function hiderecurse( elem ){
           for( var i = elem.length - 1; i >= 0; i-- ) {
              var icon = elem.eq( i );
               if( icon.hasClass( 'lyteIconOpened' ) ){
                  setTimeout( icon.click.bind( icon ) , 20 );
              }
           }
        }

        function searchListFind( nodeName ){
              var searchList = [];
              var target = [];
              for(var i = 0; i < nodeName.childElementCount; i++)
                {
                  while(nodeName.children[i].childElementCount)
                     {
                        returnedVal = searchListFind(nodeName.children[i]);
                        searchList = searchList.concat(returnedVal[0]);
                        target = target.concat(returnedVal[1]);
                        break;
                     }
                  if(!nodeName.children[i].childElementCount) 
                      {
                        searchList.push(nodeName.children[i].textContent);
                        target.push(nodeName.children[i]);
                      }
                }
              return [searchList,target];
         };

      function findingList(){
            var data = this._searchPluginData;
            var scope = getScope( this, typeof data.scope == 'string' ? document.querySelector(data.scope) : data.scope );
            var searchList = [], targetList = [], searchComp = [], related = [];
            if(data.search)   
                {
                    searchComp = scope.querySelectorAll( data.search.trim() )
                    var target = data.target ? data.target : data.search;
                    for(var j = 0; j < searchComp.length; j++){
                        var valueToPush = searchComp[ j ].textContent;
                        if( data.diacritic ){
                          valueToPush = _lyteUiUtils.convert_diacritics( valueToPush );
                        }
                        searchList.push( valueToPush );
                    }
                    targetList = scope.querySelectorAll( target )
                }
            else
                {
                    var callSearchList = searchListFind(scope)
                    searchList = callSearchList[0];
                    targetList = callSearchList[1];
                    searchComp = targetList.slice();
                } 
              if( data.related && ( data.target || data.scope  ) ) {
                  related = scope.querySelectorAll( data.related );
              }
              return [searchList, targetList, searchComp, related];  
      };

      function accfilter ( vis, hid, value ){
            var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];
            for( var i = 0; i < vis.length; i++ ){
              var close1 = $L( vis[ i ] ).closest( 'lyte-accordion-item', scope )
              for( var j = 0; j < hid.length; j++ ){
                 var close2 = $L( hid[ j ] ).closest( 'lyte-accordion-item', scope )
                 if( close1[ 0 ] == close2[ 0 ] ){
                    Lyte.arrayUtils( hid, 'removeAt', j );
                    j--; continue;
                 }
              }
              if( vis[ i + 1 ] ) {
                 var close2 = $L( vis[ i + 1 ] ).closest( 'lyte-accordion-item', scope );
                 if( close1[ 0 ] == close2[ 0 ] ){
                    Lyte.arrayUtils( vis, 'removeAt', i + 1 );
                    i--;
                 }
              }
            }
            // scope[ 0 ].component.getAllHeights();
            $L.fastdom.mutate( function(){
                for( var i = scope.ltProp( 'exclusive' ) ? ( vis.length - 1 ) : 0; i < vis.length; i++ ){
                   var isclose = false, close = $L( vis[ i ] ).closest( 'lyte-accordion-item' );
                   isclose = !close.hasClass( 'lyteAccordionActive' );
                   if( !value ){
                       isclose = !isclose
                   }
                   if( isclose ){
                      close.click();
                   }
                }

                for( var j = 0; j < hid.length; j++ ){
                    var close = $L( hid[ j ] ).closest( 'lyte-accordion-item' )
                    close.hasClass( 'lyteAccordionActive' ) && close.click();
                }
            })
        }

      function treeinremove ( arr ){
          for( var i = 0; i < arr.length; i++ ){
              if( arr[ i + 1 ] ){
                 var cur = $L( arr[ i ] ).closest( '.lyteTreeBodyDiv' )[ 0 ], next = $L( arr[ i + 1 ] ).closest( '.lyteTreeBodyDiv' )[ 0 ];
                 if( cur.contains( next ) ){
                    Lyte.arrayUtils( arr, 'removeAt', i + 1 );
                 } else if(next.contains( cur ) ){
                    Lyte.arrayUtils( arr, 'removeAt', i );
                    i--;
                 }
              }
          }
      }

      function treefilter( vis, hid, value, clear ){
         var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];
         for( var i = 0; i < vis.length; i++ ){
           var cur = $L( vis[ i ] ).closest( '.lyteTreeBodyDiv' );
           for( j = 0; j < hid.length; j++ ){
             var hide = $L( hid[ j ] ).closest( '.lyteTreeBodyDiv' ),
             flg = cur[ 0 ].contains( hide[ 0 ] ) || hide[ 0 ].contains( cur[ 0 ] );
             if( flg ){
                hide.addClass( 'lyteSearchHidden' );
                Lyte.arrayUtils( hid, 'removeAt', j );
                j--;
             }
           }
         }
        for( var i = 0; i < vis.length; i++ ){
          removeClse( vis[ i ], scope )
          value.length && scope.ltProp( 'stateAttr', $L( vis[ i ] ).closest( 'lyte-tree-body' ).attr( 'data-value' ) )
        }
        if( value.length ) {
          for( var i = 0; i < hid.length; i++ ){
            $L( hid[ i ] ).closest( '.lyteTreeBodyDiv' ).addClass( 'lyteSearchHidden' )
          }
        } else {
           hiderecurse( $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope ), clear );
        }
      }

      function removeClse( target, scope ){
            var el = $L( target ).closest( '.lyteSearchHidden', scope );
            if( el.length ){
               el.removeClass( 'lyteSearchHidden' );
               removeClse( target, scope );
            }
        }

      function additionalHand( target, check, val ){
          var query = this._searchPluginData, comp = query.component;
          if( check ){
              if( comp == 'dropdown' ){
                var clo = $L( target ).closest( 'lyte-drop-box' )[ 0 ] 
                if( clo ) {
                   clo.classList.contains( 'lyteDropdownHidden' ) && ( clo.origindd ? clo.origindd.toggle() : $L( clo ).closest( 'lyte-dropdown' ).get( 0 ).toggle() )
                }
              } 
             target.classList.remove( 'lyteSearchHidden' );
          } else if( comp != "tree" ) {
            if( target.classList.contains( 'lyteSearchHidden' ) ){
                return;
            }
            target.classList.add( 'lyteSearchHidden' );
          }
      }

        lyteDomObj.prototype.search = function( data ){
            data = data ? data : {};
            if(!data.scope)
                {
                    console.error('scope is not given');
                    return;
                }
            // var scope = typeof data.scope == 'string' ? document.body.querySelector( data.scope.trim() ) : data.scope;    
            var element = this[ 0 ]
            var searchList = [], targetList = [], searchComp = [];
            element._searchPluginData = data;
            if( data.component == "accordion" ){
               data.related = "lyte-accordion-item";
            } else if( data.component == "tree" ){
               data.related = ".lyteTreeBodyDiv lyte-yield:not(.noChildClass) lyte-tree-icon";
            }

            element.setValueForSearch = element.setValue = function(value){
                var element = this
                value = value != undefined ? value : '';
                element.tagName == 'LYTE-INPUT' ? element.ltProp({'value' : value}) : element.value = value;
                var evt = new Event('keyup');
                evt.which = evt.keyCode = 8;
                element.dispatchEvent(evt);
            }

        element.addEventListener('keyup', keyUpBind ); 

        element.addEventListener( 'input', inputBind);
        element.reset = pressFunc.bind( element );                  
        return this;
      }

      $L.prototype.removeSearch = function(){
          var removeElements = this;

          for( var i = 0; i < removeElements.length; i++ ){
              var current = removeElements[ i ],
              scope, search, related;
              if( !current._searchPluginData ){
                 continue;
              }

              delete current.reset; 
              scope = current._searchPluginData.scope;
              search = current._searchPluginData.target || current._searchPluginData.search;
              related = current._searchPluginData.related;
              if( !scope ){
                continue;
              }
              scope = $L( getScope( current, scope ) );
              scope.find( search ).removeClass( 'lyteSearchHidden' );
              related && scope.find( related ).removeClass( 'lyteSearchHidden' );
              delete current._searchPluginData;
              delete current.setValueForSearch; delete current.setValue;

              current.removeEventListener( 'input', inputBind );
              current.removeEventListener( 'keyup', keyUpBind );
          }
          return this;
      }

    }
})();

/**
 * Keyboards Supported
 * 1. US keyboard
 */
 /**
 Issues
 block it for mobiles
 ctrl+functional keys test it
 */
/**
 * Intializes the shortcut library
 * @param {object} window - window object
 * @param {document} document - document object
 */
;(function(window,document){

	// Private Variables

	var _registeredKeys = {};
	var _timeoutID;
	var _currentPressed = []
	var _allPressed = []
	var _allPressedWithModifier = []
	var _currentPointer = {}
	var _funcId
	var _clickId
	var _specialKeys = {
		8 : 'backspace',
        9 : 'tab',
        13 : 'enter',
        16 : 'shift',
        17 : 'ctrl',
        18 : 'alt',
        20 : 'capslock',
        27 : 'esc',
		32 : 'space',
		33 : 'pageup',
		34 : 'pagedown',
		35 : 'end',
		36 : 'home',
		37 : 'left',
        38 : 'up',
        39 : 'right',
        40 : 'down',
        45 : 'insert',
		46 : 'delete',
		91 : 'meta',
		92 : 'meta', // windows key
		93 : 'meta',
		224 : 'meta'
	}

	var _otherSpecialKeys = {
		48 : ')',
		49 : '!',
		50 : '@',
		51 : '#',
		52 : '$',
		53 : '%',
		54 : '^',
		55 : '&',
		56 : '*',
		57 : '(',
		187 : 'plus',
		188 : '<',
		190 : '>',
		191 : '?',
		192 : '~',
		219 : '{',
		220 : '|',
		221 : '}',
		222 : '"'
	}

	/* English Languate/US Layout */
	var _conversionUS = {
		'_' : '-',
		'plus' : '=',
		'{' : '[',
		'}' : ']',
		'|' : '\\',
		':' : ';',
		'"' : '\'',
		'<' : ',',
		'>' : '.',
		'?' : '/',
		'~' : '`',
		'!' : '1',
		'@' : '2',
		'#' : '3',
		'$' : '4',
		'%' : '5',
		'^' : '6',
		'&' : '7',
		'*' : '8',
		'(' : '9',
		')' : '0'
	}

	
	// Private Methods

	/**
	 * Checks if the current key is a modifier
	 * @param {string} string - The string which contains the currently processed key
	 */

	function _checkIfModifier(string){
		string = string.toLowerCase()
		return string === "ctrl" || string === "command" || string === "alt" || string === "shift"
	}


	/**
	 * Checks if the character is a function key
	 * @param {string} character - The character that should be checked
	 */


	function _checkIfFunctionKey(character){
		for(var i = 1;i <= 12;i++){
			if(character.toLowerCase() === ('f' + i)){
				return true
			}
		}
		return false
	}


	/**
	 * Checks if the key is one of the modified keys by comparing it with the globally defined map
	 * @param {string} key - The key that should be checked for
	 */


	function _checkIfModifiedKey(key){
		if(_conversionUS[key]){
			return true
		}
		return false
	}

	/**
	 * Split keys in modifiers and normal keys
	 * @param {string} keys - The keys registered to shortcut
	 */

	function _preprocess(keys){
		var array = _getProperArray(keys)
		var modifier = []
		for(var i = 0;i < array.length;i++){
			if(_checkIfModifier(array[i])){
				array[i] = array[i] === 'command'?'meta':array[i]
				if(keys.indexOf('+') != -1){
					modifier.push(array[i])
					array.splice(i,1)
					i--;
				}
			}
			else if(_checkIfFunctionKey(array[i])){
				array[i] = array[i].toLowerCase()
			}
			else if(_checkIfModifiedKey(array[i])){
				if(keys.indexOf('+') != -1){
					modifier.push('shift')
					array[i] = _conversionUS[array[i]]
				}
			}
		}
		var modifierFlag
		if(keys.indexOf('+') !== -1){
			array = array.join('+')
			modifierFlag = true
		}
		else{
			array = array.join(' ')
			modifierFlag = false
		}
		return {
			modifier : modifier,
			newKey : array,
			modifierFlag : modifierFlag
		}
	}

	/**
	 * Split keys and build an array
	 * @param {string} keys - split between spaces or plus
	 */

	function _getProperArray(keys){
		if(keys.indexOf('+') !== -1){
			return keys.split('+')
		}
		else{
			return keys.split(' ')
		}
	}

	/**
	 * Increase character pointer of all the registered keys if the match
	 * @param {string} character - currently pressed character
	 */

	function _increaseCharPointer(character){
		for(var keys in _registeredKeys){
				if(keys.indexOf('r:') !== -1){
					var exp = keys.substring(2)
					var matches = exp.match(new RegExp('^/(.*?)/([gimy]*)$'))
					var regex = new RegExp(matches[1],matches[2])
					if(regex.test(_allPressed.join(''))){
						_currentPointer[keys] = 1
						continue;
					}
					else{
						_currentPointer[keys] = 0
					}
				}
				var key = _getProperArray(keys)
				var progress
				_currentPointer[keys] = progress =  _currentPointer[keys]?_currentPointer[keys]:0
				var withoutMod = _conversionUS[key[progress]]
				if(withoutMod && character === 'shift'){

					continue
				}
				else if(_conversionUS[character] && _conversionUS[character] === key[progress]){
					var items = _registeredKeys[keys]
					var incFlag = false

					for(var i=0;i<items.length;i++){
						if(items[i].modifierFlag && items[i].modifier.indexOf('shift') !== -1){
							_currentPointer[keys]++;

							incFlag = true
							break;
						}
					}
					if(incFlag){
						continue;
					}
				}
				if(key[progress] === character){
					_currentPointer[keys]++;
				}
				else{
					_currentPointer[keys] = 0
				}
			//}
		}
	}

	

	/**
	 * Calls a the matched element which should be invoked.
	 * @param {function} func - The callback that must be invoked
	 * @param {number} wait - A wait period where a user can press a different key to invoke a different element
	 * @param {object} event - The current keydown event
	 */

	function _invokeFunction(func,wait,event,invokedKey){
		
		if(wait){
			_flushTimeout()
			_funcId = setTimeout(function(){
				var prevent
				prevent = func.call(window,event,invokedKey)
				prevent = prevent === false?prevent:true
				if(!prevent){
					event.preventDefault()
				}
				_currentPointer = {}
				_allPressed = []
				_allPressedWithModifier = []
			},wait)
		}
		else{
			_flushTimeout()
			var prevent = func.call(window,event,invokedKey)
			prevent = prevent === false?prevent:true
			if(!prevent){
				event.preventDefault()
			}
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		}
	}

	function _isVisible(element){
		var tagName = element.tagName
		var parent = element;
		switch(tagName){
			case 'BUTTON':
			case 'LYTE-ACCORDION-ITEM':
			case 'LYTE-NAV-ITEM':
				return !!( element.offsetWidth || element.offsetHeight || element.getClientRects().length );
				break;
			case 'LYTE-MENU-ITEM':
				while(parent.tagName !== 'LYTE-MENU-BODY'){
					parent = parent.parentElement
				}
				var menu = parent.parent
				var query = menu.ltProp('query')
				var all = document.querySelectorAll(query)
				for(var i=0;i<all.length;i++){
					var isVisible = !!( all[i].offsetWidth || all[i].offsetHeight || all[i].getClientRects().length );
					if(isVisible){
						return true
					}
				}
				return false

		}
	}

	/**
	 * Triggers a click event on the element that is matched
	 * @param {HTMLElement} element - The HTMLElement that should be clicked
	 * @param {number} wait - A wait period where a user can press a different key to invoke a different element
	 */


	function _invokeClick(element,wait){
		element = element.tagName === 'LYTE-BUTTON'? element.querySelector('button'):element;
		var isVisible = _isVisible(element)
		if(!isVisible){
			return ;
		}
		if(wait){
			_flushTimeout()
			_clickId = setTimeout(function(){
				element.click()
				_currentPointer = {}
				_allPressed = []
				_allPressedWithModifier = []
			},wait)
		}
		else{
			_flushTimeout()
			element.click()
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		}
	}

	/**
	 * Clears the timeout in both the invoke functions
	 */

	function _flushTimeout(){
		clearTimeout(_funcId)
		clearTimeout(_clickId)
	}

	/**
	 * Callbacks/elements that need to be invoked/clicked
	 * @param {array} matchedElements - all the keys that have matched the current sequence of characters
	 */

	function _invokeMatchedElements(matchedElements,event){
		for(var i=0;i<matchedElements.length;i++){
			var type = matchedElements[i].type
			var value = matchedElements[i].value
			var wait = matchedElements[i].wait
			var invokedKey = matchedElements[i]._invokedKey
			if(typeof value === 'function'){
				_invokeFunction(value,wait,event,invokedKey)
			}
			else{
				_invokeClick(value,wait)
			}
		}
	}

	/**
	 * get all the modifiers that are currently pressed
	 * @param {object} event - the keydown event
	 */

	function _getModifiers(event){
		var modifier = []
		if(event.altKey){
			modifier.push('alt')
		}
		if(event.ctrlKey){
			modifier.push('ctrl')
		}
		if(event.shiftKey){
			modifier.push('shift')
		}
		if(event.metaKey){
			modifier.push('meta')
		}
		return modifier
	}

	/**
	 * get all the matching elements for the current sequence
	 * @param {object} event - the keydown event
	 */

	function _getMatchedElements(event){
		var allValues = [], foundMatches = {};
		var allModifier = _getModifiers(event)
		// _invokedKey writes in the global object but it won't cause problems i guess
		for(var keys in _currentPointer){
			if(keys.indexOf('r:') !== -1 && _currentPointer[keys] > 0){
				var item = _registeredKeys[keys]
				item._invokedKey = keys
				allValues.push(item)
				continue
			}
			for(var i = 0;i < _registeredKeys[keys].length;i++){
				var item = _registeredKeys[keys][i]
				if(item.modifierFlag &&	_currentPointer[keys] ===  _getProperArray(keys).length && item.modifier.sort().join(' ') === allModifier.sort().join(' ')){
					item._invokedKey = item.modifier.sort().length !== 0? item.modifier.sort().join('+') + "+" + keys:keys
					allValues.push(item)
					foundMatches[ keys ] = true;
				}
				else if(!item.modifierFlag && _currentPointer[keys] ===  _getProperArray(keys).length && _allPressedWithModifier.length === _getProperArray(keys).length){
					item._invokedKey = keys
					allValues.push(item)
					foundMatches[ keys ] = true;
				}
			}
		}

		for( var key in foundMatches ) {
			if( foundMatches[ key ] ) {
				_currentPointer[ key ] = 0;
			}
		}

		return allValues
	}

	/**
	 * Returns character from event
	 * @param {object} event - the keydown event
	 */

	function _getKeyFromKeyCode(event){
		var code = event.which
		if(_specialKeys[code]){
			return _specialKeys[code]
		}
		else if(_otherSpecialKeys[code]){
			if(event.shiftKey){
				return _otherSpecialKeys[code]
			}
			return _conversionUS[_otherSpecialKeys[code]]
		}
		return String.fromCharCode(code).toLowerCase()
	}


	// A timeout that refreshes the current pressed keys when no more keys are pressed


	function _createGracePeriod(){
		 clearTimeout(_timeoutID)
		_timeoutID = setTimeout(function(){
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		},1000)
	}


	// Checks if the active element is a input/select/textarea

	function _checkActiveElement(){
		var activeElement = document.activeElement
		var tagName = activeElement.tagName
		var inputTypesAllowed = ['checkbox','radio','file','color','range']
		if(
			( 
				(
					tagName === 'INPUT' && inputTypesAllowed.indexOf(activeElement.type) === -1
				) 
				||
					activeElement.getAttribute('contenteditable') === "true"
				||
					tagName === 'SELECT' 
				|| 
					tagName === 'TEXTAREA'
			) 
			&& 
				!activeElement.classList.contains('lyte-shortcut')
			) {
			return true;
		}
		return false
	}

	/**
	 * The callback for the keydown event
	 * @param {object} event - the keydown event
	 */

	function _handleKeyPress(event){
		var shouldReject = _checkActiveElement();
		if(shouldReject){
			return ;
		}
		var character = _getKeyFromKeyCode(event)
		if(!_specialKeys[event.which]){
			_allPressed.push(character)
			_allPressedWithModifier.push(character)
		}
		else {
			_allPressedWithModifier.push(_specialKeys[event.which])
		}
		_increaseCharPointer(character)
		var matchedElements = _getMatchedElements(event)
		_createGracePeriod()
		if(matchedElements.length){
			_invokeMatchedElements(matchedElements,event)
		}
	}

	/**
	 * Builds the registered keys from array
	 * @param {array} keys - Array of keys
	 * @param {function} callback - Function to be invoked for the keys
	 */

	function _processObject(keys,callback,options){
		for(var i = 0;i < keys.length;i++){
			var key = keys[i]
			_processString(key,callback,options)
		}
	}

	/**
	 * Builds the registered key from the string
	 * @param {string} keys - String that represents the key
	 * @param {function} callback - Function to be invoked for the key
	 */

	function _processString(keys,callback,options){
		shortcut.push({
			newKey:keys,
			oldKey:undefined,
			value:callback,
			options:options
		})
	}

	/**
	 * strips white spaces
	 * @param {string} key - The key for which white spaces need to be removed
	 */

	function _stripSpaces(key){
		key = key.replace(/\s+/i,' ');
		return key;
	}


	/**
	 * Adds the regex expression to the registeredKeys
	 * @param {string} key - The regular expresssion
	 * @param {function/HTMLElement} callback - The function or the HTMLElement that should be invoked
	 * @param {object} options - Configuarion for this particular key
	 */


	function _pushRegex(keys,callback,options){
		keys = 'r:' + keys
		var wait = options.wait? options.wait:0
		var type = typeof callback 
		_registeredKeys[keys] = {
			type : type,
			value : callback,
			wait : wait
		}
	}
	

	/**
	 * registers function keys and solves other cross browser issues
	 */


	function _registerOtherKeys(){
		for(var i = 0;i <= 9;i++){
			_specialKeys[i + 96] = i.toString()
		}
		for(var i = 1;i <= 12;i++){
			_specialKeys[111 + i] = 'f' + i
		}
		var sniff = navigator.userAgent
		if(sniff.match('Firefox')){
			_otherSpecialKeys[59] = ':'
			_otherSpecialKeys[173] = '_'
		}
		else{
			_otherSpecialKeys[186] = ':'
			_otherSpecialKeys[189] = '_'
		}
	}

	/**
	 * Removing a single key and its functions
	 * @param {string} keys - The key to remove
	 */

	function _removeKey(keys){
		var obj = _preprocess(_stripSpaces(keys))
		var container = _registeredKeys[obj.newKey]
		if(!container){
			return ;
		}
		for(var i = 0;i < container.length;i++){
			if(obj.modifierFlag && container[i].modifier.sort().join(' ') === obj.modifier.sort().join(' ')){
				_registeredKeys[obj.newKey].splice(i,1)
				break;
			}
			else if(!obj.modifierFlag){
				_registeredKeys[obj.newKey].splice(i,1)
				break;
			}
		}
	}

	// Constructor

	/** 
	 * Shortcut constructor
	 * registers listeners
	 */


	function shortcut(target){
		_registerOtherKeys()
		target.addEventListener('keydown',_handleKeyPress)
	}


	// Public methods

	/**
	 * Exposes the push function so that the custom elements register key presses
	 */


	Object.defineProperty(shortcut,"push",{
		writable:false,
		value : function(entry){
			var oldkey = entry.oldKey
			if(oldkey){
				shortcut.unregister(oldkey)
			}
			if(!entry.newKey){
				return ;
			}
			var key = _stripSpaces(entry.newKey)  // don't know if we need this
			if(entry.type === 'regex'){
				_pushRegex(key,entry.value,options)
				return ;
			}
			var value = entry.value
			var returnedObject = _preprocess(key)
			var wait
			if(entry.options){
				wait = entry.options.wait? entry.options.wait:0
			}
			else{
				wait = 0
			}
			var type = typeof value
			if(_registeredKeys[returnedObject.newKey]){
				var pushed = true
				for(var i = 0; i < _registeredKeys.length;i++){
					if(_registeredKeys[i].modifier.sort().join(' ') === returnedObject.modifier.sort().join(' ')){
						_registeredKeys[returnedObject.newKey][i] = {
							type : type,
							value : value,
							modifier : returnedObject.modifier,
							modifierFlag : returnedObject.modifierFlag,
							wait : wait
						}
						pushed = false
						break;
					}
				}
				if(pushed){
					_registeredKeys[returnedObject.newKey].push({
						type : type,
						value : value,
						modifier : returnedObject.modifier,
						modifierFlag : returnedObject.modifierFlag,
						wait : wait
					})
				}
			}
			else{
				_registeredKeys[returnedObject.newKey] = [{
					type : type,
					value : value,
					modifier : returnedObject.modifier,
					modifierFlag : returnedObject.modifierFlag,
					wait : wait
				}]
			}
			
		}
	})


	/**
	 * Exposes the register function so that developers can register key pressess
	 */


	Object.defineProperty(shortcut,"register",{
		writable:false,
		value : function(keys,callback,options){
			if(options && options.type === 'regex'){
				_pushRegex(keys,callback,options)
			}
			var type = typeof keys 
			if(type !== 'string' && type !== 'object'){
				console.error("Invalid Type")
				return ;
			}
			if(type === 'object'){
				_processObject(keys,callback,options)
			}
			else{
				_processString(keys,callback,options)
			}
		}
	})


	/**
	 * Exposes the unregister function so that developers can unregister already registered keys
	 */


	Object.defineProperty(shortcut,"unregister",{
		writable:false,
		value : function(keys){
			if(typeof keys === 'object'){
				for(var i=0;i < keys.length;i++){
					var _key = keys[i]
					_removeKey(_key);
				}
			}
			else {
				_removeKey(keys);
			}
		}
	})

	/** 
	 * Exposes the unregisterAll function so developers can unregister all keys at once 
	 */


	 Object.defineProperty(shortcut,"unregisterAll",{
		writable:false,
		value : function(){
			for(var key in _registeredKeys){
				delete _registeredKeys[key]
			}
		}
	})



	// Intializing

	shortcut(document)
	window.shortcut = shortcut


})(window,document);
/*------------------------   NOTES   ------------------------*/
/*
  Date - 22/06/2018 - Documented
  1. Added scrollDivX property to check for horizontal scrolling.
  Date - 28/08/2018
  1. Added method to destroy sortable.
  Date - 13/09/2018
  1. Added omitRestricted - to exclude the restricted elements from list while calculating from and to index position.
  Date - 19/02/2019
  1. Providing rtl support - issue in chrome and ie not fixed
*/
/*
	Issues with relative Horizontal scroll div - Fixed
*/


;(function( window ) {

	if(lyteDomObj){			
		lyteDomObj.prototype.manageSortable = {
			keyPressed : false,
			keyValue : 0,
			countSortable : 0,
			init : false,
			prevSortable : false,
			mousedownTriggered : false,
			draggedEle : null,
			_ssData : {},
			measureQueue : [],
			mutateQueue : [],
			isEqual : function (value, other) {
				if(value.length != other.length){
					return false;
				}
				for(var i = 0 ; i < value.length ; i++){
					if(other.indexOf(value[i]) == -1){
						return false;
					}
				}
				// If nothing failed, return true
				return true;
			},

			convertToArrayOfItems : function(selector){
				if(typeof selector != "string" && selector.length > 0){
					return selector;
				}
				var selectorArray = selector.split(',');
				var retArray = [];
				selectorArray.forEach(function(item,indexVal){
					var items = $L(item.trim());
					if(items.length){
						for(var i=0;i < items.length ;i++){
							if(retArray.indexOf(items[i]) == -1 && items[i].tagName != "TEMPLATE"){
								retArray.push(items[i]);
							}
						}
					}
					else{
						if(retArray.indexOf(items) == -1 && items.tagName != "TEMPLATE"){
							retArray.push(items);
						}
					}
				});
				return retArray;
			},

			destroy : function(element){
				if(!(element.classList.contains('sortable-parent'))){
					console.info("ALERT! - U have already destroyed its sortable behaviour.");
					return;
				}
				var childrens = Array.from(element.children).filter(function(node) { return node.tagName != 'TEMPLATE'});
				var sortableElemClass = element.getSortableClass();
				for(var i = 0; i<childrens.length; i++){
					childrens[i].classList.remove('sortable-element',sortableElemClass);
					if(childrens[i]._sortableChildData){
						childrens[i]._sortableChildData = null;
					}
				}
				if(element._mousedown){
					element.removeEventListener('mousedown',element.__mouseDownEvent);
					element.removeEventListener('touchstart',element.__mouseDownEvent, true);
					element._mousedown = false;
				}
				element.classList.remove('sortable-parent');
				// element._sortableParentData = null;
				if(element._sortableParentData.multiSortable) {
					element._sortableParentData.allSortableClass = null;
				}
				delete element._sortableParentData;
				delete element.getSortableClass;
			},

			cancel : function(element){
				if(!(element.classList.contains('sortable-parent'))){
					console.info("ALERT! - The element is not a sortable parent.");
					return;
				}
				var childrens = this.getChildElements(element) /*element.children*/;
				for(var i = childrens.length-1; i >= 0 ; i--){
					if(childrens[i]._pos != i){
						var elem = undefined;
						for(var j = i; j >= 0; j--){
							if(childrens[j]._pos == i){
								elem = childrens[j];
								break;
							}
						}
						if(elem){
							if(i == childrens.length-1){
								_lyteUiUtils.appendChild(element,elem);
							}
							else{
								_lyteUiUtils.insertBefore(childrens[i+1],elem);
							}
						}
						childrens = this.getChildElements(element);
					}
				}
			},

			getChildElements : function(parent){
				return Array.from(parent.children).filter(function(ele){ return ele.tagName != "TEMPLATE" });
			},

			disable : function(elements){
				for(var i = 0; i < elements.length; i++){
					var sortableElem = elements[i];
					if(!(sortableElem.classList.contains('sortable-element'))){
						console.info(sortableElem, " cannot be disabled as it is not a sortable element.");
					}
					else{
						var disabledData = {
												class : 'sortable-element',
												data : Object.assign({}, sortableElem._sortableChildData)
											};
						sortableElem.classList.add('sort-disabled-element');
						sortableElem.classList.remove('sortable-element', sortableElem._sortableChildData.sortableElemClass);
						sortableElem._disabledData = disabledData;
						sortableElem._sortableChildData = null;
					}
				}
			},

			enable : function(elements){
				for(var i = 0; i < elements.length; i++){
					var sortableElem = elements[i];
					if(!(sortableElem._disabledData || sortableElem.classList.contains('sort-disabled-element'))){
						console.info(sortableElem, " cannot be enabled as it is not a disabled sortable element.");
					}
					else{
						sortableElem._sortableChildData = Object.assign({}, sortableElem._disabledData.data);
						sortableElem.classList.remove('sort-disabled-element');
						sortableElem.classList.add('sortable-element', sortableElem._sortableChildData.sortableElemClass);
						delete sortableElem._disabledData;
					}
				}
			},

			alreadySortable : function(elements){
				for(var i = 0; i<elements.length; i++){
					if($L(elements[i]).hasClass('sortable-parent') && elements[i]._sortableParentData){
						return {found : true, class : elements[i]._sortableParentData.sortableElemClass}
					}
				}
				return {found : undefined};
			},

			isOver : function(event, data, fromDraggable){
				var manageSortable = lyteDomObj.prototype.manageSortable;
				if(fromDraggable){
					var prevOffset = manageSortable.prevSortable ? manageSortable.prevSortable.getBoundingClientRect() : null;
					if(prevOffset && (event.clientX < prevOffset.left || event.clientX > prevOffset.right || event.clientY < prevOffset.top || event.clientY > prevOffset.bottom)){
						if(manageSortable.prevSortable && manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onLeave){
							manageSortable.prevSortable._sortableParentData.onLeave(event,{element : data._element, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
						}
						manageSortable.prevSortable = false;
					}
					else{
						var sortables = document.querySelectorAll(data.connectToSortable+".sortable-parent");
						if(sortables.length){
							for(var i = sortables.length-1; i >= 0; i--){
								var sortableOffset = sortables[i]._bcr || sortables[i].getBoundingClientRect();
								if(sortables[i]._sortableParentData.droppable && (event.clientX >= sortableOffset.left) && (event.clientX <= sortableOffset.right) && (event.clientY >= sortableOffset.top) && (event.clientY <= sortableOffset.bottom)){
									// return sortables[i];
									if(!manageSortable.prevSortable || (manageSortable.prevSortable && manageSortable.prevSortable != sortables[i])){
										manageSortable.prevSortable = sortables[i];
										if(manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onEnter){
											manageSortable.prevSortable._sortableParentData.onEnter(event,{element : data._element, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
										}
									}
									break;
								}
							}
						}
					}
				}
				else{
					var prevOffset = manageSortable.prevSortable ? ( manageSortable.prevSortable._bcr || manageSortable.prevSortable.getBoundingClientRect() ) : null;
					if(prevOffset && (event.clientX < prevOffset.left || event.clientX > prevOffset.right || event.clientY < prevOffset.top || event.clientY > prevOffset.bottom)){
						// manageSortable.prevSortable.classList.remove('disableHover');
						if(manageSortable.prevSortable && manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onLeave){
							manageSortable.prevSortable._sortableParentData.onLeave(event,{element : data._div, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
						}
						manageSortable.prevSortable = false;
					}
					else{
						var sortables = data.connectedWith.length ? data.connectedWith : [data._parentElem];
						if(sortables.length){
							for(var i = sortables.length-1; i >= 0; i--){
								var sortableOffset = sortables[i]._bcr || sortables[i].getBoundingClientRect();
								if(sortables[i]._sortableParentData.droppable && (event.clientX >= sortableOffset.left) && (event.clientX <= sortableOffset.right) && (event.clientY >= sortableOffset.top) && (event.clientY <= sortableOffset.bottom)){
									// return sortables[i];
									if(!manageSortable.prevSortable || (manageSortable.prevSortable && manageSortable.prevSortable != sortables[i])){
										manageSortable.prevSortable = sortables[i];
										// manageSortable.prevSortable.classList.add('disableHover');
										if(manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onEnter){
											manageSortable.prevSortable._sortableParentData.onEnter(event,{element : data._div, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
										}
									}
									break;
								}
							}
						}
					}
				}
			},

			getSortableClasses : function(elements, previousObject) {
				var object = previousObject || {};
				elements.forEach(function(element){
					if( element && element._sortableParentData){
						var classNameForSortable = element._sortableParentData.sortableElemClass;
						if(!object.hasOwnProperty(classNameForSortable)) {
							object[classNameForSortable] = element;
						}
					}
				});
				return object;
			},

			enableDroppable : function(element) {
				if($L(element).hasClass('sortable-parent')) {
					element[0]._sortableParentData.droppable = true;
				}
			},

			disableDroppable : function(element) {
				if($L(element).hasClass('sortable-parent')) {
					element[0]._sortableParentData.droppable = false;
				}
			}
		};
		
		lyteDomObj.prototype.sortable = function(object) {
			var manageSortable = lyteDomObj.prototype.manageSortable;
			if(!manageSortable.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				if (!Array.from) {
				  Array.from = (function () {
				    var toStr = Object.prototype.toString;
				    var isCallable = function (fn) {
				      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
				    };
				    var toInteger = function (value) {
				      var number = Number(value);
				      if (isNaN(number)) { return 0; }
				      if (number === 0 || !isFinite(number)) { return number; }
				      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
				    };
				    var maxSafeInteger = Math.pow(2, 53) - 1;
				    var toLength = function (value) {
				      var len = toInteger(value);
				      return Math.min(Math.max(len, 0), maxSafeInteger);
				    };

				    // The length property of the from method is 1.
				    return function from(arrayLike/*, mapFn, thisArg */) {
				      // 1. Let C be the this value.
				      var C = this;

				      // 2. Let items be ToObject(arrayLike).
				      var items = Object(arrayLike);

				      // 3. ReturnIfAbrupt(items).
				      if (arrayLike == null) {
				        throw new TypeError('Array.from requires an array-like object - not null or undefined');
				      }

				      // 4. If mapfn is undefined, then let mapping be false.
				      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
				      var T;
				      if (typeof mapFn !== 'undefined') {
				        // 5. else
				        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
				        if (!isCallable(mapFn)) {
				          throw new TypeError('Array.from: when provided, the second argument must be a function');
				        }

				        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
				        if (arguments.length > 2) {
				          T = arguments[2];
				        }
				      }

				      // 10. Let lenValue be Get(items, "length").
				      // 11. Let len be ToLength(lenValue).
				      var len = toLength(items.length);

				      // 13. If IsConstructor(C) is true, then
				      // 13. a. Let A be the result of calling the [[Construct]] internal method 
				      // of C with an argument list containing the single item len.
				      // 14. a. Else, Let A be ArrayCreate(len).
				      var A = isCallable(C) ? Object(new C(len)) : new Array(len);

				      // 16. Let k be 0.
				      var k = 0;
				      // 17. Repeat, while k < len… (also steps a - h)
				      var kValue;
				      while (k < len) {
				        kValue = items[k];
				        if (mapFn) {
				          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
				        } else {
				          A[k] = kValue;
				        }
				        k += 1;
				      }
				      // 18. Let putStatus be Put(A, "length", len, true).
				      A.length = len;
				      // 20. Return A.
				      return A;
				    };
				  }());
				}
				manageSortable.init = true;
			}
			
			if(typeof object === "string"){
				if(object === "destroy"){
					if(this.length > 1){
						var elemArray = this;
						for(var i = 0; i<elemArray.length; i++){
							manageSortable.destroy(elemArray[i]);
						}
					}
					else{
						manageSortable.destroy(this[0]);
					}
				}
				else if(object === "cancel"){
					if(this.length > 1){
						var elemArray = this;
						for(var i = 0; i<elemArray.length; i++){
							manageSortable.cancel(elemArray[i]);
						}
					}
					else{
						manageSortable.cancel(this[0]);
					}
				}
				else if(object === "disable"){
					manageSortable.disable(this);
				}
				else if(object === "enable"){
					manageSortable.enable(this);
				}
				else if(object === "disableDroppable"){
					manageSortable.disableDroppable(this);
				}
				else if(object === "enableDroppable"){
					manageSortable.enableDroppable(this);
				}
				return;
			}
			var data = object ? object : {};

			/* -------- BROWSER RELATED CHECKS -------- */
			var detectBrowser = function(){
				//Check if browser is IE11
			    if (navigator.userAgent.search("rv:11") >= 0) {
			        return "ie";
			    }
			    //Check if browser is Edge
			    if (navigator.userAgent.search("Edge") >= 0) {
			        return "edge";
			    }
			    //Check if browser is Chrome || Opera
			    else if (navigator.userAgent.search("Chrome") >= 0) {
			        return "chrome";
			    }
			    //Check if browser is Firefox 
			    else if (navigator.userAgent.search("Firefox") >= 0) {
			        return "firefox";
			    }
			    //Check if browser is Safari
			    else if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
			        return "safari";
			    }
			};

			var getOS = function() {
				var userAgent = window.navigator.userAgent,
				    platform = window.navigator.platform,
				    macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
				    windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],
				    iosPlatforms = ['iPhone', 'iPad', 'iPod'],
				    os = null;

				if (macosPlatforms.indexOf(platform) !== -1) {
				    os = 'Mac OS';
				} else if (iosPlatforms.indexOf(platform) !== -1) {
				    os = 'iOS';
				} else if (windowsPlatforms.indexOf(platform) !== -1) {
				    os = 'Windows';
				} else if (/Android/.test(userAgent)) {
				    os = 'Android';
				} else if (!os && /Linux/.test(platform)) {
				    os = 'Linux';
				}

				return os;
			};

			var isMobileOrTabletCheck = function() {
				var check = false;
				(function(a){
					if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) ||
						/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) {
						check = true;
					}
				})(navigator.userAgent||navigator.vendor||window.opera);
				return check;
			};
			
			if(this.length > 1){
				var elemArray = this;
				if(!data.changed){
					++manageSortable.countSortable;
					data.changed = true;
				}
				var check = manageSortable.alreadySortable(this);
				if(check.found){
					data.sortableElemClass = check.class;
				}
				for(var i = 0 ; i < elemArray.length ; i++){
					$L(elemArray[i]).sortable(Object.assign({},data));
				};
				return;
			}

			var element = this.length == undefined ? this : this[0];

			if(element._sortableParentData){
				var _sortableData = element._sortableParentData;
				data._parentElem = data._parentElem == undefined ? _sortableData._parentElem : data._parentElem;

				//Data overriding
				data.containment = data.containment ? data.containment : _sortableData.containment;
				data.connected = data.connectedWith ? manageSortable.isEqual(data.connectedWith, _sortableData.connectedWith) : _sortableData.connected;
				data.connectedWith = data.connectedWith ? data.connectedWith : _sortableData.connectedWith;
				data.orientation = data.orientation ? data.orientation : _sortableData.orientation;
				data.droppable = (data.droppable == undefined) ? _sortableData.droppable : data.droppable;
				data.draggable = (data.draggable == undefined) ? _sortableData.draggable : data.draggable;
				data.sortableElemClass = _sortableData.sortableElemClass;	
				data.placeholder = data.placeholder ? data.placeholder : _sortableData.placeholder;
				data.disabled = data.disabled ? data.disabled : _sortableData.disabled;
				data.onReady = data.onReady ? data.onReady : _sortableData.onReady;
				data.onSelect = data.onSelect ? data.onSelect : _sortableData.onSelect;
				data.onDragStart = data.onDragStart ? data.onDragStart : _sortableData.onDragStart;
				data.onDrag = data.onDrag ? data.onDrag : _sortableData.onDrag;
				data.onPlaceholder = data.onPlaceholder ? data.onPlaceholder : _sortableData.onPlaceholder;
				data.onBeforeDrop = data.onBeforeDrop ? data.onBeforeDrop : _sortableData.onBeforeDrop;
				data.onDrop = data.onDrop ? data.onDrop : _sortableData.onDrop;
				data.cancel = data.cancel == undefined ? _sortableData.cancel : data.cancel instanceof Array ? data.cancel : data.cancel.split(",") ;
				data.tolerance = data.tolerance ? data.tolerance : _sortableData.tolerance;
				data.items = data.items == undefined ? _sortableData.items : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt == undefined ? _sortableData.cursorAt : data.cursorAt;
				data.restrict = data.restrict == undefined ? _sortableData.restrict : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX == undefined ? _sortableData.scrollDivX : typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX;
				data.scrollDivY = data.scrollDivY == undefined ? _sortableData.scrollDivY : typeof data.scrollDivY === "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY;
				data.omitRestricted = data.omitRestricted == undefined ? _sortableData.omitRestricted : data.omitRestricted;
				data.onEnter = data.onEnter ? data.onEnter : _sortableData.onEnter;
				data.onLeave = data.onLeave ? data.onLeave : _sortableData.onLeave;
				data.clone = data.clone ? data.clone : _sortableData.clone;
				data.preventDefault = data.preventDefault ? data.preventDefault : _sortableData.preventDefault;
				data.appendTo = data.appendTo ? (data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent") : _sortableData.appendTo;
				data.helper = data.helper ? data.helper : _sortableData.helper;
				data.preventDropAtEnd = data.preventDropAtEnd == undefined ? _sortableData.preventDropAtEnd : data.preventDropAtEnd;
				data.preventDropAtStart = data.preventDropAtStart == undefined ? _sortableData.preventDropAtStart : data.preventDropAtStart;
				data.onMultiSelectDrag = data.onMultiSelectDrag ? data.onMultiSelectDrag : _sortableData.onMultiSelectDrag;
				data.gridView = data.gridView ? data.gridView : _sortableData.gridView;
				data.multiSortable = data.multiSortable ? data.multiSortable : _sortableData.multiSortable;
				if(data.multiSortable && data.connectedWith) {
					data.allSortableClass = _sortableData.allSortableClass ? _sortableData.allSortableClass : manageSortable.getSortableClasses(data.connectedWith, _sortableData.allSortableClass);
				}
				if(!($L(element).hasClass('sortable-parent'))){
					$L(element).addClass('sortable-parent','lyteSortableParent')
				}
				if(data.executeOnReady){
					data._parentElem.executedOnReady = false;
				}
			}
			else{

				if(!data.connected && !data.changed){
					// console.log(data,++manageSortable.countSortable);
					++manageSortable.countSortable;
					data.changed = true;
				}
				//Parent Element
				data._parentElem = element;
				$L(data._parentElem).addClass('sortable-parent','lyteSortableParent');

				//Data initialization
				data.containment = data.containment;
				data.connectedWith = data.connectedWith ? data.connectedWith : [];
				data.orientation = data.orientation ? data.orientation : "default";
				data.droppable = (data.droppable == undefined) ? true : data.droppable;
				data.draggable = (data.draggable == undefined) ? true : data.draggable;
				data.sortableElemClass = data.sortableElemClass ? data.sortableElemClass : element.parentElement && element.parentElement._sortableParentData ? element.parentElement._sortableParentData.sortableElemClass : (data.orientation === "horizontal") ? "sortable-element-h"+manageSortable.countSortable : (data.orientation === "vertical") ? "sortable-element-v"+manageSortable.countSortable : "sortable-element-d"+manageSortable.countSortable;
				data.placeholder = data.placeholder ? data.placeholder : "lyteSortablePlaceholder";
				data.disabled = data.disabled ? data.disabled : "lyteSortableDisabledPlaceholder";
				data.cancel = data.cancel == undefined ? [] : data.cancel instanceof Array ? data.cancel : data.cancel.split(",");
				data.tolerance = data.tolerance ? data.tolerance : "intersect";
				data.items = data.items == undefined ? [] : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt;
				data.restrict = data.restrict == undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX ? ( typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX) : undefined;
				data.scrollDivY = data.scrollDivY ? ( typeof data.scrollDivY === "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY) : undefined;
				data.omitRestricted = data.omitRestricted == undefined ? false : data.omitRestricted;
				data.clone = data.clone ? true : false;
				data.preventDefault = data.preventDefault == undefined ? { "mousedown" : isMobileOrTabletCheck() ? false : true, "mousemove" : true } : data.preventDefault;
				data.appendTo = data.appendTo && data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent";
				data.preventDropAtEnd = data.preventDropAtEnd == undefined ? true : data.preventDropAtEnd;
				data.preventDropAtStart = data.preventDropAtStart == undefined ? true : data.preventDropAtStart;
				data.gridView = data.gridView ? true : false;
			}


			var _offset = [0,0];
			var _isDown = false;
			var _isMoved = false;
			var _mousePosition;
			var _elemBelow;
			var _droppablePlace;
			var _marginTop = 0;
			var _marginLeft = 0;
			var _sortableElemClass;
			var _sortableElem;
			var _placeholder = "";
			var _div = "";
			var _scrollLeft = 0;
			var _scrollTop = 0;
			var _requestId1 = null;
			var _requestId2 = null;
			var _animationFrameFired1 = false;
			var _animationFrameFired2 = false;
			var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
			var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
			var _maxScrollWidth = 0;
			var _maxScrollHeight = 0;
			var _prevMode = null;
			var prevTop = null;
			var _prevScrollDiv = null;
			var _prevData = null;

			function mouseDownEvent(event){
				
		
				//Disable right click on the sortable elements to avoid unwanted behaviour
				if(event.which == 3){
					return;
				}

				if(manageSortable.mousedownTriggered){
					manageSortable.mousedownTriggered = false;
					return;
				}
				
				var target = event.target;

				while(target){
					if($L(target).hasClass("sortable-element")){
						_sortableElem = target;
						break;
					}
					target = target.parentElement;
				}

				if(!target){
					_sortableElem = null;
					manageSortable.draggedEle = null;
				}

				if(_sortableElem && checkForSortable(_sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData, event.target) && checkForItems(_sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData, event.target)){
					manageSortable.draggedEle = _sortableElem;
					var data = _sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData;
					if(data.preventDefault.mousedown == undefined || data.preventDefault.mousedown){
						event.preventDefault();
					}
					if(_sortableElem.parentElement && !_sortableElem.classList.contains(_sortableElem.parentElement._sortableParentData.sortableElemClass)){
						_sortableElem.classList.add(_sortableElem.parentElement._sortableParentData.sortableElemClass)
					}
					if(typeof data.helper == "function"){
						var helper = data.helper(_sortableElem);
						if(helper){
							helper._isHelper = true;
							helper.classList.add('sortable-helper');
							helper._sortableChildData = Object.assign({},_sortableElem._sortableChildData);
							helper.classList.add(_sortableElem.parentElement._sortableParentData.sortableElemClass);
							helper._origin = _sortableElem;
							manageSortable.draggedEle = helper;
							if(data.appendTo == "parent"){
								_lyteUiUtils.appendChild(_sortableElem.parentElement, helper);
							}
							else{
								_lyteUiUtils.appendChild($L(data.appendTo)[0], helper);
							}
							data = helper._sortableChildData;
							helper.style.visibility = "hidden";
						}
					}

					_placeholder = getClone(manageSortable.draggedEle, data.clone); //_sortableElem.cloneNode()
					data._div = _div = manageSortable.draggedEle/*_sortableElem*/;
					var returnVal = true;
					data._source = getSource(data);
					data._fromIndex = getFromIndex(data);
					
					//Callback fired
					if(data.onSelect){
						returnVal = onSelect(data,event);
					}
					if(returnVal){
						
						_div.classList.add("sortable-element-selected");
						var sortableElemCS = window.getComputedStyle(_div/*_sortableElem*/);
						var divOffset = isHelper(_div) ? _div._origin.getBoundingClientRect() : _div.getBoundingClientRect();
						if(data.scrollDivX && window.getComputedStyle(data.scrollDivX).position == "relative"){
							data._isRelative = true; 
						}
						else{
							data._isRelative = false;
						}
						
						if(sortableElemCS.marginTop){
							_marginTop = sortableElemCS.marginTop;
						}
						if(sortableElemCS.marginLeft){
							_marginLeft = sortableElemCS.marginLeft;
						}
						if(event.type == "mousedown"){
							_offset = [
								data.cursorAt && data.cursorAt.left || event.clientX - divOffset.left,
								data.cursorAt && data.cursorAt.top || event.clientY - divOffset.top
							];
						}
						else if(event.type == "touchstart"){
							_offset = [
								data.cursorAt && data.cursorAt.left || event.touches[0].clientX - divOffset.left,
								data.cursorAt && data.cursorAt.top || event.touches[0].clientY - divOffset.top
							];
							
							//Binding eventlistener for touch
							document.addEventListener('touchmove',data._parentElem.__mouseMoveEvent, {capture : true, passive : false});
							document.addEventListener('touchend',data._parentElem.__mouseUpEvent, true);
						}

						//Binding the values to the draggable element
						data._isDown = true;
						data._placeholder = _placeholder;
						data._offset = _offset;
						data._marginTop = _marginTop;
						data._marginLeft = _marginLeft;
						data._event = event;
						data._placedPlaceholder = false;

						if(!manageSortable.draggedEle/*_sortableElem*/._sortableChildData){
							manageSortable.draggedEle/*_sortableElem*/._sortableChildData = data;
						}
						_placeholder = null;
						_div = null;
						_sortableElem = null;

						//Binding mousedown and mouseup event
						if(event.type == "mousedown"){
							document.addEventListener('mousemove',mouseMoveEvent);
							document.addEventListener('mouseup',mouseUpEvent);
							manageSortable.mousedownTriggered = true;
							if(getOS() === "Windows"){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
								manageSortable.mouseMoveTriggered = true;
							}
						}
					}
					else{
						if(data.helper){
							manageSortable.draggedEle.remove();
						}
						manageSortable.draggedEle = null;
						_sortableElem = null;
					}
				}
				else{
					_sortableElem = null;
				}
			}

			var mouseMoveEvent = function(event){
				if(getOS() === "Windows" && manageSortable.mouseMoveTriggered){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
					manageSortable.mouseMoveTriggered = false;
					return;
				}
				
				if(event.type == "touchmove"){
					event.preventDefault();
				}
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}
				
				if(manageSortable.draggedEle && manageSortable.draggedEle.classList.contains("sortable-element-selected") && manageSortable.draggedEle._sortableChildData._isDown){
					_sortableElem = manageSortable.draggedEle;
				}
				else{
					_sortableElem = null;
					return;
				}
				
				if(_sortableElem){

					var data = _sortableElem._sortableChildData;
					if(data && data._isDown){
						if(data.preventDefault.mousemove == undefined || data.preventDefault.mousemove){
							event.preventDefault();
						}
						if(typeof document.body.style.MozUserSelect!="undefined"){
							document.body.style.MozUserSelect = "none";
						}
						_div = data._div;
						_placeholder = data._placeholder;
						_offset = data._offset;
						_marginTop = data._marginTop;
						_marginLeft = data._marginLeft;
						_sortableElemClass = data.sortableElemClass;
						var divOffset = _sortableElem.getBoundingClientRect(); 

						var scrollLeftValue = 0;
						

						//Find scroll div
						var scrollDiv;
						if(data.scrollDivY){
							scrollDiv = data.scrollDivY;
						}
						else{
							scrollDiv = data.orientation != "horizontal" && findScrollDiv(data._placedPlaceholder ? _placeholder : _div);
						}
						if(scrollDiv && (!_prevScrollDiv || (_prevScrollDiv && _prevScrollDiv != scrollDiv))){
							_maxScrollHeight = scrollDiv.scrollHeight - scrollDiv.offsetHeight;
							_prevScrollDiv = scrollDiv;
						}
						
						//Find scrollDiv is relative or contains any relative parent and store scrollTop
						var isRelativeY = false;
						if(scrollDiv && (window.getComputedStyle(scrollDiv).position == "relative" || window.getComputedStyle(scrollDiv).position == "fixed"/* || window.getComputedStyle(scrollDiv).position == "absolute"*/) && (!isHelper(_div) || (isHelper(_div) && scrollDiv.contains(_div)))){
							isRelativeY = true;
							_scrollTop = scrollDiv.scrollTop;
						}
						else{
							_scrollTop = 0;
						}
						if(!data._placedPlaceholder){
							//onDragStart
							if(data.onDragStart){
								onDragStart(data, event);
							}
							divOffset = isHelper(_sortableElem) ? _sortableElem._origin.getBoundingClientRect() : _sortableElem.getBoundingClientRect(); 

							//set containment properties
							if(data.containment){
								data.containmentDimensions = setContainment(data,_sortableElem);
							}
							else{
								data.containmentDimensions = null;
							}

							// console.log("getting called");
							var width = /*$L(_sortableElem).outerWidth() divOffset.width*/ divOffset.width;
							var height = /*$L(_sortableElem).outerHeight() divOffset.height*/ divOffset.height;
							var cellSpacing = 0;
							var parent = _sortableElem.offsetParent;
							if(data.scrollDivX){
								// if(detectBrowser() == "ie" || detectBrowser() == "edge"){
								// 	_maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth;
								// }
								// else{
									_maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.clientWidth;
								// }
							}
							else{
								_maxScrollWidth = 0;
							}
							data._maxScrollWidth = _maxScrollWidth;
							if(data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft;
							}
							if(!_lyteUiUtils.isNegativeScroll() && _lyteUiUtils.getRTL() && detectBrowser() == "chrome" && data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft - data._maxScrollWidth;
							}
							if(parent.tagName.toLowerCase() == "table"){
								cellSpacing = parent.cellSpacing;
								if(cellSpacing == ""){
									cellSpacing = 2;
								}
							}
							while((parent.tagName.toLowerCase() == "table" || parent.tagName.toLowerCase() == "lyte-table-structure") && parent.style.position == ""){
								parent = parent.offsetParent;
							}
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && parent != relativeParent){
								parent = relativeParent;
							}
							var parentOffset = parent.getBoundingClientRect();
							_div.style.top = divOffset.top - (parentOffset.top + parseInt(cellSpacing) + parseInt(_marginTop)) + _scrollTop + 'px';
							_div.style.left = divOffset.left - (parentOffset.left + parseInt(_marginLeft)) + scrollLeftValue + 'px';
							_div.style.boxSizing = "border-box";
							_div.style.zIndex = 3001;
							_div.style.width = width + "px";
							_div.style.height = height + "px";
							if(isHelper(_div)){
								_div.style.visibility = "";
							}
							
							if(_sortableElem.tagName.toLowerCase() == "tr" || _sortableElem.tagName.toLowerCase() == "lyte-tr"){
								fixWidth(_sortableElem);
							}
							
							//Create placeholder and append it to the DOM
							// _placeholder.innerHTML = "";
							$L(_placeholder).attr('id','dummy');
							// $L(_placeholder).removeClass('sortableElem');
							_placeholder.style.width = width + "px";
							_placeholder.style.height = height + "px";
							_div.classList.add('lyteSortableElem');
							_placeholder.style.padding = "0px";
							_placeholder.classList.add(data.placeholder);

							//Insert the placeholder in the DOM and make the selected element's position absolute
							_lyteUiUtils.insertBefore(isHelper(_div) ? _div._origin : _div ,_placeholder);
							_div.style.position = "absolute";
							_div.classList.add('lyteSortableDisablePE');
							data._placedPlaceholder = true;
							callPlaceholder(data, _div.parentElement);
							// if(window.getComputedStyle(_placeholder).display == "inline"){
							// 	_placeholder.style.display = "inherit";
							// }
							data._div = _div;
							data._placeholder = _placeholder;
							data._prevTop = event.clientY;
							data._prevLeft = event.clientX;

							if(data.onDrag){
								onDrag(data,event);
							}
							manageSortable.isOver(event,data);
							data._isMoved = true;
							return;
						}

						var measure1 = $L.fastdom.measure(function(){
							manageSortable.measureQueue.shift();
							if(!_sortableElem){
								return;
							}
							if(data.containment){
								data.containmentDimensions = setContainment(data,_sortableElem);
							}

							if(event.type == "mousemove"){
								_mousePosition = {
									x : event.clientX,
									y : event.clientY
								};
							}
							else if(event.type == "touchmove"){
								_mousePosition = {
									x : event.touches[0].clientX,
									y : event.touches[0].clientY
								};
							}
							
							var parent = _div.offsetParent;
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && parent != relativeParent){
								parent = relativeParent;
							}
							var parentOffset = parent.getBoundingClientRect();
							var leftVal;
							var topVal;
							// var scrollLeftValue = 0;
							if(data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft;
							}
							if(!_lyteUiUtils.isNegativeScroll() && _lyteUiUtils.getRTL() && detectBrowser() == "chrome" && data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft - data._maxScrollWidth;
							}
							divOffset = _div.getBoundingClientRect();
							_sortableElem.parentElement._bcr = _sortableElem.parentElement.getBoundingClientRect();
							var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : 0,
							droppableOffset,droppablePlace;
							
							//Animation Frame fired for vertical scrolling
							if(scrollDiv && (divOffset.left <= scrollDivOffset.right) && (divOffset.right >= scrollDivOffset.left)){
								_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset,_maxScrollHeight,null,isRelativeY,_mousePosition,_offset,parentOffset));
								_animationFrameFired1 = true;
							}

							//Animation Frame fired for horizontal scrolling
							if(data.scrollDivX){
								scrollDivOffset = data.scrollDivX.getBoundingClientRect();
								if(divOffset.left <= scrollDivOffset.left || divOffset.right >= (scrollDivOffset.right - 3)){
									_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,_mousePosition,_offset,parentOffset,data._isRelative));
									_animationFrameFired2 = true; 
								}
							}

							var mutate1 = $L.fastdom.mutate(function(){
								manageSortable.mutateQueue.shift();
								if(!_sortableElem){
									return;
								}
								
								leftVal = _mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue;
								topVal = _mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop;
								// console.log("left",leftVal);
								// console.log("top",topVal);
								// console.log("bottom",(data.containmentDimensions.offsetTop + (data.containmentDimensions.height - divOffset.height) + _scrollTop))
								if(data.containment){
									var limit = {
											top : data.containmentDimensions.top,
											bottom : (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height) + _scrollTop),
											left : data.containmentDimensions.left,
											right : (data.containmentDimensions.left + (data.containmentDimensions.width - divOffset.width) + scrollLeftValue)
										};
									// console.log(limit);
									if(data.orientation == "vertical"){
										if(topVal+parentOffset.top >= data.containmentDimensions.top && topVal+parentOffset.top <= (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height) + _scrollTop)){
											_div.style.top = topVal + 'px';
										}
									}
									else{
										if(leftVal+parentOffset.left >= data.containmentDimensions.left && leftVal+parentOffset.left <= (data.containmentDimensions.left + (data.containmentDimensions.width - divOffset.width) + scrollLeftValue)){
											_div.style.left = leftVal + 'px';
										}
										else{
											// console.log("leftVal ===>", leftVal);
											if(leftVal+parentOffset.left < limit.left){
												_div.style.left = (limit.left - parentOffset.left) + 'px';
											}
											else if(leftVal+parentOffset.left > limit.right){
												// debugger
												_div.style.left = (limit.right - parentOffset.left) + 'px';
											}
										}
										if(topVal+parentOffset.top >= data.containmentDimensions.top && topVal+parentOffset.top <= (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height) + _scrollTop)){
											// console.log("calculating",topVal+parentOffset.top, "=======", (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height)));
											_div.style.top = topVal + 'px';
										}
										else{
											// console.log("topVal ===>", topVal);
											if(topVal+parentOffset.top < limit.top){
												_div.style.top = (limit.top - parentOffset.top) + 'px';
											}
											else if(topVal+parentOffset.top > limit.bottom){
												// debugger
												_div.style.top = (limit.bottom - parentOffset.top) + 'px';
											}
										}
									}
								}
								else{
									if(data.orientation == "vertical"){
										_div.style.top = topVal + 'px';
									}
									else{
										_div.style.left = leftVal + 'px';
										_div.style.top = topVal + 'px';
									}
								}

								divOffset = { left : parentOffset.left + (leftVal - scrollLeftValue), top : parentOffset.top + (topVal - _scrollTop), right : parentOffset.left + (leftVal - scrollLeftValue) + divOffset.width, bottom : parentOffset.top + (topVal - _scrollTop) + divOffset.height }; /*_div.getBoundingClientRect();*/

								if(data.onMultiSelectDrag){
									onMultiSelectDrag(data, event)
								}
									
									//Find the below element over which the sortable element is being dragged
								var measure2 = $L.fastdom.measure(function(){
									manageSortable.measureQueue.shift();
									if(!_sortableElem){
										return;
									}
									_elemBelow = document.elementFromPoint(_mousePosition.x,_mousePosition.y);
									if(data.multiSortable) {
										if(_elemBelow) {
											var sortableClasses = data.allSortableClass;
											for(var key in sortableClasses) {
												droppablePlace = $L(_elemBelow).closest('.'+key,sortableClasses[key])[0];
												if(droppablePlace) {
													break;
												}
											}
										}	
										else {
											droppablePlace = null;
										}
									}
									else {
										droppablePlace = _elemBelow ? _elemBelow.closest('.'+_sortableElemClass) : null;
									}
									droppableOffset = droppablePlace ? droppablePlace.getBoundingClientRect() : {};

									if(!_elemBelow){
										return;
									}

									var mutate2 = $L.fastdom.mutate(function(){
										manageSortable.mutateQueue.shift();
										if(!_sortableElem){
											return;
										}
										if(droppablePlace && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)){

											if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem/*,isRelativeY,scrollDiv*/)){
												// $L(_elemBelow).append(_placeholder);
												_lyteUiUtils.appendChild(_elemBelow,_placeholder);
												callPlaceholder(data, _elemBelow, droppablePlace);
											}
											else{
												if(data.tolerance == "pointer"){
													if(data.orientation === "horizontal"){
														if(event.clientX < data._prevLeft){
															_lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(event.clientX > data._prevLeft){
															_lyteUiUtils.insertAfter(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														data._prevLeft = event.clientX;
													}
													else{
														if(((data.gridView && (event.clientX < data._prevLeft)) || (event.clientY < data._prevTop)) && (droppablePlace.previousElementSibling != _placeholder /*!_placeholder.nextElementSibling || (_placeholder.nextElementSibling && _placeholder.nextElementSibling != droppablePlace)*/)){	//!placeholder.nextElementSibling to check if placeholder is the last element and the draggable element's top goes above the last element's top
															// console.log("calling for droppable ele insertBefore => ",droppablePlace.textContent);
															_lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(((data.gridView && (event.clientX > data._prevLeft)) || (event.clientY > data._prevTop)) && (droppablePlace.nextElementSibling != _placeholder /*!_placeholder.previousElementSibling || (_placeholder.previousElementSibling && _placeholder.previousElementSibling != droppablePlace)*/)){
															// console.log("calling for droppable ele insertAfter => ",droppablePlace.textContent);
															_lyteUiUtils.insertAfter(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														data._prevTop = event.clientY;
													}
												}
												if(data.tolerance == "intersect"){
													if(data.orientation === "horizontal"){
														if(divOffset.left < (droppableOffset.left)){
															_lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(divOffset.right > (droppableOffset.right)){
															_lyteUiUtils.insertAfter(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
													}
													else{
														if(((data.gridView && (divOffset.left < droppableOffset.left)) || (divOffset.top < droppableOffset.top)) && ( droppablePlace.previousElementSibling != _placeholder /*(_placeholder.nextElementSibling && _placeholder.nextElementSibling != droppablePlace) || (_placeholder.parentElement != droppablePlace.parentElement)*/)){
															// console.log("calling for droppable ele insertBefore => ",droppablePlace.textContent);
															_lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(((data.gridView && (divOffset.right > droppableOffset.right)) || (divOffset.bottom > droppableOffset.bottom)) && ( droppablePlace.nextElementSibling != _placeholder /*(_placeholder.previousElementSibling && _placeholder.previousElementSibling != droppablePlace) || (_placeholder.parentElement != droppablePlace.parentElement)*/)){
															// console.log("calling for droppable ele insertAfter => ",droppablePlace.textContent);
															_lyteUiUtils.insertAfter(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
													}
												}
											}
										}
										else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv) && (!data.preventDropAtEnd || lastChildNotRestricted(data, _elemBelow))){
											// $L(_elemBelow).append(_placeholder);
											_lyteUiUtils.appendChild(_elemBelow,_placeholder);
											callPlaceholder(data, _elemBelow, droppablePlace);
										}
										data._belowElem = _elemBelow != null ? _elemBelow : data._belowElem;
										if(data.onDrag){
											onDrag(data,event);
										}
										manageSortable.isOver(event,data);
										data._isMoved = true;
										droppablePlace = null;
										_elemBelow = null;
									});
									manageSortable.mutateQueue.push(mutate2);
								});
								manageSortable.measureQueue.push(measure2);
							});
							manageSortable.mutateQueue.push(mutate1);
						});
						manageSortable.measureQueue.push(measure1);
					}
				}
			}

			var mouseUpEvent = function(event){
				var target = event.target;
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}
				if(manageSortable.measureQueue.length){
					while(manageSortable.measureQueue.length){
						$L.fastdom.clear(manageSortable.measureQueue.shift());
					}
				}
				if(manageSortable.mutateQueue.length){
					while(manageSortable.mutateQueue.length){
						$L.fastdom.clear(manageSortable.mutateQueue.shift());
					}
				}
				//UnBinding mousedown and mouseup event
				if(event.type == "mouseup"){
					document.removeEventListener('mousemove',mouseMoveEvent);
					document.removeEventListener('mouseup',mouseUpEvent);
				}
				if(event.type == "touchend"){
					document.removeEventListener('touchmove',mouseMoveEvent, {capture : true, passive : false});
					document.removeEventListener('touchend',mouseUpEvent, true);
				}
				
				if(manageSortable.prevSortable){
					manageSortable.prevSortable = false;
				}
				if(manageSortable.draggedEle && $L(manageSortable.draggedEle).hasClass("sortable-element-selected") && manageSortable.draggedEle._sortableChildData._isDown){
					_sortableElem = manageSortable.draggedEle;
					_sortableElem.classList.remove('lyteSortableDisablePE');
				}
				else{
					abnormalMC(event);
					_sortableElem = null;
					manageSortable.draggedEle = null;
					manageSortable.mousedownTriggered = false;
					return;
				}
				if(_sortableElem){
					var data = _sortableElem._sortableChildData;
					var prevParent = _sortableElem.parentElement;
					if(data._isDown){
						data._isDown = false;
						_div = data._div;
						_placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
						var _placeholderParent = _placeholder.parentElement;
						if(data._isMoved){
							data._isMoved = false;
							data._toIndex = checkDroppedItemPosition(data, _placeholder,Array.from(_placeholderParent.children).filter(function(ele){ return ele.tagName != "TEMPLATE" && !($L(ele).hasClass('sortable-element-selected')) }));
							var returnVal = true;
							
							//Callback fired
							if(data.onBeforeDrop){
								returnVal = onBeforeDrop(data,event,_placeholder,_placeholderParent);
							}

							if($L(_placeholder).hasClass(data.disabled)){
								callRevertBack(data);
								manageSortable.draggedEle = null;
								manageSortable.mousedownTriggered = false;
								return;
							}

							if(!returnVal){
								callRevertBack(data);
								if(isHelper(_div)){
									_div.remove();
								}
								manageSortable.draggedEle = null;
								manageSortable.mousedownTriggered = false;
								return;
							}
							
							var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
							var elementData = sibling && sibling._sortableChildData ? Object.assign({}, sibling._sortableChildData) : Object.assign({}, _placeholder.parentElement._sortableParentData);
							// if(_sortableElem.classList.contains('sortable-parent')){

							// 	elementData._parentElem = _sortableElem;
							// }
							// $L(_placeholder).replace(_div);
							if((data._fromIndex == data._toIndex) && (data._parentElem == _placeholderParent)){
								_placeholder.remove();
							}
							else{
								_lyteUiUtils.replaceWith(_placeholder, _div);
							}
							removeStyle(_div);

							_placeholder = null;

							_div._sortableChildData = elementData;

							//Callback fired
							if(data.onDrop){
								onDrop(data,event);
							}
							if(isHelper(_div)){
								delete _div._origin;
							}
						}
						else{
							removeStyle(_div);
							if(isHelper(_div)){
								delete _div._origin;
								_div.remove();
							}
							if(_sortableElem.tagName.toLowerCase() == 'a'){
								window.location.href = _sortableElem.href;
							}
						}
						data._div = null;
						data._placeholder = null;
						data._placedPlaceholder = false;
						data._returnElemBelow = null;
						data._belowElem = null;
						data._source = null;
						data._fromIndex = null;
					}
					$L(_sortableElem).removeClass('sortable-element-selected');
					_offset = null;
					_isDown = null;
					_isMoved = null;
					_mousePosition = null;
					_elemBelow = null;
					_droppablePlace = null;
					_marginTop = null;
					_marginLeft = null;
					_sortableElemClass = null;
					_sortableElem = null;
					_placeholder = null;
					_div = null;
					_prevScrollDiv = null;

				}
				
				abnormalMC(event);

				manageSortable.draggedEle = null;
				manageSortable.mousedownTriggered = false;
			}

			var abnormalMC = function(event){
				//Check for abnormal mouse clicks
				var dummies = event.target.ownerDocument.querySelectorAll('.lyteSortablePlaceholder');
				for(var i = 0; i < dummies.length; i++){
					if(dummies[i]._callee){
						var elem = dummies[i]._callee;
						_lyteUiUtils.replaceWith(dummies[i], elem);
						$L(elem).removeClass('sortable-element-selected');
						removeStyle(elem);
						if(isHelper(elem)){
							elem.remove();
						}
					}
					else{
						dummies[i].remove();
					}
				}
				var elements = event.target.ownerDocument.querySelectorAll('.sortable-element-selected');
				for(var i =0; i<elements.length; i++){
					$L(elements[i]).removeClass('sortable-element-selected');
					removeStyle(elements[i]);
					if(isHelper(elements[i])){
						elements[i].remove();
					}
				}
			};

			element.addToSortable = function(elem){
				elem._sortableChildData = element._sortableParentData;
				$L(elem).addClass("sortable-element "+element._sortableParentData.sortableElemClass);
			};

			element.getSortableClass = function(){
				return element._sortableParentData.sortableElemClass;
			};

			element.removeFromSortable = function(elem){
				delete elem._sortableChildData;
				$L(elem).removeClass("sortable-element "+element._sortableParentData.sortableElemClass);
			};
			
			var callPlaceholder = function(data, _elemBelow, droppablePlace){
				if(!data.onPlaceholder || checkValidDroppable(data,_elemBelow || droppablePlace.parentElement)){
					if(_placeholder.classList.contains(data.disabled)){
						_placeholder.classList.remove(data.disabled);
					}
					_placeholder.classList.add(data.placeholder);
				}
				else{
					if(_placeholder.classList.contains(data.placeholder)){
						_placeholder.classList.remove(data.placeholder);
					}
					_placeholder.classList.add(data.disabled);
				}
				

				//Callback fired
				data._returnElemBelow = droppablePlace || _elemBelow;
			};

			var callForScrollX = function(data,parentOffset,_mousePosition,_offset,parent,isRelative){
				if(!data._div){
					return;
				}
				// console.log("Scroll X getting called");
				var divOffset = data._div.getBoundingClientRect();
				_scrollLeft = data.scrollDivX.scrollLeft;
				_maxScrollWidth = data._maxScrollWidth;
				if( !_lyteUiUtils.getRTL() || (!_lyteUiUtils.isNegativeScroll() && _lyteUiUtils.getRTL() && detectBrowser() == "chrome" && !isRelative)){
					if((divOffset.right >= parentOffset.right) && (_scrollLeft < _maxScrollWidth)){
						if((_maxScrollWidth - _scrollLeft) >= 5){
							data.scrollDivX.scrollLeft += 5;
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
							}
						}
						else{
							data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
							}
						}
					}
					else if((divOffset.left <= parentOffset.left) && (_scrollLeft > 0)){
						if(isRelative && data.scrollDivX.contains(data._div)){
							data._div.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) > 5 ? 5 : (5 - (_maxScrollWidth - _scrollLeft))) + _scrollLeft + "px";
						}
						data.scrollDivX.scrollLeft -= 5;
					}
					else{
						cancelAnimationFrame(_requestId2);
						_animationFrameFired2 = false;
						_requestId2 = null;
						return;
					}
				}
				else{
					if(!_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome" && isRelative){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft < _maxScrollWidth)){
							if((_maxScrollWidth - _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + (_scrollLeft - _maxScrollWidth) + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft > 0)){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) + 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if((_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome") || detectBrowser() == "firefox" || detectBrowser() == "safari"){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft < 0)){
							if((_maxScrollWidth + _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth + _scrollLeft));
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft > -(_maxScrollWidth))){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (_scrollLeft - 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if(detectBrowser() == "ie" || detectBrowser() == "edge"){
						// debugger
						if((divOffset.right >= parentOffset.right) && (_scrollLeft > 0)){
							if(_scrollLeft >= 5){
								data.scrollDivX.scrollLeft -= 5;
								// if(isRelative){
								// 	data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
								// }
							}
							else{
								data.scrollDivX.scrollLeft -= _scrollLeft;
								// if(isRelative){
								// 	data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
								// }
							}
						}
						else if((divOffset.left <= parentOffset.left) && (_scrollLeft < _maxScrollWidth)){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (-_scrollLeft) - 5 + "px";
							}
							data.scrollDivX.scrollLeft += 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}

				}
				_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,parentOffset,_mousePosition,_offset,parent,isRelative)); 
			};

			var callForScrollY = function(data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent){
				$L.fastdom.measure(function(){
					if(!data._div){
						return;
					}
					// var scrollDiv = arguments[1];
					// var parentOffset = arguments[2];
					var divOffset = data._div.getBoundingClientRect();
					var diff = data._placeholder.parentElement.offsetTop - scrollDiv.offsetTop + 5;
					// var _maxScrollHeight = arguments[3];
					// var topNBottom = arguments[4];
					// var isRelativeY = arguments[5];
					var scrollTop = scrollDiv.scrollTop;
					$L.fastdom.mutate(function(){
						if(!data._div){
							return;
						}
						if((divOffset.top - parseInt(data._marginTop) <= parentOffset.top + diff) && (scrollTop > 0)){
							if(isRelativeY && scrollDiv.contains(data._div)){
								data._div.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight - scrollTop) + scrollTop + "px";
							}
							scrollDiv.scrollTop -= 10;
						}
						else if((divOffset.bottom >= (parentOffset.bottom - 3)) && (scrollTop < _maxScrollHeight)){
							if(_maxScrollHeight - scrollTop > 10){
								if(isRelativeY && scrollDiv.contains(data._div)){
									data._div.style.top = _mousePosition.y - _offset[1] - parent.top + 10 + scrollTop + "px";
								}
								scrollDiv.scrollTop += 10;
							}
							else{
								if(isRelativeY && scrollDiv.contains(data._div)){
									data._div.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop + scrollTop + "px";
								}
								scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
							}
						}
						else{
							if((scrollTop == 0) && (divOffset.top - parseInt(data._marginTop) <= parentOffset.top + diff) && !isFirstOrLastELement(data, "first")){
								appendPlaceholderAt(data, "first");
							}
							else if((scrollTop == _maxScrollHeight) && (divOffset.bottom >= (parentOffset.bottom - 3)) && !isFirstOrLastELement(data, "last")){
								appendPlaceholderAt(data, "last");
							}
							cancelAnimationFrame(_requestId1);
							_animationFrameFired1 = false;
							_requestId1 = null;
							return;
						}
						_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent));
					});
				});
			};

			var isFirstOrLastELement = function(data, pos){
				var placeholder = data._placeholder,
					parent = placeholder.parentElement,
					children = getChildren(data,parent);
				if(pos === "first"){
					return children[0] == placeholder;
				}
				return children[children.length - 1] == placeholder;	//incase of last 
			};

			var getChildren = function(data, parent){
				if(data && data.omitRestricted){
					return Array.from(parent.children).filter( function(ele) { return (ele.tagName != "TEMPLATE" && isNotRestricted(data,ele))} );
				}
				return Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
			};

			var appendPlaceholderAt = function(data, pos){
				var placeholder = data._placeholder,
					parent = placeholder.parentElement,
					children = getChildren(data,parent);
				if(data.gridView){
					return;
				}
				if(pos === "first"){
					// _lyteUiUtils.insertBefore(children[0], placeholder);
					for(var i = 0; i < children.length; i++){
						if(!data.preventDropAtStart || (isNotRestricted(data, children[i]) && !(children[i].classList.contains('sort-disabled-element')))){
							_lyteUiUtils.insertBefore(children[i], placeholder);
							break;
						}
					}
				}
				else{
					// _lyteUiUtils.insertAfter(children[children.length - 1], placeholder);
					for(var i = children.length - 1; i >= 0; i--){
						if(!data.preventDropAtEnd || (isNotRestricted(data, children[i]) && !(children[i].classList.contains('sort-disabled-element')))){
							_lyteUiUtils.insertAfter(children[i], placeholder);
							break;
						}
					}
				}
			};

			var isNotRestricted = function(data,targetElem){
				for(var i = 0; i<data.restrict.length ; i++){
					if(targetElem.matches(data.restrict[i])){
						return false;
					}
				}
				return true;
			};

			var lastChildNotRestricted = function(data, parent){
				var children = getChildren(null, parent);
				return children.length ? isNotRestricted(data, children[children.length - 1]) : true;
			};

			var checkForSortable = function(data,targetElem){
				if(!data.draggable){
					return false;
				}
				for(var i = 0; i<data.cancel.length ; i++){
					var elem = targetElem;
					while(elem.parentElement){
						if(elem.matches(data.cancel[i])){
							return false;
						}
						if($L(elem).hasClass('sortable-element')){
							break;
						}
						elem = elem.parentElement;
					}
				}
				return true;
			};

			var checkDroppedItemPosition = function(data, ele,siblings){
				if(data.omitRestricted){
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
				}
				for(var i = 0; i<siblings.length; i++){
					if(siblings[i].tagName != "TEMPLATE" && ele == siblings[i]){
						return i;
					}
				}
			};

			var getFromIndex = function(data){
				var element = isHelper(data._div) ? data._div._origin : data._div;
				if(data.omitRestricted){
					var siblings = Array.from(data._source.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
                    return siblings.indexOf(element);
				}
				else{
					return Array.from(data._source.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } ).indexOf(element);
				}
			}

			var getSource = function(data){
				var current = isHelper(data._div) ? data._div._origin : data._div;
				var parentElem = data._parentElem;
				if(current.classList.contains('sortable-parent') && current.parentElement.classList.contains('sortable-parent')){
					parentElem = current.parentElement;
				}
				return parentElem;
			}

			/*---------------Callbacks Start--------------*/
			var onReady = function(data){
				data.onReady(data._parentElem);
			}

			var onSelect = function(data,event){
				var returnVal = data.onSelect(data._div, data._fromIndex, data._source,event);
				return ( returnVal == undefined) ? true : returnVal;
			}

			var onDragStart = function(data, event){
				data.onDragStart(data._div,data._source, event);
			}

			var onDrag = function(data,event){
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				data.onDrag(data._div,data._returnElemBelow,event,placeholder,data._belowElem);
			}

			var onBeforeDrop = function(data,event,placeholder){
				// var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				var returnVal = data.onBeforeDrop(data._div,data._returnElemBelow,placeholder,data._fromIndex, data._toIndex /*checkDroppedItemPosition(data, placeholder,Array.from(placeholder.parentElement.children).filter(function(ele){ return ele.tagName != "TEMPLATE" && !($L(ele).hasClass('sortable-element-selected')) }))*/, data._source, placeholder ? placeholder.parentElement : null,event);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onDrop = function(data,event){
				data.onDrop(data._div, data._div._sortableChildData._parentElem, data._returnElemBelow, data._fromIndex, data._toIndex /*checkDroppedItemPosition(data, data._div,Array.from(data._div._sortableChildData._parentElem.children).filter(function(ele){ return ele.tagName != "TEMPLATE" }))*/, data._source, event);
			}

			var onMultiSelectDrag = function(data, event){
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				data.onMultiSelectDrag(data._div,event,placeholder,placeholder.parentElement);
			}
			/*---------------Callbacks End--------------*/

			var checkValidDroppable = function(data,destination){
				if(destination.id && destination.id == "dummy"){
					destination = destination.parentElement;
				}
				else{
					while(destination){
						if($L(destination).hasClass('sortable-parent')){
							break;
						}
						destination = destination.parentElement;
					}
				}
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				var returnVal = data.onPlaceholder(data._div,placeholder, data._parentElem, placeholder ? placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}


			//Bind events to the child elements that will be sortable
			var childrens = /*data._parentElem.children*/ getChildren(data, data._parentElem);
			data._parentElem.__mouseDownEvent = mouseDownEvent;
			data._parentElem.__mouseMoveEvent = mouseMoveEvent;
			data._parentElem.__mouseUpEvent = mouseUpEvent;
			data._parentElem._sortableParentData = data;
			for(var i = 0 ; i < childrens.length ; i++){
				childrens[i]._pos = i;
				if(/*childrens[i].tagName != "TEMPLATE" &&*/ isNotRestricted(data,childrens[i]) && !(childrens[i].classList.contains('sortable-element-selected'))){
					childrens[i]._sortableChildData = data;
					$L(childrens[i]).addClass("sortable-element "+data.sortableElemClass);
				}
			}
			if(data.draggable && !data._parentElem._mousedown){
				data._parentElem.addEventListener("mousedown",data._parentElem.__mouseDownEvent);
				data._parentElem.addEventListener("touchstart",data._parentElem.__mouseDownEvent, true);
				data._parentElem._mousedown = true;
			}
			// else{
			// 	if(data._parentElem._mousedown){
			// 		data._parentElem.removeEventListener("mousedown",data._parentElem.__mouseDownEvent);
			// 		data._parentElem.removeEventListener("touchstart",data._parentElem.__mouseDownEvent, true);
			// 	}
			// }
			

			
			
			//Check whether the arrays are connected or not and has connectedWith
			if(!data.connected && data.connectedWith.length > 0){
				data.connectedWith = manageSortable.convertToArrayOfItems(data.connectedWith);
				data.connectedWith.forEach(function(id){
					var connectedWith = data.connectedWith.concat(),
					index = connectedWith.indexOf(id);
					connectedWith.splice(index,1);
					connectedWith.push(id);
					// connectedWith.push(data._parentElem);
					if(data.multiSortable && _sortableData &&  _sortableData.connectedWith) {
						data.connectedWith = _sortableData.connectedWith;
					}
					else {
						$L(id).sortable({
							_parentElem : $L(id)[0],
							connectedWith : connectedWith,
							connected : true,
							// droppable : data.droppable,
							// draggable : data.draggable,
							// placeholder : data.placeholder,
							// disabled : data.disabled,
							// orientation : data.orientation,
							// cancel : data.cancel,
							// items : data.items,
							// cursorAt : data.cursorAt,
							restrict : data.restrict,
							// scrollDivX : data.scrollDivX,
							// omitRestricted : data.omitRestricted,
							sortableElemClass : data.sortableElemClass,
							// clone : data.clone
						});
					}
				});
			}

			if(data.onReady && !data._parentElem.executedOnReady){
				onReady(data);
				data._parentElem.executedOnReady = true;
			}

			var setContainment = function(data,sortableElem){
				if(data.containment == "parent"){
					var dimensions = isHelper(sortableElem) ? sortableElem._origin.parentElement.getBoundingClientRect() : sortableElem.parentElement.getBoundingClientRect();
					return ({left : dimensions.left,
							right : dimensions.right,
							top : dimensions.top,
							bottom : dimensions.bottom,
							height : dimensions.height,
							width : dimensions.width,
							offsetLeft : isHelper(sortableElem) ? sortableElem._origin.parentElement.offsetLeft : sortableElem.parentElement.offsetLeft,
							offsetTop : isHelper(sortableElem) ? sortableElem._origin.parentElement.offsetTop : sortableElem.parentElement.offsetTop});
				}
				else{
					var containment = $L(data.containment).length == undefined ? null : $L(data.containment)[0];
					var dimensions = containment.getBoundingClientRect();
					return ({left : dimensions.left,
							right : dimensions.right,
							top : dimensions.top,
							bottom : dimensions.bottom,
							height : dimensions.height,
							width : dimensions.width,
							offsetLeft : containment.offsetLeft,
							offsetTop : containment.offsetTop});
				}
			};

			/*----------------------- UTILITY FUNCTIONS FOR SORTABLE ---------------------*/

			var findScrollDiv = function(elem){
				var parent = elem.parentElement;
				while(elem.parentElement){
					elem = elem.parentElement;
					if((parent.scrollHeight > elem.clientHeight) && ((window.getComputedStyle(elem).overflowY != "hidden" && window.getComputedStyle(elem).overflow != "visible") || elem.matches('.lyteScrollBar')) /*!(elem.style.overflow && elem.style.overflow == 'hidden')*/){
						return elem;
					}
				}
				return null;
			};

			var fixWidth = function(element){
				var childrens = element.children,
				width = []
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].__prevWidth = childrens[i].style.width;
						width[ i ] = childrens[i].__prevWidth || ( childrens[i].offsetWidth + 'px' ) ;
					}
				}
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].style.width = width[ i ];
					}
				}
			};

			var removefixedWidth = function(element){
				var childrens = element.children;
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].style.width = childrens[i].__prevWidth;
					}
				}
			};

			var calculateHeight = function(element) {
				var cs = getComputedStyle(element);

				var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

				var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

				// Element height minus padding and border
				var elementHeight = element.offsetHeight - paddingY - borderY;
				return elementHeight;
			};

			var calculateWidth = function(element) {
				var cs = getComputedStyle(element);

				var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);

				var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

				// Element width minus padding and border
				var elementWidth = element.offsetWidth - paddingX - borderX;
				return elementWidth;
			};

			var getRelativeParent = function(element){
				while(element.parentElement){
					element = element.parentElement;
					var cs = getComputedStyle(element);
					if(cs.position == "relative"){
						return element;
					}
				}
				return null;
			};

			//Checks whether the element can be dropped or not
			var checkDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				if(element.id != "dummy"){
					var sortableParentId = sortableElem.parentElement.id;
					var droppableParentId = element.parentElement.id;
					if(containmentDimensions){
						if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
							return false;
						}
					}
					if(sortableElem.parentElement == element.parentElement || element.parentElement == sortableElem._sortableChildData._parentElem){
						return true;
					}
					if(((connectedWith).indexOf(element.parentElement) != -1) && element._sortableChildData.droppable){
						return true;
					}
				}
				return false;
			};

			//Checks whwther the element can be dropped or not 
			var checkParentDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				var sortableParentId = sortableElem.parentElement.id;
				if(containmentDimensions){
					if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
						return false;
					}
				} 
				if(sortableElem.parentElement == element || element == parentElem){
					return true;
				}
				if(((connectedWith).indexOf(element) != -1) && checkDroppableValue(element)){
					return true;
				}
				return false;
			};

			var checkDroppableValue = function(element){
				var childrens = element.children;
				var childElem;
				for(var v= 0; v<childrens.length; v++){
					if(childrens[v] != element.querySelector("#dummy") && childrens[v].tagName != "TEMPLATE" && $L(childrens[v]).hasClass('sortable-element')){
						childElem = childrens[v];
						break;
					}
				}
				return (childElem && childElem._sortableChildData ? childElem._sortableChildData.droppable : element._sortableParentData.droppable);
			};

			//Checks for appending the sortable elements at the end of the div
			var checkPossiblePosition = function(element,sortableElem){
				if(element.childElementCount > 0){
					var lastChild = element.lastElementChild;
					if(sortableElem.getBoundingClientRect().top > lastChild.getBoundingClientRect().bottom){
						return true
					}
				}
				else{
					return true;
				}
				return false;
			};

			var checkIfDroppable = function(parentElem,ele){
				if(ele.parentElement === parentElem && parentElem.childElementCount === 1 && (((ele.getBoundingClientRect().right > (parentElem.getBoundingClientRect().left + ele.getBoundingClientRect().width / 2)) && 
					(ele.getBoundingClientRect().right <= parentElem.getBoundingClientRect().right)) || ((ele.getBoundingClientRect().left < (parentElem.getBoundingClientRect().right - ele.getBoundingClientRect().width / 2)) && 
					(ele.getBoundingClientRect().left >= parentElem.getBoundingClientRect().left)))){
					return true;
				}
				return false;
			};

			var checkForIntersect = function(parentElem,mP){
				var cs = window.getComputedStyle(parentElem);
				var offset = parentElem.getBoundingClientRect();
				// console.log("cs",cs);
				// console.log("offset",offset);
				// console.log("_mousePosition",mP.x,mP.y);
				if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
					return true;
				}
				return false; 
			};

			var checkForBetween = function(parentElem,mP,div,isRelativeY,scrollDiv){
				var childrens = parentElem.children;
				var templateTags = 0;
				var childElem = [];
				for(var i = 0;i<childrens.length;i++){
					if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy" && isNotRestricted(parentElem._sortableParentData,childrens[i])){
						childElem.push(childrens[i]);
					}
					else{
						templateTags++;
					}
				}
				if(templateTags == childrens.length){
					return true;
				}
				else if((childElem.length == 1 && childElem[childElem.length - 1] == div) || (childElem.length > 1 && childElem[childElem.length - 1] == div && div.getBoundingClientRect().top > (childElem[childElem.length - 2].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0)))){
					return true;
				}
				else if(div.getBoundingClientRect().top > (childElem[childElem.length - 1].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0))){
					return true;
				}
				return false;
			};

			var callRevertBack = function(data) {
				$L(data._div).removeClass("sortable-element-selected");
				removeStyle(data._div);
				data._placeholder.remove();
			};

			var removeStyle = function(element){
				element.style.position = '';
				element.style.top = '';
				element.style.left = '';
				element.style.width = '';
				element.style.height = '';
				// element.style.display = '';
				element.style.zIndex = '';
				element.style.boxSizing = '';
				$L(element).removeClass('lyteSortableElem');
				$L(element).removeClass('lyteSortableDisablePE');
				if(isHelper(element)){
					$L(element).removeClass('sortable-helper');
				}
				if(element.tagName.toLowerCase() == "tr" || element.tagName.toLowerCase() == "lyte-tr"){
					removefixedWidth(element);
				}
			};

			var findPreviousElem = function(elem){
				while(elem.previousElementSibling){
					elem = elem.previousElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var findNextElem = function(elem){
				while(elem.nextElementSibling){
					elem = elem.nextElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var checkForItems = function(data,targetElem){
				if(data.items.length > 0){
					for(var i = 0 ; i<data.items.length ; i++){
						var elements = document.querySelectorAll(data.items[i]);
						for(var j = 0; j<elements.length; j++){
							if(elements[j] == targetElem){
								return true;
							}
						}
					}
				}
				else{
					return true;
				}
				return false;
			};

			var getClone = function(elem,deepCopy){
				var clone;
				if(deepCopy){
					clone = elem.cloneNode(deepCopy);
					var cloneChildren = clone.children;
					var elemChildren = elem.children;
					for(var i = 0; i<cloneChildren.length; i++){
						var childOffset = elemChildren[i].getBoundingClientRect();
						// cloneChildren[i].innerHTML = "";
						cloneChildren[i].style.width = childOffset.width + "px";
						cloneChildren[i].style.height = childOffset.height + "px";
						// cloneChildren[i].style.boxSizing = "border-box";
						cloneChildren[i].classList.add('lyteSortableDummyTr');
					}
				}
				else{
					clone = elem.cloneNode();
					clone.innerHTML = "";
					clone.style.boxSizing = "border-box";
				}
				clone._callee = elem;
				clone.classList.remove('sortable-element-selected','sortableElem');
				if(isHelper(elem)){
					clone.style.visibility = "";
				}
				return clone;
			};

			var isHelper = function(elem){
				return (elem.classList.contains('sortable-helper') || elem._isHelper);
			};

			return this;

		}
		
	}

})( window );

/*------------------------   NOTES   ------------------------*/
/*
  1. Added dropbody attribute
  2. Added displayMentions attribute
*/


;(function( window ) {

	if(lyteDomObj){	
		var postpone = (function () {
		    var fnMap = new Map(), idMap = new Map(), fnId = 0;
		    var msg = { fnId: 0 };
		    function _postpone(fn) {
		        if (!fnMap[fn]) {
		            fnId++;
		            fnMap[fn] = fnId;
		            idMap[fnId] = fn;
		        }
		        msg.fnId = fnMap[fn];
		        postMessage(msg, '*');
		    }
		    function _postponeListener(e) {
		        var fnId = e.data.fnId;
		        if (fnId) {idMap[fnId]()};
		    }
		    window.addEventListener("message", _postponeListener);
		    return _postpone;
		}());
		
		lyteDomObj.prototype.mIManager = {
			KEY : { BACKSPACE : 8, TAB : 9, RETURN : 13, ESC : 27, LEFT : 37, UP : 38, RIGHT : 39, DOWN : 40, COMMA : 188, SPACE : 32, HOME : 36, END : 35 }, // Keys "enum"
			inputBuffer : [],
			currentDataQuery : null,
			textarea : null,
			escapeMap : { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;'},
			bindResize : false,
			id : null,
			bindScroll : false,
			bindClick : false,
			searchTriggeredId : false,
			mentionRegex : new RegExp("\\@\\[\\d+\\:\\w+\\]","gi"),
			encodeMsg : function(str, mentionsArray){
				var mIManager = lyteDomObj.prototype.mIManager, newStr = "", pos = 0;
				mentionsArray.forEach(function(mention){
					if(str.indexOf(mention) != -1){
						newStr += mIManager.htmlEncode(str.substring(0, str.indexOf(mention))) + mention;
						pos = str.indexOf(mention) + mention.length;
						str = str.substring(pos);
					}
				});
				newStr += mIManager.htmlEncode(str);
				return newStr;
			},
			htmlEncode : function (str) {
			  var mIManager = lyteDomObj.prototype.mIManager;
			  var escaper = function(match){
			  	return mIManager.escapeMap[match];
			  }
			  var src = '(?:' + Object.keys(mIManager.escapeMap).join('|') + ')';
			  var testRegexp = RegExp(src);
    		  var replaceRegexp = RegExp(src, 'g');
    		  str = str == null ? '' : '' + str;
		      return testRegexp.test(str) ? str.replace(replaceRegexp, escaper) : str;
		    },
		    mentionsSyntax : function(mention){
		    	return "["+mention.value+":"+mention.id+"]";
		    },
			createElement : function(tagName,id,className){
				var element = document.createElement(tagName);
				if (id) {
					element.id = id;
				}
				if (className) {
					$L(element).addClass(className);
				}
				return element;
			},
			setCaratPosition : function (domNode, caretPos) {
		      if (domNode.createTextRange) {
		        var range = domNode.createTextRange();
		        range.move('character', caretPos);
		        range.select();
		      } else {
		        if (domNode.selectionStart) {
				  domNode.setSelectionRange(caretPos, caretPos);
		          domNode.focus();
		        //   domNode.setSelectionRange(caretPos, caretPos);
		        } else {
		          domNode.focus();
		        }
		      }
		    },
			init : function(element){
				var mIManager = lyteDomObj.prototype.mIManager;
				var ele1 = mIManager.createElement("div",null,"lyteMIWrapper");
				_lyteUiUtils.insertBefore(element,ele1);
				_lyteUiUtils.appendChild(ele1,element);
				// ele1.append(element);
				var ele = mIManager.createElement("div",null,"lyteMIDropdown");
				_lyteUiUtils.insertAfter(element,ele);
				mIManager.copyTextarea(element);
				var cs = window.getComputedStyle(element);
				var ele2 = mIManager.createElement("div",null,"lyteMentions");
				ele2.style.fontFamily = cs.fontFamily;
				ele2.style.fontSize = cs.fontSize;
				ele2.style.fontWeight = cs.fontWeight;
				var ele3 = mIManager.createElement("div",null,"lyteMentionsInnerDiv");
				_lyteUiUtils.appendChild(ele2,ele3);
				// ele2.append(mIManager.createElement("div",null,"lyteMentionsInnerDiv"));
				_lyteUiUtils.insertBefore(element,ele2);
				return ele;
			},
			rtrim : function(string) {
    			return string.replace(/\s+$/,"");
  			},
  			ltrim : function(string) {
    			return string.replace(/^\s+/,"");
  			},
  			highlightContent : function (value, term) {
			    if (!term && !term.length) {
			      return value;
			    }
			    return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<b>$1</b>");
		    },
		    copyTextarea : function(element) {
		      var mIManager = lyteDomObj.prototype.mIManager;
		      //	We will create a div clone of the textarea
		      //	by copying these attributes from the textarea to the div.
		      var attrs = [ 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'fontSize', 'lineHeight', 'fontFamily', 'width', 'fontWeight', 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width', 'borderTopStyle', 'borderTopColor', 'borderRightStyle', 'borderRightColor', 'borderBottomStyle', 'borderBottomColor', 'borderLeftStyle', 'borderLeftColor', 'box-sizing', '-moz-box-sizing', '-webkit-box-sizing'];

		        // CopyTextarea only works on textareas
		        if (element.type !== 'textarea') {
		          return false;
		        }

		        var mITextarea = $L(element),
		          cloneTextarea = $L(mIManager.createElement('div')).css({'display':'none','word-wrap':'break-word'}),
		          lineHeight = parseInt(mITextarea.css('line-height'), 10) || parseInt(mITextarea.css('font-size'), '10'),
		          minheight = parseInt(mITextarea.css('height'), 10) || lineHeight * 3,
		          maxheight = parseInt(mITextarea.css('max-height'), 10) || Number.MAX_VALUE,
		          goalheight = 0;

		          cloneTextarea.addClass('lyteMIOffsetDiv');
		        // Updates the width of the twin. (solution for textareas with widths in percent)
		        function setCloneDivWidth(textareaWidth, cloneWidth) {
		          var curatedWidth = Math.floor(parseInt((textareaWidth || mITextarea.outerWidth()), 10));

		          if(mITextarea[0]._mIData && mITextarea[0]._mIData._overlayDiv){
		          	$L(mITextarea[0].previousElementSibling).css("fontSize",mITextarea.css("fontSize"));
		          }
		          if ((cloneWidth || cloneTextarea.outerWidth()) !== curatedWidth) {
		            cloneTextarea.css({'width': curatedWidth + 'px', 'fontSize': mITextarea.css("fontSize")});

		            if(cloneTextarea[0].getAttribute('setHeight') === "true"){
		            	cloneTextarea[0].setAttribute('setHeight',"false");
		            }
		            else{
		            	// Update height of textarea
		            	updateTextarea(true);
		            }
		            
		          }
		        }

		        // Sets a given height and overflow state on the textarea
		        function setHeightAndOverflow(height, overflow, textareaHeight) {

		          var curratedHeight = Math.floor(parseInt(height, 10));
		          if (textareaHeight !== curratedHeight) {
		            mITextarea.css({'height': curratedHeight + 'px','overflow':overflow});

		            // // Fire the custom event resize
		            setCloneDivWidth();

		          }
		        }

		        // This function will update the height of the textarea if necessary
		        var updateTextarea = function(forced) {
		        	cloneTextarea[0].style.display = "block";

		        	// Get curated content from the textarea.

			        var textareaContent = mITextarea[0].value.replace(/&/g, '&amp;').replace(/ {2}/g, '&nbsp;').replace(/<|>/g, '&gt;').replace(/\n/g, '<br />');

			        // Compare curated content with curated twin.
			        var cloneContent = (cloneTextarea[0].innerHTML).replace(/<br>/ig, '<br />');

			        if (forced || textareaContent + '&nbsp;' !== cloneContent) {

			            // Add an extra white space so new rows are added when you are at the end of a row.
			            cloneTextarea[0].innerHTML = (textareaContent + '&nbsp;');

			            var cloneHeight = cloneTextarea.outerHeight(), 
			            	textareaHeight = mITextarea.outerHeight();
			            // Change textarea height if twin plus the height of one line differs more than 3 pixel from textarea height
			            if (Math.abs(cloneHeight + lineHeight - textareaHeight) >= 3 || textareaContent === "") {

			            	cloneTextarea[0].setAttribute('setHeight',"true");
				            var goalheight = cloneHeight;
				            if (goalheight >= maxheight) {
				                setHeightAndOverflow(maxheight, 'auto', textareaHeight);
				            } else if (goalheight <= minheight) {
				                setHeightAndOverflow(minheight, 'hidden', textareaHeight);
				            } else {
				                setHeightAndOverflow(goalheight, 'hidden', textareaHeight);
				            }
			            }

			            var cloneWidth = cloneTextarea.outerWidth(),
			            	textareaWidth = mITextarea.outerWidth();
			            //Check for the width changes in textarea
			            if(textareaWidth != cloneWidth){
			            	cloneTextarea[0].setAttribute('setHeight',"true");
			            	setCloneDivWidth(textareaWidth, cloneWidth);
			            }
			            cloneTextarea[0].style.display = "";
			        }

		        };

		        // Opera returns max-height of -1 if not set
		        if (maxheight < 0) {
		          maxheight = Number.MAX_VALUE;
		        }

		        // Append the twin to the DOM
		        // We are going to meassure the height of this, not the textarea.

		        _lyteUiUtils.insertAfter(mITextarea[0],cloneTextarea[0]);

		        // Copy the essential styles (attrs) from the textarea to the twin
		        var i = attrs.length;
		        while (i--) {

		          if (attrs[i].toString() === 'width' && mITextarea.css(attrs[i].toString()) === '0px') {
		            setCloneDivWidth();
		          } else {
		            cloneTextarea.css(attrs[i].toString(), mITextarea.css(attrs[i].toString()));
		            // console.log(attrs[i].toString() +"===" + mITextarea.css(attrs[i].toString()))
		          }
		        }

		        updateTextarea(true);

		        // debugger
		        // Update textarea size on keyup, change, cut and paste
		        mITextarea[0]._closureEvnt = updateTextarea;
		        mITextarea[0].addEventListener('input', mITextarea[0]._closureEvnt);
		        mITextarea[0].addEventListener('change', mITextarea[0]._closureEvnt);

		    },

		    //Call setCloneDivWidth function at the end of the resize event so that the changes are available for calculation
	        callAtTheEndOfResize : function (e){
	        	var mIManager = lyteDomObj.prototype.mIManager;
	        	clearTimeout(mIManager.id);
				mIManager.id = setTimeout(function(){
					var mentionElems = document.querySelectorAll('textarea[data-lyte-mentions="true"]');
					if(mentionElems.length > 0){
						for(var i = 0; i<mentionElems.length; i++){
							var mITextarea = $L(mentionElems[i]),
								cloneTextarea = $L(mentionElems[i].nextElementSibling),
								curatedWidth = Math.floor(parseInt(mITextarea.outerWidth(), 10));
							if(mITextarea[0]._mIData && mITextarea[0]._mIData._overlayDiv){
								$L(mITextarea[0].previousElementSibling).css("fontSize",mITextarea.css("fontSize"));
							}
							if (cloneTextarea.outerWidth() !== curatedWidth) {
								cloneTextarea.css({'width': curatedWidth + 'px', 'fontSize': mITextarea.css("fontSize")});
								if(cloneTextarea[0].getAttribute('setHeight') === "true"){
					            	cloneTextarea[0].setAttribute('setHeight',"false");
					            }
					            else{
					            	// Update height of textarea
					            	var evt;
									if(typeof(Event) === 'function') {
									    evt = new Event('change');
									}else{
									    evt = document.createEvent('Event');
									    evt.initEvent('change', true, true);
									}
					            	mITextarea[0].dispatchEvent(evt);
					            }
							}
						}
					}
				}, 200);
	        }

		}


		lyteDomObj.prototype.mentionsInput = function(object) {
			var mIManager = lyteDomObj.prototype.mIManager;
			if(!mIManager.bindResize){
				//findIndex
				if (!Array.prototype.findIndex) {
				  Object.defineProperty(Array.prototype, 'findIndex', {
				    value: function(predicate) {
				     // 1. Let O be ? ToObject(this value).
				      if (this == null) {
				        throw new TypeError('"this" is null or not defined');
				      }

				      var o = Object(this);

				      // 2. Let len be ? ToLength(? Get(O, "length")).
				      var len = o.length >>> 0;

				      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
				      if (typeof predicate !== 'function') {
				        throw new TypeError('predicate must be a function');
				      }

				      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
				      var thisArg = arguments[1];

				      // 5. Let k be 0.
				      var k = 0;

				      // 6. Repeat, while k < len
				      while (k < len) {
				        // a. Let Pk be ! ToString(k).
				        // b. Let kValue be ? Get(O, Pk).
				        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
				        // d. If testResult is true, return k.
				        var kValue = o[k];
				        if (predicate.call(thisArg, kValue, k, o)) {
				          return k;
				        }
				        // e. Increase k by 1.
				        k++;
				      }

				      // 7. Return -1.
				      return -1;
				    },
				    configurable: true,
				    writable: true
				  });
				}

	        	window.addEventListener('resize', mIManager.callAtTheEndOfResize);
	        	mIManager.bindResize = true;
	        }



			/*--------------------------------  UTILITY FUNCTIONS START  ----------------------------------*/
			var lyteMIList, textarea,
	            lyteMIActiveItem = [],
	            lyteMICollection = [],
	            currentDataQuery = '';

			var resetBuffer = function(){
				mIManager.inputBuffer = [];
			};

			var callOnBeforeAdd = function(data, selectedObj, newValue){
				return data.onBeforeAdd(selectedObj, newValue);
			}
			var callOnAdd = function(data,selectedObj){
		    	data.onAdd(selectedObj);
		    };

		    var callonRemove = function(data,removedCollection){
		    	if(data.onRemove){
		    		data.onRemove(removedCollection);
		    	}
		    }

			var filterDuplicateResult = function(rArray,mArray){
				for(var i = 0; i<mArray.length; i++){
					for(var j = 0; j<rArray.length; j++){
						if(mArray[i].id == rArray[j].id){
							rArray.splice(j,1);
						}
					}
				}
				return rArray;
			};

			var getIndexPosition = function(message, str){
				return message.indexOf(str) + str.length;
			};

			var modifyNodeContent = function() {
		      var syntaxMessage = textarea.value || "";
		      var searchBy = textarea._mIData.searchBy;
		      var indPos = 0, processedStr = "", mentionsArray = [];
			  textarea._mIData.lyteMICollection.forEach(function(mention) {
				var textSyntax = textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]});
				mentionsArray.push(textSyntax);
				processedStr = syntaxMessage.substring(0,indPos);
				syntaxMessage = processedStr + syntaxMessage.substring(indPos).replace(mention[textarea._mIData.searchBy], textSyntax);
				indPos = getIndexPosition(syntaxMessage,textSyntax);	
			  });

		      // var mentionText = mIManager.htmlEncode(syntaxMessage);
		      var mentionText = mIManager.encodeMsg(syntaxMessage, mentionsArray);

		      textarea._mIData.lyteMICollection.forEach(function (mention) {
		        var textSyntax = textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]});
		        var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>"+mention[textarea._mIData.searchBy]+"</span></strong>";

		        mentionText = mentionText.replace(textSyntax, textHighlight);
		      });

		      mentionText = mentionText.replace(/\n/g, '<br />');
		      mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');

		      textarea._mIData.syntaxMessage = syntaxMessage;
		      textarea._mIData._overlayDiv.innerHTML = mentionText;
		    }

		    var updatelyteMICollection = function() {
		      // var inputText = textarea.value;
		      var syntaxMessage = textarea._mIData.syntaxMessage;
		      var searchBy = textarea._mIData.searchBy;
		      lyteMICollection = textarea._mIData.lyteMICollection;
		      var newCollection = [], removedCollection = [];
		      for(var i = 0; i<lyteMICollection.length; i++){
		      	if(lyteMICollection[i][searchBy] && syntaxMessage.indexOf(lyteMICollection[i][searchBy]+":"+lyteMICollection[i].id) != -1 ){
		      		newCollection.push(lyteMICollection[i]);
		      	}
		      	else{
		      		removedCollection.push(lyteMICollection[i]);
		      	}
		      }
		      textarea._mIData.lyteMICollection = newCollection;
		      if(removedCollection.length){
		      	callonRemove(textarea._mIData,removedCollection);
		      }
		    }
		    var positionalPush = function(data, msg){
		    	var indPos = 0,
		    		count = 0,
		    		searchBy = textarea._mIData.searchBy,
		    		lyteMICollection = textarea._mIData.lyteMICollection, processedStr="";
		    	for(var i = 0; i < lyteMICollection.length; i++){
		    		var ind = msg.substring(indPos).indexOf(lyteMICollection[i][searchBy]);
		    		if(ind == -1){
		    			break;
		    		}
		    		else{
		    			indPos = getIndexPosition(msg,lyteMICollection[i][searchBy]);
		    			++count;
		    		}
		    	}
		    	textarea._mIData.lyteMICollection.splice(count,0,data);

		    }

			var updateCollection = function(data) {
			  textarea._addedMentions = true;
		      var currentMessage = textarea.value;
			  var appendSpaceOnAdd = textarea._mIData.appendSpaceOnAdd;
		      var value = data[textarea._mIData.searchBy];
		      //Get the mentions position based on cursor position
		      var startCaretPosition = textarea.selectionEnd - mIManager.currentDataQuery.length - 1;
		      var currentCaretPosition = textarea.selectionEnd;

		      //If the string received based on cursor position dosent match the query, get the query position
		      if(currentMessage.substring(startCaretPosition,currentCaretPosition) !== textarea._mIData.triggerChar + mIManager.currentDataQuery){ 
		      	  // Using a regex to figure out positions
			      var regex = new RegExp("\\" + textarea._mIData.triggerChar + mIManager.currentDataQuery, "gi");
			      regex.exec(currentMessage);

			       startCaretPosition = regex.lastIndex - currentDataQuery.length - 1;
			       currentCaretPosition = regex.lastIndex;
		      }
		      
		      var start = currentMessage.substr(0, startCaretPosition);
		      var end = currentMessage.substr(currentCaretPosition, currentMessage.length);
		      var startEndIndex = (start + value).length + (appendSpaceOnAdd?1:0);

		      var updatedMessageText = start + value +(appendSpaceOnAdd?" ":"") + end;
			  if(textarea._mIData.onBeforeAdd &&  callOnBeforeAdd(textarea._mIData,data, updatedMessageText) ===  false){
				hideDropdown();
				return;
			  }
		      data.position = {start : startCaretPosition, end : startCaretPosition + value.length};
		      positionalPush(data, start);

		      // Cleaning before inserting the value, otherwise auto-complete would be triggered with "old" inputbuffer
		      resetBuffer();
		      mIManager.currentDataQuery = '';
		      hideDropdown();

		      // Mentions - syntax message
		      textarea.value = updatedMessageText;
		      modifyNodeContent();
		      triggerChangeEvt(textarea);
		   //    var evt;
			  // if(typeof(Event) === 'function') {
			  //     evt = new Event('change');
			  // }else{
			  //     evt = document.createEvent('Event');
			  //     evt.initEvent('change', true, true);
			  // }
		   //    textarea.dispatchEvent(evt);
		      // Set correct focus and selection
		    // textarea.focus();
		      setTimeout( function(){
			      mIManager.setCaratPosition(textarea, startEndIndex);
			  },50);
		      if(textarea._mIData.onAdd){
		      	callOnAdd(textarea._mIData,data);
		      }
		    }

			var hideDropdown = function(input, dropdown){
				var tArea = input ? input : textarea;
				lyteMIActiveItem = [];
				dropdown = dropdown || lyteMIList;
				if(!dropdown){
					dropdown = tArea._mIData.lyteMIList;
				}
				if(tArea._mIData.onHide){
					tArea._mIData.onHide(dropdown, tArea);
				}
				if(tArea._mIData.dropbody){
					dropdown.innerHTML = "";
				}
				if(tArea._mIData.preventParentScroll && tArea._scrollDisabled) {
					disableParentListeners(tArea);
				}
				
				dropdown.classList.remove('lyteMIDisplayBlock','lyteMIAddOverflow','lyteMIListAppended','lyteMIDropdown__Down','lyteMIDropdown__Up');
				if(tArea._mIData.dropdownClass) {
					dropdown.classList.remove(tArea._mIData.dropdownClass);
				}
				dropdown.style = "";
			};

			var createLiElement = function(data){
				var ele = mIManager.createElement('lyte-mentions-item');
				ele._mentionsData = data;
				var value = mIManager.highlightContent(data[textarea._mIData.searchBy],mIManager.currentDataQuery);
				var span = mIManager.createElement('span','','lyteMIItemContent');
				span.innerHTML = value;
				ele.appendChild(span);
				return ele;
			};
			var updateAdvancedCollections = function(newSyntax){
				lyteMICollection = textarea._mIData.lyteMICollection;
				var newCollection = [], removedCollection = [];
				var searchBy = textarea._mIData.searchBy;
				var mentionsSyntax = mIManager.mentionsSyntax;
				var triggerChar = textarea._mIData.triggerChar;
				var regex = new RegExp(textarea._mIData.triggerChar+"\\[(.+?)\\:(.+?)\\]",'gi');
				var start = 0, mappedStart = 0, end;
				for(var i = 0; i<lyteMICollection.length; i++){
					var actualValue =  lyteMICollection[i][searchBy];
					var mentionObj = {id: lyteMICollection[i].id, value: actualValue};
					var mentionSyntax = triggerChar+mentionsSyntax(mentionObj);
					var index = newSyntax.indexOf(mentionSyntax);
					var previousString = newSyntax.substring(0,index);
					var missed = regex.exec(previousString);
					if(missed === null && index != -1 ){
						start += (index + actualValue.length);
						mappedStart = index + mentionSyntax.length;
						lyteMICollection[i].position = {end: start};
						newCollection.push(lyteMICollection[i]);
						newSyntax = newSyntax.substring(mappedStart);
					}
					else{
						removedCollection.push(lyteMICollection[i]);
						end = lyteMICollection[i].position.end;
					}
				}
				textarea._mIData.lyteMICollection = newCollection;
				if(removedCollection.length){
					callonRemove(textarea._mIData,removedCollection);
					return {end: end};
				}
			};

			var addToCollections = function(data, startIndex){
		    	var index = 0,
		    	lyteMICollection = textarea._mIData.lyteMICollection;
		    	for(; index < lyteMICollection.length; index++){
		    		if(lyteMICollection[index].position.end > startIndex) {
						break;
					}
		    	}
		    	textarea._mIData.lyteMICollection.splice(index,0,data);
		    };

			var advancedModifyNodeContent = function(newText) {
				var newSyntax = textarea._valueMap.newSyntax;
				var mentions = []; 
				textarea._mIData.lyteMICollection.forEach(function(mention){
					mentions.push(textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]}));
				});
				var mentionText = mIManager.encodeMsg(newSyntax, mentions);
				var newTextValue = newText;
		     	textarea._mIData.lyteMICollection.forEach(function (mention,index) {
					var textSyntax = mentions[index];
					var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>"+mention[textarea._mIData.searchBy]+"</span></strong>";
					mentionText = mentionText.replace(textSyntax, textHighlight);
		      	});
				mentionText = mentionText.replace(/\n/g, '<br />');
				mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');
				textarea._valueMap = {
					oldSyntax: newSyntax,
					oldText: newText
				}
				textarea._mIData.syntaxMessage = newSyntax;
				textarea._mIData._overlayDiv.innerHTML = mentionText;
			};
			var copyObject = function(object){
				return Object.assign({},object);
			};
			
			var addMentions = function(mention){
				mention =  copyObject(mention);
				textarea._addedMentions = true;
				var appendSpaceOnAdd = data.appendSpaceOnAdd;
				var str = textarea._valueMap.oldSyntax;
				var startCaretPosition = textarea.selectionEnd - mIManager.currentDataQuery.length - 1;
				var currentCaretPosition = textarea.selectionEnd;
				var start = mapTextIndex(str, startCaretPosition, 'start');
   				var end = start + currentCaretPosition - startCaretPosition;
				var insert = textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]})+(appendSpaceOnAdd?" ":"");
				var newValue = str.substring(0,start)+insert+str.substring(end);
				var newText = getText(newValue);
				if(textarea._mIData.onBeforeAdd &&  callOnBeforeAdd(textarea._mIData, data, newText) ===  false){
					hideDropdown();
					return;
				}
				textarea._valueMap.newSyntax =  newValue; 
				addToCollections(mention,startCaretPosition);
				// if(newText !=  textarea.value) {

				resetBuffer();
				mIManager.currentDataQuery = '';
				hideDropdown();

				textarea.value = newText;
				updateAdvancedCollections(newValue);
				advancedModifyNodeContent(newText);

				setSelectionPosition(mention.position.end+(appendSpaceOnAdd?1:0));// 1 for space
				if(textarea._mIData.onAdd){
					callOnAdd(textarea._mIData,data);
				}
				// }
			};

			var setSelectionPosition = function(end){
				triggerChangeEvt(textarea);
				// textarea.focus();
				setTimeout( function(){
					mIManager.setCaratPosition(textarea, end);
					setSelection(textarea);
				},10);
			};

			var onSelect = function(event) {
		    	var elmTarget = $L(this);
		    	if(!lyteMIList){
		    		lyteMIList = this.closest('.lyteMIDropdown');
		    	}
		    	textarea = lyteMIList._textarea;
				var advanced = data.removeHighlightCompletely;
				if(advanced) {
					addMentions(elmTarget[0]._mentionsData);
				}
				else {
					updateCollection(elmTarget[0]._mentionsData);
				}
		    	// updateCollectionPosition(textarea);
		    	// textarea.dispatchEvent(new InputEvent('change'));

		    	event.stopPropagation();
		    }


			var onKeyUpOrDown = function(ele){
				if(!ele){
					return;
				}

				if($L('lyte-mentions-item'/*textarea._mIData.listItemTag*/,lyteMIList).length){
					$L('lyte-mentions-item'/*textarea._mIData.listItemTag*/,lyteMIList).removeClass(textarea._mIData.activeItem);
				}
				$L(ele).addClass(textarea._mIData.activeItem);
				lyteMIActiveItem = [];
		    	lyteMIActiveItem.push(ele);
			};

			var getCursorXY = function(textarea, scrolled){
				var customDiv = document.createElement('div');
				var styles = getComputedStyle(textarea);
				
				var currentMessage = textarea.value;
				var properties = {};
				for(var prop in styles){
					if(!((/[\d -]+/g).test(prop) || typeof styles[prop] == "function") ){
						if( prop == "lineHeight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "letterSpacing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "height" ){
							properties[prop] = "auto";
						}
						if( prop == "width" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontSize" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "boxSizing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "whiteSpace" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontWeight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontFamily" ){
							properties[prop] = styles[prop];
						}
						if( prop == "testAlign" ){
							properties[prop] = styles[prop];
						}
						if( prop == "display" ){
							properties[prop] = styles[prop];
						}
						if( prop == "direction" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordBreak" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordWrap" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordSpacing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "position" ){
							properties[prop] = "relative";
						}
					}
				}
				for(var prop in properties){
					customDiv.style[prop] = styles[prop];
				}

			    // Figure out positions
				var selectionStart =  scrolled?textarea._prevSelectionStart:textarea.selectionStart;
			    var startCaretPosition = selectionStart - (mIManager.currentDataQuery.length+1);

				var textContent = currentMessage.substr(0, startCaretPosition);
				customDiv.textContent = textContent;
				// customDiv.style.height = 'auto';
				var span = document.createElement('span');
				span.textContent = currentMessage.substr(startCaretPosition, mIManager.currentDataQuery.length+1) || '.';
				customDiv.appendChild(span);
				var customWrapper = document.createElement('div');
				customWrapper.className = "lyteMentionsCustomWrapper";
				customWrapper.appendChild(customDiv);
				document.body.appendChild(customWrapper);
				var textareaOffset = textarea.getBoundingClientRect();
				var spanOffset = span.getBoundingClientRect();
				var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                var yscroll = window.pageYOffset || document.documentElement.scrollTop;
				var offset = {
					x : textareaOffset.left + xscroll + span.offsetLeft - textarea.scrollLeft,
					y : textareaOffset.top + yscroll + span.offsetTop - textarea.scrollTop,
					height : spanOffset.height,
					width : spanOffset.width
				}
				customWrapper.remove();
				return offset;
			};

			var resetScrollForParent = function(event) {
				var scrollTop = $L( this ).data( 'lyte-scrollTop' ),
				scrollLeft = $L( this ).data( 'lyte-scrollLeft' );
				this.scrollTop = scrollTop;
				this.scrollLeft = scrollLeft;
			};

			var disableLyteScrollBar = function( event ) {
				event.stopPropagation();
			};

			var isScrollable = function( index, item ) {
				var overflowY = $L( item ).css( 'overflow-y' ),
				overflowX = $L( item ).css( 'overflow-x' );
				var allowableValue = ["scroll","auto"];
				if( ( item.clientWidth < item.scrollWidth && allowableValue.indexOf(overflowX) > -1 ) || ( item.clientHeight < item.scrollHeight && allowableValue.indexOf(overflowY) > -1 ) ) {
					return true;
				}
		
				return false;
			};

			var isLyteScrollBar = function( index, item ) {
				return item.classList.contains( 'lyteScrollBar' );
			};

			var disableParentListeners =  function(textarea) {
				var scrollableParents = textarea._scrollableParents;
				var lyteScrollBarParents =  textarea._lyteScrollBarParents;
				if( scrollableParents ) {
					scrollableParents.off( 'scroll', textarea._resetScrollFunc );
					delete textarea._scrollableParents;
					delete textarea._resetScrollFunc;
				}
				if( lyteScrollBarParents ) {

					lyteScrollBarParents.each( function( index, item ) {
		
						if( item ) {
							item.removeEventListener( 'touchmove', textarea._disableLyteScrollBar, true );
							item.removeEventListener( 'wheel', textarea.disableLyteScrollBar, true );
						}
						
					} );
					delete textarea._lyteScrollBarParents;
					delete textarea._disableLyteScrollBar;
				}
				delete textarea._scrollDisabled;
			};

			var preventParentScroll = function(dropdown, textarea) {

				var parents = $L( textarea ).parents(),
				lyteScrollBarParents;
		
				parents = parents.filter( isScrollable );

				lyteScrollBarParents = parents.filter( isLyteScrollBar );

				lyteScrollBarParents = lyteScrollBarParents.map( function( index, item ) {
					return item.parentNode;
				} );
				parents.each( function( index, item ) {
					$L( item ).data( 'lyte-scrollTop', item.scrollTop );
					$L( item ).data( 'lyte-scrollLeft', item.scrollLeft );
				} );
				textarea._disableLyteScrollBar = disableLyteScrollBar;
				lyteScrollBarParents.each( function( index, item ) {
					if( item ) {
						item.addEventListener( 'touchmove', textarea._disableLyteScrollBar, true );
						item.addEventListener( 'wheel', textarea._disableLyteScrollBar, true );
					}
				} );
				textarea._scrollableParents = parents;
				textarea._lyteScrollBarParents = lyteScrollBarParents;
				textarea._scrollDisabled = true;
				textarea._resetScrollFunc  = resetScrollForParent;
				parents.on( 'scroll', textarea._resetScrollFunc );
		
				document.body.classList.add( 'lyteBodyWrapper' );
			};

			var positionDropdown = function(lyteMIList, scrolled){
				var textarea = lyteMIList._textarea;
				if(scrolled && textarea._mIData.preventParentScroll) {
					return;
				}
			    var textareaOffset = textarea.getBoundingClientRect();
			    var listOffset = lyteMIList.getBoundingClientRect();
			    var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
				var winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
			    var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                var yscroll = window.pageYOffset || document.documentElement.scrollTop;
			    winH += yscroll;
			    var xy = getCursorXY(textarea, scrolled);
			    // console.log("listOffset.height ====" + listOffset.height);
			    // console.log("winH - textareaOffset.bottom ====" + (winH - textareaOffset.bottom));
			    // console.log("winH - textareaOffset.top ====" + (winH - textareaOffset.top));
			    if(listOffset.height < (winH - (xy.y + xy.height + 5))){  //Appending at Bottom
			    	lyteMIList.style.top = (xy.y + xy.height + 5) + "px";
			    	$L(lyteMIList).removeClass('lyteMIDropdown__Up');
			    	$L(lyteMIList).addClass('lyteMIDropdown__Down');
			    }
			    else if(listOffset.height < xy.y){  //Appending at Top
			    	lyteMIList.style.top = xy.y - listOffset.height + "px";
			    	$L(lyteMIList).removeClass('lyteMIDropdown__Down');
			    	$L(lyteMIList).addClass('lyteMIDropdown__Up');
			    }
			    else{  //Appending at Bottom Forcefully
			    	var position = getPositionUpOrDown(winH, xy.y, xy.height);
			    	if(position == "up"){
			    		lyteMIList.style.top = "5px";
				    	$L(lyteMIList).height(xy.y - 5);
				    	$L(lyteMIList).addClass('lyteMIAddOverflow','lyteMIDropdown__Up');
			    	}
			    	else{
			    		lyteMIList.style.top = (xy.y + xy.height + 5) + "px";
				    	$L(lyteMIList).height(winH - (xy.y + xy.height + 5) - 5);
				    	$L(lyteMIList).addClass('lyteMIAddOverflow','lyteMIDropdown__Down');
			    	}
			    }
			    if((xy.x + listOffset.width) < textareaOffset.right){
			    	lyteMIList.style.left = xy.x + "px";
			    }
			    else{
			    	var leftVal = (xy.x + xy.width) - listOffset.width;
			    	if(leftVal < 0){
			    		if(xy.x + xy.width <= textareaOffset.left + (textareaOffset.width / 2)){
			    			lyteMIList.style.maxWidth = (textareaOffset.right - xy.x) + "px";
			    			leftVal = xy.x;
			    		}
			    		else{
			    			lyteMIList.style.maxWidth = (listOffset.width + leftVal) - 10 + "px";
			    			leftVal = 10;
			    		}
			    	}
			    	else if(leftVal > textareaOffset.right){
			    		leftVal = textareaOffset.left;
			    	}
					var dropdownRight = leftVal+listOffset.width;
					if(dropdownRight > winWidth) {
						leftVal = leftVal + (winWidth - dropdownRight);
					}
			    	lyteMIList.style.left = leftVal + "px";
			    }
			    
			    if(!scrolled){
					$L(lyteMIList).addClass('lyteMIListAppended');
					if(textarea._mIData.preventParentScroll && !textarea._scrollDisabled) {
						preventParentScroll(lyteMIList, textarea);
					}
					if(textarea._mIData.onBeforeShow){
				    	textarea._mIData.onBeforeShow(lyteMIList,textarea);
				    }
					textarea._prevSelectionStart = textarea.selectionStart;
				}
			    
			}

			var getPositionUpOrDown = function(winH,tATop,tAHeight){
				if((tATop - 5) > (winH - (tATop + tAHeight + 5))){
					return "up";
				}
				else{
					return "down";
				}
			}

			var checkForMaxWidth = function(lyteMIList){
				if(getComputedStyle(lyteMIList).maxWidth === "none"){
					var cs = getComputedStyle(lyteMIList._textarea);
					lyteMIList.style.maxWidth = (parseFloat(cs.width) - (parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight))) + "px";
				}
			}

			//Create the dropdown
			var populateDropdown = function(results){
				if (!results.length) {
			        // hideDropdown();
			        return;
			      }

			      var elmDropDownList = mIManager.createElement('ul');

			      for(var i = 0; i<results.length; i++){
			      	  var liEle = createLiElement(results[i]);
			      	  liEle.addEventListener('click',onSelect,true);
			          
				      if(textarea._mIData.avatars && results[i].avatar){
				      	  var elmIcon = new Image();
				      	  elmIcon.src = results[i].avatar;
				      	  liEle.prepend(elmIcon);
				      }
				      elmDropDownList.append(liEle);
				      liEle = null;
			      }
			      lyteMIList.append(elmDropDownList);
			      if(!lyteMIList._appended){
			      	_lyteUiUtils.appendChild(document.body, lyteMIList);
			      	lyteMIList._appended = true;
			      }
			      onKeyUpOrDown(elmDropDownList.children[0]);
				  if(textarea._mIData.dropdownClass) {
					$L(lyteMIList).addClass(textarea._mIData.dropdownClass);
				  }
			      $L(lyteMIList).addClass('lyteMIHide');
			      $L(lyteMIList).addClass('lyteMIDisplayBlock');
			      checkForMaxWidth(lyteMIList);
			      positionDropdown(lyteMIList);
			      $L(lyteMIList).removeClass('lyteMIHide');
			};

			var filterData = function(responseData){
				var mode = textarea._mIData.mode,
					searchBy = textarea._mIData.searchBy,
					query = mIManager.currentDataQuery,
					results = [];
				if(responseData.length)
                {
                   for(var i = 0; i < responseData.length; i++){
                      	switch(mode){
                          	case 'contains' : {
                              	if(responseData[i][searchBy].trim().toLowerCase().indexOf(query.toLowerCase()) >= 0)
                               	  {
                                      results.push(responseData[i]);
                                  }
                              break;    
                           	}
                           	case 'startsWith' : {
                                if(responseData[i][searchBy].trim().toLowerCase().startsWith(query.toLowerCase()))
                                   {
                                      results.push(responseData[i]);
                                   }
                                break;
                           	}
                           	case 'endsWith' : {
                                if(responseData[i][searchBy].trim().toLowerCase().endsWith(query.toLowerCase()))
                                   {
                                        results.push(responseData[i]);
                                   }
                                break;
                           	}
                        }  
                    }

                    populateDropdown(textarea._mIData.allowDuplicates ? results : filterDuplicateResult(results,textarea._mIData.lyteMICollection));
                }
			};

			var trigerSearch = function(){
				var query = mIManager.currentDataQuery;
				if (((textarea._mIData.minChars == 0) || (query && query.length && query.length >= textarea._mIData.minChars))
					&& ((textarea._mIData.maxChars === Infinity) || (query && query.length && query.length <= textarea._mIData.maxChars))) {
      				var responseData = textarea._mIData.onDataRequest(query);
      				if(responseData){
  						if( responseData.then ) {
							Promise.resolve( responseData ).then( function( arg ) {
								if(data.dropbody === false) {
									if(!lyteMIList._appended){
								      	_lyteUiUtils.appendChild(document.body, lyteMIList);
								      	lyteMIList._appended = true;
								    }
									var returnVal = data.displayMentions(arg, query, lyteMIList);
									if(returnVal === undefined || returnVal){
										if(returnVal === "bindClick"){
											textarea._mIData.validateCollections = true;
											var listItems = $L('lyte-mentions-item',lyteMIList);
											for(var i = 0; i<listItems.length; i++){
												listItems[i].addEventListener('click',onSelect,true);
											}
										}
										onKeyUpOrDown(lyteMIList.querySelector('lyte-mentions-item'/*data.listItemTag*/));
										$L(lyteMIList).addClass('lyteMIHide');
									    $L(lyteMIList).addClass('lyteMIDisplayBlock');
									    checkForMaxWidth(lyteMIList);
									    positionDropdown(lyteMIList);
									    $L(lyteMIList).removeClass('lyteMIHide');
									}
								} else {
									populateDropdown(arg);
								}
							}, function(e) {
								console.error(e);
							});
						} else {
							filterData(responseData);
						}
      				}
    			}
			};

			var scrollIntoView = function(parent, element, move ) {
				var offsetTop = element.offsetTop,
				scrollT = parent.scrollTop,
				height = parent.getBoundingClientRect().height,
				elementHeight = element.getBoundingClientRect().height;

				if( move === 'down' 
					&& scrollT + height < offsetTop + elementHeight 
				) {
					parent.scrollTop = parent.scrollTop + offsetTop + elementHeight - ( height + scrollT );
				}
				else if( move === 'up' 
						&& offsetTop < scrollT 
					) {
					parent.scrollTop = offsetTop
				}
			};

			var getElement = function(element, cond){
				var reqdEle = null, tag = element.tagName;
				if(cond == "next"){
					while(element.nextElementSibling){
						if(element.nextElementSibling.tagName === tag){
							reqdEle = element.nextElementSibling;
							break;
						}
						element = element.nextElementSibling;
					}
				}
				if(cond == "prev"){
					while(element.previousElementSibling){
						if(element.previousElementSibling.tagName === tag){
							reqdEle = element.previousElementSibling;
							break;
						}
						element = element.previousElementSibling;
					}
				}
				return reqdEle;
			};

			var getLastIndex = function(message, query){	//gets the particular word without space and returns the index of the query
				// var lastSpaceIndex = message.lastIndexOf(" ");
				// var msg = message.substring(lastSpaceIndex === -1 ? 0 : lastSpaceIndex+1);
					
				// 	// Scenarios to be considered -
				// 	// * Valid if only one @ is present and it is the first alphabet of the word. eg- @sam
				// 	// * Invalid if more than one @ is present.Dropdown should be hidden. eg- @sam@zoho
				// 	// * Invalid if there are more characters or alphabets before @. eg- random@sam
				
				// if((msg.match(new RegExp(query,"g")) || []).length == 1 && (msg.indexOf(query) == 0)){
				// 	return message.lastIndexOf(query);
				// }
				// console.log("from getLastIndex",message);
				var occurences = (message.match(new RegExp(query,"g")) || []).length;
				var lastIndex;
				var withSpace =  data.triggerWithSpace;
				while(occurences > 0 && message){
					lastIndex = message.lastIndexOf(query);
					if(lastIndex == 0){
						return lastIndex;
					}
					if(lastIndex > 0 && (!withSpace || (message.charAt(lastIndex - 1) == " ") || (message.charAt(lastIndex - 1) == "\n"))){
						return lastIndex;
					}
					message = message.substring(0,lastIndex);
					occurences = (message.match(new RegExp(query,"g")) || []).length;
				}
				return -1;
			};

			var omitMentionedFromTextInput = function(message){
				var mentions = textarea._mIData.lyteMICollection;
				if(mentions.length > 0){
					for(var i = mentions.length - 1; i >= 0; i--){
						if(mentions[i].position.end <= message.length){
							return message.substring(mentions[i].position.end);
						}
					}
				}
				return message;
			};


			var isValidQuery = function(query){
				/*Notes : here query.indexOf("\n") > -1 added to fix the currentDataQuery 
				example @someName \n someName here search should not be triggered.
				*/
				if((query.charAt(0) == " ") || (query.charAt(0) == "\n") || query.indexOf("\n") > -1){
					return false;
				}
				return true;
			};


			var triggerChangeEvt = function(textarea){
				var evt;
				if(typeof(Event) === 'function') {
				    evt = new Event('change');
				}else{
				    evt = document.createEvent('Event');
				    evt.initEvent('change', true, true);
				}
				textarea.dispatchEvent(evt);
			};

			/*--------------------------- UTILITY FUNCTIONS END ----------------------------*/

			/*--------------------------- INITIALIZATION STARTS -------------------------*/

			if(typeof object === "string"){
				if(object === "setMessage"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						if(typeof arguments[1] === "object"){
							if(textarea.value){
								this.mentionsInput('reset');
							}
							var message = arguments[1].message;
							var mentionText = message;
							var collection = arguments[1].collection ? arguments[1].collection : textarea._mIData.onDataRequest();
							var newCollection = [],
							msgArr = [],
							currMsg = message;
							collection.forEach(function(mention){
								mention = copyObject(mention);
								var mentionObj = {id : mention.id, value : mention[textarea._mIData.searchBy]};
								var textSyntax = textarea._mIData.triggerChar+mIManager.mentionsSyntax(mentionObj);
								var index = message.indexOf(textSyntax);
		        
								if(index != -1){
									var ind = currMsg.indexOf(textSyntax);
									msgArr.push(currMsg.substring(0,ind));
									currMsg = currMsg.substring(ind+textSyntax.length);

									mention.position = {start : index, end : index + mentionObj.value.length};
									newCollection.push(mention);
									var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>"+mentionObj.value+"</span></strong>";
									message = message.replace(textSyntax,mentionObj.value);
									mentionText = mentionText.replace(textSyntax,textHighlight);
									msgArr.push(textHighlight);
								}
							});
							msgArr.push(currMsg);
							mentionText = mentionText.replace(/\n/g, '<br />');
						    mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');
						    if(textarea._callee && textarea._callee.tagName == "LYTE-INPUT"){
						    	textarea._callee.ltProp('value',message);
						    }
						    else{
						    	textarea.value = message;
						    }
						    textarea._mIData.syntaxMessage = arguments[1].message + " ";
						    // textarea._mIData._overlayDiv.innerHTML = mentionText;
						    msgArr.forEach(function(text,index){
						    	if(index%2 == 0){
						    		var textNode = document.createTextNode(text);
						    		textarea._mIData._overlayDiv.appendChild(textNode);
						    	}
						    	else{
						    		textarea._mIData._overlayDiv.innerHTML = textarea._mIData._overlayDiv.innerHTML + text;
						    	}
						    });
						    textarea._mIData.lyteMICollection = newCollection;
						    triggerChangeEvt(textarea);
							if(textarea._mIData.removeHighlightCompletely){
								textarea._valueMap = {
									oldSyntax: arguments[1].message,
									oldText: message
								};
							}
						 //    var evt;
							// if(typeof(Event) === 'function') {
							//     evt = new Event('change');
							// }else{
							//     evt = document.createEvent('Event');
							//     evt.initEvent('change', true, true);
							// }
							// textarea.dispatchEvent(evt);
							textarea.focus();	
						}
						else{

							if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
							console.error("Inappropriate arguments passed. Please pass an object containing a message and a collection to be set.");
							return null;
						}
					}
					else{
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "getMessage"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						return (textarea._mIData.syntaxMessage ? textarea._mIData.syntaxMessage : textarea.value);
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "getCollection"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						return textarea._mIData.lyteMICollection;
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "destroy"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						textarea.removeAttribute('data-lyte-mentions');
						if(textarea._mIData.removeHighlightCompletely) { 
							textarea.removeEventListener('mouseup',textarea._lyteMenIpMouseUpEvent);
							delete textarea._lyteSetSelection;
							delete textarea._lyteMenIpMouseUpEvent;
						}
						if(textarea.scrollableParents && textarea._scrollDisabled) {
							disableParentListeners(textarea);
						}
						var wrapper = textarea.parentElement;
						_lyteUiUtils.insertBefore(wrapper,textarea);
						textarea._mIData._overlayDiv = null;
						textarea._mIData.lyteMIList._textarea = null;
						textarea._mIData.element = null;
						textarea._mIData.lyteMIList.remove();
						textarea._mIData.lyteMIList = null;
						textarea._mIData = null;
						wrapper.remove();
						textarea.removeEventListener('keydown', textarea._lyteMenIpKeydownEvent);
				    	textarea.removeEventListener('keypress', textarea._lyteMenIpKeypressEvent);
				    	textarea.removeEventListener('input', textarea._lyteMenIpInputEvent);
				    	// textarea.removeEventListener('click', textarea._lyteMenIpClickEvent, true);
				    	// textarea.removeEventListener('blur', textarea._lyteMenIpBlurEvent);
				    	textarea.removeEventListener('paste', textarea._lyteMenIpPasteEvent);
				    	textarea.removeEventListener('input',textarea._closureEvnt);
				    	textarea.removeEventListener('change',textarea._closureEvnt);
						delete textarea._prevSelectionStart;
				    	delete textarea._lyteMenIpKeydownEvent;
				    	delete textarea._lyteMenIpKeypressEvent;
				    	delete textarea._lyteMenIpInputEvent;
				    	delete textarea._lyteMenIpClickEvent;
				    	delete textarea._lyteMenIpBlurEvent;
				    	delete textarea._closureEvnt;
						delete textarea._lyteMenIpPasteEvent;
						delete textarea._valueMap;
						delete textarea._selection;
						delete textarea._mIData;
						delete textarea._lytePosDropdown;
						delete textarea._lyteHideDropdown;
						delete textarea.triggerInputEvent;
						delete textarea._lyteDisableParentScrollListeners;
				    	if(mIManager.bindResize && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		window.removeEventListener('resize', mIManager.callAtTheEndOfResize);
				    		mIManager.bindResize = false;
				    	}
				    	if(mIManager.bindClick && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.body.removeEventListener('click', mIManager.onClick, true);
							mIManager.onClick = null;
				    		mIManager.bindClick = false;
				    	}
				    	if(mIManager.bindScroll && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		window.removeEventListener('scroll', mIManager.onScroll, true);
							mIManager.onScroll = null;
				    		mIManager.bindScroll = false;
				    	}
						if(mIManager.bindSelect && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.body.removeEventListener('selectionchange', mIManager.onSelection, true);
							mIManager.onSelection = null;
				    		mIManager.bindSelect = false;
				    	}
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "reset"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						if(textarea._callee && textarea._callee.tagName == "LYTE-INPUT"){
					    	textarea._callee.ltProp('value', '');
					    }
					    else{
					    	textarea.value = '';
					    }
						if(textarea._mIData.removeHighlightCompletely){
							textarea._valueMap = {
								newText : "",
								newSyntax: ""
							};
							updateAdvancedCollections("");
							advancedModifyNodeContent("");
						}
						else {
							modifyNodeContent();
							updatelyteMICollection();
						}
						triggerChangeEvt(textarea);
						// var evt;
						// if(typeof(Event) === 'function') {
						//     evt = new Event('change');
						// }else{
						//     evt = document.createEvent('Event');
						//     evt.initEvent('change', true, true);
						// }
						// textarea.dispatchEvent(evt);
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				return true;
			}
			var data = object ? object : {};
			var element;

			if(this.length > 1){
				var elemArray = this;
				for(var i=0; i<elemArray.length; i++){
					if(elemArray[i].tagName == "LYTE-INPUT" && elemArray[i].ltProp('type') == "textarea"){
						var elem = elemArray[i].querySelector('textarea');
						var copyData = Object.assign({},data);
						copyData.isLyteInput = true;
						$L(elem).mentionsInput(Object.assign({},copyData));
					}
					else{
						$L(elemArray[i]).mentionsInput(Object.assign({},data));
					}
					
				}
				return;
			}
			else{
				if(this[0].tagName == "LYTE-INPUT" && this[0].ltProp('type') == "textarea"){
					element = this[0].querySelector('textarea');
					data.isLyteInput = true;
				}
				else{
					element = this[0];
				}
			}
			if(element.getAttribute('data-lyte-mentions')){
				if(element._mIData){
					element._mIData.mode = data.mode ? data.mode : element._mIData.mode;
					element._mIData.activeItem = data.activeItem ? data.activeItem : element._mIData.activeItem;
					element._mIData.triggerChar = data.triggerChar ? data.triggerChar : element._mIData.triggerChar;
					element._mIData.minChars = data.minChars == undefined ? element._mIData.minChars : parseInt(data.minChars);
					element._mIData.maxChars = data.maxChars === undefined ? element._mIData.maxChars : parseInt(data.maxChars);
					element._mIData.avatars = data.avatars == undefined ? element._mIData.avatars : data.avatars;
					element._mIData.searchBy = data.searchBy ? data.searchBy : element._mIData.searchBy;
					element._mIData.dropbody = data.dropbody == undefined ? element._mIData.dropbody : data.dropbody;
					element._mIData.listItemTag = data.listItemTag == undefined ? element._mIData.listItemTag : data.listItemTag;
					element._mIData.interval = data.interval ? parseInt(data.interval) : element._mIData.interval;
					element._mIData.onDataRequest = data.onDataRequest ? data.onDataRequest : element._mIData.onDataRequest;
					element._mIData.onAdd = data.onAdd ? data.onAdd : element._mIData.onAdd;
					element._mIData.onBeforeAdd = data.onBeforeAdd ? data.onBeforeAdd : element._mIData.onBeforeAdd;
					element._mIData.onRemove = data.onRemove ? data.onRemove : element._mIData.onRemove;
					element._mIData.displayMentions = data.displayMentions ? data.displayMentions : element._mIData.displayMentions;
					element._mIData.onHide = data.onHide ? data.onHide : element._mIData.onHide;
				}
				else{
					element._mIData = data;
					console.error("ALERT ! You are trying to bind mentions behaviour to a textarea which already has it enabled. Please don't call it twice to avoid abnormal behaviour.");
				}
				return this;
			}
			element.setAttribute('data-lyte-mentions',true);
			//Initialize values
			data.element = element;
			data.mode = data.mode ? data.mode : "contains"; //contains,startsWith, endsWith
			data.activeItem = data.activeItem ? data.activeItem : "lyteMIActive";
			data.triggerChar = data.triggerChar ? data.triggerChar : '@';
			data.minChars = data.minChars == undefined ? 1 : parseInt(data.minChars);
			data.maxChars = data.maxChars === undefined ? Infinity : parseInt(data.maxChars);
			data.avatars = data.avatars == undefined ? true : data.avatars;
			data.searchBy = data.searchBy ? data.searchBy : "name";
			data.lyteMICollection = [];
			data.dropbody = data.dropbody == undefined ? true : data.dropbody;
			data.listItemTag = data.listItemTag == undefined ? 'li' : data.listItemTag;
			data.interval = data.interval ? parseInt(data.interval) : 0;
			data.allowDuplicates = data.allowDuplicates ? true : false;
			data.removeHighlightCompletely = data.removeHighlightCompletely? true : false;
			data.triggerWithSpace =  data.triggerWithSpace === undefined? true : data.triggerWithSpace;
			data.appendSpaceOnAdd = data.appendSpaceOnAdd === undefined? true : data.appendSpaceOnAdd;
			data.dropdownClass =  data.dropdownClass === undefined ? "" : data.dropdownClass;
			data.preventParentScroll = data.preventParentScroll === undefined ? false : data.preventParentScroll;
			var clickEvent = function(event){
				resetBuffer();
			};

			var inputEvent = function(event){
				textarea = this;
				lyteMIList = textarea._mIData.lyteMIList;
				// console.log("inputEvent",cursorPos.prev,event);
				if(textarea._mIData.removeHighlightCompletely) {
					var skipUpdate;
					var valueMap = textarea._valueMap;
					if(valueMap.undoAndRedo){
						if(valueMap.oldText === textarea.value) {
							skipUpdate = true;
						}
						delete valueMap.undoAndRedo;
					} ;
					var selection = textarea._selection;
					var range = {
						start : selection.start,
						end : selection.end,
						currentEnd : textarea.selectionEnd
					};
					var returnValue = skipUpdate ?{newValue:valueMap.oldSyntax}:updateMentions(textarea.value,range);
					var newMappedValue = returnValue.newValue;
					var selectionEnd = returnValue.selectionEnd;
					valueMap.newSyntax = newMappedValue;
					var newText = getText(newMappedValue);
					var removed = updateAdvancedCollections(newMappedValue);
					advancedModifyNodeContent(newText);
					if(removed) {
						textarea.value = newText;
						setSelectionPosition(selectionEnd);
					}
					setSelection(textarea);
				}
				else {
					modifyNodeContent();
				}
				if(textarea._mIData.dropbody || textarea._mIData.validateCollections){
					!data.removeHighlightCompletely && updatelyteMICollection();
				}
				 // updateCollectionPosition(textarea);
	        	 hideDropdown();
	        	 getInputBuffer(textarea);
	        	 // console.log("input",mIManager.inputBuffer);
	        	 // var triggerCharIndex = findLastIndex(mIManager.inputBuffer, textarea._mIData.triggerChar); //Returns the last match of the triggerChar in the inputBuffer
	        	 var triggerCharIndex = getLastIndex(mIManager.inputBuffer.join(''), textarea._mIData.triggerChar);
	        	 if (triggerCharIndex > -1 && isValidQuery(mIManager.inputBuffer.slice(triggerCharIndex + 1).join(''))) { //If the triggerChar is present in the inputBuffer array
	        	 	if(mIManager.searchTriggeredId){
	        	 		clearTimeout(mIManager.searchTriggeredId);
	        	 		mIManager.searchTriggeredId = false;
	        	 	}
	        	 	mIManager.searchTriggeredId = setTimeout(function(){
	        	 		mIManager.searchTriggeredId = false;
	        	 		currentDataQuery = mIManager.inputBuffer.slice(triggerCharIndex + 1).join(''); //Gets the currentDataQuery
		        	    mIManager.currentDataQuery = currentDataQuery/*mIManager.ltrim(currentDataQuery)*/; //Deletes the whitespaces
		        	    // console.log("before requesting",mIManager.currentDataQuery);
		        	    trigerSearch(); //Invoking the function trigerSearch
	        	 	},textarea._mIData.interval);
	        	 }
	        	 else{
	        	 	if(mIManager.searchTriggeredId){
	        	 		clearTimeout(mIManager.searchTriggeredId);
	        	 		mIManager.searchTriggeredId = false;
	        	 	}
	        	 }
			};

			var getInputBuffer = function(textarea){
				var currentMessage = textarea.value || "";
				mIManager.inputBuffer = [];
				// var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
				if(textarea.selectionStart < textarea.selectionEnd/* && typedValue*/){
					currentMessage = currentMessage.substring(0,textarea.selectionStart);
					// mIManager.inputBuffer = [];
				}
				currentMessage = omitMentionedFromTextInput(currentMessage.substring(0,textarea.selectionEnd))/* + typedValue*/;
				// console.log("message in keypress",currentMessage);
				var triggerCharIndex = getLastIndex(currentMessage, textarea._mIData.triggerChar)/*currentMessage.lastIndexOf(textarea._mIData.triggerChar)*/;
				if(triggerCharIndex > -1){
					var bufferMessage = currentMessage.substring(triggerCharIndex)/* + typedValue*/;
					mIManager.inputBuffer = bufferMessage.split("");
				}
			};
			var initializeSelection= function() {
				if(!mIManager.bindSelect) {
					mIManager.onSelection = function(){
						var activeElement = document.activeElement;
						if(activeElement.getAttribute("data-lyte-mentions")) {
							activeElement._lyteSetSelection(activeElement);
						}
					};
					document.body.addEventListener('selectionchange',mIManager.onSelection,true);
					mIManager.bindSelect = true;
				}
			};
			var keypressEvent = function(event){
				textarea = this;
				// console.log("calling from key press"+mIManager.inputBuffer+"===="+String.fromCharCode(event.which || event.keyCode))
				var KEY = mIManager.KEY;
				if((event.keyCode === KEY.LEFT && event.key !== "%") || (event.keyCode === KEY.RIGHT && event.key !== "'") || (event.keyCode === KEY.HOME && event.key !== "$") || (event.keyCode === KEY.END && event.key !== "#") || (event.keyCode === KEY.UP && event.key !== "&") || (event.keyCode === KEY.DOWN && event.key !== "(") || event.keyCode === KEY.BACKSPACE || event.keyCode === KEY.TAB || event.keyCode === KEY.RETURN || event.keyCode === KEY.ESC || event.key === "Shift" || event.key == "Control" || event.key == "Alt" || event.key == "Meta"){
					return;
				}
				// if(mIManager.inputBuffer.length != 0 || (mIManager.inputBuffer.length == 0 && textarea.selectionStart == 0) || textarea._addedMentions){
					// var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
    //   				mIManager.inputBuffer.push(typedValue);
    //   				textarea._addedMentions = false;
    //   				console.log("pushing it",mIManager.inputBuffer);
				// }
				// else{	//when the cursor is taken out of the textarea and again it is cliked to type any alphabet
					// console.log("calling it",mIManager.inputBuffer);
					var currentMessage = textarea.value || "";
					var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
					if(textarea.selectionStart < textarea.selectionEnd && typedValue){
						currentMessage = currentMessage.substring(0,textarea.selectionStart) + typedValue;
						mIManager.inputBuffer = [];
					}
					currentMessage = omitMentionedFromTextInput(currentMessage.substring(0,textarea.selectionStart)) + typedValue;
					// console.log("message in keypress",currentMessage);
					var triggerCharIndex = getLastIndex(currentMessage, textarea._mIData.triggerChar)/*currentMessage.lastIndexOf(textarea._mIData.triggerChar)*/;
					if(triggerCharIndex > -1){
						var bufferMessage = currentMessage.substring(triggerCharIndex)/* + typedValue*/;
						mIManager.inputBuffer = bufferMessage.split("");
					}
				// }
			};

			var keydownEvent = function(event){
				textarea = this;
				var KEY = mIManager.KEY;
				// This also matches HOME/END on OSX which is CMD+LEFT, CMD+RIGHT
	            if (event.keyCode === KEY.LEFT || event.keyCode === KEY.RIGHT || event.keyCode === KEY.HOME || event.keyCode === KEY.END) {
	                // Defer execution to ensure carat pos has changed after HOME/END keys then call the resetBuffer function
	                // _.defer(resetBuffer);
	                postpone(resetBuffer);

	                return;
	            }
				if(data.removeHighlightCompletely) {
					setSelection(textarea);
				}
	            //If the key pressed was the backspace or cut(ctrl+x or cmd+x) or 
	            //to clear the text to ths left of the cursor in that line by pressing cmd+backspace in mac
	            if (event.keyCode === KEY.BACKSPACE || ((event.metaKey || event.ctrlKey) && event.keyCode == 88)) {
	            	var length = textarea.selectionStart - textarea.selectionEnd;
	            	// var userDeleted = checkForDeletedUser(textarea);
	            	// if(userDeleted){
	            	// 	event.preventDefault();
	            	// }
					// console.log("keydown delete or remove",textarea.selectionStart,textarea.selectionEnd);
	            	if(Math.abs(length) > mIManager.inputBuffer.length || (event.metaKey && (event.keyCode === KEY.BACKSPACE))/* || userDeleted*/){
						mIManager.inputBuffer = [];
	            	}
	            	else{
	            		mIManager.inputBuffer = mIManager.inputBuffer.slice(0, (length == 0 ? -1 : length) + mIManager.inputBuffer.length); // Can't use splice, not available in IE
	            	} 
	                return;
	            }

	            //if key pressed is undo(ctrl+z or cmd+z), then hide the dropdown and empty the inputBuffer
	            if(((event.metaKey || event.ctrlKey) && event.keyCode == 90)){
					if(data.removeHighlightCompletely) {
						textarea._valueMap.undoAndRedo = true;
					}
	            	resetBuffer();
	            }

	            //If the lyteMIList is hidden
	            if(!lyteMIList){
	            	lyteMIList = textarea._mIData.lyteMIList;
	            }
	            if ($L(lyteMIList).css("display") != "block") {
	            	// keypressEvent.call(this, event);
	                return ;
	            }

	            switch (event.keyCode) {
	                case KEY.UP: //If the key pressed was UP or DOWN
	                case KEY.DOWN:
	                    var lyteMICurrentItem = null, move;
	                    if (event.keyCode === KEY.DOWN) { //If the key pressed was DOWN
	                        if (lyteMIActiveItem && lyteMIActiveItem.length) { //If lyteMIActiveItem exits
	                        	lyteMICurrentItem = getElement(lyteMIActiveItem[0], "next"); //Gets the next li element in the list
	                            // lyteMICurrentItem = lyteMIActiveItem[0].nextElementSibling; 
	                        	move = "down";
	                        } else {
	                            lyteMICurrentItem = lyteMIList.querySelector('lyte-mentions-item'/*textarea._mIData.listItemTag*/); //Gets the first li element found
	                        	move = "up";
	                        }
	                    } else {
	                    	lyteMICurrentItem = getElement(lyteMIActiveItem[0], "prev"); //The key pressed was UP and gets the previous li element
	                        // lyteMICurrentItem = lyteMIActiveItem[0].previousElementSibling; 
	                    	move = "up";
	                    }
	                    if (lyteMICurrentItem) {
	                        onKeyUpOrDown(lyteMICurrentItem);
	                        scrollIntoView(lyteMIList, lyteMICurrentItem, move);
	                    }
	                    event.preventDefault();
	                    event.stopPropagation();
	                    break;
	                case KEY.RETURN: //If the key pressed was RETURN or TAB
	                case KEY.TAB:
	                    if (lyteMIActiveItem && lyteMIActiveItem.length) {
				            // lyteMIActiveItem[0].click();
				            lyteMIActiveItem[0].dispatchEvent(new Event('click'));
				            event.preventDefault();
				            event.stopPropagation();
				          }
	                	break;
	                // default:
	                // 	keypressEvent.call(this, event);
	            }
	            return;
			};

			var blurEvent = function(event){
				hideDropdown(event.target);
			};

			var mouseoverEvent = function(event){
				textarea = event.currentTarget._textarea;
				var target = event.target.closest('lyte-mentions-item'/*textarea._mIData.listItemTag*/);
				onKeyUpOrDown(target);
			};

			var setSelection = function(textarea){
				textarea._selection = {
					start:textarea.selectionStart,
					end: textarea.selectionEnd
				}
			};

			var iterateMentions = function(value, markupIterator, textIterator) {
				var regex = new RegExp(textarea._mIData.triggerChar+"\\[(.+?)\\:(.+?)\\]",'gi');
				regex =  new RegExp(regex);
				var match;
				var start = 0;
				var currentTextIndex = 0;
				var offset = textarea._mIData.triggerChar.length + 1;
				while ((match = regex.exec(value)) !== null) {
					var id = match[2];
					var matchedValue = match[1];
					var substr = value.substring(start, match.index);
					textIterator(substr, start, currentTextIndex);
					currentTextIndex += substr.length
					markupIterator(match[0],match.index,currentTextIndex,id,matchedValue);
					currentTextIndex += matchedValue.length;
					start = regex.lastIndex;
				}

				if (start < value.length) {
					textIterator(value.substring(start), start, currentTextIndex);
				}
			};

			var getText = function(value) {
				var result = '';
				var textIterator = function(matchedValue) {
					result += matchedValue;
				};
				var markupIterator = function(markup,index,mentionTextIndex,id,text) {
					result += text;
				}
				iterateMentions(value,markupIterator,textIterator);
				return result;
			}
			var mapTextIndex = function(value, indexInText, operation){
				if (typeof indexInText !== 'number') {
				  return indexInText;
				}
			  
				var result;
				var textIterator = function(substr, index, substrTextIndex) {
				  if (result !== undefined) {
					return;
				  } 
				  if (substrTextIndex + substr.length >= indexInText) {
					result = index + indexInText - substrTextIndex;
				  }
				}
				var markupIterator = function(markup,index,mentionTextIndex,id,display) {
				  if (result !== undefined){
					return;
				  } 
			  
				  if (mentionTextIndex + display.length > indexInText) {
					if (!operation) {
						result = null;
					} else {
					  result = index + (operation === 'end' ? markup.length : 0)
					}
				  }
				}
				iterateMentions(value, markupIterator, textIterator);
				return result === undefined ? value.length : result;
			};

			var updateMentions = function( newText, range) {
				var valueMap = textarea._valueMap;
				var oldText = valueMap.oldText;
				var oldSyntaxString = valueMap.oldSyntax;
				var prevStart = range.start,
				prevEnd = range.end,
				currentEnd = range.currentEnd;
				var delta  = oldText.length -  newText.length;
				// console.log(prevStart,prevEnd,currentEnd);
				if (prevStart === undefined) {
					prevStart = currentEnd + delta;
				}

				if (prevEnd === undefined) {
					prevEnd = prevStart;
				}

				if (prevStart === prevEnd && prevEnd === currentEnd && oldText.length === newText.length) {
					prevStart = prevStart - 1;
				}
				
				
				var insert = newText.slice(prevStart, currentEnd);
				var start = Math.min(prevStart, currentEnd);
				var end = prevEnd;
				if (prevStart === currentEnd) {
					end = Math.max(prevEnd, prevStart + delta);
				}

				var mappedStart = mapTextIndex(oldSyntaxString, start, 'start');
				var mappedEnd = mapTextIndex(oldSyntaxString, end, 'end');
				var mismatchedStart = mapTextIndex(oldSyntaxString, start);
				var mismatchedEnd = mapTextIndex(oldSyntaxString, end);
				var willRemove = mismatchedStart === null || mismatchedEnd === null;
				var newValue = oldSyntaxString.substring(0, mappedStart) + insert + oldSyntaxString.substring(mappedEnd);
				var returnObject = {};
				//TO handle undo and redo mismatch.
				var oldTextValue = getText(oldSyntaxString.substring(0, mappedStart));
				returnObject.selectionEnd = oldTextValue.length +  insert.length;
				if(!willRemove) {
					var mismatchedValue = getText(newValue);
					var maxCount = 50;
					var loopCount = 0;
					while (mismatchedValue !== newText && loopCount <= maxCount ) {
						start = 0;
						while (newText[start] === mismatchedValue[start]){
							start++;
						}
						insert = newText.slice(start, currentEnd);

						// find index of the unchanged remainder
						end = oldText.lastIndexOf(newText.substring(currentEnd));

						// re-map the corrected indices
						mappedStart = mapTextIndex(oldSyntaxString, start, 'start');
						mappedEnd = mapTextIndex(oldSyntaxString, end, 'end');
						newValue = oldSyntaxString.substring(0, mappedStart) + insert + oldSyntaxString.substring(mappedEnd);
						mismatchedValue = getText(newValue);
						loopCount++;
					}
					if(loopCount > maxCount) {
						console.warn("lyte mentionsInput match failed");
					}
				}
				returnObject.newValue = newValue;
				return returnObject;
			};

			var mouseupEvent = function(event){
				setSelection(event.target);
			};

			var pasteEvent = function(event){
				textarea = this;
				// console.log("pasteEvent",textarea.selectionStart,textarea.selectionEnd);
				if(textarea.selectionStart == textarea.selectionEnd){
					// var paste = textarea.value + (event.clipboardData || window.clipboardData).getData('text');
					var paste = omitMentionedFromTextInput(textarea.value) + (event.clipboardData || window.clipboardData).getData('text');
				}
				else{
					var paste = textarea.value.substring(0,textarea.selectionStart) + (event.clipboardData || window.clipboardData).getData('text');
					var restMsg = textarea.value.substring(textarea.selectionEnd);
					if(restMsg.length > 0){
						var lastSpaceIndex = restMsg.indexOf(' ');
						paste += restMsg.substring(0,(lastSpaceIndex > -1 ? lastSpaceIndex : restMsg.length));
					}
				}
				mIManager.inputBuffer = paste.split("");
			};

			var triggerInputEv = function(){
	    		var evt;
				if(typeof(Event) === 'function') {
				    evt = new Event('input');
				}else{
				    evt = document.createEvent('Event');
				    evt.initEvent('input', true, true);
				}
	    		element.dispatchEvent(evt);
	    	};

			/*---------------- BIND EVENTS AND DATA ------------------*/

			data.lyteMIList = mIManager.init(element);
			data.lyteMIList._textarea = element;
			data._overlayDiv = element.previousElementSibling.children[0];
			if (!data.isLyteInput) {
				$L(element.previousElementSibling).addClass('lyteMentionsNormalTextarea');
			}
	        element._mIData = data;
	        element._lyteMenIpKeydownEvent = keydownEvent;
	        element._lyteMenIpKeypressEvent = keypressEvent;
	        element._lyteMenIpInputEvent = inputEvent;
	        element._lyteMenIpClickEvent = clickEvent;
	        element._lyteMenIpBlurEvent = blurEvent;
	        element._lyteMenIpPasteEvent = pasteEvent;
			element._lyteHideDropdown = hideDropdown;
			element._lytePosDropdown = positionDropdown;
			element._valueMap = {oldText: "", oldSyntax: ""};
			element._selection = {};
			element._lyteDisableParentScrollListeners = disableParentListeners;
	    	element.addEventListener('keydown', element._lyteMenIpKeydownEvent);
	    	// element.addEventListener('keypress', element._lyteMenIpKeypressEvent);	/*Removed keypress as it is not supported by mobile browsers*/
	    	element.addEventListener('input', element._lyteMenIpInputEvent);
	    	element.triggerInputEvent = triggerInputEv;
	    	// element.addEventListener('click', element._lyteMenIpClickEvent, true);
	    	// element.addEventListener('blur', element._lyteMenIpBlurEvent);
	    	element.addEventListener('paste', element._lyteMenIpPasteEvent);
	    	data.lyteMIList.addEventListener('mouseover',mouseoverEvent);
			if(element._mIData.removeHighlightCompletely) {
				element._lyteSetSelection = setSelection;
				element._lyteMenIpMouseUpEvent = mouseupEvent;
				element.addEventListener('mouseup', element._lyteMenIpMouseUpEvent);
				initializeSelection();
			}
	    	if(!mIManager.bindScroll){
	    		mIManager.onScroll = function(event){
	    			if(!event || !event.target || event.target.isEqualNode(document) || event.target.tagName == "HTML" || event.target.closest('.lyteMIDropdown')){
	    				return;
	    			}
	    			var elems = document.querySelectorAll('.lyteMIListAppended');
	    			if(elems.length > 0){
	    				for(var i = 0; i<elems.length; i++){
	    					positionDropdown(elems[i],true);
	    				}
	    			}
	    		}
	    		window.addEventListener('scroll',mIManager.onScroll,true);
	    		mIManager.bindScroll = true;
	    	}
	    	if(!mIManager.bindClick){
	    		mIManager.onClick = function(event){
	    			var target = event.target;
	    			while(target){
	    				if((target.tagName === "TEXTAREA" && target.getAttribute('data-lyte-mentions') === "true") || target.tagName == "HTML"){
	    					break;
	    				}
	    				target = target.parentElement;
	    			}
	    			if(target && target.tagName === "TEXTAREA"){
	    				target._lyteMenIpClickEvent(event);
	    				var openLists = document.querySelectorAll('.lyteMIDropdown.lyteMIDisplayBlock');
	    				for(var i = 0; i < openLists.length; i++){
	    					if(!(target._mIData.lyteMIList.isEqualNode(openLists[i]))){
								var textarea = openLists[i]._textarea;
	    						textarea._lyteHideDropdown(openLists[i]._textarea);
	    					}
	    				}
	    				target._addedMentions = false;
	    			}
	    			else if(target && target.tagName === "HTML"){
	    				var openLists = document.querySelectorAll('.lyteMIDropdown.lyteMIDisplayBlock');
	    				for(var i = 0; i < openLists.length; i++){
							var textarea = openLists[i]._textarea;
	    					textarea._lyteHideDropdown(textarea,openLists[i]);
	    				}
	    			}
	    		}
	    		document.body.addEventListener('click',mIManager.onClick,true);
	    		mIManager.bindClick = true;
	    	}
	    	/*---------------------------------------------------------*/

	    	/*--------------------------- INITIALIZATION ENDS -------------------------*/

	    	return this;
		}
		
	}

})( window );

	;(function(window){
		var elData, AniData,
		curves = {
			'ease-in': function( t ) {
				return t * t;
			},

			'ease-out': function( t ) {
				return t * ( 2 - t );
			},

			'linear': function( t ) {
				return t;
			},

			'ease-in-out': function( t ) {
				return t < 0.5 ? ( 2 * t * t ) : ( -1 + ( 4 - 2 * t ) * t );
			}
		};

		$L.Tween = {
			propHooks: {}
		};

		function firecallback( item ) {
			var anidata = AniData.data[ item.lyteAnimateId ][ 0 ],
			opts = ( anidata || {} ).options,
			complete = ( opts || {} ).complete,
			props, param = {}, aniProp;

			if( complete ) {
				props = elData.get( item, 'animeProp', 'animate' );
				aniProp = elData.get( item, 'animeProp' );
				param.transitionProperty = props;
				param.from = aniProp.from;
				param.to = aniProp.to;
				param.startTime = aniProp.startTime;

				complete.call( item, param );
			}
		}

		function mapOnCurve( t, timingFunction ) {
			return curves[ timingFunction ]( t );
		}

		function progress( prop, final, before, diff, initial, total, remaining, timingFunction, obj, data ) {
			var now = Date.now(),
			change = now - before,
			remaining = remaining - change,
			elapsed = total - remaining,
			tweenProps = $L.Tween.propHooks[ prop ], t, multiplier;

			elapsed = remaining < 0 ? total : elapsed;
			t = elapsed / total;
			multiplier = mapOnCurve( t, timingFunction );

			if( 'set' in tweenProps ) {
				tweenProps.set( obj, initial + diff * multiplier, data );
			}
			else {
				this[ prop ] = initial + ( diff * multiplier );
			}

			/**
			 * When .stop is called inside the set in scrollTo plugin
			 * we were cancelling the current request animation frames instead
			 * of preventing the next one from happening
			 * so we are using this flag to determine when it needs to be stopped
			 * We still had to cancel the rAFs though because
			 * we register scrollLeft and scrollTop rAFs
			 * If the rAF of scrollLeft is responsible for cancelling the animation with .stop
			 * we need to prevent the rAF of scrollTop from firing and calling the .stop again
			 *
			 */
			if( data._stopped ) {
				return ;
			}
			
			if( remaining > 0 ) {
				this[ 'rAF' + prop ] = window.requestAnimationFrame( 
					progress.bind( 
						this, 
						prop, 
						final, 
						now, 
						diff, 
						initial, 
						total, 
						remaining, 
						timingFunction, 
						obj,
						data 
				) );

			}
			else {
				tryDequeue( obj.get( 0 ), false );
			}

		}

		function animateNonStandard( prop, final, element ) {
			var now = Date.now(),
			obj = $L( element ),
			tweenProps = $L.Tween.propHooks[ prop ],
			initial = getCurrentValueForNonStandards( prop, obj ),
			diff = final - initial,
			data = AniData.data[ element.lyteAnimateId ][ 0 ].options,

			// If duration is 0 make sure it is 1
			duration = data.duration || 1,
			aniProps = elData.get( element, 'animeProp' ),
			timingFunction,
			start = data.start,

			// fired is going to tell us whether start has fired or not
			fired = data.fired;

			// We don't do ease functions over here
			timingFunction = data.timingFunction = ( data.timingFunction === 'ease' ? 'ease-in-out' : data.timingFunction );

			if( start && !fired ) {
				data.fired = true;

				start.call( element, {
					options: data,
					from: aniProps.from,
					to: aniProps.to,
					value: data.value,
					startTime: now,

					// I think the target is wrong over here and over there in standard start section
					// TODO: fix target
					target: element,
					transitionProperty: Object.keys( aniProps.to )
				} );
			}

			element[ 'rAF' + prop ] = window.requestAnimationFrame( 
				progress.bind( 
					element, 
					prop, 
					final, 
					now, 
					diff, 
					initial, 
					duration, 
					duration, 
					timingFunction, 
					obj,
					data
			 ) );
		}

		// compStyles can be undefined when we are searching for a window
		function isStandard( prop, compStyles ) {
			return prop in ( compStyles || {} );
		}

		function getCurrentValueForNonStandards( key, obj ) {
			var tweenProps = $L.Tween.propHooks[ key ];

			if( 'get' in tweenProps ) {
				return tweenProps.get( obj );
			}
		
			return obj.get( 0 )[ key ];	
		}

		/**
		 * This tries to dequeue the animateProperty from the queue
		 * @param {DOMElement} item - item whose animation needs to be dequeued
		 * @param {Boolean} standard - whether it is a standard or a non standard property
		 *
		 */

		function tryDequeue( item, standard ) {
			if( !AniData.data[ item.lyteAnimateId ][ 0 ] ){
				return;
			}
			var anidata = AniData.data[ item.lyteAnimateId ][ 0 ],
			nsC = anidata.nonstandard || 0, 
			comp_standard = anidata.standard, 
			animates = elData.get( item, 'animeProp', 'animate' ) || [],
			comp_ns;

			// if( !animates.length ) {
			// 	return ;
			// }

			if( standard ) {
				anidata.standard = comp_standard = true;
			}
			else {
				nsC--;
				anidata.nonstandard = nsC;
			}

			// never going to be lesser but just a safety
			comp_ns = nsC <= 0 ? true : false; 

			// Both standard and non standard animations have completed
			if( comp_standard && comp_ns ) {
				AniData.dequeue( item );
			}
		}

		function getDefaultDisplay( elem ) {
			if( !elem.lyteAnimateId ) {
				AniData.add( elem );
			}
			var nodeName = elem.nodeName, display = elData.get( elem, 'displayValue' );

			if ( display ) {
				return display;
			}

			if( elem.hasAttribute( 'lyte-rendered' ) ){
				display = "block";
			} else {
				var owner = elem.ownerDocument,temp = owner.body.appendChild( owner.createElement( nodeName ) );
				display = owner.defaultView.getComputedStyle( temp ).display;
				owner.body.removeChild( temp );

				if ( display === "none" ) {
					display = "block";
				}
			}
			elData.set( elem, 'displayValue', display );
			return display;
		}

		function generateDummyProps ( prop, flag ) {
			var dummy = {};
			var arr = [ 'left', 'right', 'top', 'bottom' ];
			for( var i = 0; i < arr.length; i++ ){
				dummy[ 'margin-' + arr[ i ] ] = dummy[ 'padding-' + arr[ i ] ] = prop;
			}
			if( flag ){
				dummy.width = dummy.height = dummy.opacity = prop;
			}
			return dummy;
		}

		function showhide( elems, flag ) {
			var disps = []
			for( var i = 0; i < elems.length; i++ ) {
				var el = elems[ i ];
				AniData.add( el );
				var actDisp = el.style.display;
				if( flag ) {
					if( actDisp == 'none' ) {
						disps[ i ] = null || elData.get( el,'display' )
						if( !disps[ i ] ) {
							disps[ i ] = "";
						}
					}
					if( actDisp == "" && $L( el ).css( 'display' ) == "none" ) {
						disps[ i ] = getDefaultDisplay( el );
					}
				}else if( actDisp != 'none' ) {
					disps[ i ] = 'none';
					elData.set( el,'display', actDisp );
				}
			}
			for( var j = 0; j < elems.length; j++ ) {
				$L( elems[ j ] ).css( 'display', disps[ j ] )
			}
			return elems;
		}

		function show() {
			return showhide( [ this ], true );
		}

		function hide() {
			return showhide( [ this ] );
		}

		function toggle( arg, prop ) {
			if( !isValid( arg, prop ) ) {
				return;
			}
			if( arg.constructor == Boolean ) {
				return showhide( [ this ], arg )
			}

			return $L.each( this, function() {
				toggle( $L( this ).css( 'display' ) != 'none' ) 
			})
		}

		function camelCase (string){
		 return string.replace(/(-\w)/g, function (m) {
	            return m[1].toUpperCase();
	        });
		}

		function dasherize(string){
			return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}

		function AnimationData(){
			this.data = {};
		}

		function animationEnd(evt){
			if(evt.target == this){
				elData.get(this, 'endCallback').call(this, evt);
			}
		}

		AnimationData.prototype = {
			add : function(elem){
				if( elem.lyteAnimateId ){
					return elem.lyteAnimateId;
				}
				var randomId = 'lyteAnimate' + parseInt(Math.random() * Math.pow(10,6));
				elem.lyteAnimateId = randomId;
				this.data[randomId] = [];
				elem[elem.lyteAnimateId] = {}
				return randomId;
			},
			queue : function(elems, options, value){
				for(var i = 0; i < elems.length; i++){
					var el = elems[i];
					var id  = el.lyteAnimateId
					if(!id){
							id = this.add(el);
						}
					this.data[id].push({elem : el, options : options, value : value, properties : Object.keys(value)});
					if(this.data[id].length == 1){
						el.addEventListener('transitionend', animationEnd);
						this.next(el);	
					}
				}
			},
			dequeue : function(elem){
				firecallback( elem );
			 	this.data[elem.lyteAnimateId].splice(0, 1);
				this.next(elem);
			},
			dequeueAll : function(elem){
				this.data[elem.lyteAnimateId] = this.data[elem.lyteAnimateId].splice();
				this.next(elem);
			},
			next : function(elems){
				clearTimeout( elems._nextime );
				elems._nextime = setTimeout(this.call.bind(this), 13, elems);
			},
			call : function(elem){
				delete elem._nextime;		
				if(elem.lyteAnimateId && this.data[elem.lyteAnimateId][0]){
						lyteAnimation.call(elem);
				}else{
					this.data[elem.lyteAnimateId] = [];
					elem.removeEventListener('transitionend', animationEnd);
				}	
			}
		}

		function ElementData(){
		}

		ElementData.prototype = {
			set :  function(){
				if(arguments.length < 3){
					return;
				}
				if(arguments.length == 3){
					if(arguments[0][arguments[0].lyteAnimateId] == undefined){
						arguments[0][arguments[0].lyteAnimateId] = {};
					}
					arguments[0][arguments[0].lyteAnimateId][arguments[1]] = arguments[2];
				}
				else if(arguments.length == 4){
					if(arguments[0][arguments[0].lyteAnimateId][arguments[1]] == undefined){
						arguments[0][arguments[0].lyteAnimateId][arguments[1]] = {};
					}
					arguments[0][arguments[0].lyteAnimateId][arguments[1]][arguments[2]] = arguments[3]
				}

			},
			get : function(){
				if(arguments.length < 1){
					return;
				}
				if(arguments.length == 1){
					return arguments[0][arguments[0].lyteAnimateId];
				}
				else if(arguments.length == 2){
					return arguments[0][arguments[0].lyteAnimateId][arguments[1]];
				}
				else if(arguments.length == 3){
					if(arguments[0][arguments[0].lyteAnimateId][arguments[1]]){
						return arguments[0][arguments[0].lyteAnimateId][arguments[1]][arguments[2]];
					}	
				}
				return;
			}
		}

		function checkCrctValue(value, key, camelCaseKey, compStyle){
			var valueCopy = value[key].toString();
			if(/^(\()/g.exec(valueCopy)){
				return valueCopy;
			}
			var operatorRegex = /^\+=|\-=|\*=|\/=/g, unitRegex = /cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|auto|vmin|vmax|%+$/ig, unit = valueCopy.match(unitRegex), finalVal = valueCopy.match(operatorRegex);
			if(compStyle[camelCaseKey] != "none" && !/matrix/ig.test(compStyle[camelCaseKey])){
				if(unit == null){
					var newUnit = compStyle[camelCaseKey].match(unitRegex);
					if(newUnit == null){
						unit = "";
					}else{
						if(newUnit[0] == 'auto'){
							unit = 'px';
						}else{
							unit = newUnit[0]
						}
					}
				}else{
					unit = unit[0];
					valueCopy = valueCopy.slice(0, valueCopy.indexOf(unit));
				}
			}else{
				unit = "";
			}
			if(finalVal){
				var temp = parseInt(compStyle[camelCaseKey]), split = valueCopy.split("=");
				temp = temp == NaN ? 0 : temp;
				switch(split[0]){
					case '/' : 
						valueCopy = temp  / parseFloat(split[1]);
						break;
					case '-' : 
						valueCopy = temp  - parseFloat(split[1]);
						break;
					case '*' : 
						valueCopy = temp  * parseFloat(split[1]);
						break;
					default : 
						valueCopy = temp  + parseFloat(split[1]);
				}
			}
			// return [valueCopy + unit, unit];
			return valueCopy + unit;

		}

		function lyteAnimation (){	
				var newObj = {}, 
				units = {},
				win = $L.isWindow( this ), 
				def = win ? false : this.ownerDocument.defaultView;

				$L.fastdom.measure( function(){
					// windows are not hidden but if it isn't a window, hidden is recaculated below
					var hidden = def;
					// We are ignoring if it is a window
					if( def ) {
						var compstyle = def.getComputedStyle( this );

						hidden = compstyle.display == "none";

						if( !hidden && !this.offsetParent ){
							autoAnimate.call( this )
							return;
						}
					}

					var anidata = AniData.data[this.lyteAnimateId][0];
					if( !anidata ){
						return;
					}
					var value = anidata.value, auto = [],
					keys = Object.keys( value ), value, animeProp = [], from = {}, to = {}, val,
					originalData = elData.get(this, 'animeProp', 'original');
					if( !originalData ){
						originalData = {};
						elData.set( this, 'animeProp', 'original', originalData )
					}

					$L.fastdom.mutate( function() {
						anidata = AniData.data[ this.lyteAnimateId ][ 0 ];
						if( !anidata ){
							return;
						}
						var flag = true, standardObj = {}, 
						compstyle, bcr, obj = $L( this ), standardPresent = false;

						for( var i = 0; i < keys.length; i++ ){
							var curkey = camelCase( keys[ i ] ), curval = value[ keys[ i ] ],

							// standard - properties that are present in the CSSStyleDeclaration
							// Non standard  - Eg: scrollTop
							val = null, standard;

							// Skipping if it is a window
							if( def && /show|hide|toggle/.test( curval ) ){
								if( curval == 'hide' || !hidden && curval == "toggle" ){
									val = "hide";
								} else if( curval == "show" || hidden && curval == "toggle" ){
									val = "show";
								}
								if( val == "show" && !hidden || val == "hide" && hidden ){
									continue;
								}
							}

							// Skipping if it is a window
							if( def && flag ){
								if( hidden ){
									if( this._lytedisplay == undefined ){
										this.style.display = getDefaultDisplay( this );
									} else {
										this.style.display = this._lytedisplay || '';

									}
								} else {
									this._lytedisplay = this.style.display;
								}
								// force measure needed
								compstyle = def.getComputedStyle( this );
								bcr = this.getBoundingClientRect();
								flag = false;
							}

							if( animeProp.indexOf( curkey ) == -1 ){
								animeProp.push( curkey );
							}

							standardObj[ curkey ] = 
							standardObj[ curkey ] = 
							standard = isStandard( curkey, compstyle );

							// We are checking if there is atleast 1 standard property
							// If there are no standard props we don't call autoanimate
							// else we do
							standardPresent = standardPresent || ( standard ? true : false );

							/* Element is not hidden */
							if( !hidden ) {
								if( val != "hide" ) {
									// There is a difference between getting a non standard from an object 
									// and a non standard from a DOM. If you are getting it from the DOM you need to use the getter
									// from tweenProps else you can just get it from the object.
									to[ curkey ] = !standard ? 
													value[ keys[ i ] ] : 
													checkCrctValue( value, keys[ i ], curkey, compstyle );
								} else{
									/* This gets fired when they are trying to hide an element 
									which doesn't happen with scrollTo or non standard animations */
									originalData[ curkey ] = this.style[ curkey ];
									to[ curkey ] =  0;
								}

								from[ curkey ] = !standard ? getCurrentValueForNonStandards( curkey, obj ) : compstyle[ curkey ];
							} else {
								if( val != "show" ){
									from[ curkey ] = !standard ? getCurrentValueForNonStandards( curkey, obj ) : compstyle[ curkey ];
								} else {
									originalData[ curkey ] = this.style[ curkey ];
									from[ curkey ] = 0;
								}

								to[ curkey ] = !standard ? 
												value[ keys[ i ] ] 
												: !val ? 
													checkCrctValue( value, keys[ i ], curkey, compstyle ) 
													: compstyle[ curkey ];
							}

							if( parseFloat( to[ curkey ] ) == parseFloat( from[ curkey ] ) || /auto/.test( to[ curkey ] ) || /auto/.test( from[ curkey ] ) ){
								delete from[ curkey ]; delete to[ curkey ]; 
								var index = animeProp.indexOf( curkey );

								if( index > -1 ) {
									animeProp.splice( index, 1 );
								}
							}
						}

						elData.set( this, 'animeProp', 'from', from );
						elData.set( this, 'animeProp', 'to', to );
						elData.set( this, 'animeProp', 'mode', val );
						elData.set( this, 'animeProp', 'animate', animeProp );
						elData.set( this, 'animeProp', 'standardObj', standardObj );


						// We just set this to true when we are about to animate any property( standard or nonstandard )
						// and set it to false inside autoanimate after standards finish animating
						// elData.set( this, 'animeProp', 'standard', false );
						// false as in standard has not finished
						// true as in there are no standards and we consider it to be finished
						anidata.standard = !standardPresent;

						if( !standardPresent && $L.isEmptyObject( to ) ) {
							// If there are no properties to animate just dumpster it 
							tryDequeue( this );
						}

						// Froms are used to animate standard properties, non-standards don't really care about them
						if( standardPresent ) {
							$L.each( from, function( prop, val ) {
								if( standardObj[ prop ] ) {
									this.style[ prop ] = val;
								}
							}.bind( this ) );

							autoAnimate.call( this );	
						}
						

						// Tos are used to animate non standard properties
						$L.each( to, function( prop, val ) {
							var nsC = anidata.nonstandard || 0;

							if( !standardObj[ prop ] ) {
								// Maintaining a count of the number of nonstandards that are getting animated
								// Will be decreased by 1 when their animation stops
								// We don't maintain a count for standards because they are all animated at once
								// which is not the case for nonstandards
								anidata.nonstandard = nsC + 1;
								animateNonStandard( prop, val, this );
							}
						}.bind( this ) );
						
						// When both standards and non standards finish we dequeue	

					}.bind( this ))
				}.bind( this ))
		}

		function constructCss(){
			if( !document.body.contains( this ) ){
				return;
			}
			var opts = AniData.data[this.lyteAnimateId][0].options,
			defaultOpts = ['timingFunction', 'duration', 'delay'], constyle="",
			value  =  Object.keys(AniData.data[this.lyteAnimateId][0].value || {});
			for(var i = 0; i < defaultOpts.length; i++){
				if(defaultOpts[i] in opts){
					var sec = '';
					if(defaultOpts[i] == 'delay' || defaultOpts[i] == 'duration'){
						if(!/[ms|s]+/ig.test(opts[defaultOpts[i]])){
							sec = 'ms'
						}
					}
					constyle += 'transition-' + dasherize(defaultOpts[i]) + ':' + opts [defaultOpts[i]] + sec + ";";
	 			}
			}
			if(value.length)
				{
					constyle += 'transition-property : ';
					for(var j = 0; j < value.length; j++){
						constyle += j > 0 ? ','+ dasherize(value[j]) : dasherize(value[j]);
					}
				}
			return constyle += ";";
		}

		function removeStyle(){
			this.style.removeProperty('transition');
		}

		function autoAnimate () {
			if( ( elData.get(this, 'animeProp', 'animate') || [] ).length) {

					removeStyle.call(this);
					var newstyle = constructCss.call(this);
					elData.set(this, 'endCallback', function(evt){				
					 	evt.type != 'timeout' && evt.stopPropagation();
						var props = elData.get(this, 'animeProp', 'animate');
						if( !AniData.data[this.lyteAnimateId].length ){
							return;
						}
						var propLength = elData.get(this, 'propertyCount');
						if( evt.type == 'timeout' ){
							propLength = props.length - 1;
						}
						elData.set(this, 'propertyCount', ++propLength);
						if(props.length == propLength)
							{
								clearTimeout( this._anitime ); delete this._anitime;
								// clearTimeout( this._styletime ); delete this._styletime;	
								removeStyle.call(this);
								var mode = elData.get(this, 'animeProp', 'mode'), original = elData.get(this, 'animeProp', 'original');
								if(mode){
									if(mode == 'hide'){
										  if( evt.type == "timeout" ){
										  	hide.call(this);
										  	$L.each( original, function( prop, value ){
												$L( this ).css( prop, value );
											}.bind( this ))

										  	tryDequeue( this, true );
										  } else {
											  setTimeout(function(){
											  	hide.call(this);
											  	$L.each( original, function( prop, value ){
													$L( this ).css( prop, value );
												}.bind( this ))

											  	tryDequeue( this, true );
											  }.bind(this), 20);
										  	}
										}
									else{
										$L.each( original, function( prop, value ){
											$L( this ).css( prop, value );
										}.bind( this ))

										tryDequeue( this, true );
									}
								}else{	

									tryDequeue( this, true );
								}
								
								setTimeout(function(){
									this.style.overflow = this._orioverflow;
									delete this._orioverflow;
								}.bind(this), 20);	
							}
					});
			    	this._orioverflow = this.style.overflow;
			    	this.style.overflow = "hidden";
					elData.set(this, 'propertyCount', 0);
					this._styletime =  setTimeout( function(){
						delete this._styletime;
						var sty = $L(this).attr('style');
						$L(this).attr('style', ( sty ? ( sty + ';' ) : "") + newstyle );
						setTimeout(dummy.bind(this), 20);
					}.bind( this ), 20 )
				}
			else{

				tryDequeue( this, true );
			}		

		}

		function dummy(){
				var anidata = AniData.data[this.lyteAnimateId][0];
				if(anidata){
					var options = anidata.options,
					currTime = Date.now(),

					// The fired is going to tell us whether the start callback has been fired or not
					fired = options.fired;

					elData.set(this, 'animeProp', 'startTime', currTime);
					var aniProp = elData.get(this, 'animeProp');

					if( options.start && !fired ) {
						options.fired = true;
						// TODO: fix target

						options.start.call(this, {options : options, from : aniProp.from, to : aniProp.to, value : AniData.data[this.lyteAnimateId][0].value, startTime : currTime, target : this, transitionProperty : Object.keys(aniProp.to)});
					}
					var elem = this;
					$L.each(elData.get(this, 'animeProp', 'to'), function(prop, val){
						$L(elem).css(prop, val);
					})
					this._anitime = setTimeout( animationEnd.bind( this, { type : "timeout", target : this } ), returntran( options.duration.toString() ) + 10 )
				}else{
					removeStyle.call(this);
					this.removeEventListener('transitionend', animationEnd);
				}
		}

		function returntran( prop ){
			var ret = 0;
			if( /\d+/.test( prop ) ){
				var match = prop.match( /(\d+)(s|ms){0,}$/ );
				ret = parseFloat( match[ 1 ] ) * ( match[ 2 ] == "s" ? 1000 : 1 );
			}
			return ret;
		} 

		elData = new ElementData();
		AniData = new AnimationData();

		function getCorrectOption (duration, ease, callbacks){
			var obj = {};
			if(callbacks){
				if(callbacks.constructor == Function){
					obj.complete = callbacks;
				}
			}
			if(ease){
				if(ease.constructor == Function){
					obj.complete = ease;
				}
				else if(ease.constructor == Object){
					$L.extend( obj, ease );
					// Object.assign(obj, ease);
				}
				else if(ease.constructor == String){
					obj.timingFunction = ease;
				}
			}
			if(duration != undefined){
				if(duration.constructor == Object){
					$L.extend( obj, duration );
					// Object.assign(obj, duration);
				}
				else if(duration.constructor == Number){
					obj.duration = duration
				}
				else if(duration.constructor == Function){
					obj.complete = duration
				}
			}
			if(obj.delay != undefined ){
				if(/[s]+/ig.test(obj.delay)){
					options.delay = parseInt(options.delay) * 1000;
				}
			}
			if(!('duration' in obj)){
				obj.duration = 400;
			}
			if(/[s]+/ig.test(obj.duration)){
					options.duration = parseInt(options.duration) * 1000;
				}
			if(!obj.timingFunction){
				obj.timingFunction = "ease";
			}	
			return obj;
		}

		function replaceStyle( props, from, percent ) {
			$L(this).css(props, this.style[props].replace(/([0-9.-]+)/, function(arg){
				return ((parseFloat(arg) - from) * percent + from);
			}))
		}

		function stopAnimation(jumpToEnd, clearQueue){
			if(jumpToEnd){
				var propLength = elData.get(this, 'propertyCount');
				elData.set(this, 'propertyCount', ( elData.get(this, 'animeProp', 'animate') || [] ).length - 1);
				// this.dispatchEvent(new Event('transitionend'));
				animationEnd.call( this, { target : this, type : 'timeout' } );
				if(clearQueue){
					AniData.dequeueAll(this);
				}
			}else{
				// issues in stop with JumpToEnd false. Need to be fixed after 2.0 release
				var data = AniData.data[this.lyteAnimateId];
				if( !data ) {
					return
				}
				clearTimeout( this._anitime ); delete this._anitime;
				var options = data[0].options, animate = elData.get(this, 'animeProp');
				var currTime = Date.now(), val, from = animate.from, to = animate.to;
				var startTime = animate.startTime;
				var remain = Math.max(0, startTime + options.duration - currTime);
				var percent = 1 - (remain / options.duration);
				var props = Object.keys(animate.to || {});
				var standardObj = elData.get( this, 'animeProp', 'standardObj' );


				for(var i = 0; i < props.length; i++){
					if( !standardObj[ props[ i ] ] ) {
						window.cancelAnimationFrame( this[ 'rAF' + props[ i ] ] );
						tryDequeue( this, false );
						continue;
					}

					tryDequeue( this, true );
					var from1 = from[props[i]];
					if( from1 == 'none' && !( /deg/ig.test( from1 ) ) ){
						from1 = 1
					}
					from1 = parseInt( from1 )
					from1 = isNaN(from1) ? 0 : from1;
					replaceStyle.call( this, props[ i ], from1, percent )
				}
				$L(this).css('transition', '');
				if(clearQueue){
					AniData.dequeueAll(this);
				}
				// else{
				// 	AniData.dequeue(this);
				// }
			}
		}

		function isValid( bol, prop ){
			if( ( prop == 'hide' && bol ) || ( prop == 'show' && !bol ) ){
				return false;
			}
			return true
		}

		if( lyteDomObj ){
			lyteDomObj.prototype.animate = function(){
				if(arguments.length)
					{
						var opts = getCorrectOption(arguments[1], arguments[2], arguments[3]);
						AniData.queue(this, opts, arguments[0]);
					}
				return this;
			}

			lyteDomObj.prototype.fadeTo = function( value, duration, ease, callback){
				if( duration != undefined && duration.constructor == Number ){
					if( duration < 1 ){
						var temp = duration;
						duration = value;
						value = temp;
					}
				}
				value = value || 0;
				var opts = getCorrectOption(duration, ease, callback);
				AniData.queue(this, opts, value.constructor == Object ? value :  {opacity : value});
				return this;
			}

			$L.each({
					fadeIn : { opacity : 'show'}, 
					fadeOut : { opacity : 'hide' }, 
					fadeToggle : { opacity : 'toggle'},
					slideUp : { height : 'hide', paddingTop : "hide", paddingBottom : "hide" },
					slideDown : {height : 'show', paddingTop : "show", paddingBottom : "show" },
					slideToggle :  { height : 'toggle', paddingTop : "toggle", paddingBottom : "toggle"}
				}, function(property, value){
					lyteDomObj.prototype[property] = function(duration, ease, callback){
					   return this.animate(value, duration, ease, callback);
					}
			})

			lyteDomObj.prototype.stop = function(clearQueue, jumpToEnd){
				return $L.each(this, function(){
					stopAnimation.call(this, jumpToEnd != undefined ? jumpToEnd : true, clearQueue);
				})
			}

			lyteDomObj.prototype.finish = function( jumpToEnd ){
				return $L.each(this, function(){
					var queues = AniData.data[this.lyteAnimateId];
					if( queues && queues.length )
						{
							for(var i = 1; i < queues.length; i++){
								queues[i].options.duration = 1;
							}
							// setTimeout( stopAnimation.bind( this, true, false ), 13 );
							stopAnimation.call(this, true, false);
						}
				})
			}

			$L.each({
					show : generateDummyProps('show', true), 
					hide : generateDummyProps('hide', true), 
					toggle : generateDummyProps('toggle', true)
				}, function(property, value){
					lyteDomObj.prototype[property] = function(duration, ease, callback){
					   if(duration && duration.constructor != Boolean){
							return this.animate(value, duration, ease, callback);
						}
					   return $L.each(this, function(){
							toggle.call(this, $L(this).css('display') == 'none', property);
						})
					}
			})
		}

	})(window);
;( function(){
	if( lyteDomObj ){

		function getScope( elem, scope ){
           var data = elem._finddata;
           scope = data.dynamicScope ? data.dynamicScope( elem ) : scope;
           if( data.checkFromParent ){
             scope = elem.parentNode;
           }
           return scope;
        }

		function switchfn( text, value, method ){
			var flag
			switch( method ){
				case 'startswith' : {
					flag = text.indexOf( value ) == 0;
					break;
				}
				case 'endswith' : {
					var idx = text.indexOf( value );
					if( idx != -1 ){
						flag = idx + value.length == text.length;
					}
					break;
				}
				default : {
					flag = text.indexOf( value ) != -1;
				}
			}
			return flag;
		}

		function treecheck( visible, hidden, scope, value, data ){
			var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			rgx2 = /(?!>)([^><]+)(?=<)/ig;
			for( var i = 0; i < visible.length; i++ ){
				var vis = $L( visible[ i ] ).closest( 'lyte-tree' )[ 0 ];
				for( var j = 0; j < hidden.length; j++ ){
					var hid = $L( hidden[ j ] ).closest( 'lyte-tree' )[ 0 ];
					if( vis == hid || hid.contains( vis ) ){
						data.highlight && hide( hidden[ j ] )
						Lyte.arrayUtils( hidden, 'removeAt', j );
						j--;
					}
				}
			}
			for( var i = 0; i < visible.length; i++ ){
			   data.highlight && highlightnode( visible[ i ], value, data, rgx1, rgx2 );
			   value.length && scope.ltProp( 'stateAttr', $L( visible[ i ] ).closest( 'lyte-tree' ).attr( 'temp-var' ) )
			}
			for( var i = 0; i < hidden.length; i++ ){
				hide( hidden[ i ] )
				if( value.length ){
					var inn = $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', $L( hidden[ i ]  ).closest( 'lyte-tree' ).parent() ).eq( 0 );
					inn.hasClass( 'lyteIconOpened' ) && inn.click();
				}
			}
			if( !value.length ) {
				closealltree.call( this, scope )
			}
		}

		function closealltree( scope ){
			var icons = $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope );
			for( var i = icons.length - 1; i >= 0; i-- ){
				var cur = icons.eq( i );
				cur.hasClass( 'lyteIconOpened' ) && cur.click();
			}
		}

		function highlightnode( element, value, data, rgx1 ){
			$L( element ).addClass( 'lyteSearchHidden' );

			var exspan = element._findelement,
			cloned_element = element.cloneNode( true );

			cloned_element.normalize();

			if( !exspan ){
				exspan = $L( document.createElement( element.tagName ) ).addClass( 'lyteHighlightdiv' ).get( 0 );
				_lyteUiUtils.insertAfter( element, exspan );

				element._findelement = exspan;
				exspan._originalelement = element;
			}

			exspan.style.display = '';

			convertString( Array.from( cloned_element.childNodes ), value, data );

			var __child = Array.from( cloned_element.childNodes );

			exspan.innerHTML = '';

			__child.forEach( function( item ){
				exspan.appendChild( item );
			});
		}

		function convertString( nodes, value, data ){
			var str = '';
			nodes.forEach( function( item ){
				var tag = item.tagName || '';
				if( /^template$/i.test( tag ) ){
					item.remove();
				} else if( tag ){
					convertString( Array.from( item.childNodes ), value, data );
				} else {
					var str = item.nodeValue,
					lower = str.toLowerCase(),
					index = lower.indexOf( value ),
					is_modified,
					ref = item;

					while( index != -1 ){
						var first = str.slice( 0, index ),
						limit = index + value.length,
						second = str.slice( index, limit ),
						third = str.slice( limit ),
						is_modified = true;

						if( first ){
							var node = document.createTextNode( first );
							Lyte.Component.insertAfter( ref, ref = node );
						}

						var node = $L( document.createElement( 'span' ) ).addClass( 'lyteFindHighlight '+ ( data.highlightclass || '' ) ).get( 0 );
						node.textContent = second;
						Lyte.Component.insertAfter( ref, ref = node );

						str = third;
						lower = str.toLowerCase();
						index = lower.indexOf( value );
					}

					if( is_modified ){
						if( str ){
							var node = document.createTextNode( str );
							Lyte.Component.insertAfter( ref, node );
						}
						item.remove();
					}
				}
			});
		}

		function hide( elem ){
			$L( elem ).removeClass( 'lyteSearchHidden' );
			$L( elem._findelement ).css( 'display', 'none' );
		}

		function acccheck( visible, hidden, scope, value, data ){
			// var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			// rgx2 = /(?!>)([^><]+)(?=<)/ig, exs = scope.ltProp( 'exclusive' );

			for( var i = 0; i < visible.length; i++ ){
				for( var j = 0; j < hidden.length; j++ ){
					if( $L( hidden[ j ] ).closest( 'lyte-accordion-item' ).is( $L( visible[ i ] ).closest( 'lyte-accordion-item' ) ) ){
						data.highlight && hide( hidden[ j ] );
						Lyte.arrayUtils( hidden, 'removeAt', j );
						j--; continue;
					}
				}
				if( visible[ i + 1 ] ){
					if( $L( visible[ i ] ).closest( 'lyte-accordion-item' ).is( $L( visible[ i + 1 ] ).closest( 'lyte-accordion-item' ) ) ){
						value.length && data.highlight && highlightnode( visible[ i + 1 ], value, data/*, rgx1, rgx2*/ );
					}
				}
				value.length && data.highlight && highlightnode( visible[ i ], value, data/*, rgx1, rgx2*/ )
			}

			for( var i = 0; i < visible.length; i++ ){
				!value.length && hide( visible[ i ] );
				var close = $L( visible[ i ] ).closest( 'lyte-accordion-item ', scope )
				if( !close.hasClass( 'lyteAccordionActive' ) ){
					if( exs && i != visible.length - 1 ){
						continue;
					}
					value && close.click()
				} else if( !value ){
					close.click();
				}
			}

			for( var i = 0; i < hidden.length; i++ ){
				data.highlight && hide( hidden[ i ] );
				$L( hidden[ i ] ).closest( 'lyte-accordion-item.lyteAccordionActive' , scope ).click()
			}
			
		}

		function commonCheck( visible, hidden, scope, value, data ){
			var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			rgx2 = /(?!>)([^><]+)(?=<)/ig;

			if( value.length ){
				for( var i = 0; i < visible.length; i++ ){
			    	data.highlight && highlightnode( visible[ i ], value, data, rgx1, rgx2 );
				}
			}

			for( var i = 0; i < hidden.length; i++ ) {
				data.highlight && hide( hidden[ i ] );
			}

			if( !value.length ){
				for( var i = 0; i < visible.length; i++ ){
			    	data.highlight && hide( visible[ i ] );
				}
			}

		}

		function processing( evt ){
			var data = this._finddata,
			scope = $L( getScope( this, data.scope ) )[ 0 ],
			comp = data.component,
			search = $L( data.search || data.target, scope ),
			method = data.method,
			value = ( this.tagName != "LYTE-INPUT" ? this.value : this.querySelector( 'input,textarea' ).value ).toLowerCase(), text = [], visible = [], hidden = [];
			if( data.trim ){
				value = value.trim();
			}
			for( var i = 0; i < search.length; i++ ){
				if( search.eq( i ).hasClass( 'lyteHighlightdiv' ) ){
					continue;
				}
				if( switchfn( search[ i ].textContent.trim().toLowerCase(), value, method ) ){
					visible.push( search[ i ] )
				} else {
					hidden.push( search[ i ] )
				}	
			}
			if( data.onSearch && data.onSearch.call( this, visible, hidden, evt, value, this ) == false ){
				return;
			}
			( comp == 'tree' && treecheck.call( this, visible, hidden, scope, value, data ) ) || ( comp == "accordion" && acccheck.call( this, visible, hidden, scope, value, data ) ) || ( comp == undefined && commonCheck.call( this, visible, hidden, scope, value, data ) );
		}

		function eventFunc( evt ){
			clearTimeout( this._timeout );
			this._timeout = setTimeout( processing.bind( this, evt ), 250 );
		}

		function setValue( value ){
			if( this.tagName != "LYTE-INPUT" ){
				this.value = value;
			} else{
				this.ltProp( 'value', value );
			}
			eventFunc.call( this, {} ); 
		}

		lyteDomObj.prototype.lytefind = function( data ){
			data = data || {};
			data.highlight = data.highlight != undefined ? data.highlight : true;
			var current = this.get( 0 );
			if( current._finddata ){
				this.eq( 0 ).removefind();
			}
			current._finddata = data;
			current.setValueForFind = current.setValue = setValue.bind( current );
			// current.resetValue = setValue.bind( current );
			current.addEventListener( 'input', eventFunc );
			return this;
		}

		lyteDomObj.prototype.removefind = function(){
			for( var i = 0; i < this.length; i++ ){
				var cur = this[ i ];
				if( cur._finddata ){
					var spans = $L( '.lyteHighlightdiv', getScope( cur, cur._finddata.scope ) ),
					_length = spans.length;
					
					for( var j = 0; j < _length; j++ ){
						// $L( spans[ j ] ).parent().children( '.lyteSearchHidden' ).removeClass( 'lyteSearchHidden' );
						var current = spans[ j ];
						if( current._originalelement ){
							$L( current._originalelement ).removeClass( 'lyteSearchHidden' );
							delete current._originalelement._findelement;
							delete current._originalelement;
						}
						current.remove();
					} 
					clearTimeout( cur._timeout );
					cur.removeEventListener( 'input', eventFunc );
					delete cur._finddata; delete cur._timeout; delete cur.setValue; delete cur.setValueForFind;
					// delete cur.resetValue;
				}
			}
			return this;
		}
	}
})();
( function() {
	function returnCallback( settings, val, last, parent ) {
		var opts = $L.extend( {}, settings ), 
		key = !last ? 'onAfterFirst' : 'onAfter', 
		after = opts[ key ];

		if( after ) {
			opts.complete = function( settings ) {
				after.call( parent, val, opts );
			}
		}

		return opts;
	}

	// last animations will have the onAfter callback as the complete function
	// first animations will have onAfterFirst callback as the complete function
	function scrollTo( parent, change, options, val, last ) {
		$L( parent ).animate( change, 
			returnCallback( 
				options, 
				val, 
				last,
				parent 
		) );
	}

	function buildProps( dimensions, parent, change, len, options, val, item, index ) {
		var suffix = item === 'x' ? 'Left' : 'Top',
		obj = $L( parent ),
		queue = options.queue,
		prop = 'scroll' + suffix,
		lower = suffix.toLowerCase(),
		final =  dimensions.dom ? 
					dimensions[ suffix ] + obj[ prop ]() 
					: dimensions[ lower ],
		isNegativeScroll = _lyteUiUtils.isNegativeScroll();

		change[ prop ] = Math.abs( final );

		if( isNegativeScroll && change.scrollLeft >= 0 ) {
			change.scrollLeft = change.scrollLeft * -1;
		}
		
		if( queue ) {
			scrollTo( parent, change, options, val, index === len - 1 );
		}
		else if( len - 1 === index ) {
			scrollTo( parent, change, options, val, true );
		}
	}

	function findAxis( dimensions, parent, val, options ) {
		var axis = options.axis,
		dirs = axis.split( '' ),
		change = {}, len = dirs.length,
		queue = options.queue;

		if( queue ) {
			options.duration /= 2;
		}

		dirs.forEach( function( item, index ) {
			if( queue ) {
				change = {};
			}

			buildProps.call( this, dimensions, parent, change, len, options, val, item, index )
		} );
	}

	function setDimensions( item, options, dimensions, obj, vBCR, pBCR ) {
		var margin = options.margin,
		prop = item.toLowerCase(), extra;

		extra = margin ? parseInt( obj.css( 'margin' + item ), 10 ) + parseInt( obj.css( 'border' + item + 'Width' ), 10 ) : 0;
		dimensions[ item ] = vBCR[ prop ] - pBCR[ prop ] - extra;
	}

	function findMax( elem, iswin, prop ) {
		var obj = $L( elem ),
		doc = elem.document,
		dim = prop.toLowerCase(),
		html = ( doc || {} ).documentElement,
		htmlObj = $L( html );

		return iswin ? htmlObj[ dim ]() - elem[ 'inner' + prop ] : elem[ 'scroll' + prop ] - obj[ dim ]();
	}

	function findDimensions( val, parent, options ) {
		// val can be object aswell with left and top
		var dimensions = val, 
		percent, rpercent = /([0-9]*)%/g, 
		obj, arr = [ 'Left', 'Top' ],
		iswin = $L.isWindow( parent ), pBCR, vBCR;

		switch( typeof val ) {
			case 'number':
			case 'string':
				percent = ( rpercent.exec( val ) || [] )[ 1 ];
				dimensions = {
					top: percent ? 0.01 * percent * findMax( parent, iswin, 'Height' ) : parseFloat( val ),
					left: percent ? 0.01 * percent * findMax( parent, iswin, 'Width' ) : parseFloat( val ),
					dom: false
				};
				break;
				
			// Its a DOMElement or lyteDomObj
			case 'object':
				if( val.nodeType 
					|| ( val instanceof lyteDomObj 
						&& ( val = val.get( 0 ) ) 
				) ) {
					obj = $L( val );
					dimensions = {};
					vBCR = val.getBoundingClientRect();
					pBCR = $L.isWindow( val ) ? { top: 0, left: 0 } : parent.getBoundingClientRect();

					arr.forEach( function( item ) {
						setDimensions( item, options, dimensions, obj, vBCR, pBCR );
					} );

					dimensions.dom = true;
				}
				else {
					dimensions.dom = false;
				}
				break;

		}

		subtractOffset( dimensions, options.offset );

		return dimensions;
	}

	function subtractOffset( dimensions, obj ) {
		var obj = typeof obj === 'object' ? obj : { left: obj, top: obj }, key;

		for( key in dimensions ) {
			dimensions[ key ] = dimensions[ key ] + ( obj[ key.toLowerCase() ] || 0 ) 
		}

	}

	lyteDomObj.prototype.scrollTo = function( val, duration, options ) {
		var dimensions;

		if( typeof options === 'function' ) {
			options = { onAfter: options };
		}

		if( typeof duration === 'object' ) {
			if( ( options || {} ).onAfter ) {
				duration.onAfter = options.onAfter;
			} 

			options = duration;
			duration = options.duration; 
		}

		if( !options ) {
			options = {};
		}

		options = $L.extend( {}, $L.scrollTo.defaults, options );
		
		this.each( function() {
			dimensions = findDimensions( val, this, options );
			findAxis( dimensions, this, val, options );
		} );
		
	}

	$L.scrollTo = function() {
		$L( window ).scrollTo();
	}

	$L.scrollTo.defaults = {
		axis: 'xy',
		duration: 0
	};

	$L.each( [ 'scrollLeft', 'scrollTop' ], function( index, fn ) {
		$L.Tween.propHooks[ fn ] = {
			get: function( elem ) {
				return elem[ fn ]();
			},

			set: function( elem, value, options ) {
				var rounded = Math.round( value ),
				curr = elem[ fn ](), key = '_old' + fn;

				if( options.interrupt && options[ key ] && options[ key ] !== curr ) {
					elem.stop( false, false );
					options._stopped = true;
				}

				options[ key ] = rounded;
				elem[ fn ]( rounded );
			}
		}
	} ); 
} )();
;(function(){

    if(lyteDomObj){

    lyteDomObj.prototype.selector = function(selections){

      if(!selections){
        selections = {}
      }

      var imageTagOriginal = this[0];
      var selectionArray = [];
      selectionArray = $L(imageTagOriginal).data('classes');
      var currentClass = ''
      var parentDiv = imageTagOriginal.parentElement;
      var wrapperDiv = document.createElement('DIV');
      var imageTag = document.createElement('IMG');
      imageTag.src = imageTagOriginal.src;
      imageTag.setAttribute('class' , 'lyteSelectorBackImage' )
      var selectionData = {};

      var imageMinWidth,imageMinHeight;

      if(selections.minWidth){
        imageMinWidth = selections.minWidth
      } else {
        imageMinWidth = 20
      }
      if(selections.minHeight){
        imageMinHeight = selections.minHeight
      } else {
        imageMinHeight = 20
      }

      var imageTop,imageLeft,imageRight,imageBottom,imageHeight,imageWidth;

      var currentX , currentY;
      var prevLeft, prevTop, prevRight, prevBottom; // VARIABLES USED IN moveSelection FUNCTION
      var rpLeft, rpTop, rpRight, rpBottom, rpWidth, rpHeight; // VARIABLES USED IN resizeSelectionBox FUNCTION RESIZE PREVIOUS VALUES
      var currentHandle; // CURRENT HANDLE HOLDED FOR RESIZING THE SELECTION BOX

      var currentDeleteBtn; // CURRENT DELETE BTN
      var deleteAllButton={};
      // var selectionStart = selectionEnd = deleteSingle = deleteMul = function(){};


      var onCreate = function(){}
      ,onDragStart = function(){}
      ,onDragEnd = function(){}
      ,onResizeStart = function(){}
      ,onResizeEnd = function(){}
      ,onDeleteOne = function(){}
      ,onDeleteAll = function(){}

      // if(!preventEvent){
        parentDiv.addEventListener('mousedown' , mainFun)
      // } else {
      //   preventEvent = true;
      // }


      if(selections){

        if(selections.onCreate){
          onCreate = selections.onCreate
        }
        if(selections.onDragStart){
          onDragStart = selections.onDragStart
        }
        if(selections.onDragEnd){
          onDragEnd = selections.onDragEnd
        }
        if(selections.onResizeStart){
          onResizeStart = selections.onResizeStart
        }
        if(selections.onResizeEnd){
          onResizeEnd = selections.onResizeEnd
        }
        if(selections.onDeleteOne){
          onDeleteOne = selections.onDeleteOne
        }
        if(selections.onDeleteAll){
          onDeleteAll = selections.onDeleteAll
        }

        if(selections.selections){

          selections = selections.selections;

          imageTag.onload = function(){

            if(!$L('.lyteSelectorBackImage')[0]){
              wrapperDiv.appendChild(imageTag);
              imageTag.style.height = imageTagOriginal.getBoundingClientRect().height + "px";
              imageTag.style.width = imageTagOriginal.getBoundingClientRect().width + "px";

              imageTagOriginal.style.display = "none"
            }

            if(!$L('.lyteSelectionWrapperBox')[0]){

              wrapperDiv.setAttribute('class' , 'lyteSelectionWrapperBox');
              parentDiv.appendChild(wrapperDiv);
              wrapperDiv.style.height = imageTag.getBoundingClientRect().height+"px";
              wrapperDiv.style.width = "auto";

              if(!($L('.lyteSelectionFreezeLayer')[0])){
                var freezeLayer = document.createElement('DIV');
                freezeLayer.setAttribute('class' , 'lyteSelectionFreezeLayer');
                wrapperDiv.appendChild(freezeLayer);
                freezeLayer.style.top = "0px";
                freezeLayer.style.left = "0px";
                freezeLayer.style.height = imageTag.getBoundingClientRect().height + "px";
                freezeLayer.style.width = imageTag.getBoundingClientRect().width + "px";
              }



              for(var i=0;i<selections.length;i++){

                var dummyDiv = document.createElement('DIV');
                dummyDiv.classList.add('lyteSelectionBox')
                dummyDiv.classList.add('lyteSelector'+(i+1));
                currentClass = 'lyteSelector'+(i+1);

                if(!selectionArray){
                  selectionArray = []
                }

                selectionArray.push(currentClass)
                $L(imageTagOriginal).data('classes' , selectionArray)

                var tlCorner = document.createElement('DIV');
                var trCorner = document.createElement('DIV');
                var brCorner = document.createElement('DIV');
                var blCorner = document.createElement('DIV');

                var tEdge = document.createElement('DIV');
                var bEdge = document.createElement('DIV');
                var rEdge = document.createElement('DIV');
                var lEdge = document.createElement('DIV');

                var deleteBtn = document.createElement('DIV');
                var workArea = document.createElement('DIV');

                var selectorLabelTop = document.createElement('DIV');
                var selectorLabelBottom = document.createElement('DIV');



                tlCorner.setAttribute('class' , 'lyteSelectorHandles lyteTLCorner')
                trCorner.setAttribute('class' , 'lyteSelectorHandles lyteTRCorner')
                brCorner.setAttribute('class' , 'lyteSelectorHandles lyteBRCorner')
                blCorner.setAttribute('class' , 'lyteSelectorHandles lyteBLCorner')
                tEdge.setAttribute('class' , 'lyteSelectorHandles lyteTEdge')
                bEdge.setAttribute('class' , 'lyteSelectorHandles lyteBEdge')
                rEdge.setAttribute('class' , 'lyteSelectorHandles lyteREdge')
                lEdge.setAttribute('class' , 'lyteSelectorHandles lyteLEdge')

                deleteBtn.setAttribute('class' , 'lyteSelectorDeleteBtn')
                workArea.setAttribute('class' , 'lyteSelectorWorkArea')

                selectorLabelTop.setAttribute('class' , 'lyteSelectorLabel')
                selectorLabelBottom.setAttribute('class' , 'lyteSelectorLabel')

                onCreate(workArea)


                dummyDiv.appendChild(tlCorner)
                dummyDiv.appendChild(trCorner)
                dummyDiv.appendChild(brCorner)
                dummyDiv.appendChild(blCorner)
                dummyDiv.appendChild(tEdge)
                dummyDiv.appendChild(bEdge)
                dummyDiv.appendChild(rEdge)
                dummyDiv.appendChild(lEdge)
                dummyDiv.appendChild(deleteBtn)
                dummyDiv.appendChild(workArea)

                dummyDiv.appendChild(selectorLabelTop)
                dummyDiv.appendChild(selectorLabelBottom)

                if(selections[i].borderColor){
                  dummyDiv.style.borderColor = selections[i].borderColor;
                }

                if(selections[i].dataLabel){
                  selectorLabelTop.classList.add('lyteSelectorLabelTop')
                  selectorLabelBottom.classList.add('lyteSelectorLabelBottom')
                  selectorLabelTop.classList.add(selections[i].dataLabel[0].className)
                  selectorLabelBottom.classList.add(selections[i].dataLabel[1].className)
                  selectorLabelTop.innerText = selections[i].dataLabel[0].label;
                  selectorLabelBottom.innerText = selections[i].dataLabel[1].label;
                }

                wrapperDiv.appendChild(dummyDiv)

                var ar = imageTag.naturalWidth / imageTag.getBoundingClientRect().width;

                $L('.'+currentClass)[0].style.width = selections[i].width / ar + "px";
                $L('.'+currentClass)[0].style.height = selections[i].height / ar + "px";
                $L('.'+currentClass)[0].style.top = selections[i].top / ar + "px";
                $L('.'+currentClass)[0].style.left = selections[i].left / ar + "px";

                $L('.'+currentClass)[0].style.backgroundImage = "url('"+ imageTag.src +"')"
                $L('.'+currentClass)[0].style.backgroundPosition = (-($L('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
                $L('.'+currentClass)[0].style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
                $L('.'+currentClass)[0].style.backgroundRepeat = "no-repeat";

              }

            }
          }

        }
      }

      function mainFun(){

        imageTop = imageTag.getBoundingClientRect().top;
        imageLeft = imageTag.getBoundingClientRect().left;
        imageRight = imageTag.getBoundingClientRect().left + imageTag.getBoundingClientRect().width;
        imageBottom = imageTag.getBoundingClientRect().top + imageTag.getBoundingClientRect().height;
        imageHeight = imageTag.getBoundingClientRect().height;
        imageWidth = imageTag.getBoundingClientRect().width;

        event.preventDefault();

        if((event.target.nodeName === 'IMG')||(event.target.className === 'lyteSelectionFreezeLayer')){

          currentX = event.clientX;
          currentY = event.clientY;

          if((!selectionArray) || (selectionArray.length < 1)){
            selectionArray = [];
            selectionArray.push('lyteSelector1')
            currentClass = 'lyteSelector1'
            $L(imageTagOriginal).data('classes' , selectionArray)
            // getSelectedData();
          } else {
            var arr = $L(imageTagOriginal).data('classes');
            var regex = /\d+/g
            var test = parseInt(arr[arr.length-1].match( regex )[0])
            test +=1
            var newClass = arr[arr.length-1].replace(regex , test);
            selectionArray.push(newClass)
            currentClass = newClass
            $L(imageTagOriginal).data('classes' , selectionArray)
          }
          createSelection()

          document.addEventListener('mousemove' , setDim);
        } else if($L(event.target).hasClass('lyteSelectionBox')) {

          onDragStart();


          currentX = event.clientX;
          currentY = event.clientY;

          if($L('.lyteSelectorActiveBox')[0]){
            $L('.lyteSelectorActiveBox')[0].classList.remove('lyteSelectorActiveBox');
          }

          var elem = event.target;
          elem.classList.add('lyteSelectorActiveBox')
          prevLeft = elem.getBoundingClientRect().left;
          prevTop = elem.getBoundingClientRect().top;
          prevRight = elem.getBoundingClientRect().left+elem.getBoundingClientRect().width;
          prevBottom = elem.getBoundingClientRect().top + elem.getBoundingClientRect().height;
          document.addEventListener('mousemove' , moveSelection);

        } else if($L(event.target).hasClass('lyteSelectorHandles')){

          onResizeStart();


          var acele = $L('.lyteSelectorActiveBox')[0]; // ACTIVE ELEMENT acele

          var currentHold = event.target.className.split(' ');
          currentHandle = currentHold[1];

          currentX = event.clientX;
          currentY = event.clientY;

          rpLeft = acele.getBoundingClientRect().left;
          rpTop = acele.getBoundingClientRect().top;
          rpBottom = acele.getBoundingClientRect().top + acele.getBoundingClientRect().height;
          rpRight = acele.getBoundingClientRect().left + acele.getBoundingClientRect().width;

          rpWidth = acele.getBoundingClientRect().width;
          rpHeight = acele.getBoundingClientRect().height;

          document.addEventListener('mousemove' , resizeSelectionBox);

        } else if($L(event.target).hasClass('lyteSelectorDeleteBtn')){

          deleteOne();

        }



      }

      function createSelection(){



        var div = document.createElement('DIV');
        div.setAttribute('class' , currentClass);
        div.classList.add('lyteSelectionBox');

        if(!$L('.lyteSelectorBackImage')[0]){
          wrapperDiv.appendChild(imageTag);
          imageTag.style.height = imageTagOriginal.getBoundingClientRect().height + "px";
          imageTag.style.width = imageTagOriginal.getBoundingClientRect().width + "px";

          imageTagOriginal.style.display = "none"
        }


        var tlCorner = document.createElement('DIV');
        var trCorner = document.createElement('DIV');
        var brCorner = document.createElement('DIV');
        var blCorner = document.createElement('DIV');

        var tEdge = document.createElement('DIV');
        var bEdge = document.createElement('DIV');
        var rEdge = document.createElement('DIV');
        var lEdge = document.createElement('DIV');

        var deleteBtn = document.createElement('DIV');
        var workArea = document.createElement('DIV');

        var selectorLabelTop = document.createElement('DIV');
        var selectorLabelBottom = document.createElement('DIV');
        tlCorner.setAttribute('class' , 'lyteSelectorHandles lyteTLCorner')
        trCorner.setAttribute('class' , 'lyteSelectorHandles lyteTRCorner')
        brCorner.setAttribute('class' , 'lyteSelectorHandles lyteBRCorner')
        blCorner.setAttribute('class' , 'lyteSelectorHandles lyteBLCorner')
        tEdge.setAttribute('class' , 'lyteSelectorHandles lyteTEdge')
        bEdge.setAttribute('class' , 'lyteSelectorHandles lyteBEdge')
        rEdge.setAttribute('class' , 'lyteSelectorHandles lyteREdge')
        lEdge.setAttribute('class' , 'lyteSelectorHandles lyteLEdge')

        selectorLabelTop.setAttribute('class' , 'lyteSelectorLabel')
        selectorLabelBottom.setAttribute('class' , 'lyteSelectorLabel')

        deleteBtn.setAttribute('class' , 'lyteSelectorDeleteBtn')
        workArea.setAttribute('class' , 'lyteSelectorWorkArea')

        onCreate(workArea)


        div.appendChild(tlCorner)
        div.appendChild(trCorner)
        div.appendChild(brCorner)
        div.appendChild(blCorner)
        div.appendChild(tEdge)
        div.appendChild(bEdge)
        div.appendChild(rEdge)
        div.appendChild(lEdge)

        div.appendChild(selectorLabelTop)
        div.appendChild(selectorLabelBottom)
        wrapperDiv.appendChild(div)

        if(!$L('.lyteSelectionWrapperBox')[0]){
          wrapperDiv.setAttribute('class' , 'lyteSelectionWrapperBox');
          parentDiv.appendChild(wrapperDiv);
          wrapperDiv.style.height = imageTag.getBoundingClientRect().height+"px";
          wrapperDiv.style.width = imageTag.getBoundingClientRect().width+"px";;
        }

        if($L('.lyteSelectorActiveBox')[0]){
          $L('.lyteSelectorActiveBox')[0].classList.remove('lyteSelectorActiveBox');
        }

        if(!($L(div).hasClass('lyteSelectorActiveBox'))){
          div.classList.add('lyteSelectorActiveBox');
        }

        if(!($L('.lyteSelectionFreezeLayer')[0])){
          var freezeLayer = document.createElement('DIV');
          freezeLayer.setAttribute('class' , 'lyteSelectionFreezeLayer');
          wrapperDiv.appendChild(freezeLayer);
          freezeLayer.style.height = imageTag.getBoundingClientRect().height + "px";
          freezeLayer.style.top = 0 + "px";
          freezeLayer.style.width = imageTag.getBoundingClientRect().width + "px";
        }

        $L('.'+currentClass)[0].style.backgroundImage = "url('"+ imageTag.src +"')"
        $L('.'+currentClass)[0].style.backgroundPosition = (-($L('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
        $L('.'+currentClass)[0].style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
        $L('.'+currentClass)[0].style.backgroundRepeat = "no-repeat";

        document.addEventListener('mouseup' , removeEve)

        function removeEve(){
          document.removeEventListener('mousemove' , setDim);
          document.removeEventListener('mouseup' , removeEve);
          document.removeEventListener('mousedown' , mainFun);
          if($L('.'+currentClass)[0]){
            if(($L('.'+currentClass)[0].getBoundingClientRect().width<5)||($L('.'+currentClass)[0].getBoundingClientRect().height<5)){
              $L('.'+currentClass)[0].style.width = imageMinWidth + 'px';
              $L('.'+currentClass)[0].style.height = imageMinHeight + 'px';
              $L('.'+currentClass)[0].style.top = currentY - imageTag.getBoundingClientRect().top+'px';
              $L('.'+currentClass)[0].style.left = currentX - imageTag.getBoundingClientRect().left+'px';
              $L('.'+currentClass)[0].style.backgroundImage = "url('"+ imageTag.src +"')"
              $L('.'+currentClass)[0].style.backgroundPosition = (-($L('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
              $L('.'+currentClass)[0].style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
              $L('.'+currentClass)[0].style.backgroundRepeat = "no-repeat";
            }
          }
          div.appendChild(deleteBtn)
          div.appendChild(workArea)
        }

      }

      function setDim(){

        var xChange = currentX - event.clientX;
        var yChange = currentY - event.clientY;
        if(xChange < 0){
          $L('.'+currentClass)[0].style.left = currentX - imageTag.getBoundingClientRect().left + 'px'
        } else {
          $L('.'+currentClass)[0].style.left = event.clientX - imageTag.getBoundingClientRect().left + 'px'
        }
        if(yChange < 0){
          $L('.'+currentClass)[0].style.top = currentY - imageTag.getBoundingClientRect().top + 'px'
        } else {
          $L('.'+currentClass)[0].style.top = event.clientY - imageTag.getBoundingClientRect().top + 'px'
        }


        $L('.'+currentClass)[0].style.width = Math.abs(xChange) + 'px'
        $L('.'+currentClass)[0].style.height = Math.abs(yChange) + 'px'

        if(event.clientX <= imageTag.getBoundingClientRect().left ){

          $L('.'+currentClass)[0].style.left = '0px';
          $L('.'+currentClass)[0].style.width = currentX - imageTag.getBoundingClientRect().left + 'px';

        }

        if(event.clientY <= imageTag.getBoundingClientRect().top ){

          $L('.'+currentClass)[0].style.top = '0px';
          $L('.'+currentClass)[0].style.height = currentY - imageTag.getBoundingClientRect().top + 'px';

        }

        if(event.clientX >= (imageTag.getBoundingClientRect().left + imageTag.getBoundingClientRect().width)){

          $L('.'+currentClass)[0].style.width = ( ( imageTag.getBoundingClientRect().left +  imageTag.getBoundingClientRect().width ) - currentX) + 'px';

        }

        if(event.clientY >= (imageTag.getBoundingClientRect().top + imageTag.getBoundingClientRect().height) ){

          $L('.'+currentClass)[0].style.height = ( (imageTag.getBoundingClientRect().top + imageTag.getBoundingClientRect().height) - currentY) + 'px';

        }

        $L('.'+currentClass)[0].style.backgroundPosition = (-($L('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"

      }

      function moveSelection(){


        var leftVal = prevLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left;
        var topVal = prevTop - (currentY - event.clientY) - imageTag.getBoundingClientRect().top

        if(leftVal < 0){

          leftVal = 0;

        }

        if(topVal < 0){

          topVal = 0;

        }

        if((leftVal + $L('.lyteSelectorActiveBox')[0].getBoundingClientRect().width) >= imageTag.getBoundingClientRect().width){

          leftVal = imageTag.getBoundingClientRect().width - $L('.lyteSelectorActiveBox')[0].getBoundingClientRect().width

        }

        if((topVal + $L('.lyteSelectorActiveBox')[0].getBoundingClientRect().height) >= imageTag.getBoundingClientRect().height){

          topVal = imageTag.getBoundingClientRect().height - $L('.lyteSelectorActiveBox')[0].getBoundingClientRect().height

        }

        $L('.lyteSelectorActiveBox')[0].style.left = leftVal + "px";
        $L('.lyteSelectorActiveBox')[0].style.top = topVal + "px";

        $L('.lyteSelectorActiveBox')[0].style.backgroundPosition = (-($L('.lyteSelectorActiveBox')[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.lyteSelectorActiveBox')[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"


        document.addEventListener('mouseup' , removeMoveEve)


      }

      function removeMoveEve(){
        onDragEnd();
        document.removeEventListener('mousemove' , moveSelection);
        document.removeEventListener('mouseup' , removeMoveEve);
        document.removeEventListener('mousedown' , mainFun);
      }

      function resizeSelectionBox(){


        var th = $L('.lyteSelectorActiveBox')[0];

        switch (currentHandle) {

          case 'lyteTLCorner':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - (currentY - event.clientY) - imageTag.getBoundingClientRect().top + "px";
          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";

          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }

          break;
          case 'lyteTRCorner':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - (currentY - event.clientY) - imageTag.getBoundingClientRect().top + "px";
          th.style.width = rpWidth - (currentX - event.clientX) - 2 + "px";
          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
          break;
          case 'lyteBRCorner':
          th.style.width = rpWidth - (currentX - event.clientX) - 2 + "px";
          th.style.height = rpHeight - (currentY - event.clientY) - 2 + "px";
          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
          break;
          case 'lyteBLCorner':
          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";
          th.style.height = rpHeight - (currentY - event.clientY) + "px";
          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }

          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
          break;
          case 'lyteTEdge':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - imageTag.getBoundingClientRect().top - (currentY - event.clientY) + "px";

          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }

          break;
          case 'lyteBEdge':
          th.style.height = rpHeight - (currentY - event.clientY) + "px";
          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
          break;
          case 'lyteREdge':
          th.style.width = rpWidth - (currentX - event.clientX) + "px";
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
          break;
          case 'lyteLEdge':

          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";

          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }

          break;

        }

        $L('.lyteSelectorActiveBox')[0].style.backgroundPosition = (-($L('.lyteSelectorActiveBox')[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L('.lyteSelectorActiveBox')[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"

        document.addEventListener('mouseup' , removeReEve)

      }
      function removeReEve(){
        onResizeEnd()
        document.removeEventListener('mousemove' , resizeSelectionBox)
        document.removeEventListener('mouseup' , removeReEve)
        document.removeEventListener('mousedown' , mainFun);
      }

      function deleteOne(){

        event.preventDefault();

        onDeleteOne()

        var delElem = $L('.lyteSelectorActiveBox')[0];
        wrapperDiv.removeChild(delElem);

        var currentElemArr = $L(imageTagOriginal).data('classes');
        var delElemClass = delElem.classList[0];

        currentElemArr.splice( currentElemArr.indexOf(delElemClass) , 1 )

        if(currentElemArr.length < 1){

          wrapperDiv.removeChild($L('.lyteSelectionFreezeLayer')[0]);
          selectionArray = [];
          parentDiv.removeChild(wrapperDiv)
          imageTagOriginal.style.display = "block";

        }

      }

      function getSelectedData(){

        var returnData = {};

        returnData.imageNaturalWidth = imageTag.naturalWidth;
        returnData.imageNaturalHeight = imageTag.naturalHeight;

        returnData.imageWidth = imageTag.getBoundingClientRect().width;
        returnData.imageHeight = imageTag.getBoundingClientRect().height;

        var totalBoxes = $L(imageTagOriginal).data('classes').length;
        var classesArr = $L(imageTagOriginal).data('classes');
        var imageSelections = [];


        for(var i=0;i<totalBoxes;i++){

          var dummy = {};

          var ratioChange = imageTag.naturalWidth / imageTag.getBoundingClientRect().width;

          dummy.width = $L('.'+classesArr[i])[0].getBoundingClientRect().width;
          dummy.height = $L('.'+classesArr[i])[0].getBoundingClientRect().height;
          dummy.left = $L('.'+classesArr[i])[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left;
          dummy.top = $L('.'+classesArr[i])[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top;
          dummy.naturalWidth = $L('.'+classesArr[i])[0].getBoundingClientRect().width * ratioChange;
          dummy.naturalHeight = $L('.'+classesArr[i])[0].getBoundingClientRect().height * ratioChange;
          dummy.naturalLeft = ( $L('.'+classesArr[i])[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)*ratioChange;
          dummy.naturalTop = ($L('.'+classesArr[i])[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)*ratioChange;

          imageSelections.push(dummy);

        }

        returnData.imageSelections = imageSelections;


        return returnData;


      }

      selectionData.getData = function(){

        return getSelectedData()

      }


      selectionData.deleteAll = function (){

        onDeleteAll();

        var classArr = $L(imageTagOriginal).data().classes;

        for(var i=0;i<classArr.length;i++){
          wrapperDiv.removeChild( $L('.'+classArr[i])[0] )
        }

        wrapperDiv.removeChild($L('.lyteSelectionFreezeLayer')[0]);
        selectionArray = [];
        currentClass = '';

        parentDiv.removeChild(wrapperDiv)
        imageTagOriginal.style.display = "block";

      }

      $L(imageTagOriginal).data('lyteSelector' , selectionData);

    }

  }

}());

;( function(){
	if( window.lyteDomObj ){

		var isSticky = {}, span = document.createElement( 'span' );
		span.style.position = "sticky";
		if( span.style.position == "sticky" ){
			isSticky.sticky = true;
		} else {
			span.style.position = "-webkit-sticky";
			if( span.style.position == "-webkit-sticky" ){
				isSticky.webkitsticky = true;
			} else {
				isSticky.sticky = false;
			}
		}
		span = undefined;

		function getPos( pos ) {
			if( _lyteUiUtils.getRTL() ) {
				if( pos == "left" ){
					return 'right';
				} else if( pos == "right" ) {
					return "left";
				}

			} 
			return pos;
		}

		function globalScroll( evt ){
			var target = evt.target;
			if( target._sticky ){
				if( isSticky.sticky == false ){
					findScroll.call( target, target._sticky.highlight, true )
				} else if( target._sticky.highlight ) {
					findScroll.call( target, true );
				}
			}
		}

		function makeSticky( arg ){
			var elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query );
			for( var i = 0; i < elms.length; i++ ){
				var sty = elms[ i ].style, parstyle = elms[ i ].parentElement.style
				elms[ i ]._sticky = { val : sty[ arg.position ], position : sty.position, parPos : parstyle.position };
				if( isSticky.sticky != false ) {
					sty.position = isSticky.sticky ? "sticky" : ( isSticky.webkitsticky ?  "-webkit-sticky" : '' );
					sty[ arg.position ] = arg.offset + 'px';
				} else {
					sty.position = "relative";
					parstyle.position = "relative";
				}

			}
		}

		function unbind( arg ){
			var elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query );
			for( var i = 0; i < elms.length; i++ ){
				var obj = elms[ i ]._sticky, style = elms[ i ].style, parstyle = elms[ i ].parentElement.style;
				if( obj ){
					elms[ i ].classList.remove( 'lyteStickyActive' );
					style.position = obj.position;
					parstyle.position = obj.parPos;
					style[ arg.position ] = obj.val;
					delete elms[ i ]._sticky;
				}
			}
		}

		function findScroll( highlight, prevent ){
			if( !this.offsetParent ) {
				return
			}
			var arg = this._sticky, offs = [], slft, stp, elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query ),
			stp = this == document.body ? window.pageYOffset : this.scrollTop, slft = this == document.body ? window.pageXOffset : this.scrollLeft,
			pos = arg.position, vert = [ 'bottom', 'top' ].indexOf( pos ) != -1, 
			bcr = this.getBoundingClientRect(), wid = vert ? "height" : "width", ofset = arg.offset;
			if( ( !vert && arg._prevx != slft ) || ( vert && arg._prevy != stp ) ) {
				for( var i = 0; i < elms.length; i++ ) {
					offs[ i ] = {};
					offs[ i ].node = elms[ i ]; elms[ i ].parent = elms[ i ].parentElement;
					offs[ i ].curBcr = elms[ i ].getBoundingClientRect();
					offs[ i ].parBcr = elms[ i ].parentElement.getBoundingClientRect();
				}
				for( var i = 0; i < elms.length; i++ ) {
					var cEl = offs[ i ], pBcr = cEl.parBcr, curBcr = cEl.curBcr, node = cEl.node.style,
					fact = 1, val = 0, flag = false;
					if( [ 'bottom', 'right' ].indexOf( pos ) != -1 ) {
						fact *= -1;
					}
					if( fact > 0 ) {
						if( parseInt( pBcr[ pos ] ) <= parseInt( bcr[ pos ] ) && ( parseInt( pBcr[ pos ] + pBcr[ wid ] ) >= parseInt( bcr[ pos ] + ofset ) ) ){
							var min = bcr[ pos ] - ( pBcr[ pos ] )
						 	val = min + ofset;
							flag = true;
						}
					} else {
						if( parseInt( pBcr[ pos ] ) >= parseInt( bcr[ pos ] ) && ( parseInt( pBcr[ pos ] - pBcr[ wid ] ) < parseInt( bcr[ pos ] - ofset ) ) ){
							var min = pBcr[ pos ] - bcr[ pos ];
							val = min + ofset;
							flag = true;
						}
					}
					if( flag ) {
						if( prevent ){
							node[ pos ] = val + 'px';
						}
						arg.onAdd && !cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onAdd.call( this, cEl.node );
						highlight && cEl.node.classList.add( 'lyteStickyActive' );
						if( stp == 0 ){
							arg.onRemove && cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onRemove.call( this, cEl.node );
							cEl.node.classList.remove( 'lyteStickyActive' );
						}
					} else {
						arg.onRemove && cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onRemove.call( this, cEl.node );
						highlight && cEl.node.classList.remove( 'lyteStickyActive' );
					}
				}
			}
			arg._prevx = slft; arg._prevY = stp;
		}

		lyteDomObj.prototype.destroySticky = function(){
			$L( '.lyteSticky' ).removeSticky();
			window.removeEventListener( 'scroll', globalScroll, true )
			return this;
		}

		lyteDomObj.prototype.removeSticky = function(){
			for( var i = 0; i < this.length; i++ ){
				var obj = this[ i ]._sticky;
				if( obj ) {
					clearTimeout( obj._stickytime ); clearTimeout( obj._init );
					clearTimeout( obj._genscroll );
					unbind.call( this[ i ], obj ); 
					this[ i ].classList.remove( 'lyteSticky' );
					delete this[ i ]._sticky; 
				}
			}
			return this;
		}

		lyteDomObj.prototype.sticky = function( obj ){
			obj = obj || {};
			obj.position = getPos( obj.position ) || "top";
			obj.offset = obj.offset || 0;
			obj.query = obj.query || "*>*:first-child:not(template)";
			for( var i = 0; i < this.length; i++ ){
				if( this[ i ]._sticky ){
					$L( this[ i ] ).removeSticky();
				}
				this[ i ].classList.add( 'lyteSticky' );
				this[ i ]._sticky = $L.extend( true, {}, obj );
				this[ i ]._sticky._stickytime = setTimeout( makeSticky.bind( this[ i ] ), 20, this[ i ]._sticky )
				// if( isSticky.sticky == false ) {
					this[ i ]._sticky._init = setTimeout( findScroll.bind( this[ i ], obj.highlight, isSticky.sticky == false ), 40 )
				// }
			}
		 	return this;
		}
		
			window.addEventListener( 'scroll', globalScroll, true )
		// }
	}
} )( window )
;( function() {
	if( window.lyteDomObj ) {
		function fndChdrn( ori ){
			var query = ".lyteScrollSpy " + this._scrollspy.obj.query +":not(template)", ignore = this._scrollspy.obj.ignore;
			if( ignore.constructor == String ) {
				ignore = ignore.split( ',' );
			}
			for( var i = 0; i < ignore.length; i++ ) {
				query += ":not(" + ignore[ i ].trim() + ")";
			}
			
			return this.parentElement.querySelectorAll( query );
		}

		function intEl( prev, curr, cd ){
			var grp = [];
			for( var i = 0; i < cd.length; i++ ) {
				if( cd[ i ] != prev && cd[ i ] != curr && ( ( cd[ i ].off > prev.off && cd[ i ].off < curr.off ) || ( cd[ i ].off < prev.off && cd[ i ].off > curr.off ) ) ) {
					grp.push( cd[ i ] ); 
				}
			}	
			return grp;
		}

		function oT( src, sT, flag ) {
			var bcr = src.getBoundingClientRect();
			return Math.round( Math.max( 0, ( -this.getBoundingClientRect().top + sT + bcr.top + ( flag ? bcr.height : 0 ) ) ) )
		}

		function spyall( cd, hgt, sT, cge ) {
			var curr = [], prev = [], map = [], chged;
			for( var i = 0; i < cd.length; i++ ) { 
				map.push( { topp : oT.call( this, cd[ i ], sT ), hgt : cd[ i ].offsetHeight } );
				var cls = $L( cd[ i ] ).hasClass( 'lyteSpyActive' );
				if( ( map[ i ].topp <= sT + hgt && map[ i ].topp > sT  ) || ( ( map[ i ].topp + map[ i ].hgt ) >= sT && ( map[ i ].topp + map[ i ].hgt ) <= sT + hgt ) || ( map[ i ].topp <= sT && ( map[ i ].topp + map[ i ].hgt ) >= sT + hgt ) ) {
						if( !cls ) {
							$L( cd[ i ] ).addClass( 'lyteSpyActive' );
							chged = true
						}
						curr.push( cd[ i ] )
				} else if( cls ) {
					$L( cd[ i ] ).removeClass( 'lyteSpyActive' );
					prev.push( cd[ i ] ) 
					chged = true
				}	
			}
			if( chged && cge && cge.constructor == Function ){
				cge( curr, prev ,this )
			}
		}

		function setClass( cd ){
			var wO = this._wheelObj, hgt = this.offsetHeight, spy = this._scrollspy.obj, sT = ( wO ? wO.scrollTop : ( this == document.body ? window.pageYOffset : this.scrollTop ) ), prev = this.parentElement.querySelector( '.lyteScrollSpy ' + spy.query + '.lyteSpyActive:not(template)' ), curr, cge = spy.onChange;
			if( cd.length ) {
				if( spy.position == "all" ) {
					spyall.call( this, cd, hgt, sT, cge )
				} else {
					if( spy.position == "bottom" ) {
						for( var i = cd.length - 1; i >= 0; i-- ) {
							cd[ i ].off = oT.call( this, cd[ i ], sT, true ); 
							if( sT + hgt - this._scrollspy.obj.offset > cd[ i ].off ) {
								if( curr && cd[ i ].off < curr.off ){
									continue;
								}
								curr = cd[ i ];
							}
						}
					} else {
						for( var i = 0; i < cd.length; i++ ) {
							cd[ i ].off = oT.call( this, cd[ i ], sT ) + cd[ i ].offsetHeight; 
							if( sT + this._scrollspy.obj.offset < cd[ i ].off ) {
								if( curr && cd[ i ].off > curr.off ){
									continue;
								}
								curr = cd[ i ];
							}
						}
					}
					if( prev != curr ) {
						if( prev ){
							prev.classList.remove( 'lyteSpyActive' );
						}
						curr.classList.add( 'lyteSpyActive' );
						if( cge && cge.constructor == Function ){
							cge( curr, prev, prev ? intEl.call( this, prev, curr, cd ) : [] ,this )
						}
					}
				}
			}	

		}
		function innfun(){
			var chdrn = setClass.call( this, fndChdrn.call( this, this.children ) );	
			delete this._scrollspy.obj._spytime;
		}

		function glbscrll( evt ) {
			var tg = evt.target,
			spy = tg._scrollspy;

			if( spy ) {
				if( spy.obj.position == "visible" ){
					intersection_scroll.call( tg );
				} else{
					if( tg._scrollFun ) {
						clearTimeout( spy.obj._spytime );
						spy.obj._spytime = setTimeout( innfun.bind( tg ) , 0 );
					} else {
						innfun.call( tg );
					}
				}
			}
		}

		function intersection_scroll(){
			var bcr = this.getBoundingClientRect(),
			active = [],
			in_active = [],
			obj = this._scrollspy.obj,
			class_name = obj.activeClass,
			callback = obj.onChange,
			offset = obj.offset,
			left_str = "left",
			right_str = "right",
			top_str = "top",
			bottom_str = "bottom",
			partial = function( __bcr, to_check, _left, _right ){
				var value = __bcr[ to_check ];
				return ( ( bcr[ _left ] - offset ) < value ) && ( value < ( bcr[ _right ] + offset ) );
			},
			is_visible = function( __bcr ){
				return ( partial( __bcr, left_str, left_str, right_str ) || partial( __bcr, right_str, left_str, right_str ) ) && ( partial( __bcr, top_str, top_str, bottom_str ) || partial( __bcr, bottom_str, top_str, bottom_str ) );
			};

			Array.from( fndChdrn.call( this ) ).forEach( function( item ){
				var __bcr = item.getBoundingClientRect(),
				$elem = $L( item ),
				_has = $elem.hasClass( class_name );

				if( is_visible( __bcr ) ){
					if( !_has ){
						active.push( item );
						// $elem.addClass( class_name );
					}
				} else if( _has ){
					in_active.push( item );
					// $elem.removeClass( class_name );
				}
			});

			active.forEach( function( item ){
				$L( item ).addClass( class_name );
			});

			in_active.forEach( function( item ){
				$L( item ).removeClass( class_name );
			});

			if( callback && ( active.length || in_active.length ) ){
				callback( active, in_active, this );
			}
		}

		lyteDomObj.prototype.removeScrollspy = function(){

			var len = this.length;

			for( var i = 0; i < len; i++ ){
				var current = this.eq( i ),
				dom = current.get( 0 ),
				data = dom._scrollspy;
				current.removeClass( 'lyteScrollSpy' );
				clearTimeout( data.obj._spytime );
				delete dom._scrollspy;
			}
		}
		lyteDomObj.prototype.scrollspy = function( obj ) {
			var length = this.length;

			if( obj == "reset" ){
				for( var i = 0; i < length; i++ ) {
				 	glbscrll( { target : this[ i ] } );
				}
				return this;
			}
			obj = obj || {};
			obj.activeClass = obj.activeClass || 'lyteSpyActive';
			obj.offset = obj.offset || 0; obj.ignore = obj.ignore || [];
			obj.position = obj.position || "top";
			obj.query = obj.query || ">*";

			for( var i = 0; i < length; i++ ) {
				var jelem = this.eq( i ),
				dom = jelem.get( 0 ),
				copy_obj = $L.extend( true, {}, obj );

				dom._scrollspy = {
					obj : copy_obj
				};

				jelem.addClass( 'lyteScrollSpy' );
				setTimeout( glbscrll, 20, { target : dom } );
			}
			return this;	
		}
		window.addEventListener( 'scroll', glbscrll, true );
	}
} )( window );
;( function( window ){
		if( lyteDomObj ){
			var shortMon = [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],
			longMon = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'  ],
			weekLong = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			weekMid = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			weekShort = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			dayArr = [ 31, 28, 31, 30, 31, 30, 31, 31,30, 31, 30, 31 ],
			week = 'W', wod = 1,
			lm = "lyteMoment",
			uLimit = 19,
			lLimit = 80,
			timeZoneOffsets = {"Etc/GMT+12":-720,"Etc/GMT+11":-660,"Pacific/Midway":-660,"Pacific/Niue":-660,"Pacific/Pago_Pago":-660,"Pacific/Samoa":-660,"US/Samoa":-660,"America/Adak":-540,"America/Atka":-540,"Etc/GMT+10":-600,"HST":-600,"Pacific/Honolulu":-600,"Pacific/Johnston":-600,"Pacific/Rarotonga":-600,"Pacific/Tahiti":-600,"SystemV/HST10":-600,"US/Aleutian":-540,"US/Hawaii":-600,"Pacific/Marquesas":-510,"AST":-480,"America/Anchorage":-480,"America/Juneau":-480,"America/Metlakatla":-480,"America/Nome":-480,"America/Sitka":-480,"America/Yakutat":-480,"Etc/GMT+9":-540,"Pacific/Gambier":-540,"SystemV/YST9":-540,"SystemV/YST9YDT":-480,"US/Alaska":-480,"America/Ensenada":-420,"America/Los_Angeles":-420,"America/Santa_Isabel":-420,"America/Tijuana":-420,"America/Vancouver":-420,"Canada/Pacific":-420,"Etc/GMT+8":-480,"Mexico/BajaNorte":-420,"PST":-480,"PST8PDT":-420,"Pacific/Pitcairn":-480,"SystemV/PST8":-480,"SystemV/PST8PDT":-420,"US/Pacific":-420,"America/Boise":-360,"America/Cambridge_Bay":-360,"America/Chihuahua":-360,"America/Creston":-420,"America/Dawson":-420,"America/Dawson_Creek":-420,"America/Denver":-360,"America/Edmonton":-360,"America/Fort_Nelson":-420,"America/Hermosillo":-420,"America/Inuvik":-360,"America/Mazatlan":-360,"America/Ojinaga":-360,"America/Phoenix":-420,"America/Shiprock":-360,"America/Whitehorse":-420,"America/Yellowknife":-360,"Canada/Mountain":-360,"Canada/Yukon":-420,"Etc/GMT+7":-420,"MST":-420,"MST7MDT":-360,"Mexico/BajaSur":-360,"Navajo":-360,"PNT":-420,"SystemV/MST7":-420,"SystemV/MST7MDT":-360,"US/Arizona":-420,"US/Mountain":-360,"America/Bahia_Banderas":-300,"America/Belize":-360,"America/Chicago":-300,"America/Costa_Rica":-360,"America/El_Salvador":-360,"America/Guatemala":-360,"America/Indiana/Knox":-300,"America/Indiana/Tell_City":-300,"America/Knox_IN":-300,"America/Managua":-360,"America/Matamoros":-300,"America/Menominee":-300,"America/Merida":-300,"America/Mexico_City":-300,"America/Monterrey":-300,"America/North_Dakota/Beulah":-300,"America/North_Dakota/Center":-300,"America/North_Dakota/New_Salem":-300,"America/Rainy_River":-300,"America/Rankin_Inlet":-300,"America/Regina":-360,"America/Resolute":-300,"America/Swift_Current":-360,"America/Tegucigalpa":-360,"America/Winnipeg":-300,"CST":-360,"CST6CDT":-300,"Canada/Central":-300,"Canada/Saskatchewan":-360,"Chile/EasterIsland":-360,"Etc/GMT+6":-360,"Mexico/General":-300,"Pacific/Easter":-360,"Pacific/Galapagos":-360,"SystemV/CST6":-360,"SystemV/CST6CDT":-300,"US/Central":-300,"US/Indiana-Starke":-300,"America/Atikokan":-300,"America/Bogota":-300,"America/Cancun":-300,"America/Cayman":-300,"America/Coral_Harbour":-300,"America/Detroit":-240,"America/Eirunepe":-300,"America/Fort_Wayne":-240,"America/Grand_Turk":-240,"America/Guayaquil":-300,"America/Havana":-240,"America/Indiana/Indianapolis":-240,"America/Indiana/Marengo":-240,"America/Indiana/Petersburg":-240,"America/Indiana/Vevay":-240,"America/Indiana/Vincennes":-240,"America/Indiana/Winamac":-240,"America/Indianapolis":-240,"America/Iqaluit":-240,"America/Jamaica":-300,"America/Kentucky/Louisville":-240,"America/Kentucky/Monticello":-240,"America/Lima":-300,"America/Louisville":-240,"America/Montreal":-240,"America/Nassau":-240,"America/New_York":-240,"America/Nipigon":-240,"America/Panama":-300,"America/Pangnirtung":-240,"America/Port-au-Prince":-240,"America/Porto_Acre":-300,"America/Rio_Branco":-300,"America/Thunder_Bay":-240,"America/Toronto":-240,"Brazil/Acre":-300,"Canada/Eastern":-240,"Cuba":-240,"EST":-300,"EST5EDT":-240,"Etc/GMT+5":-300,"IET":-240,"Jamaica":-300,"SystemV/EST5":-300,"SystemV/EST5EDT":-240,"US/East-Indiana":-240,"US/Eastern":-240,"US/Michigan":-240,"America/Anguilla":-240,"America/Antigua":-240,"America/Aruba":-240,"America/Asuncion":-240,"America/Barbados":-240,"America/Blanc-Sablon":-240,"America/Boa_Vista":-240,"America/Campo_Grande":-240,"America/Caracas":-240,"America/Cuiaba":-240,"America/Curacao":-240,"America/Dominica":-240,"America/Glace_Bay":-180,"America/Goose_Bay":-180,"America/Grenada":-240,"America/Guadeloupe":-240,"America/Guyana":-240,"America/Halifax":-180,"America/Kralendijk":-240,"America/La_Paz":-240,"America/Lower_Princes":-240,"America/Manaus":-240,"America/Marigot":-240,"America/Martinique":-240,"America/Moncton":-180,"America/Montserrat":-240,"America/Port_of_Spain":-240,"America/Porto_Velho":-240,"America/Puerto_Rico":-240,"America/Santiago":-240,"America/Santo_Domingo":-240,"America/St_Barthelemy":-240,"America/St_Kitts":-240,"America/St_Lucia":-240,"America/St_Thomas":-240,"America/St_Vincent":-240,"America/Thule":-180,"America/Tortola":-240,"America/Virgin":-240,"Atlantic/Bermuda":-180,"Brazil/West":-240,"Canada/Atlantic":-180,"Chile/Continental":-240,"Etc/GMT+4":-240,"PRT":-240,"SystemV/AST4":-240,"SystemV/AST4ADT":-180,"America/St_Johns":-90,"CNT":-90,"Canada/Newfoundland":-90,"AGT":-180,"America/Araguaina":-180,"America/Argentina/Buenos_Aires":-180,"America/Argentina/Catamarca":-180,"America/Argentina/ComodRivadavia":-180,"America/Argentina/Cordoba":-180,"America/Argentina/Jujuy":-180,"America/Argentina/La_Rioja":-180,"America/Argentina/Mendoza":-180,"America/Argentina/Rio_Gallegos":-180,"America/Argentina/Salta":-180,"America/Argentina/San_Juan":-180,"America/Argentina/San_Luis":-180,"America/Argentina/Tucuman":-180,"America/Argentina/Ushuaia":-180,"America/Bahia":-180,"America/Belem":-180,"America/Buenos_Aires":-180,"America/Catamarca":-180,"America/Cayenne":-180,"America/Cordoba":-180,"America/Fortaleza":-180,"America/Godthab":-120,"America/Jujuy":-180,"America/Maceio":-180,"America/Mendoza":-180,"America/Miquelon":-120,"America/Montevideo":-180,"America/Nuuk":-120,"America/Paramaribo":-180,"America/Punta_Arenas":-180,"America/Recife":-180,"America/Rosario":-180,"America/Santarem":-180,"America/Sao_Paulo":-180,"Antarctica/Palmer":-180,"Antarctica/Rothera":-180,"Atlantic/Stanley":-180,"BET":-180,"Brazil/East":-180,"Etc/GMT+3":-180,"America/Noronha":-120,"Atlantic/South_Georgia":-120,"Brazil/DeNoronha":-120,"Etc/GMT+2":-120,"America/Scoresbysund":0,"Atlantic/Azores":0,"Atlantic/Cape_Verde":-60,"Etc/GMT+1":-60,"Africa/Abidjan":0,"Africa/Accra":0,"Africa/Bamako":0,"Africa/Banjul":0,"Africa/Bissau":0,"Africa/Casablanca":0,"Africa/Conakry":0,"Africa/Dakar":0,"Africa/El_Aaiun":0,"Africa/Freetown":0,"Africa/Lome":0,"Africa/Monrovia":0,"Africa/Nouakchott":0,"Africa/Ouagadougou":0,"Africa/Sao_Tome":0,"Africa/Timbuktu":0,"America/Danmarkshavn":0,"Antarctica/Troll":120,"Atlantic/Canary":60,"Atlantic/Faeroe":60,"Atlantic/Faroe":60,"Atlantic/Madeira":60,"Atlantic/Reykjavik":0,"Atlantic/St_Helena":0,"Eire":60,"Etc/GMT":-0,"Etc/GMT+0":-0,"Etc/GMT-0":-0,"Etc/GMT0":-0,"Etc/Greenwich":-0,"Etc/UCT":-0,"Etc/UTC":-0,"Etc/Universal":-0,"Etc/Zulu":-0,"Europe/Belfast":60,"Europe/Dublin":60,"Europe/Guernsey":60,"Europe/Isle_of_Man":60,"Europe/Jersey":60,"Europe/Lisbon":60,"Europe/London":60,"GB":60,"GB-Eire":60,"GMT":0,"GMT0":0,"Greenwich":0,"Iceland":0,"Portugal":60,"UCT":0,"UTC":0,"Universal":0,"WET":60,"Zulu":0,"Africa/Algiers":60,"Africa/Bangui":60,"Africa/Brazzaville":60,"Africa/Ceuta":120,"Africa/Douala":60,"Africa/Kinshasa":60,"Africa/Lagos":60,"Africa/Libreville":60,"Africa/Luanda":60,"Africa/Malabo":60,"Africa/Ndjamena":60,"Africa/Niamey":60,"Africa/Porto-Novo":60,"Africa/Tunis":60,"Arctic/Longyearbyen":120,"Atlantic/Jan_Mayen":120,"CET":120,"ECT":120,"Etc/GMT-1":60,"Europe/Amsterdam":120,"Europe/Andorra":120,"Europe/Belgrade":120,"Europe/Berlin":120,"Europe/Bratislava":120,"Europe/Brussels":120,"Europe/Budapest":120,"Europe/Busingen":120,"Europe/Copenhagen":120,"Europe/Gibraltar":120,"Europe/Ljubljana":120,"Europe/Luxembourg":120,"Europe/Madrid":120,"Europe/Malta":120,"Europe/Monaco":120,"Europe/Oslo":120,"Europe/Paris":120,"Europe/Podgorica":120,"Europe/Prague":120,"Europe/Rome":120,"Europe/San_Marino":120,"Europe/Sarajevo":120,"Europe/Skopje":120,"Europe/Stockholm":120,"Europe/Tirane":120,"Europe/Vaduz":120,"Europe/Vatican":120,"Europe/Vienna":120,"Europe/Warsaw":120,"Europe/Zagreb":120,"Europe/Zurich":120,"MET":120,"Poland":120,"ART":120,"Africa/Blantyre":120,"Africa/Bujumbura":120,"Africa/Cairo":120,"Africa/Gaborone":120,"Africa/Harare":120,"Africa/Johannesburg":120,"Africa/Khartoum":120,"Africa/Kigali":120,"Africa/Lubumbashi":120,"Africa/Lusaka":120,"Africa/Maputo":120,"Africa/Maseru":120,"Africa/Mbabane":120,"Africa/Tripoli":120,"Africa/Windhoek":120,"Asia/Amman":180,"Asia/Beirut":180,"Asia/Damascus":180,"Asia/Famagusta":180,"Asia/Gaza":180,"Asia/Hebron":180,"Asia/Jerusalem":180,"Asia/Nicosia":180,"Asia/Tel_Aviv":180,"CAT":120,"EET":180,"Egypt":120,"Etc/GMT-2":120,"Europe/Athens":180,"Europe/Bucharest":180,"Europe/Chisinau":180,"Europe/Helsinki":180,"Europe/Kaliningrad":120,"Europe/Kiev":180,"Europe/Mariehamn":180,"Europe/Nicosia":180,"Europe/Riga":180,"Europe/Sofia":180,"Europe/Tallinn":180,"Europe/Tiraspol":180,"Europe/Uzhgorod":180,"Europe/Vilnius":180,"Europe/Zaporozhye":180,"Israel":180,"Libya":120,"Africa/Addis_Ababa":180,"Africa/Asmara":180,"Africa/Asmera":180,"Africa/Dar_es_Salaam":180,"Africa/Djibouti":180,"Africa/Juba":180,"Africa/Kampala":180,"Africa/Mogadishu":180,"Africa/Nairobi":180,"Antarctica/Syowa":180,"Asia/Aden":180,"Asia/Baghdad":180,"Asia/Bahrain":180,"Asia/Istanbul":180,"Asia/Kuwait":180,"Asia/Qatar":180,"Asia/Riyadh":180,"EAT":180,"Etc/GMT-3":180,"Europe/Istanbul":180,"Europe/Kirov":180,"Europe/Minsk":180,"Europe/Moscow":180,"Europe/Simferopol":180,"Indian/Antananarivo":180,"Indian/Comoro":180,"Indian/Mayotte":180,"Turkey":180,"W-SU":180,"Asia/Tehran":270,"Iran":270,"Asia/Baku":240,"Asia/Dubai":240,"Asia/Muscat":240,"Asia/Tbilisi":240,"Asia/Yerevan":240,"Etc/GMT-4":240,"Europe/Astrakhan":240,"Europe/Samara":240,"Europe/Saratov":240,"Europe/Ulyanovsk":240,"Europe/Volgograd":240,"Indian/Mahe":240,"Indian/Mauritius":240,"Indian/Reunion":240,"NET":240,"Asia/Kabul":270,"Antarctica/Mawson":300,"Asia/Aqtau":300,"Asia/Aqtobe":300,"Asia/Ashgabat":300,"Asia/Ashkhabad":300,"Asia/Atyrau":300,"Asia/Dushanbe":300,"Asia/Karachi":300,"Asia/Oral":300,"Asia/Qyzylorda":300,"Asia/Samarkand":300,"Asia/Tashkent":300,"Asia/Yekaterinburg":300,"Etc/GMT-5":300,"Indian/Kerguelen":300,"Indian/Maldives":300,"PLT":300,"Asia/Calcutta":330,"Asia/Colombo":330,"Asia/Kolkata":330,"IST":330,"Asia/Kathmandu":345,"Asia/Katmandu":345,"Antarctica/Vostok":360,"Asia/Almaty":360,"Asia/Bishkek":360,"Asia/Dacca":360,"Asia/Dhaka":360,"Asia/Kashgar":360,"Asia/Omsk":360,"Asia/Qostanay":360,"Asia/Thimbu":360,"Asia/Thimphu":360,"Asia/Urumqi":360,"BST":360,"Etc/GMT-6":360,"Indian/Chagos":360,"Asia/Rangoon":390,"Asia/Yangon":390,"Indian/Cocos":390,"Antarctica/Davis":420,"Asia/Bangkok":420,"Asia/Barnaul":420,"Asia/Ho_Chi_Minh":420,"Asia/Hovd":420,"Asia/Jakarta":420,"Asia/Krasnoyarsk":420,"Asia/Novokuznetsk":420,"Asia/Novosibirsk":420,"Asia/Phnom_Penh":420,"Asia/Pontianak":420,"Asia/Saigon":420,"Asia/Tomsk":420,"Asia/Vientiane":420,"Etc/GMT-7":420,"Indian/Christmas":420,"VST":420,"Asia/Brunei":480,"Asia/Choibalsan":480,"Asia/Chongqing":480,"Asia/Chungking":480,"Asia/Harbin":480,"Asia/Hong_Kong":480,"Asia/Irkutsk":480,"Asia/Kuala_Lumpur":480,"Asia/Kuching":480,"Asia/Macao":480,"Asia/Macau":480,"Asia/Makassar":480,"Asia/Manila":480,"Asia/Shanghai":480,"Asia/Singapore":480,"Asia/Taipei":480,"Asia/Ujung_Pandang":480,"Asia/Ulaanbaatar":480,"Asia/Ulan_Bator":480,"Australia/Perth":480,"Australia/West":480,"CTT":480,"Etc/GMT-8":480,"Hongkong":480,"PRC":480,"Singapore":480,"Australia/Eucla":525,"Asia/Chita":540,"Asia/Dili":540,"Asia/Jayapura":540,"Asia/Khandyga":540,"Asia/Pyongyang":540,"Asia/Seoul":540,"Asia/Tokyo":540,"Asia/Yakutsk":540,"Etc/GMT-9":540,"JST":540,"Japan":540,"Pacific/Palau":540,"ROK":540,"ACT":570,"Australia/Adelaide":570,"Australia/Broken_Hill":570,"Australia/Darwin":570,"Australia/North":570,"Australia/South":570,"Australia/Yancowinna":570,"AET":600,"Antarctica/DumontDUrville":600,"Antarctica/Macquarie":600,"Asia/Ust-Nera":600,"Asia/Vladivostok":600,"Australia/ACT":600,"Australia/Brisbane":600,"Australia/Canberra":600,"Australia/Currie":600,"Australia/Hobart":600,"Australia/Lindeman":600,"Australia/Melbourne":600,"Australia/NSW":600,"Australia/Queensland":600,"Australia/Sydney":600,"Australia/Tasmania":600,"Australia/Victoria":600,"Etc/GMT-10":600,"Pacific/Chuuk":600,"Pacific/Guam":600,"Pacific/Port_Moresby":600,"Pacific/Saipan":600,"Pacific/Truk":600,"Pacific/Yap":600,"Australia/LHI":630,"Australia/Lord_Howe":630,"Antarctica/Casey":660,"Asia/Magadan":660,"Asia/Sakhalin":660,"Asia/Srednekolymsk":660,"Etc/GMT-11":660,"Pacific/Bougainville":660,"Pacific/Efate":660,"Pacific/Guadalcanal":660,"Pacific/Kosrae":660,"Pacific/Norfolk":660,"Pacific/Noumea":660,"Pacific/Pohnpei":660,"Pacific/Ponape":660,"SST":660,"Antarctica/McMurdo":720,"Antarctica/South_Pole":720,"Asia/Anadyr":720,"Asia/Kamchatka":720,"Etc/GMT-12":720,"Kwajalein":720,"NST":720,"NZ":720,"Pacific/Auckland":720,"Pacific/Fiji":720,"Pacific/Funafuti":720,"Pacific/Kwajalein":720,"Pacific/Majuro":720,"Pacific/Nauru":720,"Pacific/Tarawa":720,"Pacific/Wake":720,"Pacific/Wallis":720,"NZ-CHAT":765,"Pacific/Chatham":765,"Etc/GMT-13":780,"MIT":780,"Pacific/Apia":780,"Pacific/Enderbury":780,"Pacific/Fakaofo":780,"Pacific/Tongatapu":780,"Etc/GMT-14":840,"Pacific/Kiritimati":840,"UT":0,"EDT":-240,"CDT":-300,"MDT":-360,"PDT":-420},
			
			timezone_regex = new RegExp( '(' + Object.keys( timeZoneOffsets ).join('|') + ')' ),

			default_timezone,
			default_offset,

			is_IE,

			formats = [
				{ val :'YYYY', type : 'year', regex : /\d{4}/, len : 4 },
				{ val : 'GGGG', type : 'year', regex : /\d{4}/, len : 4, isWEG : true }, 
				{ val : 'gggg', type : 'year', regex : /\d{4}/, len : 4, isWEG : true }, 
				{ val : 'YY', type : 'year', regex : /\d{2}/, len : 2 }, 
				{ val : 'GG', type : 'year', regex : /\d{2}/, len : 2, isWEG : true}, 
				{ val : 'gg', type : 'year', regex : /\d{2}/, len : 2, isWEG : true}, 
				{ val : 'MMMM', type : "month", regex : /[A-z]{3,}/, long : true, str : true, array : longMon }, 
				{ val : 'MMM', str : true, type : "month", regex : /[A-z]{3,}/, array : shortMon }, 
				{ val : 'Mo', suff : true, type : "month", regex : /\d{1,2}(?=st|nd|rd|th)/, max : 12 }, 
				{ val : 'MM', type : "month", regex : /\d{2}/, len : 2, max : 12, alt : true }, 
				{ val : 'M', type : "month", regex : /\d{1,2}/, max : 12 }, 
				{ val : 'DDDD', type : 'date', regex : /\d{3}/, len : 3, year : true }, 
				{ val : 'DDDo', type : 'date', suff : true, regex : /\d{1,3}(?=st|nd|rd|th)/, len : 3, year : true, ignore : /\d{3}(?=st|nd|rd|th)/ }, 
				{ val : 'DDD', type : 'date', regex : /\d{1,3}/, year : true, ignore : /\d{3}/}, 
				{ val : 'Do', type : 'date', suff : true , regex : /\d{1,2}(?=st|nd|rd|th)/ }, 
				{ val : 'DD', type : 'date', regex : /\d{2}/, len : 2, alt : true }, 
				{ val : 'D', type : 'date', regex : /\d{1,2}/ }, 
				{ val : '[' + week + ']Wo', type : 'week', suff : true, regex : new RegExp('\[' + week + '\]\d{1,2}(?=st|nd|th|rd)'), isWEG : true },
				{ val : '[' + week + ']wo', ignore : 1, type : 'week', suff : true, regex : new RegExp('\[' + week + '\]\d{1,2}(?=st|nd|th|rd)'), isWEG : true }, 
				{ val : '[' + week + ']WW', type : 'week', regex : new RegExp( week +'(\\d{2})'), len : 2, isWEG : true, match : 1 }, 
				{ val : '[' + week + ']ww', ignore : 1, type : 'week', regex : new RegExp( week +'(\\d{2})'), len : 2, isWEG : true, match : 1 }, 
				{ val : '[' + week + ']W', type : 'week', regex : new RegExp( week +'(\\d{1,2})'), isWEG : true, match : 1 }, 
				{ val : '[' + week + ']w', ignore : 1, type : 'week', regex : new RegExp( week +'(\\d{1,2})'), isWEG : true, match : 1 }, 
				{ val : 'Wo', type : 'week', pref : 0, suff : true, regex : new RegExp('\[' + week + '\]\d{1,2}(?=st|nd|th|rd)'), isWEG : true },
				{ val : 'wo', type : 'week', pref : 0, ignore : 1, suff : true, regex : new RegExp('\[' + week + '\]\d{1,2}(?=st|nd|th|rd)'), isWEG : true }, 
				{ val : 'WW', type : 'week', pref : 0, regex : new RegExp( '(\\d{2})'), len : 2, isWEG : true, match : 1 }, 
				{ val : 'ww', type : 'week', pref : 0, ignore : 1, regex : new RegExp( '(\\d{2})'), len : 2, isWEG : true, match : 1 }, 
				{ val : 'W', type : 'week', pref : 0, regex : new RegExp( '(\\d{1,2})'), isWEG : true, match : 1 }, 
				{ val : 'w', type : 'week', pref : 0, ignore : 1, regex : new RegExp( '(\\d{1,2})'), isWEG : true, match : 1 }, 
				{ val : 'E', type : 'day', regex : /\d{1}/, isWEG : true }, 
				{ val : 'e', type : 'day', regex : /\d{1}/, isWEG : true, local : true }, 
				{ val : 'A', type : 'meridian', regex : /AM|PM/, str : true, time : true },
				{ val : 'a', type : 'meridian', regex : /am|pm/, str : true, time : true, lower : true },
				{ val : 'ZZ', type : 'timezone', regex : /(\+|\-)(\d{2})(\d{2})$/, time : true, len : 2 },
				{ val : 'Z', type : 'timezone', regex : /(\+|\-)(\d{2}):(\d{2})$/, time : true, len : 2 },
				{ val : 'HH', type : 'hour', regex : /\d{2}/, railway : true, time : true, len : 2, max : 23 },
				{ val : 'H', type : 'hour', regex : /\d{1,2}/, railway : true, time : true, max : 23 },
				{ val : 'hh', type : 'hour', regex : /\d{2}/, time : true, len : 2, max : 12 },
				{ val : 'h', type : 'hour', regex : /\d{1,2}/, time : true, max : 12 },
				{ val : 'kk', type : 'hour', regex : /\d{2}/, railway : true, time : true, len : 2, max : 24, deduct : -1 },
				{ val : 'k', type : 'hour', regex : /\d{1,2}/, railway : true, time : true, max : 24, deduct : -1 },
				{ val : 'mm', type : 'minute', regex : /\d{2}/, time : true, len : 2, max : 59 },
				{ val : 'm', type : 'minute', regex : /\d{1,2}/, time : true, max : 59 },
				{ val : 'ss', type : 'second', regex : /\d{2}/, time : true, len : 2, max : 59 },
				{ val : 's', type : 'second', regex : /\d{1,2}/, time : true, max : 59 },
				{ val : 'S', type : 'millisecond', regex : /[0-9]{1,}/, time : true, valForm : /[S]+/ },
				{ val : 'zz', type : 'timezone', regex : timezone_regex, str : true, time : true },
				{ val : 'z', type : 'timezone', regex : timezone_regex, str : true, time : true },
				{ val : 'X', type : 'timestamp', regex : /\d{10}/, time : true},
				{ val : 'x', type : 'timestamp', regex : /\d{13,}/, time : true, milli : true}, 
				{ val : 'dddd', type : "longdate", regex : /[A-z]{3,}/, long : true, str : true, array : weekLong },
				{ val : 'ddd', type : "longdate", regex : /[A-z]{3}/, str : true, array : weekMid },
				{ val : 'dd', type : "longdate", regex : /[A-z]{2}/, str : true, array : weekShort },
				{ val : 'do', type : "longdate", regex : /\d{1}(?=st|nd|rd|th)/, suff : true},
				{ val : 'd', type : 'longdate', regex : /\d{1}/ },
				{ val : 'Qo', type : 'quarter', regex : /\d{1}(?=st|nd|rd|th)/, suff : true }, 
				{ val : 'Q', type : 'quarter', regex : /\d{1}/ }
			 ];

			 ( function(){
				try{
				    new Date().toLocaleString( "en-US", { timeZone: 'Europe/London' } )
				 //    new Intl.DateTimeFormat('en-US', {
					//   year: 'numeric', month: 'numeric', day: 'numeric',
					//   hour: 'numeric', minute: 'numeric', second: 'numeric',
					//   timeZone: 'Europe/London'
					// }).format( new Date() );
				} catch( e ){
				    is_IE = true;
				}
			 })();

			function convert_frm_i18n( format, arg, callback ){
				var parsed = this.parseFormat( this.replaceTxt( format ) ).reverse();
				format = format.replace( /{{|}}/g, '' );

				parsed.forEach( function( item ){
					var arr = item.format.array || [],
					fn = window._lyteUiUtils;

					if( item.format.type == 'meridian' ){
						arr = item.format.lower ? [ 'am', 'pm' ] : [ 'AM', 'PM' ];
					}

					arr.forEach( function( _item ){
						var conv = fn ? fn.i18n( _item ) : _item ;

						if( callback ){
							conv = callback( arg, _item, conv, item.format.val ) || conv;
						}

						if( _item == conv ){
							return;
						}

						arg = replace_original( arg, _item, conv );
					});
				});
				return arg;
			}

			function replace_original( arg, original, i18n ){
				var index = arg.indexOf( i18n );
				if( index != -1 ){
					return replace_original( arg.replace( i18n, original ), original, i18n );
				}
				return arg;
			}

			function lyteMoment( arg, format, uL, lL ){

				if( arg ){
					this._arg = arg; 
				}
				this._format = format;
				var ret = isEmpty( arg ),
				convert_i18n,
				i18n_callback,
				ignore_timezone;

				if( ret ) {
					arg = new Date();
				}

				if( uL && uL.constructor == Object ){
					lL = uL.lL;
					convert_i18n = uL.i18n;
					i18n_callback = uL.i18n_callback;
					ignore_timezone = uL.ignore_timezone;
					uL = uL.uL;
				}

				if( !ignore_timezone ){
					this.timezone( default_timezone, default_offset );
				}

				if( convert_i18n && format && arg && arg.constructor == String ){
					arg = convert_frm_i18n.call( this, format, arg, i18n_callback );
				}

				this.uL = uL == undefined ? uLimit : uL;
				this.lL = lL == undefined ? lLimit : lL;

				if( !( isDef( uL ) && isDef( lL ) ) ){
					if( uL ){
						this.alt = true;		
					} else { 
						this.alt = false;
					}
				}
				this._isValid = validate.call( this, arg, format )
			}

			function isDef( arg ) {
				return arg != undefined;
			}

			function totdate( month, isLeap1, day ){
				var total = 0;
				for(var i = 0; i < month; i++ ) {
					total += dayArr[ i ];
					if( isLeap1 && i == 1 ) {
						total += 1;
					}
				} 
				return total + ( day || 0 );
			}

			function isEmpty( arg ){
				if( !arg ){
					return true;
				}
				var cons = arg.constructor;
				if( cons == Array && !cons.length ){
					return true;
				} else if( cons == Object && !Object.keys( arg ).length ){
					return true;
				}
				return false;

			}

			function isLeap( year ) {
				year = year + '';
				if( year.length == 2 ) {
					year = getCorrectYear( parseInt( year ) );
				}
				year = parseInt( year );
				return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 );
			}

			function nthconv( date ) {
				 if( date > 3 && date < 21 ) {
				 	return 'th'
				 }
			     switch ( date % 10 ) {
		            case 1 :  return "st";
		          	case 2 :  return "nd";
	          	  	case 3 :  return "rd";
			        default : return "th";
	 	        }
			}

			function replaceTxt( format ) {
				var matches = format.match( /{{/ ), matches1 = format.match( /}}/ );
				if( !( matches && matches1 ) ) {
					return format;
				}
				format = format.replace( format.slice( matches.index, matches1.index + 2 ), function( arg ){
					var ret = ""
					for( var j = 0; j < arg.length - 4; j++ ) {
						ret += '*';
					}
					return ret;
				} )
				return replaceTxt( format );
			}

			function parseFormat( format, validate ) { 
				var forCopy = $L.extend( true, [], formats ), order = [],
				prev;
				for( var i = 0; i < forCopy.length; i++ ) {
					var cur = forCopy[ i ];
					if( !format.length ) {
						break;
					}
					if( format.indexOf( cur.val ) > -1 ) {
						if( validate && cur.alt ){
							prev = true;
							continue;
						}
						if( prev ){
							cur.val = forCopy[ i - 1 ].val;
						}
						prev = false;
						order.push( { format : cur, index : format.indexOf( cur.val ) });
						format = format.replace( cur.val, Math.pow( 10, cur.val.length - 1 ) );
						i--;
						continue;
					} 
				}
				return order.sort(function( a, b ){
						return a.index - b.index
					});
			}

			function fmReplace( arg, arr ) {
				var length = 0;
				for( var i = 0; i < arr.length; i++ ) {
					arg = arg.slice( 0, arr[ i ].index + length ) + arr[ i ].format.val + lm + arg.slice( arr[ i ].index + length + arr[ i ].format.val.length );
					length += 10;
				}
				return arg;
			}

			function replace( arg, val, suff, rep ) {
				arg = arg.replace( val, rep || "" );
				if( suff ) {
					arg = arg.replace( /st|nd|rd|th/, '' )
				}
				return arg;
			}

			function find( array, val ){
				var crct, i;
				for( i = 0; i < array.length; i++ ) {
					if( new RegExp( array[ i ] ).test( val ) ) {
						crct = array[ i ];
						break;
					}
				}
				return  { mon : crct, index : i };
			}

			function getMonth( val, suff, str, long ) {
				var mon;
				if( str ) {
					var ret = find( long ? longMon : shortMon, val );
					mon = ret.mon;
					val = ret.index;
					if( !mon || val > 11 ){
						val = "Invalid";
					}
				} else {
					val = parseInt( val ) - 1;
					if( val > 11 ) {
						val = 'Invalid';
					} 
				}

				return { val : val, mon : mon };
			}

			function convertTimeZone( arg ) {
				var ret,
				hour = parseInt( arg[ 2 ] ); minute = parseInt( arg[ 3 ] );
				ret = hour * 60 + minute;
				return arg[ 1 ] == '+' ? ( ret * -1 ) : ret;
			}

			function convertRailway( hour, pm ) {
				if( pm && hour < 12 ) {
					hour += 12;
				} else if( hour == 12 && !pm ) {
					hour = 0;
				}
				return hour;
			}

			function getDay( val, isLeap ) {
				val = parseInt( val ), ini = 0, ind = 0, inc = dayArr[ 0 ];
				if( val > ( 365 + ( isLeap ? 1 : 0 ) ) ){
					return {};
				}
				while( ini + inc < val ) {
					ini += inc;
					ind++;
					inc = dayArr[ ind ]
					if( isLeap && ind == 1 ) {
						inc += 1;
					}
				}
				return { day : val - ini , mon : ind }
			}

			function getWeek( obj ) {
				if( obj.day != undefined || obj.week ) {
					var dtt = new Date( obj.year , 0 ,1 );
					if( !validate.call( this, dtt ) ) {
						return {};
					}
					var dt = dtt.getDay(), isLeap1 = isLeap( obj.year || dtt.getFullYear() ),
					total = wod + obj.week == 1 ? ( obj.day - dt + wod ) : ( obj.week == 2 ? ( 7 + wod - dt + obj.day ) : ( 7 + wod - dt + obj.day + ( obj.week - 2 ) * 7 ) )
					if( total > ( 365 + ( isLeap1 ? 1 : 0 ) ) ) {
						var newStart = new Date( obj.year + 1 , 0 ,1 ).getDay();
						if( newStart > 4 ) {
							obj.year += 1;
							total = total - ( ( 365 + ( isLeap1 ? 1 : 0 ) ) );
						}
					}
					if( total > ( 365 + ( isLeap1 ? 1 : 0 ) ) || obj.day == 0 || obj.day > 7 ) {
						obj.month = obj.year = obj.date = 'Invalid';
						return;
					}
					var ret = getDay( total, isLeap1 );
					obj.month = ret.mon; obj.date = ret.day;
				}
				if( obj.year ) {
					var yr = parseInt( obj.year );
					if( yr < 100 ) {
						obj.year = getCorrectYear( yr );
					}
				}
				if( obj.month < 0 ) {
					obj.month = 'Invalid';
				}
				if( obj.date < 1 ) {
					obj.date = 'Invalid';
				}
			}

			function getWeekReverse( dobj, ignore ){
				var year = dobj.getFullYear(),
				is_leap = isLeap( year ),
				month = dobj.getMonth(),
				date = dobj.getDate(),
				year_start = new Date( year, 0 ),
				startday = year_start.getDay(),
				start_date = year_start.getDate(),
				cur_day = dobj.getDay();

				total = totdate( month, is_leap );

				if( !ignore ){
					if( month == 0 && startday > 4 && ( date <= ( 8 - startday ) ) ){
						var ret = getWeekReverse( new Date( year - 1, 11, 31 ) );
						ret.day = ( ( ret.day + date ) % 8 ) || 1;
						ret.repYear = true;
						return ret;
					} else {
						if( startday > 4 && ( start_date <= ( 8 - startday ) ) ){
							date -= ( 8 - startday );
							startday = 0;
						} else {
							date--;
						}
					}
				}

				return {
					week : Math.ceil( ( total + startday + date ) / 7 ),
					day : cur_day
				};
			}

			// function getWeekReverse( dobj, ignore ) {
			// 	var isLeap1 = isLeap( dobj.getFullYear() ), month = dobj.getMonth(), date = dobj.getDate(),
			// 	total = ignore ? 0 : - wod, startday = new Date( dobj.getFullYear(), 0 ).getDay();
			// 	total += totdate( month, isLeap1 );

			// 	if( !ignore ) {
			// 		if( month == 0 && startday > 4 && date < 3 ){

			// 			// isLeap1 = isLeap( dobj.getFullYear() - 1 );
			// 			// total = total + 365 + ( isLeap1 ? 1 : 0 );
			// 			// startday = new Date( dobj.getFullYear() - 1, 0 ).getDay();
			// 			// repYear = true;

			// 			var ret = getWeekReverse( new Date( dobj.getFullYear() - 1, 11, 31 ) );
			// 			ret.repYear = true;
			// 			ret.day = ret.day + date;

			// 			return ret;
			// 		} 
			// 	}

	 	// 		return { week : Math.ceil( ( total + startday + date ) / 7 ), day : dobj.getDay() + 1};
			// }	

			function getCorrectYear( year ){
				var copyYear = year + '';
				year = parseInt( year );

				if( copyYear.length == 2 ){
					var today = Number( $L.moment().format( 'YYYY' ) ),
					prefix = parseInt( today / 100 ),
					curTwodigit = today % 100,
					upperLimit = ( curTwodigit + ( this.uL || uLimit ) ) % 100,
					lowerLimit = ( curTwodigit - ( this.lL || lLimit ) + 100 ) % 100;

					if( curTwodigit > lowerLimit ){
						if( year < lowerLimit ){
							year = ( prefix + 1 ) + '' + crctLength( year, 2 );
						} else {
							year = prefix + '' + crctLength( year, 2 );
						}
					} else {
						if( year < lowerLimit ){
							year = prefix + '' + crctLength( year, 2 );
						} else {
							year = ( prefix - 1 ) + '' + crctLength( year, 2 );
						}
					}
				}
				return year;
			}

			function valFormat( arg, format ){
				var copyFormat = {}, ret, date,
				__new = new Date(),
				prseVal = parseFormat( replaceTxt( format ), true ), copyArg = arg;
				format = format.replace(/{{|}}/g, '');
				var copyFormat1 = format;
				for( var i = 0; i < prseVal.length; i++ ) {
					var ret, cur = prseVal[ i ].format;
					switch( cur.type ) {
						case 'date' :
						case 'year':
						case 'week' :
						case 'day' : {
							if( cur.regex.test(arg) ) {
								if( cur.type == "year" ){
									ret = arg.match( cur.regex )[ cur.match || 0 ];
								} else {
									ret = parseInt( arg.match( cur.regex )[ cur.match || 0 ] );
								}
								copyFormat[ cur.type ] = ret;
								arg = replace( arg, cur.regex, cur.suff );
								copyArg = replace( copyArg, cur.regex, cur.suff, cur.val );
								if( cur.type == 'week' ) {
									arg = replace( arg, week );
								}
								if( cur.type == 'day' && cur.local ) {
									copyFormat.day++;
								}
								if( cur.year ) {
									copyFormat.date = getDay( copyFormat.date ).day;
								}
							} else {
								if( copyFormat.year && copyFormat.week ) {
									copyFormat[ cur.type ] = wod;
									format = format.replace( cur.val, '' );
									copyFormat1 = copyFormat1.replace( cur.val, '' );
								} else {
									copyFormat[ cur.type ] = 'Invalid';
								}
							}
							if( /date/i.test( cur.type ) ){
								if( copyFormat[ cur.type ] == 0 ){
									copyFormat[ cur.type ] = 'Invalid';
								}
							}
							break;
						}
						case 'month' : {
							if( cur.regex.test(arg) ) {
								ret = getMonth( arg.match(  cur.regex )[ 0 ], cur.suff, cur.str, cur.long );
								copyFormat.month = ret.val;
								arg = replace( arg, ret.mon || ( cur.regex ), cur.suff );
								copyArg = replace( copyArg, ret.mon || ( cur.regex ), cur.suff, cur.val );
							} else {
								copyFormat.month = 'Invalid';
							}
							if( copyFormat.month < 0 ){
								copyFormat.month = 'Invalid';
							}
							break;
						}
						case 'quarter' : {
							if( cur.regex.test(arg) ) {
								ret = arg.match(  cur.regex )[ 0 ];
								copyFormat.quarter = ret;
								arg = replace( arg, ret, cur.suff );
								copyArg = replace( copyArg, ret, cur.suff, cur.val );
							}
							break;
						}
						case 'longdate' : {
							if( cur.regex.test(arg) ) {
								if( cur.str ) {
									ret = find( cur.array, arg.match(  cur.regex )[ 0 ] );
								} else {
									ret = parseInt( arg.match( cur.regex )[ 0 ] );
								}
								copyFormat.longdate = !isDef( ret.index ) ? ret : ret.index;
								arg = replace( arg, ret.mon || ret, cur.suff )
								copyArg = replace( copyArg, ret.mon || ret, cur.suff, cur.val );
							}
							break;
						}
						case 'hour' : 
						case 'minute' : 
						case 'second' :
						case 'meridian' : {
							if( cur.regex.test(arg) ) {
								if( cur.str ) {
									ret = arg.match( cur.regex )[ 0 ];
								} else {
									ret = parseInt( arg.match( cur.regex )[ 0 ] );
									if( cur.railway ) {
										copyFormat.railway = true;
									}
								}
								if( cur.deduct ) {
									ret--;
								}
								copyFormat[ cur.type ] = ret;
								if( cur.max && ret > cur.max ) {
								    copyFormat[ cur.type ] = 'Invalid';
								}
								arg = replace( arg, cur.regex );
								copyArg = replace( copyArg, cur.regex, cur.suff, cur.val );
							}
							break;
						}
						case 'millisecond' : {
							if( cur.regex.test(arg) ) {
								ret = arg.match( cur.regex )[ 0 ];
								copyFormat.millisecond = parseFloat( ret );
								arg = replace( arg, ret ).replace(/[S]+/, '');
								copyArg = replace( copyArg, cur.regex, cur.suff, cur.val );
								copyFormat1 = copyFormat1.replace(/[S]+/, 'S');
							}
							break;
						}
						case 'timestamp' : {
							if( cur.regex.test(arg) ) {
								ret = parseInt( arg.match( cur.regex )[ 0 ] );
								copyFormat.timestamp = ret * ( cur.milli ? 1 : 1000 );
								arg = replace( arg, ret );
								copyArg = replace( copyArg, ret, cur.suff, cur.val );
							}
							break;
						}
						case 'timezone' : {
							if( cur.regex.test(arg) ) {
								if( cur.str ) {
									ret = arg.match( cur.regex )[ 0 ];
									ret = -timeZoneOffsets[ ret ];
								} else {
									ret = convertTimeZone( arg.match( cur.regex ) )
								}
								copyFormat.timezone = ret;
								arg = replace( arg, cur.regex );
								copyArg = replace( copyArg, cur.regex, cur.suff, cur.val );
							}
							break;
						}
					}
				format = format.replace( cur.valForm || cur.val, '' );
				}
					
				// date = new Date( __new.getFullYear(), isDef( copyFormat.month ) ? copyFormat.month : __new.getMonth(), copyFormat.date || 1 );
				// date = new Date( __new.getFullYear(), 0 );

				date = new Date( __new.getFullYear(), isDef( copyFormat.month ) ? copyFormat.month : __new.getMonth(), copyFormat.date || 1, copyFormat.hour || 0, copyFormat.minute || 0, copyFormat.second || 0 );

				if( isDef( copyFormat.day ) || isDef( copyFormat.week ) ){
					var oriDate = copyFormat.date
					if( !isDef( copyFormat.year ) ) {
						copyFormat.year = date.getFullYear();
					}
					if( !isDef( copyFormat.day ) ) {
						copyFormat.day = wod;
					} 
					getWeek.call( this, copyFormat );
					if( isDef( oriDate ) ){
						if( copyFormat.date > oriDate ) {
							copyFormat.month++;
						} 
						copyFormat.date = oriDate;
					}
				}
				if( isDef( copyFormat.longdate ) && copyFormat.day && copyFormat.day != copyFormat.longdate ) {
					date.setFullYear( 'Invalid' );
				} else if( isDef( copyFormat.year ) ) {
					date.setFullYear( getCorrectYear( copyFormat.year ) );
				}
				if( isDef( copyFormat.month ) ) {
					date.setMonth( copyFormat.month );
				}
				if( isDef( copyFormat.date ) ) {
					date.setDate( copyFormat.date <= ( dayArr[ date.getMonth() ] + ( date.getMonth() == 1 && isLeap( date.getFullYear() ) ? 1 : 0 ) ) ? copyFormat.date : 'Invalid');
				}
				if( isDef( copyFormat.hour ) ) {
					var mer = copyFormat.meridian;
					date.setHours( copyFormat.railway ? convertRailway( copyFormat.hour, mer ? ( /pm/i.test( mer ) ) : ( copyFormat.hour > 11 ) ) : ( /pm/i.test( mer ) ? ( copyFormat.hour < 12 ? ( copyFormat.hour + 12 ) : copyFormat.hour ) : copyFormat.hour % 12 ) )
				}
				if( isDef( copyFormat.minute ) ) {
					date.setMinutes( copyFormat.minute )
				}
				if( isDef( copyFormat.second ) ) {
					date.setSeconds( copyFormat.second )
				}
				if( isDef( copyFormat.millisecond ) ){
					date.setMilliseconds( copyFormat.millisecond )
				}
				if( isDef( copyFormat.timestamp ) ) {
					date = new Date( copyFormat.timestamp )
				}

				if( isDef( copyFormat.timezone ) ){
					var act_diff = date.getTimezoneOffset();

					copyFormat.timezone -= act_diff;
					date.setMinutes( date.getMinutes() + copyFormat.timezone );

					var new_diff = date.getTimezoneOffset();

					if( act_diff != new_diff ){

						/* Daylight saving time causing many issues.
					   	   Here when we are passing wrong timezone date Ex. '2021-11-07T02:30:00-04:00' new date reads it correctly ( In -04:00 timezone machine ). But setting the timezone difference in setMinutes causing problem.
					       Dont know the exact fix. So wrote this as temporary fix. Assuming string contains timezone is readable in new Date()*/

						var new_date = new Date( this._arg );
						// May be we can create a date object by passing already available data

						if( new_date.toString() == 'Invalid Date' ){
							/* In this case can't do anything from moment side. Need to change the input date string */ 
							date.setMinutes( date.getMinutes() - copyFormat.timezone );
						} else{
							date = new_date;
						}
					}

				} else if( isDef( this._timezone ) ){
					copyFormat.timezone = this.timezoneOffset( date ) - date.getTimezoneOffset();
					date.setMinutes( date.getMinutes() + copyFormat.timezone );
				}

				var def_format = "YYYY-MM-DDTHH:mm:ssZ"; 

				if( copyFormat1 != def_format && arg.length == format.length && copyFormat1 == copyArg && validate.call( this, date ) ) {
					return this._isCorrectFormat = true;
				} else if( !this._format || copyFormat1 == def_format ) {
					return validate.call( this, new Date( this._arg ) );
				}
			}

			function crctLength( val, length, suff, deduct ) {
				var sfx = ''
				if( deduct ) {
					val++;
				}
				if( suff ) {
					sfx = nthconv( val );
				}
				if( length ) {
					val = val.toString();
					for( var i = 1; i < length; i++ ) {
						if( val.length <= i ) {
							val = '0' + val;
						}
					}
				}
				return val + sfx;
			}

			function getDObj(){
				var date = this._dateObj,
				timeZone = this._timezone;

				if( timeZone ) {
					if( this.is_IE ){
						date.setMinutes( date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset( date ) );
					} else{
						return new Date( convert_timezone_DLS( date, timeZone ) );
					}
				}
				return date;
			}

			function convertFormat( arg ) {
				var parseVal = parseFormat( replaceTxt( arg ) ), isWeek = {},
				act_date = this.toDate(),
				obj = this.split_date( act_date ),
				fake_time,
				create_fake = function(){
					return new Date( act_date.getTime() + ( act_date.getTimezoneOffset() - obj.timezone ) * 1e3 * 60 );
				};

				arg = fmReplace( arg.replace(/{{|}}/g, ''), parseVal );
				for( var i = 0; i < parseVal.length; i++ ) {
					var ret, cur = parseVal[ i ].format;
					switch( cur.type ) {
						case "date" : {
							arg = arg.replace( cur.val + lm, crctLength( ( cur.year ? totdate( obj.month - 1, isLeap( obj.year ), obj.date ) : obj.date ), cur.len, cur.suff ) )
						}
						break;
						case "month" : {
							if( cur.str ) {
								arg = arg.replace( cur.val + lm, cur.array[ obj.month - 1 ] );
							} else {
								arg = arg.replace( cur.val + lm, crctLength( obj.month, cur.len, cur.suff ) );
							}
						}
						break;
						case "year" : {
							arg = arg.replace( cur.val + lm, cur.len == 2 ? crctLength( obj.year % 100, 2 ) : ( ( obj.year + '' ).length == 4 ) ? obj.year : crctLength( obj.year, 4 ) );
							isWeek.year = isWeek.year || [];
							isWeek.year.push( cur );
						}
						break;
						case "day" :
						case "week" : {
							isWeek.flag = true
							isWeek[ cur.type ] = isWeek[ cur.type ] || [];
							isWeek[ cur.type ].push( cur );
						}	
						break;
						case "quarter" : {
							arg = arg.replace( cur.val + lm, crctLength( Math.ceil( ( obj.month ) / 3 ), null , cur.suff ) )
						}
						break;
						case 'longdate' : {
							fake_time =  fake_time || create_fake();
							var __day = fake_time.getDay();
							if( cur.str ) {
								arg = arg.replace( cur.val + lm, cur.array[ __day ]);
							} else {
								arg = arg.replace( cur.val + lm, crctLength( __day, null , cur.suff ) )
							}
						}
						break;
						case 'hour' : {
							var hr = obj.hour;
							arg = arg.replace( cur.val + lm, crctLength( !cur.railway ? ( hr > 12 ? hr % 12 : ( hr || 12 ) ) : hr, cur.len, null, cur.deduct ) )
						}
						break;
						case 'minute' : {
							arg = arg.replace( cur.val + lm, crctLength( obj.minute, cur.len ) );
						}
						break;
						case 'second' : {
							arg = arg.replace( cur.val + lm, crctLength( obj.second, cur.len ) );
						}
						break;
						case 'millisecond' : {
							arg = arg.replace( cur.val + lm, crctLength( act_date.getMilliseconds(), 3 ) ).replace( /\\S+/, '' )
						}
						break;
						case 'timezone' : {
							var val = '';
							if( !cur.str ) {
								var off = obj.timezone, hr = crctLength( Math.abs( parseInt( off / 60 ) ), 2 ), min = crctLength( Math.abs( off % 60 ), 2 ), sign = off <= 0 ? '+' : '-';
								if( cur.val == 'ZZ' ) {
									val = sign + hr + min;
								} else {
									val = sign + hr + ':' + min;
								}
							}
							arg = arg.replace( cur.val + lm, val );
						}
						break;
						case 'timestamp' : {
							var val = '';
							if( cur.val == 'X' ) {
							 	val += parseInt( act_date.getTime() / 1000 )
							} else {
								val += act_date.getTime();
							}
							arg = arg.replace( cur.val + lm, val );
						}
						break;
						case 'meridian' : {
							var forr = obj.meridian;
							if( cur.lower ) {
								forr = forr.toLowerCase();
							}
							arg = arg.replace( cur.val + lm, forr );
						}
					}
				}
				if( isWeek.flag ) {
					fake_time = fake_time || create_fake();
					var ret = getWeekReverse( fake_time );
					if( isWeek.week ){
						for( var j = 0; j < isWeek.week.length; j++ ){
							var __cur = isWeek.week[ j ],
							__ret = getWeekReverse( fake_time, __cur.ignore );
							arg = arg.replace( __cur.val + lm, ( __cur.pref == 0 ? "" : week ) + crctLength( __ret.week, __cur.len, __cur.suff ) );
						}
					}
					if( isWeek.day ) {
						for( var j = 0; j < isWeek.day.length; j++ ){
							arg = arg.replace( isWeek.day[ j ].val + lm, ret.day - ( isWeek.day[ j ].local ? 1 : 0 ) );
						}
					}
					if( ret.repYear && isWeek.year ) {
						for( var j = 0; j < isWeek.year.length; j++ ){
							arg = arg.replace( ( isWeek.year[ j ].len == 2 ? obj.year % 100 : obj.year ), ( isWeek.year[ j ].len == 2 ? obj.year % 100 : obj.year ) - 1 );
						}
					}
				}
				return arg.replace(/{{|}}/g, '')
			}

			function validate( arg, format ) {
				var cons = arg.constructor;
				if( cons == Date ) {
					this._dateObj = arg;
					this._isMoment = true;
					if( arg.toString() == 'Invalid Date' ) {
						return false;
					} else {
						return true;
					}
				} else if( cons == String ) {
					if( format ) {
						var ret = valFormat.call( this, arg, format );
						if( ret && this._isCorrectFormat ) {
							this._format = format;
						}
						return ret;
					} else {
						if( this.constructFormat ){
							return validate.call( this, arg, this.constructFormat.call( this, arg ) );
						} else {
							console.warn( 'Its not supported in lyte-moment-basic.js. Add lyte-moment-additional.js for format construction' );
						}
					}
				} else if( cons == Array ) {
					// new (Function.prototype.bind.apply(Date, [null].concat([1996,04,28])))
					return validate.call( this, new Date( Date.parse( Date.apply( Date, cons ) ) ).getTime() );
				} else if( cons == Number ) {
					arg *= /^\d{10}$/.test( arg ) ? 1000 : 1;
					return validate.call( this, new Date( arg ) );
				} else if( arg._isMoment ) {
					return validate.call( this, arg._dateObj.getTime() );
				}
			}

			function convert_timezone_DLS( date_obj, name, short ){
				return date_obj.toLocaleString( "en-US", { timeZone: name, timeZoneName: short || "short" } );
			}

			lyteMoment.prototype = {

				isDef : isDef, 

				find : find,

				totdate : totdate,

				isLeap : isLeap,

				dayArr : dayArr,

				getDObj : getDObj,

				getWeekReverse : getWeekReverse,

				weekShort : weekShort,

				weekMid : weekMid,

				weekLong : weekLong,

				longMon : longMon,

				shortMon : shortMon,

				week : week,

				crctLength : crctLength,

				formats : formats,

				replace : replace,

				inbuiltFormats : {},

				getCorrectYear : getCorrectYear,

				parseFormat : parseFormat,

				replaceTxt : replaceTxt,

				is_IE : is_IE,

				validate : function(){
					return !!this._isValid;
				},

				toDate : function(){
					return this._dateObj;
				},

				isSame : function( arg ){
					if( this.validate() && arg && arg._isMoment && arg._isValid ) {
						return this._dateObj.getTime() == arg._dateObj.getTime();
					}
					return false;
				},

				format : function( arg ) {
					if( this.validate() ) {
						arg = this.inbuiltFormats[ arg ] || arg || "YYYY-MM-DDTHH:mm:ssZ";
						return convertFormat.call( this, arg );	
					}
				},

				utc : function( arg ) {
					return this.timezone( 'UTC' );
				},

				local : function( arg ){
					return this.timezone( void 0 );
				},

				timezone : function( arg, off ){
					this._timezone = arg;

					if( isDef( off ) ){
						if( typeof off == 'string' ){
							timeZoneOffsets[ arg ] = -convertTimeZone( off.match( /(\+|\-)(\d{2}):(\d{2})$/ ) ); 
						} else{
							timeZoneOffsets[ arg ] = off;
						}

						this.is_IE = true;
					}

					return this;
				},	

				getCurrentTimeZone : function(){
					return this._timezone;
				},

				parseDate : function( str, date_obj, timezone ){
					var date_rgx = /(\d+)\/(\d+)\/(\d+),\s(\d+):(\d+):(\d+)\s(AM|PM)/,
					match = str.match( date_rgx ),
					obj = {},
					gmt_rgx = /GMT(\+|-)(\d+):(\d+):(\d+)$/,
					hr_min_rgx = /GMT(\+|-)(\d+):(\d+)$/,
					hr_only_gmt = /GMT(\+|-)(\d+)$/,
					end_rgx = /\s([A-Z]+)$/;

					[ 'month', 'date', 'year', 'hour', 'minute', 'second' ].forEach( function( item, index ){
						obj[ item ] = parseInt( match[ index + 1 ] );
					});

					obj.meridian = match[ 7 ];

					var hr = obj.hour,
					ns = {"ACDT":"GMT+10:30","ACST":"GMT+9:30","ACT":"GMT-5","ACWST":"GMT+8:45","ADT":"GMT-3","AEDT":"GMT+11","AEST":"GMT+10","AFT":"GMT+4:30","AKDT":"GMT-8","AKST":"GMT-9","AMST":"GMT-3","AMT":"GMT+4","ART":"GMT-3","AST":"GMT+3","AT":"GMT-4/GMT-3","AWST":"GMT+8","AZOST":"GMT+0","AZOT":"GMT-1","AZT":"GMT+4","BDT":"GMT+8","BIT":"GMT-12","BNT":"GMT+8","BOT":"GMT-4","BRST":"GMT-2","BRT":"GMT-3","BST":"GMT+11","BTT":"GMT+6","CAT":"GMT+2","CCT":"GMT+6:30","CDT":"GMT-4","CEST":"GMT+2","CET":"GMT+1","CHADT":"GMT+13:45","CHAST":"GMT+12:45","CHOST":"GMT+9","CHOT":"GMT+8","CHST":"GMT+10","CHUT":"GMT+10","CIST":"GMT-8","CIT":"GMT+8","CKT":"GMT-10","CLST":"GMT-3","CLT":"GMT-4","COST":"GMT-4","COT":"GMT-5","CST":"GMT+8","CT":"GMT-6/GMT-5","CVT":"GMT-1","CWST":"GMT+8:45","CXT":"GMT+7","DAVT":"GMT+7","DDUT":"GMT+10","EASST":"GMT-5","EAST":"GMT-6","EAT":"GMT+3","ECT":"GMT-5","EDT":"GMT-4","EEST":"GMT+3","EET":"GMT+2","EGST":"GMT+0","EGT":"GMT-1","EIT":"GMT+9","EST":"GMT-5","ET":"GMT-5/GMT-4","FET":"GMT+3","FJT":"GMT+12","FKST":"GMT-3","FKT":"GMT-4","FNT":"GMT-2","GALT":"GMT-6","GAMT":"GMT-9","GET":"GMT+4","GFT":"GMT-3","GILT":"GMT+12","GIT":"GMT-9","GMT":"GMT+0","GST":"GMT-2","GYT":"GMT-4","HADT":"GMT-9","HAST":"GMT-10","HKT":"GMT+8","HMT":"GMT+5","HOVST":"GMT+8","HOVT":"GMT+7","ICT":"GMT+7","IDT":"GMT+3","IOT":"GMT+6","IRDT":"GMT+4:30","IRKT":"GMT+8","IRST":"GMT+3:30","IST":"GMT+2","JST":"GMT+9","KGT":"GMT+6","KOST":"GMT+11","KRAT":"GMT+7","KST":"GMT+9","LHDT":"GMT+11","LHST":"GMT+10:30","LINT":"GMT+14","MAGT":"GMT+11","MART":"GMT-9:30","MAWT":"GMT+5","MDT":"GMT-6","MHT":"GMT+12","MIST":"GMT+11","MIT":"GMT-9:30","MMT":"GMT+6:30","MSK":"GMT+3","MST":"GMT+8","MT":"GMT-7/GMT-6","MUT":"GMT+4","MVT":"GMT+5","MYT":"GMT+8","NCT":"GMT+11","NDT":"GMT-2:30","NFT":"GMT+11","NPT":"GMT+5:45","NRT":"GMT+12","NST":"GMT-3:30","NT":"GMT-3:30","NUT":"GMT-11","NZDT":"GMT+13","NZST":"GMT+12","OMST":"GMT+6","ORAT":"GMT+5","PDT":"GMT-7","PET":"GMT-5","PETT":"GMT+12","PGT":"GMT+10","PHOT":"GMT+13","PhST":"GMT+8","PHT":"GMT+8","PKT":"GMT+5","PMDT":"GMT-2","PMST":"GMT-3","PONT":"GMT+11","PST":"GMT-8","PT":"GMT-8/GMT-7","PWT":"GMT+9","PYST":"GMT-3","PYT":"GMT-4","RET":"GMT+4","ROTT":"GMT-3","SAKT":"GMT+11","SAMT":"GMT+4","SAST":"GMT+2","SBT":"GMT+11","SCT":"GMT+4","SGT":"GMT+8","SLST":"GMT+5:30","SRET":"GMT+11","SRT":"GMT-3","SST":"GMT-11","SYOT":"GMT+3","TAHT":"GMT-10","TFT":"GMT+5","THA":"GMT+7","TJT":"GMT+5","TKT":"GMT+13","TLT":"GMT+9","TMT":"GMT+5","TOT":"GMT+13","TRT":"GMT+3","TVT":"GMT+12","ULAST":"GMT+9","ULAT":"GMT+8","USZ1":"GMT+2","UTC":"GMT+0","UYST":"GMT-2","UYT":"GMT-3","UZT":"GMT+5","VET":"GMT-4","VLAT":"GMT+10","VOLT":"GMT+4","VOST":"GMT+6","VUT":"GMT+11","WAKT":"GMT+12","WAST":"GMT+2","WAT":"GMT+1","WEST":"GMT+1","WET":"GMT+0","WFT":"GMT+12","WGST":"GMT-2","WIB":"GMT+7","WIT":"GMT+9","WST":"GMT+8","YAKT":"GMT+9","YEKT":"GMT+5"};

					if( match[ 7 ] == 'PM' ){
						if( hr != 12 ){
							obj.hour += 12;
						}
					} else{
						if( hr == 12 ){
							obj.hour = 0;
						}
					}

					function fn( str, frm_recursive ){
						if( gmt_rgx.test( str ) ){
							var gmt_match = str.match( gmt_rgx );
							obj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 + parseInt( gmt_match[ 3 ] ) ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );
						} else if( hr_min_rgx.test( str ) ){
							var gmt_match = str.match( hr_min_rgx );
							obj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 + parseInt( gmt_match[ 3 ] ) ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );
						} else if( hr_only_gmt.test( str ) ){
							var gmt_match = str.match( hr_only_gmt );
							obj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );
						} else{
							if( frm_recursive ){
								obj.timezone = 0;
							} else{
								if( end_rgx.test( str ) ){

									var clone = {
										"AMT" : {
											"Amazon Time" : "GMT-4",
											"Armenia Time" : "GMT+4"
										},
										"AST" : {
											"Atlantic Standard Time" : "GMT-4",
											"Arabia Standard Time" : "GMT+3"
										},
										"BST" : {
											"British Summer Time" : "GMT+1",
											"Bangladesh Standard Time" : "GMT+6",
											"Bougainville Standard Time" : "GMT+11"
										},
										"CDT" : {
											"Central Daylight Time" : "GMT-5",
											"Cuba Daylight Time" : "GMT-4"
										},
										"CST" : {
											"Central Standard Time" : "GMT-6",
											"Cuba Standard Time" : "GMT-5",
											"China Standard Time" : "GMT+8"
										},
										"GST" : {
											"Gulf Standard Time" : "GMT+4",
											"South Georgia Time" : "GMT-2"
										},
										"IST" : {
											"Indian Standard Time" : "GMT+5:30",
											"Irish Standard Time" : "GMT+1",
											"Israel Standard Time" : "GMT+2"
										},
										"MST" : {
											"Mountain Standard Time" : "GMT-7",
											"Malaysia Standard Time" : "GMT+8"
										},
										"WGST" : {
											"West Greenland Time" : "GMT-3",
											"West Greenland Summer Time" : "GMT-2"
										}
									},
									value = str.match( end_rgx )[ 1 ],
									clone_value = clone[ value ],
									to_send = ns[ value ];

									if( clone_value ){
										var return_str = convert_timezone_DLS( date_obj, timezone, 'long' );
										for( var key in clone_value ){
											if( return_str.indexOf( key ) != -1 ){
												to_send = clone_value[ key ];
												break;
											}
										}
									} else if( !to_send ){
										to_send = convert_timezone_DLS( date_obj, timezone, 'long' );
									} else {
										var dual = [ 'AT', 'CT', 'ET', 'MT', 'PT' ];
										if( dual.indexOf( value ) != -1 ){
											to_send = to_send.replace( /\/(.+)/, '' );
										}
									}

									fn( to_send, true );
								}
							}
						}
					};

					fn( str );

					return obj;
				},

				split_date : function( date_obj ){
					if( this.is_IE ){
						var dobj = this.getDObj(),
						hr = dobj.getHours(),
						obj = {
							year : dobj.getFullYear(),
							month : dobj.getMonth() + 1,
							date : dobj.getDate(),
							hour : hr,
							minute : dobj.getMinutes(),
							second : dobj.getSeconds(),
							meridian : hr > 11 ? "PM" : "AM",
							timezone : this.timezoneOffset( date_obj )
						};
						return obj;
					} else {
						try{
							var timezone_date = convert_timezone_DLS( date_obj, this._timezone ),
							timezone_split = this.parseDate( timezone_date, date_obj, this._timezone );
							return timezone_split;
						} catch( e ){
							this.is_IE = true;
							return this.split_date();
						}
					}
				},

				timezoneOffset : function( date_obj ){
					if( isDef( this._timezone ) ){
						if( this.is_IE ){
							var value = timeZoneOffsets[ this._timezone ];
							return -( isDef( value ) ? value : this._timezone );
						}

						var timezone_split = this.split_date( date_obj );

						return timezone_split.timezone;
					}

					if( this.validate() ){
						return this.toDate().getTimezoneOffset();
					}

					return new Date().getTimezoneOffset();
				},

				utcOffset : function( arg ) {
					if( this._isValid ) {
						return this.timezoneOffset( this.toDate() );
					}
				}	

			}

			$L.moment = function( arg, format, uL, lL ){
				return new lyteMoment( arg, format, uL, lL );
			}

			$L.moment.lyteMoment = lyteMoment;

			$L.moment.setLimits = function( a, b ){
				uLimit = a;
				lLimit = b;
			}

			$L.moment.setTimezone = function( arg, off ){
				default_timezone = arg;
				if( isDef( off ) ){
					default_offset = off;
				}
			}
		}
	})(window);
;( function( window ){
	if( $L.moment ) {
		var proto = $L.moment.lyteMoment.prototype;
		var standardDate = [
			{ val : 'YYYY-MM-DD', regex : /^(\d{4}-\d{2}-\d{2})/ },
			{ val : 'GGGG-['+ proto.week + ']WW-E', regex : new RegExp( '\^(\\d{4}-'+ proto.week + '\\d{2}-\\d)' ) },
			{ val : 'GGGG-['+ proto.week + ']WW', regex : new RegExp( '\^(\\d{4}-'+ proto.week + '\\d{2})' ) },
			{ val : 'YYYY-DDD', regex : /^(\d{4}-\d{3})/ },
			{ val : 'YYYY-MM', regex : /^(\d{4}-\d{2})/ },
			{ val : 'YYYYMMDD', regex : /^(\d{8})/},
			{ val : 'GGGG['+ proto.week + ']WWE', regex : new RegExp( '\^(\\d{4}'+ proto.week + '\\d{2}\\d)' ) },
			{ val : 'GGGG['+ proto.week + ']WW', regex : new RegExp( '\^(\\d{4}'+ proto.week + '\\d{2})' ) },
			{ val : 'YYYYDDD', regex : /^(\d{4}\d{3})/ }
		],
		standardTime = [
			{ val : 'HH:mm:ss.SSSS', regex : /^\d{2}:\d{2}:\d{2}\.[0-9]{1,}$/ },
			{ val : 'HH:mm:ss,SSSS', regex : /^\d{2}:\d{2}:\d{2},[0-9]{1,}$/ },
			{ val : 'HH:mm:ss', regex : /^\d{2}:\d{2}:\d{2}$/ },
			{ val : 'HH:mm', regex : /^\d{2}:\d{2}$/ },
			{ val : 'HHmmss.SSSS', regex : /^\d{6}\.[0-9]{1,}$/ },
			{ val : 'HHmmss,SSSS', regex : /^\d{6},[0-9]{1,}$/ },
			{ val : 'HHmmss', regex : /^\d{6}$/ },
			{ val : 'HHmm', regex : /^\d{4}$/ },
			{ val : 'HH', regex : /^\d{2}$/ }
		];
		function constructFormatCopy( arg, isTime ) {
			var cpForm = this.formats.slice(), obj = {}, dummy = arg, isWEG = new RegExp(  this.week + '|G|E' , 'i' ).test( arg );
			for( var i = 0; i < cpForm.length; i++ ) {
				var cur = cpForm[ i ];
				if( isTime != cur.time ) {
					continue;
				}
				if( cur.regex.test( dummy ) && isWEG == !!cur.isWEG && !this.isDef( obj[ cur.type ] ) ) {
					if( cur.ignore && !cur.ignore.test( dummy ) ) {
						var dd = this.dayArr[ obj.month ] || 30;
						if( parseInt( dummy.match( cur.regex )[ 0 ] ) < dd ){
							continue;
						}
					}
					if( cur.str ) {
						var matches = this.find( cur.array, dummy.replace( /(Y|G)+/, '' ) ).mon;
						if( matches ){
							arg = this.replace( arg, matches, false, cur.val );
							obj[ cur.type ] = cur.array ? this.find( cur.array, matches ).index : matches;
						}
					} else {
						var matches = dummy.match( cur.regex )[ 0 ];
						arg = this.replace( arg, cur.regex, cur.suff, cur.val );
						obj[ cur.type ] = parseInt( matches );
						if( cur.type == 'week' ) {
							arg = replace( arg, new RegExp( this.week + '(?=\\\[' + this.week + ')') );
						}
					}
					dummy = dummy.replace( matches, '' );
				}
			}
			return arg;
		}

		function iterate( array, arg ) {
			for( var i = 0; i < array.length; i++ ) {
				if( array[ i ].regex.test( arg ) ) {
					return array[ i ];
				}
			}
		}

		function get_day( month, year ){
			var dayArr = this.dayArr,
			isLeap = this.isLeap( year );

			return dayArr[ month ] + ( month == 1 && isLeap ? 1 : 0 );
		}

		function constructFormat( arg ) {
			var dateFormat = iterate.call( this, standardDate, arg ), timeFormat;
			if( dateFormat ) {
				timeFormat = iterate.call( this, standardTime, arg.replace( dateFormat.regex, '' ) );
				if( timeFormat ) {
					arg = dateFormat.val + timeFormat.val;
				} else {
					arg = constructFormatCopy.call( this, arg.replace( dateFormat.regex, dateFormat.val ), true );
				}
			} else {
				arg = constructFormatCopy.call( this, arg )
				arg = constructFormatCopy.call( this, arg, true )
			}
			return arg;
		}

		proto.additional = true;

		$L.extend( proto, {

			 inbuiltFormats : {
			 	localDatetime: 'YYYY-MM-DDTHH:mm',            
		        localSecondDatetime: 'YYYY-MM-DDTHH:mm:ss',
		        localMillisecondDatetime: 'YYYY-MM-DDTHH:mm:ss.SSS',   
		        defaultDate: 'YYYY-MM-DD',                             
		        defaultTime: 'HH:mm',                                
		        defaultTimeSecond: 'HH:mm:ss',                 
		        defaultTimeMillisecond: 'HH:mm:ss.SSS',           
		        defaultWeek: 'GGGG-[W]WW',    
		        defaultMonth: 'YYYY-MM'
			 },

			get : function( arg ){
				if( arg ){
					return this[ arg ]();
				}
			},

			set : function( arg, val ) {
				if( arg ) {
					if( val.constructor == Object ) {
						for( var key in val ) {
							this[ key ]( val[ key ] );
						}
						return this
					} else {
						return this[ arg ]( val );
					}
				}
			},

			constructFormat : constructFormat,

			i18N : i18N
		})

		new Array( { prop : 'date', array : [ proto.weekLong, proto.weekShort, proto.weekMid] }, { prop : 'day', array : [ proto.weekLong, proto.weekShort, proto.weekMid] } , { prop : 'month', array : [ proto.shortMon, proto.longMon ] }, { prop : 'year'}, { prop : 'fullYear' }, { prop : 'hours' }, { prop : 'minutes' }, { prop : 'seconds' }, { prop : 'milliseconds' },{ prop : 'UTCMilliseconds' }, { prop : 'time' } ).forEach( function( val ) {
			
			proto[ val.prop ] = function( arg ){
				if( this.validate() ) {
					var dob = this.toDate();
					var prop = val.prop[ 0 ].toUpperCase() + val.prop.slice( 1 );
					if( this.isDef( arg ) ) {
						if( arg.constructor == String ) {
							for( var i = 0; i < val.array.length; i++ ) {
								var ret = this.find( val.array[ i ], arg )
								if( ret.mon ) {
									arg = ret.index;
									break;
								}
							}
						} else if( arg.constructor == Number && Math.floor( arg ) != arg ) {
							if( val.prop == 'year' ) {
								val.prop = 'month';
								arg = Math.round( arg * 12 );
							} else {
								arg = Math.round( arg )
							}
						}
						if( val.prop == 'day' ) {
							dob.setDate( dob.getDate() + ( arg - dob.getDay() ) );
						} else{
							dob[ 'set' + prop ]( arg );
						}
						return this;
					} else {
						return dob[ 'get' + prop ]();
					}
				}
			}
		});

		$L.extend( proto, {
			week : function( arg ) {
				if( this.validate() ) {
					var dob = this.toDate();
					if( this.isDef( arg ) ) {
						dob.setDate( dob.getDate() + ( arg - this.week() ) * 7 );
						return this;
					} else{
						return this.getWeekReverse( dob, 1 ).week;
					}
				}
			},

			quarter : function( arg ) {
				if( this.validate() ) {
					var dob = this.toDate();
					if( this.isDef( arg ) ) {
						var mon = dob.getMonth();
						dob.setMonth( dob.getMonth() + ( arg - this.quarter() ) * 3 );
						return this;
					} else{
						return Math.ceil( dob.getMonth() / 3 );
					}
				}
			},

			add : function( val, prop, cyclic ) {

				if( val < 0 ){
					return this.subtract( Math.abs( val ), prop, cyclic );
				}

				if( this.validate() ) {
					var dob = this.toDate();
					if( this.isDef( prop ) ) {
						if( this._timezone && prop == "month" ){

							var ref = $L.moment( dob );

							for( var i = 0; i < val; i++ ){
								var _month = Number( ref.format( 'M' ) ) - 1,
								date = _month ? get_day.call( this, _month, Number( ref.format( 'YYYY' ) ) ) : 31,
								old_time = ref.getDObj().getTimezoneOffset();

								ref.add( date, 'date' );

								var new_time = ref.getDObj().getTimezoneOffset();

								if( new_time != old_time ){
									this.subtract( new_time - old_time, "minutes" );
								}
							}
							return this;
						} else{
						 	var old_time = dob.getTimezoneOffset(),
						 	newmoment = this.set( prop, this.get( prop ) + val );
						 	if( cyclic ){
								return convertCyclic.call( this, newmoment );
							}
							return newmoment;
						}
					}
				}
			},

			subtract : function( val, prop, cyclic ) {

				if( val < 0 ){
					return this.add( Math.abs( val ), prop, cyclic );
				}

				if( this.validate() ) {
					var dob = this.toDate();
					if( this.isDef( prop ) ) {
						var newmoment;

						if( this._timezone && prop == "month" ){

							var ref = $L.moment( dob );

							for( var i = 0; i < val; i++ ){
								var _month = Number( ref.format( 'M' ) ) - 1,
								date = _month > 1 ? get_day.call( this, _month - 1, Number( ref.format( 'YYYY' ) ) ) : 31,
								old_time = ref.getDObj().getTimezoneOffset();

								ref.subtract( date, 'date' );

								var new_time = ref.getDObj().getTimezoneOffset();

								if( new_time != old_time ){
									this.subtract( new_time - old_time, "minutes" );
								}
							}
							return this;
						}

						var newmoment = this.set( prop, this.get( prop ) - val );
						if( cyclic ){
							return convertCyclic.call( this, newmoment );
						}
						return newmoment;
					}
				}
			},

			startOf : function( prop ){
				if( this.validate() ){
					var dob = this.toDate(),
					flag,
					format = this.format(),
					replace = [],
					year = Number( format.slice( 0, 4 ) ),
					month = Number( format.slice( 5, 7 ) ),
					date = Number( format.slice( 8, 10 ) ),
					hour = Number( format.slice( 11, 13 ) ),
					minute = Number( format.slice( 14, 16 ) ),
					second = Number( format.slice( 17, 19 ) ),
					milliseconds = dob.getMilliseconds(),
					to_deduct = 0,
					old_time = this.timezoneOffset( dob );

					if( prop == "week" ){
						var day = dob.getDay() || 7;
						to_deduct = ( day - 1 ) * 24 * 60 * 60 * 1e3;
						flag = true;
						prop = "hour";
					}

					switch( prop ){
						case "year" : {
							flag = true;
						}
						case "month" : {
							if( flag ){
								to_deduct += this.totdate( month - 1, this.isLeap( year ) ) * 24 * 60 * 60 * 1e3;
							}
							flag = true;
						}
						case "date" : 
						case "day" : {
							if( flag ){
								to_deduct += ( date - 1 ) * 24 * 60 * 60 * 1e3;
							}
							flag = true;
						}
						case "hour" : {
							if( flag ){
								to_deduct += hour * 60 * 60 * 1e3;
							}
							flag = true;
						}
						case "minute" : {
							if( flag ){
								to_deduct += minute * 60 * 1e3;
							}
							flag = true;
						}
						case "second" : {
							if( flag ){
								to_deduct += second * 1e3;
							}
						}
					}

					if( to_deduct ){
						dob.setTime( dob.getTime() - to_deduct - milliseconds );

						var new_time = this.timezoneOffset( dob ),
						diff = new_time - old_time;

						if( diff ){
							dob.setTime( dob.getTime() + diff * 60 * 1e3 );
						}
					}

					return this;
				}
			},

			endOf : function( prop ){
				if( this.validate() ){
					this.startOf( prop );

					var to_add = 1;

					if( prop == "week" ){
						prop = "day";
						to_add = 7;
					}

					var map = {
						hour : "hours",
						minute : "minutes",
						second : "seconds",
						date : "date",
						day : "day",
						month : "month",
						year : "fullYear"
					};

					this.add( to_add, map[ prop ] || prop );
					this.subtract( 1, "milliseconds" );
					return this;
				}
			},

			fromNow : function( arg, to_accurate ){
				if( this.validate() ){
					var today = this,
					past_date = $L.moment( arg );

					if( !past_date.validate() ){
						return;
					}

					var old_time = today.get( 'time' ),
					new_time = past_date.get(  'time' ),
					diff = parseInt( ( new_time - old_time ) / 1000 ),
					past = diff < 0,
					limits = { years : { val : 320 * 24 * 60 * 60, conv : 365 * 24 * 60 * 60 }, months : { val : 26 * 24 * 60 * 60, conv : 30 * 24 * 60 * 60 }, days : { val : 22 * 60 * 60, conv : 24 * 60 * 60 }, hours : { val : 45 * 60, conv : 60 * 60 }, minutes : { val : 44, conv : 60 }, seconds : { val : 0, conv : 1 } };
					timestamp = new_time - old_time,
					ns1 = to_accurate ? 'conv' : 'val',
					ns2 = to_accurate ? 'floor' : 'round',
					fn = function( _diff, obj ){
						var key,
						value;

						for( key in limits ){
							if( _diff >= limits[ key ][ ns1 ] ) {
								val = Math[ ns2 ]( _diff / limits[ key ].conv );
								value = val;

								var new_diff = _diff - val * limits[ key ].conv;
								if( new_diff > 0 ){
									fn( new_diff, obj );
								}
								break;
							}
						}

						obj[ key ] = { value : value };

						return {
							property : key,
							value : value
						};
					},
					obj = { past : past, timestamp : timestamp };

					diff = Math.abs( diff ); 

					return $L.extend( obj, fn( diff, obj ) );
				}
			}		
		} );

		function convertCyclic( newmoment ){
			var dob = this.toDate();
			
			dob.setFullYear( parseInt( this.getCorrectYear( this.crctLength( Number( this.format( 'YYYY' ) ) % 100, 2 ) ) ) );
			return this;
		}

		function i18N( format, callBack ){
			if( this.validate() ){
				var parsed = this.parseFormat( this.replaceTxt( format ) ).reverse();
				format = format.replace( /{{|}}/g, '' );

				parsed.forEach( function( item ){
					var value = item.format.val,
					formatted = this.format( value ),
					i18ned = window._lyteUiUtils ? _lyteUiUtils.i18n( formatted ) : formatted,
					index = item.index;

					format = format.slice( 0, index ) + ( callBack ? callBack( formatted, i18ned, value ) : i18ned ) + format.slice( index + value.length );
				}.bind( this ) );

				return format;
			}
		}

	}
})(window);
;( function(){
	if( window.lyteDomObj ){
		function CanvasPool() {
			var canvases = [];
			return {
	    	
	        pop: function pop() {
	          if (this.length === 0) {
	            canvases.push(document.createElement('canvas'));
	          }
	    
	          return canvases.pop();
	        },
	        
	        get length() {
	          return canvases.length;
	        },

	        release: function release(canvas) {
	          var context = canvas.getContext('2d');
	          context.clearRect(0, 0, canvas.width, canvas.height);
	          canvases.push(canvas);
	        },

	        clear: function clear() {
	          canvases.splice(0, canvases.length);
	        },

	        get elements() {
	          return canvases;
	        }
	    
	      };
	    }
	    var shared = CanvasPool();
	    var canvasPool = (shared);

		function lyteWatermark(object, promise){
			var data = object ? object : {};
			var positions = ["atPos","lowerRight","upperRight","lowerLeft","upperLeft","center","custom"];
			var styles = ["image","text"];

			data.target = data.target;
			data.watermark = data.watermark;
			data.style = data.style && styles.indexOf(data.style) !== -1 ? data.style : "text";
			data.position = data.position && positions.indexOf(data.position) !== -1 ? data.position : "lowerRight";
			data.alpha = data.alpha && data.alpha >= 0 && data.alpha <= 1 ? data.alpha : 1;
			data.font = data.font ? data.font : "20px Josefin Slab";
			data.fillStyle = data.fillStyle ? data.fillStyle : "#fff";
			data.size = data.size;
			data.init = data.init ? data.init : function init() {};
			data.initialized = data.initialized;
			data.type = "image/png";
			data.encoderOptions = 0.92;
			if(data.position == "atPos"){
				data.posX = typeof data.posX === "function" ? data.posX : returnFnRef(data.posX);
				data.posY = typeof data.posY === "function" ? data.posY : returnFnRef(data.posY);
			}
			data.onLoad = data.onLoad;
			data.onComplete = data.onComplete;
			var promise = this.promise = promise !== undefined ? promise : null;
			
			this.promise || (promise = this.promise = loadImages(getImageArray(data), data.init));

			if(!data.initialized){
				data.initialized = true;
				if(data.position === "custom"){
					if(!data.onLoad){
						// console.error("For custom style you need to provide onLoad function to position the watermark");
						// this.promise = "ERROR ! onLoad not provided for custom position.";
						throw new Error("ERROR ! onLoad not provided for custom position.");
						// return ;
					}
					promise = this.promise = afterImageLoad(data.onLoad)
				}
				else if(data.style == "image"){
					if(data.position == "lowerRight"){
						promise = this.promise = afterImageLoad(lowerRight(data.alpha));
					}
					else if(data.position == "upperRight"){
						promise = this.promise = afterImageLoad(upperRight(data.alpha));
					}
					else if(data.position == "lowerLeft"){
						promise = this.promise = afterImageLoad(lowerLeft(data.alpha));
					}
					else if(data.position == "upperLeft"){
						promise = this.promise = afterImageLoad(upperLeft(data.alpha));
					}
					else if(data.position == "center"){
						promise = this.promise = afterImageLoad(center(data.alpha));
					}
					else if(data.position == "atPos"){
						promise = this.promise = afterImageLoad(atPos(data.posX, data.posY, data.alpha));
					}
				}
				else if(data.style == "text"){
					if(data.position == "lowerRight"){
						promise = this.promise = afterImageLoad(text_lowerRight(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "upperRight"){
						promise = this.promise = afterImageLoad(text_upperRight(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "lowerLeft"){
						promise = this.promise = afterImageLoad(text_lowerLeft(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "upperLeft"){
						promise = this.promise = afterImageLoad(text_upperLeft(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "center"){
						promise = this.promise = afterImageLoad(text_center(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "atPos"){
						promise = this.promise = afterImageLoad(text_atPos(data.posX, data.posY, data.watermark, data.font, data.fillStyle, data.alpha));
					}
				}
				if(data.onComplete){
					promise = this.promise = addResolve();
				}
			}

			function afterImageLoad(draw) {
			    return dataUrl(draw).then(createImage);
			}

			function dataUrl(draw) {
			    var promise_obj = $L.watermark(data, promise).then(function (images) {
			        return mapToCanvas(images, canvasPool);
			    }).then(function (canvases) {
			        return addStyleToResult(draw, canvases);
			    }).then(function (result) {
			        return release(result, canvasPool, {
			          type: data.type,
			          encoderOptions: data.encoderOptions
			        });
			    });
			    return $L.watermark(data, promise_obj);
			}

			function identity(x) {
				return x;
			}

			function getTypeOf(obj) { 
				if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { 
				    getTypeOf = function getTypeOf(obj) { return typeof obj; }; 
				} else { 
				    getTypeOf = function getTypeOf(obj) { 
					    return obj && 
					    typeof Symbol === "function" && 
					    obj.constructor === Symbol && 
					    obj !== Symbol.prototype ? "symbol" : typeof obj; 
				    }; 
				} return getTypeOf(obj); 
			}

			function getLoader(resource) {
				var type = getTypeOf(resource);
				if (type === 'string') {
    				return loadUrl;
				}
				if (resource instanceof Image) {
    				return identity;
				}
				// return loadFile;
			}

			function loadImages(imgArray, init) {
				var promises = [];

				for (var i = 0; i < imgArray.length; i++) {
				    var img = imgArray[i];
				    var loader = getLoader(img);
				    var promise = loader(img, init);
				    promises.push(promise);
				}

				return Promise.all(promises);
			}

			function loadUrl(url, init) {
				var img = new Image();
				typeof init === 'function' && init(img);
				return new Promise(function (resolve) {
				    img.onload = function () {
				    	return resolve(img);
				    };
				    img.src = url;
				});
			}

			function createImage(url, onload) {
				var img = new Image();

				if (typeof onload === 'function') {
    				img.onload = onload;
				}
				img.src = url;
				return img;
			}

			function mapToCanvas(images, pool) {
				return images.map(function (img) {
					var canvas = pool.pop();
					var ctx = canvas.getContext('2d');
					canvas.width = img.width;
					canvas.height = img.height;
					ctx.drawImage(img, 0, 0);
					return canvas;
				});
			}
			function canvasDataUrl(canvas, parameters) {
				var parameters = parameters || {
				    type: 'image/png',
				    encoderOptions: 0.92
				};
				return canvas.toDataURL(parameters.type, parameters.encoderOptions);
			}
			function addStyleToResult(draw, sources) {
				var canvas = draw.apply(null, sources);
				return {
				    canvas: canvas,
				    sources: sources
				};
			}

		    function release(result, pool, parameters) {
				var canvas = result.canvas,
			    	sources = result.sources;
				var dataURL = canvasDataUrl(canvas, parameters);
				sources.forEach(pool.release);
				return dataURL;
			}

			function atPos(xFn, yFn, alpha) {
				// alpha || (alpha = 1.0);
				return function (target, watermark) {
				    var context = target.getContext('2d');
				    context.save();
				    context.globalAlpha = alpha;
				    context.drawImage(watermark, xFn(target, watermark), yFn(target, watermark));
				    context.restore();
				    return target;
				};
			}
			function lowerRight(alpha) {
				return atPos(function (target, mark) {
				    return target.width - (mark.width + 10);
				}, function (target, mark) {
				    return target.height - (mark.height + 10);
				}, alpha);
			}
			function upperRight(alpha) {
				return atPos(function (target, mark) {
				    return target.width - (mark.width + 10);
				}, function (target, mark) {
				    return 10;
				}, alpha);
			}

			function lowerLeft(alpha) {
				return atPos(function (target, mark) {
				    return 10;
				}, function (target, mark) {
				    return target.height - (mark.height + 10);
				}, alpha);
			}

			function upperLeft(alpha) {
				return atPos(function (target, mark) {
				    return 10;
				}, function (target, mark) {
				    return 10;
				}, alpha);
			}

			function center(alpha) {
				return atPos(function (target, mark) {
				    return (target.width - mark.width) / 2;
				}, function (target, mark) {
				    return (target.height - mark.height) / 2;
				}, alpha);
			}

			function text_atPos(xFn, yFn, text, font, fillStyle, alpha) {
				return function (target) {
				    var context = target.getContext('2d');
				    context.save();
				    context.globalAlpha = alpha;
				    context.fillStyle = fillStyle;
				    context.font = font;
				    var metrics = context.measureText(text);
				    context.fillText(text, xFn(target, metrics, context), yFn(target, metrics, context));
				    context.restore();
				    return target;
				};
			}

			function text_lowerRight(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics) {
				    return target.width - (metrics.width + 10);
				}, function (target) {
				    return size || target.height - 10;
				}, text, font, fillStyle, alpha);
			}

			function text_lowerLeft(text, font, fillStyle, alpha, size) {
				return text_atPos(function () {
				    return 10;
				}, function (target) {
				    return size || target.height - 10;
				}, text, font, fillStyle, alpha);
			}

			function text_upperRight(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics) {
				    return target.width - (metrics.width + 10);
				}, function () {
				    return size || 20;
				}, text, font, fillStyle, alpha);
			}

			function text_upperLeft(text, font, fillStyle, alpha, size) {
				return text_atPos(function () {
				    return 10;
				}, function () {
				    return size || 20;
				}, text, font, fillStyle, alpha);
			}

			function text_center(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics, ctx) {
				    ctx.textAlign = 'center';
				    return target.width / 2;
				}, function (target, metrics, ctx) {
				    ctx.textBaseline = 'middle';
				    return target.height / 2;
				}, text, font, fillStyle, alpha);
			}

			function returnFnRef(val) {
				return function(){
					return val || 40;
				}
			}

			function getImageArray(data){
				var images = Array.of(data.target);
				if(data.style == "image"){
					images.push(data.watermark);
				}
				return images;
			}

			function addResolve(){
				return $L.watermark(data, promise).then(data.onComplete);
			}
		}

		lyteWatermark.prototype = {
			load: function load(resources, init) {
		      var promise = this.then(function (resource) {
		        resources.target = resource;
		        resources.initialized = false;
		        return $L.watermark(resources);
		      });
		      resources.initialized = true;
		      return $L.watermark(resources, promise);
		    },

		    then: function then() {
		      for (var len = arguments.length, funcs = new Array(len), key = 0; key < len; key++) {
		        funcs[key] = arguments[key];
		      }

		      return this.promise.then.apply(this.promise, funcs);
		    }
		}

		$L.watermark = function(arg, promise){
			if(typeof arg === "string" && arg === "destroy"){
				return canvasPool.clear();
			}
			return new lyteWatermark(arg, promise);
		}

		$L.watermark.lyteWatermark = lyteWatermark;
	}
} )( window );

/** Think about the from = 'italics' problem that you faced and fix that
We removed a condition which would normally convert a italics symbol into a text
refer the other types to get a better understanding
**/
( function() {

	var reg_sinks = {
		// 'text': /[a-zA-Z]/i,
		'line_break': /(\n|\r\n|\r)/,
		'special': /[*#\-_~!`()\[\]\.|"]/,
		'space': /[ ]/,
		'number': /\d/
	};

	var typeMap = {
		'b': 'bold',
		'i': 'italics',
		'u': 'underline',
		's': 'strike',
		'div': 'para',
		'table': 'table',
		'thead': 'thead',
		'tbody': 'tbody',
		'tr': 'tr',
		'td': 'td',
		'th': 'th',
		'img': 'image',
		'a': 'hyperlink',
		'ul': 'ul',
		'ol': 'ol',
		'li': 'li',
		'mark': 'mark',
		'blockquote': 'blockquote',
		'h1': 'h1',
		'h2': 'h2',
		'h3': 'h3',
		'h4': 'h4',
		'h5': 'h5'
	};

	function flushBuf( buf ) {
		var ret = buf.flush();

		if( ret ) {
			return new token( ret, 'text' );	
		}
	}

	function token( value, type ) {
		var obj = {
			value: value,
			type: type
		};

		this.get = function( name ) {
			return obj[ name ] || '';
		}

		return this;
	}

	function buffer() {
		var buffer = [];

		this.push = function( char ) {
			buffer.push( char );
		}

		this.flush = function() {
			var temp = buffer;

			buffer = [];

			return temp.join( "" );
		}
	}

	function tokenList() {
		var tokens = [],
		pointer = 0;

		this.push = function( token ) {
			if( token ) {
				tokens.push( token );
			}
		}

		this.peek = function() {
			return tokens[ pointer ] || new token();
		}

		this.peekback = function() {
			return tokens[ pointer - 1 ] || new token();
		}

		this.eat = function() {
			return tokens[ pointer++ ] || new token();
		}

		this.pointer = function( num ) {
			return !isNaN( num ) ? ( pointer = num ) : pointer;
		}

		this.moveback = function() {
			pointer--;
		}

		/* probably not this guy */		
		this.flush = function() {
			pointer = 0;
			tokens = [];
		}
	}

	function stack() {
		var stack = [];

		this.push = function( val ) {
			stack.push( val );

			return val;
		}

		this.pop = function() {
			stack.pop();
		}

		this.callStackContains = function( val ) {
			return !!~stack.indexOf( val );
		}

		this.isEmpty = function() {
			return stack.length === 0;
		}
	}

	function isSpace( char ) {
		return reg_sinks.space.test( char );
	}

	function isLineBreak( char ) {
		return reg_sinks.line_break.test( char );
	}

	// function isText( char ) {
	// 	return reg_sinks.text.test( char );
	// }

	function isSpecial( char ) {
		return char.match( reg_sinks.special );
	}

	function lex( text ) {
		var i = 0, length = text.length,
		buf = new buffer(), char, ret, _special, 
		list = new tokenList();

		for( ; i < length; i++ ) {
			char = text.charAt( i );

			if( isLineBreak( char ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'line_break' ) );
			}
			else if( ( _special = isSpecial( char ) ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'special' + _special[ 0 ] ) );
			}
			else if( isSpace( char ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'space' ) );
			} 
			else {
				buf.push( char );
			}
		}

		list.push( flushBuf( buf ) );

		return list;
	}


	// Node can either be a text or a node
	function getText( node ) {
		var text;

		if( typeof node !== 'string' ) {
			text = $L._lyteHTMLToText( node );
		}
		else {
			text = node;
		}

		return text;
	}

	/* The buildConfig is used to create a closure variable(an interface) which can be used to access the individual properties */
	/* 
	For now we are returning all attributes in a config but there can be a case where one of the attributes is a tagname instead of an
	attribute 
	*/
	function buildConfig( totalConfiguration ) {
		var attributes = [ 
						'bold', 'italics', 'strike', 'underline', 'blockquote', 'mark',
						'para',  
						'hyperlink', 'image', 
						'header', 'h1', 'h2', 'h3', 'h4', 'h5',
						'ol', 'ul', 'li',
						'table', 'thead', 'tbody', 'tr', 'th', 'td' ],

		configs = {};

		totalConfiguration = totalConfiguration || {};

		attributes.forEach( function( item ) {
			configs[ item ] = new config( totalConfiguration[ item ] );
		} );

		return {
			getAllAttributes: function( configName ) {
				return configs[ configName ].getAllAttributes();
			},

			getAttribute: function( configName, attributeName ) {
				return configs[ configName ].getAttribute( attributeName ) || '';
			}
		};
	}

	function config( config ) {
		var configStore = config || {};

		this.getAttribute = function( name ) {
			return configStore[ name ];
		}

		this.getAllAttributes = function() {
			return configStore;
		}

		return this;
	}

	function _rDP( list, totalConfiguration ) {
		var cs = new stack(),
		userConfig = buildConfig( totalConfiguration ),
		isTableCell, onBeforeAppend = ( totalConfiguration || {} ).onBeforeAppend;

		function join( high, low ) {
			var obj = {};

			$L.extend( obj, low );
			$L.extend( obj, high );

			return obj;
		}

		function addAllAttributes( node, configName ) {
			var attributes, key,
			domObj = $L( node );

			if( !!~[ 'h1', 'h2', 'h3', 'h4', 'h5' ].indexOf( configName ) ) {
				attributes = join( userConfig.getAllAttributes( configName ), userConfig.getAllAttributes( 'header' ) );
			}
			else {
				attributes = userConfig.getAllAttributes( configName );
			}

			for( key in attributes ) {
				domObj.attr( key, attributes[ key ] );
			}
		}

		var capture = function() {
			return list.pointer();
		}

		var backtrack = function( val ) {
			list.pointer( val );
		}

		var isEmpty = function( frag ) {
			if( typeof frag === 'boolean' ) {
				return true;
			}

			// Added a fix for IE where you have to trim the textContent or else its flags empty fragments as non empty
			return !frag.querySelector( '*' ) && !frag.textContent.trim();
		}

		var buildHeader = function() {
			var count = 0, header;

			count = findHeaders();

			if( count <= 5 
				&& (
					( !shouldConsiderWhiteSpace() && !isWhiteSpace() ) 
					|| ( shouldConsiderWhiteSpace() && isWhiteSpace( list.eat() ) )
				)
				&& hasTextualCharacter() 
			) {

				header = document.createElement( 'h' + count );
				addAllAttributes( header, 'h' + count );
				para( header );

				return header;
			}
		}

		var shouldConsiderWhiteSpace = function() {
			return !userConfig.getAttribute( 'header', 'ignoreWhiteSpaceJoiner' );
		}

		var hasTextualCharacter = function() {
			var mem = capture();

			while( !endOfLine() ) {
				if( !isWhiteSpace() ) {
					backtrack( mem );

					return true;
				}

				list.eat();
			}

			backtrack( mem );

			return false;
		} 

		var findHeaders = function() {
			var count = 0;

			while( list.peek().get( 'type' ) === 'special#' ) {
				count++;
				list.eat();
			}

			return count;
		}

		var buildQuote = function() {
			var quote;

			if( hasTextualCharacter() ) {
				quote = document.createElement( 'blockquote' );
				addAllAttributes( quote, 'blockquote' );
				para( quote );

				return quote;
			}
			
		}

		var getType = function( tag ) {
			return typeMap[ tag ];
		}

		var getElementToAppend = function( element ) {
			var tag = element.tagName.toLowerCase(),
			type = getType( tag ), ret;

			if( onBeforeAppend ) {
				ret = onBeforeAppend.call( window, element, type );
			}

			return ret ? ret : element;
		}

		var appendElement = function( parent, child ) {
			if( !parent || !child ) {
				return ;
			}

			var nodeType = child.nodeType;

			if( nodeType === 1 ) {
				child = getElementToAppend( child );	
			}
			
			parent.appendChild( child );
		}

		var buildMarkdown = function() {
			var div = document.createElement( 'div' ), ret;

			while( list.peek().get( 'type' ) !== '' ) {
				ret = buildBasedOnFirstCharacter() || document.createDocumentFragment();

				// Eating the last line line_break in para
				if( list.peek().get( 'type' ) === 'line_break' ) {
					list.eat();
				}

				appendElement( div, ret );
			}

			return div;
		}

		var buildBasedOnFirstCharacter = function() {
			var p = document.createElement( 'div' ), 
			children, mem, header, quote, table, ret, token;

			addAllAttributes( p, 'para' );
			mem = capture();

			if( isStartOfHeader() ) {
				mem = capture();
				ret = buildHeader();

				if( ret ) {
					appendElement( p, ret );
				}
				else {
					backtrack( mem );
					para( p );
				}
			}

			else if( isQuoteStart() ) {
				token = list.eat();
				mem = capture();
				ret = getImage();

				if( ret ) {
					appendElement( p, ret );

					// Image should use para
					para( p );
				}
				else {
					backtrack( mem );
					ret = buildQuote();

					if( ret ) {
						// This guy doesn't need para
						appendElement( p, ret );
					}
					else {
						backtrack( mem );
						consumeCharacter( p, token );
						para( p );
					}
				}
			}

			else if( isOrderedListStart() ) {
				// Need to fix this
				appendElement( p, buildOrderedList() );
			}

			else if( isUnorderedListStart() ) {
				// Need to fix this
				appendElement( p, buildUnorderedList() );
			}

			else if( isTableStart() ) {
				table = buildTable();

				if( table ) {
					appendElement( p, table );
					list.moveback();
				}
				else {
					backtrack( mem );
					para( p );
				}
			}
			else {
				backtrack( mem );
				para( p );
			}

			return p;

		}

		var isStartOfHeader = function() {
			var mem = capture();

			consumeLeadingWhiteSpaces();

			if( list.peek().get( 'type' ) === 'special#' ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var isQuoteStart = function() {
			var mem = capture();

			consumeLeadingWhiteSpaces();

			if( isImageStart() ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var consumeLeadingWhiteSpaces = function() {
			while( isWhiteSpace() ) {
				list.eat();
			}
		}

		var isTableStart = function() {
			var mem = capture(), token,
			type;

			consumeLeadingWhiteSpaces();

			token = list.peek(),
			type = token.get( 'type' )

			if( type === 'special|' ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var buildTable = function() {
			var table = document.createElement( 'table' ),
			tableHeader = getTableHeader(),
			tableRow, isProperSyntax;

			if( !tableHeader ) {
				return false;
			}

			isProperSyntax = consumeHeaderFooter( tableHeader.column_count );

			if( !isProperSyntax ) {
				return false;
			}

			appendElement( table, tableHeader.header );
			isProperSyntax = buildTableBody( tableHeader.column_count );

			if( !isProperSyntax ) {
				return false;
			}

			appendElement( table, isProperSyntax );
			addAllAttributes( table, 'table' );

			return table;
		}

		var buildTableBody = function( column_count ) {
			var tableRow, body = document.createElement( 'tbody' );

			while( isValidRow( buildLine() ) ) {
				tableRow = getTableRow( column_count );

				if( !tableRow ) {
					return false;
				}

				appendElement( body, tableRow );
			}

			if( body.children.length === 0 ) {
				return false;
			}

			addAllAttributes( body, 'tbody' );

			return body;
		}

		var buildLine = function() {
			var mem = capture(),
			res = '';

			while( !endOfLine() ) {
				res = res + list.eat().get( 'value' );
			}

			backtrack( mem );

			return res;
		}

		var isValidRow = function( res ) {
			return !!~res.indexOf( '|' )
		}

		var getTableRow = function( column_count ) {
			var row = document.createElement( 'tr' ), cell,
			mem = capture(), currentColumnCount = 0;

			consumeLeadingWhiteSpaces();

			while( list.eat().get( 'type' ) === 'special|' ) {
				cell = buildCell();

				if( cell ) {
					currentColumnCount++;
					appendElement( row, cell );
				}
			}

			if( currentColumnCount < column_count ) {
				addRemainingColumns( row, currentColumnCount, column_count );
			}

			if( currentColumnCount > column_count ) {
				return false;
			}

			addAllAttributes( row, 'tr' );

			return row;

		}

		var addRemainingColumns = function( row, cur, max ) {
			var cell;

			for( var i = cur; i < max; i++ ) {
				cell = document.createElement( 'td' );
				appendElement( row, cell );
				addAllAttributes( cell, 'td' );
			}
		}

		var buildCell = function() {
			var frag = document.createDocumentFragment(),
			cell = document.createElement( 'td' );

			isTableCell = true;
			para( frag );
			isTableCell = false;
			trimFragment( frag );

			if( isEmpty( frag ) ) {
				return false;
			}

			cell.appendChild( frag );
			addAllAttributes( cell, 'td' );

			return cell;
		}

		var trimFragment = function( frag ) {
			trimLeadingSpaces( frag );
			trimTrailingSpaces( frag );
		}

		var trimLeadingSpaces = function( frag ) {
			var firstNode = frag.childNodes[ 0 ], 
			value, rLeadingSpace = /^\s+/g;

			if( firstNode 
				&& firstNode.nodeType === 3 
			) {
				value = firstNode.nodeValue;
				value = value.replace( rLeadingSpace, '' );
				firstNode.nodeValue = value;
			}
		}

		var trimTrailingSpaces = function( frag ) {
			var length = frag.childNodes.length,
			lastNode = frag.childNodes[ length - 1 ],
			value, rTrailingSpace = /\s+$/g;

			if( lastNode 
				&& lastNode.nodeType === 3 
			) {
				value = lastNode.nodeValue;
				value = value.replace( rTrailingSpace, '' );
				lastNode.nodeValue = value;
			}
		}

		var consumeHeaderFooter = function( column_count ) {
			var columnCount = 0, hasNonTrailingCharacters;

			consumeLeadingWhiteSpaces();

			while( !endOfLine() ) {

				if( trailingCharacter() ) {
					break;
				}

				if( list.peek().get( 'type' ) !== 'special|' && list.peek().get( 'type' ) !== 'special-' ) {
					return false;
				}

				if( list.eat().get( 'type' ) === 'special|' && list.peek().get( 'type' ) === 'special-' ) {
					columnCount++;
				}
			}

			hasNonTrailingCharacters = consumeTrailingCharacters();

			if( hasNonTrailingCharacters ) {
				return false;
			}

			return columnCount === column_count;
		}

		var getTableHeader = function() {
			var header = document.createElement( 'thead' ),
			row = document.createElement( 'tr' ),
			column_count, head, hasNonTrailingCharacters;

			while( list.peek().get( 'type' ) === 'special|' ) {
				list.eat();
				head = buildHead();

				if( head ) {
					appendElement( row, head );
				}
			}

			column_count = row.children.length;

			if( column_count === 0 ) {
				return false;
			}
			
			appendElement( header, row );			
			hasNonTrailingCharacters = consumeTrailingCharacters();
			
			if( hasNonTrailingCharacters ) {
				return false;
			}

			addAllAttributes( header, 'thead' );
			addAllAttributes( row, 'tr' );

			return {
				column_count: column_count,
				header: header
			}
		}

		var buildHead = function() {
			var frag = document.createDocumentFragment(),
			headerCell = document.createElement( 'th' );

			isTableCell = true;
			para( frag );
			isTableCell = false;
			trimFragment( frag );

			if( isEmpty( frag ) ) {
				return false;
			}

			headerCell.appendChild( frag );
			addAllAttributes( headerCell, 'th' );

			return headerCell;
		}

		var endOfCell = function() {
			return list.peek().get( 'type' ) === 'special|' 
				|| list.peek().get( 'type' ) === 'line_break' 
				|| list.peek().get( 'type' ) === ''
		}

		var consumeTrailingCharacters = function() {
			while( !endOfLine() ) {
				if( !trailingCharacter() ) {
					return false;
				}

				list.eat();
			}

			list.eat();
		}

		var trailingCharacter = function() {
			return list.peek().get( 'type' ) === 'line_break' 
				|| list.peek().get( 'type' ) === '' 
				|| isWhiteSpace()
		}

		var endOfLine = function() {
			return list.peek().get( 'type' ) === 'line_break' || list.peek().get( 'type' ) === ''
		}

		var buildOrderedList = function() {
			var parent = document.createElement( 'ol' );

			do {
				appendElement( parent, buildListItem() );
				consumeTrailingCharacters();
			}while( isStartOfList() );

			addAllAttributes( parent, 'ol' );

			return parent;
		}

		var buildUnorderedList = function() {
			var parent = document.createElement( 'ul' );

			do {
				appendElement( parent, buildListItem() );
				consumeTrailingCharacters();
			}while( isStartOfList() );

			addAllAttributes( parent, 'ul' );

			return parent;
		}

		var buildListItem = function() {
			var item = document.createElement( 'li' ),
			frag = document.createDocumentFragment();

			para( frag );

			item.appendChild( frag );	

			return item;
		}

		var isStartOfList = function() {
			var mem = capture(),
			isListStart = isOrderedListStart() || ( backtrack( mem ), isUnorderedListStart() );

			if( !isListStart ) {
				backtrack( mem );
			}

			return isListStart;
		}

		var isOrderedListStart = function() {
			var mem = capture(), 
			token, value, type, isValidStart;

			consumeLeadingWhiteSpaces();

			token = list.eat();
			value = token.get( 'value' );
			type = token.get( 'type' );

			if( type === 'text' && !isNaN( value ) ) {
				isValidStart = list.eat().get( 'type' ) === 'special.' && list.eat().get( 'type' ) === 'space';
			}

			if( !isValidStart ) {
				backtrack( mem );
			}

			return isValidStart;
		}

		var isUnorderedListStart = function() {
			var mem = capture(), 
			token, value, type, isValidStart;

			consumeLeadingWhiteSpaces();

			token = list.eat();
			value = token.get( 'value' );
			type = token.get( 'type' );

			if( type === 'special*' || type === 'special-' ) {
				isValidStart = list.eat().get( 'type' ) === 'space';
			}

			if( !isValidStart ) {
				backtrack( mem );
			}

			return isValidStart;
		}

		var getEmphasisOrConsumeCharacter = function( allowSpace ) {
			var value = list.peek().get( 'value' ), 

			// It can have text because bold, italics, strike and underline call it as well
			type = list.peek().get( 'type' ), frag, ret, mem;

			switch( value ) {
				case '*':
					if( ( mem = capture(), ret = bold() ) ) {
						return ret;
					}
					else if( ( backtrack( mem ), !cs.callStackContains( 'bold' ) ) || ( cs.callStackContains( 'bold' ) && ( backtrack( mem ), list.peekback().get( 'type' ) === 'space' ) ) ) {
						list.eat();
						ret = document.createTextNode( '*' );

						return ret;	
					}
					else if( cs.callStackContains( 'bold' ) ) {
						return false;
					}
					
					break;
				case '_': 
					mem = capture();

					if( isUnderLineStart() ) {
						backtrack( mem );
						return buildUnderline();
					}
					else {
						backtrack( mem );
						return buildItalics();
					}

					break;
				case '~':
					if( ( mem = capture(), ret = strike() ) ) {
						return ret;
					}
					else if( ( backtrack( mem ), !cs.callStackContains( 'strike' ) ) || ( cs.callStackContains( 'strike' ) && ( backtrack( mem ), list.peekback().get( 'type' ) === 'space' ) ) ) {
						list.eat();
						ret = document.createTextNode( '~' );

						return ret;	
					}
					else if( cs.callStackContains( 'strike' ) ) {
						return false;
					}

					break;
			}

			if( isTextualCharacter() || ( allowSpace && type === 'space' ) ) {
				ret = text();

				return document.createTextNode( ret );
			}

			return false;
		}

		var buildItalics = function() {
			var mem = capture(), ret;

			if( ( ret = italics() ) ) {
				return ret;
			}
			else if( ( backtrack( mem ), !cs.callStackContains( 'italics' ) ) || ( cs.callStackContains( 'italics' ) && ( backtrack( mem ), list.peekback().get( 'type' ) === 'space' ) ) ) {
				list.eat();
				ret = document.createTextNode( '_' );

				return ret;
			}
			else if( cs.callStackContains( 'italics' ) ) {
				return false;
			}
		}

		var buildUnderline = function() {
			var mem = capture(), ret;

			if( ( ret = underline() ) ) {
				return ret;
			}
			else if( ( backtrack( mem ), !cs.callStackContains( 'underline' ) ) || ( cs.callStackContains( 'underline' ) && ( backtrack( mem ), list.peekback().get( 'type' ) === 'space' ) ) ) {
				list.eat();
				ret = document.createTextNode( '_' );

				return ret;
			}
			else if( cs.callStackContains( 'underline' ) ) {
				return false;
			} 
		}

		var isUnderLineStart = function() {
			var first = list.eat(),
			second = list.eat();

			return first.get( 'type' ) === 'special_' && second.get( 'type' ) === 'special_';
		}

		var italics = function() {
			var mem, frag, start, container;

			list.eat();
			mem = capture();
			cs.push( 'italics' );

			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special_' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createItalics( container );
			}
			else if( ( backtrack( mem ), !isEmpty( ret = recurse( 'special_' ) ) )
				&& list.peekback().get( 'type' ) !== 'space'
				&& list.eat().get( 'type' ) === 'special_' 
			) {
				frag = document.createDocumentFragment();
				frag.appendChild( ret );
				cs.pop();

				return createItalics( frag );
			}

			cs.pop();

			return false;

		}

		var underline = function() {
			var mem, frag, container;

			list.eat();
			list.eat();
			mem = capture();
			cs.push( 'underline' );

			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special_'
				&& list.eat().get( 'type' ) === 'special_'
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createUnderline( container );
			}
			else if( ( backtrack( mem ), !isEmpty( ret = recurse( 'underline' ) ) )
				&& list.peekback().get( 'type' ) !== 'space'
				&& list.eat().get( 'type' ) === 'special_' 
				&& list.eat().get( 'type' ) === 'special_' 
			) {
				frag = document.createDocumentFragment();
				frag.appendChild( ret );
				cs.pop();

				return createUnderline( frag );
			}

			cs.pop();

			return false;
		}

		var bold = function() {
			var mem, frag, end, container;

			list.eat();
			mem = capture();
			cs.push( 'bold' );
			
			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special*' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createBold( container );
			}
			else if( ( backtrack( mem ), !isEmpty( ret = recurse( 'special*' ) ) )
				&& list.peekback().get( 'type' ) !== 'space'
				&& list.eat().get( 'type' ) === 'special*' 
			) {
				frag = document.createDocumentFragment();
				frag.appendChild( ret );
				cs.pop();

				return createBold( frag );
			}

			cs.pop();

			return false;

		}

		var strike = function() {
			var mem, frag, end, container;

			list.eat();
			mem = capture();
			cs.push( 'strike' );
			
			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special~' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createStrike( container );
			}
			else if( ( backtrack( mem ), !isEmpty( ret = recurse( 'special~' ) ) )
				&& list.peekback().get( 'type' ) !== 'space'
				&& list.eat().get( 'type' ) === 'special~' 
			) {
				frag = document.createDocumentFragment();
				frag.appendChild( ret );
				cs.pop();

				return createStrike( frag );
			}

			cs.pop();

			return false;
		}


		var para = function( parent ) {
			var token = list.peek(), 
			ret, mem, char, code,
			type = token.get( 'type' );

			if( isURL() ) {
				mem = capture();
				ret = getURL();
				appendElement( parent, ret );
				processNextCharacter( parent );

				return ret;

			}

			// Found textual character
			if( isTextualCharacter() || isWhiteSpace() ) {
				ret = consumeText( parent );
				processNextCharacter( parent );

				return ret;
			}

			// Found a possible image
			else if( isImageStart() ) {
				token = list.eat();
				mem = capture();
				ret = getImage();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );			
					consumeCharacter( parent, token );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}
			
			// Found a possible emphasis token
			else if ( isEmphasis() ) {
				ret = getEmphasisOrConsumeCharacter();
				
				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					return false;
				}
			}

			// Found highlight character
			else if( isHighlight() ) {
				token = list.eat();
				mem = capture();
				ret = getHighlight();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );
					consumeCharacter( parent, token );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}

			// Found a link
			else if( isLink() ) {
				token = list.eat();
				mem = capture();
				ret = getLink();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );
					consumeCharacter( parent, token );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}

			// Found a line_break. End it.
			else if( delimiter() ) {
				return false;
			}
			
			
			// Found a weirdo. Consume weirdo as text.
			else if( !hasEnded( list ) ) {
				token = list.eat();
				mem = capture();
				consumeCharacter( parent, token );
				processNextCharacter( parent );

				return token.get( 'value' );

			}

			if( hasEnded( list ) ) {
				return parent;
			}
		}

		var isURL = function() {
			var mem = capture(),
			token = list.eat(),
			value = token.get( 'value' ),
			type = token.get( 'type' ),
			nextToken = list.peek();

			backtrack( mem );

			return type === 'text' 
				&& ( 
					value.startsWith( 'https://' ) 
					|| value.startsWith( 'http://' )
					|| ( 
						value.startsWith( 'www' ) 
						&& nextToken.get( 'type' ) === 'special.' 
					) 
				);
		}

		var getURL = function() {
			var href, text, a, textNode;

			href = text = consumeURL();

			a = document.createElement( 'a' );
			href = href.trim();

			if( !href.startsWith( 'https://' ) && !href.startsWith( 'http://' ) ) {
				href = 'https://' + href;
			}

			a.href = href
			a.setAttribute( 'target', '_blank' );
			a.setAttribute( 'rel', 'noopener noreferrer' );

			textNode = document.createTextNode( text );
			a.appendChild( textNode );

			addAllAttributes( a, 'hyperlink' );

			return a;

		}

		var consumeURL = function() {
			var str = '';
			
			while( !isWhiteSpace() && !delimiter() ) {
				str += list.eat().get( 'value' );
			}

			return str;	
		}

		var getLink = function() {
			var ret, allowSpace = true, text, textNode,
			href, a, title;

			if( !cs.callStackContains( 'link' ) ) {		
				text = getInnerText();

				if( list.eat().get( 'type' ) !== 'special]' ) {
					return false;
				}

				if( list.eat().get( 'type' ) !== 'special(' ) {
					return false;
				}

				href = consumeAsTextForLink();

				if( ( href || "" ).trim().length === 0 ) {
					return false;
				}

				if( list.peek().get( 'type' ) === 'special"' ) {
					list.eat();
					title = consumeTextAsTitle();

					if( list.eat().get( 'type' ) !== 'special"' ) {
						return false;
					}
				}

				if( list.eat().get( 'type' ) !== 'special)' ) {
					return false;
				}

				a = document.createElement( 'a' );
				a.href = href.trim();
				a.setAttribute( 'target', '_blank' );
				a.setAttribute( 'rel', 'noopener noreferrer' )

				if( text.trim().length === 0 ) {
					text = href.trim();
				}

				textNode = document.createTextNode( text );
				a.appendChild( textNode );

				if( title ) {
					a.setAttribute( 'title', title );
				} 

				addAllAttributes( a, 'hyperlink' );

				return a;
			}

			return false;
		}

		var consumeCharacter = function( parent, token ) {
			var value = token.get( 'value' ),
			textNode = document.createTextNode( value );

			parent.appendChild( textNode );
		}


		var isLink = function() {
			var token = list.peek();

			return token.get( 'type' ) === 'special[';
		}

		var getImage = function() {
			var text, img, alt = '';

			// I don't think this is needed
			if( alreadProcessingLink() ) {
				return false;
			}

			if( list.eat().get( 'type' ) === 'special[' ) {
				alt = consumeAsTextForAlt();

				if( list.eat().get( 'type' ) !== 'special]' ) {
					return false;
				}

				if( list.eat().get( 'type' ) !== 'special(' ) {
					return false;
				}

				text = consumeAsTextForSrc();

				if( list.peek().get( 'type' ) === 'special)' ) {
					list.eat();
				}
				else {
					return false;
				}

				if( ( text || "" ).trim().length === 0 ) {
					return false;
				}

				img = document.createElement( 'img' );
				img.alt = alt;
				img.src = text;
				addAllAttributes( img, 'image' );

				return img;
			}
			else {
				return false;
			}
		}

		var getHighlight = function() {
			var mark, ret;

			if( cs.isEmpty() ) {
				ret = consumeAsTextForHighlight() || "";

				if( ret.trim().length !== 0 && isHighlight() ) {
					list.eat();
					mark = document.createElement( 'mark' );
					mark.appendChild( document.createTextNode( ret ) );
					addAllAttributes( mark, 'mark' );

					return mark;
				}
			}
			
			return false;
		}

		var isHighlight = function() {
			var token = list.peek();

			return token.get( 'type' ) === 'special`';
		}

		var alreadProcessingLink = function() {
			return cs.callStackContains( 'link' );
		}

		var processNextCharacter = function( parent ) {
			var mem = capture();

			if( !para( parent ) ) {
				backtrack( mem );
			}
		}

		var isImageStart = function() {
			var token = list.peek();

			return token.get( 'type' ) === 'special!';
		}

		var consumeText = function( parent ) {
			var ret = text();

			parent.appendChild( document.createTextNode( ret ) );

			return ret;
		}

		var isEmphasis = function() {
			var token = list.peek(),
			type = token.get( 'type' );

			return type === 'special*' || type === 'special_' || type === 'special~';
		}

		var consumeAsTextForLink = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special)'
				&& list.peek().get( 'type' ) !== 'special"'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeTextAsTitle = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special"'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForSrc = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special)'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForAlt = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special]'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForHighlight = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special`'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var getInnerText = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special]'
				&& !delimiter() 
			) {
				str += list.eat().get( 'value' );
			}

			return str; 
		}

		var delimiter = function() {
			var token = list.peek();

			return isTableCell ? ( token.get( 'type' ) === '' || token.get( 'type' ) === 'line_break' || token.get( 'type' ) === 'special|' )
								: ( token.get( 'type' ) === 'line_break' || token.get( 'type' ) === '' );
		}

		var hasEnded = function( list ) {
			return delimiter();
		}


		var createBold = function( frag ) {
			var b = document.createElement( 'b' );

			b.appendChild( frag );
			addAllAttributes( b, 'bold' );

			return b;
		}

		var createUnderline = function( frag ) {
			var u = document.createElement( 'u' );

			u.appendChild( frag );
			addAllAttributes( u, 'underline' );

			return u;
		}

		var createItalics = function( frag ) {
			var i = document.createElement( 'i' );

			i.appendChild( frag );
			addAllAttributes( i, 'italics' );

			return i;
		}

		var createStrike = function( frag ) {
			var s = document.createElement( 's' );

			s.appendChild( frag );
			addAllAttributes( s, 'strike' );

			return s;
		}

		var recurse = function( type ) {
			var ret, frag = document.createDocumentFragment(),
			allowSpace = false;

			while( ( ret = getEmphasisOrConsumeCharacter( allowSpace ) )
				&& !isEndOfType( type )
				&& !delimiter()
			) {
				frag.appendChild( ret );
				allowSpace = true;
			}

			if( ret ) {
				frag.appendChild( ret );
			}

			if( !isEndOfType( type ) ) {
				return false;
			}

			return frag;
		}

		var isEndOfType = function( type ) {
			var mem, isEnd;
			list.peek().get( 'type' ) !== type 

			// TODO: Fix greedy consumption problem in recurse
			if( type === 'underline' ) {
				mem = capture();
				isEnd = list.peekback().get( 'type' ) !== 'space' && list.eat().get( 'type' ) === 'special_' && list.eat().get( 'type' ) === 'special_';
				backtrack( mem );
			}
			else {
				isEnd = list.peekback().get( 'type' ) !== 'space' && list.peek().get( 'type' ) === type;
			}

			return isEnd;
		}


		var text = function() {
			var ret = '';

			while( isTextualCharacter()
				|| isWhiteSpace()
			) {
				ret = ret + list.eat().get( 'value' );
			}

			return ret;
		}

		var isTextualCharacter = function( token ) {
			token = token ? token : list.peek();

			return isTableCell ? isTextContentWhenTable( token ) : isTextContentWhenNormal( token );
		}

		var isTextContentWhenTable = function( token ) {
			return ( isText( token ) || token.get( 'type' ) === 'special.' || token.get( 'type' ) === 'special"' ) && !isURL();
		}

		var isTextContentWhenNormal = function( token ) {
			return ( isText( token ) || token.get( 'type' ) === 'special.' || token.get( 'type' ) === 'special|' || token.get( 'type' ) === 'special"' ) && !isURL();
		}

		var isWhiteSpace = function( token ) {
			token = token ? token : list.peek();

			return token.get( 'type' ) === 'space'
		}

		var isText = function( token ) {
			token = token ? token : list.peek();

			return token.get( 'type' ) === 'text'; 
		}

		return buildMarkdown();
	}

	var convertToString = function( dom ) {
		var dummyDiv = document.createElement( 'div' );

		dummyDiv.appendChild( dom );

		// SECURITY: XSS issues over here
		return dummyDiv.innerHTML;
	}

	var getReturnBasedOnType = function( type, dom ) {
		type = ( type || "dom" ).toLowerCase();

		if( type === 'dom' ) {
			return dom;
		}
		else if( type === 'domstring' ) {
			return convertToString( dom );
		}

		return dom;
	}


	$L.markdown = function( node, config ) {
		var dom, list, text, type, ret;

		config = config || {};
		type = config.type;
		text = getText( node )
		list = lex( text )
		dom = _rDP( list, config );
		list.flush();

		ret = getReturnBasedOnType( type, dom );

		return ret;
	}
} )();


( function() {

	var wrapMap = {
		'b': {
			'start': '*',
			'end': '*'
		},

		'p': {
			'start': '',
			'end': '\n'
		},

		'div': {
			'start': '',
			'end': '\n'
		},

		'br': {
			'start': '',
			'end': '\n'
		},

		'span': {
			'start': '',
			'end': ''
		}
	}

	function shouldAddWrapper( node ) {
		var parent = node.parentNode,
		isLineBreak = node.nodeName.toLowerCase() === 'br',
		isParentParaOrDiv = parent.nodeName.toLowerCase() === 'div' || parent.nodeName.toLowerCase() === 'p',
		isSingleChild = parent.childNodes.length === 1;

		return !isLineBreak || !isParentParaOrDiv || !isSingleChild;

	}

	function wrapText( node, text ) {
		var tagName = node.nodeName.toLowerCase(),
		wrapObj = wrapMap[ tagName ],
		ret;

		if( shouldAddWrapper( node ) ) {
			ret = wrapObj.start + text + wrapObj.end;
		}
		else {
			ret = text;
		}

		return ret;
	}


	function getText( node, isFirstNode ) {
		var res = '',
		childNodes = node.childNodes;

		$L( childNodes ).each( function( index, node ) {
			isFirstNode = isFirstNode && ( index === 0 );

			if( isFirstNode ) {
				if( node.nodeType === 1 ) {
					res += getText( node ) + ( shouldAddNewLine( childNodes ) ? '\n' : '' );
				}
				else if( node.nodeType === 3 ) {
					res += node.nodeValue + ( shouldAddNewLine( childNodes ) ? '\n' : '' );
				}
			}
			else if( node.nodeType === 1 ) {
				res += wrapText( node, getText( node ) );
			}
			else if( node.nodeType === 3 ) {
				res += node.nodeValue;
			}
		} );

		return res;
	}

	function shouldAddNewLine( children ) {
		return children.length > 1;
	}

	$L._lyteHTMLToText = function( node ) {
		return getText( node, true );
	}
} )();

;( function(){
    var isRtl;

    function rtlfunc( lft, bcr, ww ) {
              if( isRtl ) {
                if( bcr ) {
                    if( lft == 'right' ) {
                        return ww - bcr.left;
                    } else if( lft == 'clientX' ) {
                        return ww - bcr.clientX
                    }
                    return ww - bcr.right;
                } else if( lft == 'left' ) {
                    return 'right';
                } 
              }
              return bcr ? bcr[ lft ] : lft;
        }

    function destroy(){
        var remove_global_events = function( win_elem, elem ){
            if( win_elem && elem.contains( win_elem ) ){
                document.removeEventListener( 'mousemove', mousemove, true );
                document.removeEventListener( 'mouseup', mouseup, true );
                document.removeEventListener( 'touchmove', mousemove, true );
                document.removeEventListener( 'touchend', mouseup, true );
                mouseup( {}, true );
            }
        };
        this.each( function( index, item ){
            var current = $L( item ),
            activeElems = current.data( 'activeElems' ) || {},
            elem = current.get( 0 ),
            resizeData = elem._resizeData,
            win_elem = window._resizeelem;

            if( !resizeData ){
                return;
            }

            remove_global_events( win_elem, elem );

            for( var key in activeElems ){  
                activeElems[ key ].remove();
            }
            if( resizeData.component == 'table' ){
                removeActive.call( elem );
                elem.removeEventListener( 'mousemove', tableMove, true );
                elem.removeEventListener( 'mousedown', tableDown, true );
                elem.removeEventListener( 'mouseout', removeActive, true );
                elem.removeEventListener( 'touchmove', tableMove, true );
                elem.removeEventListener( 'touchstart', tableDown, true );
            }
            if( elem._clone ){
                elem._clone.remove();
                delete elem._clone._elem;
                delete elem._clone;
            }
        })
        return this;
    }

    function getBcr( elem ){
        var bcr = elem.getBoundingClientRect();
        return {
            left : bcr.left,
            right : bcr.right,
            top : bcr.top,
            bottom : bcr.bottom,
            width : elem.offsetWidth,
            height : elem.offsetHeight
        };
    }

    function getStyle( elem ){
        return window.getComputedStyle( elem );
    }

    function bind( obj ){
        this.each( function( index, item ){
            if( item._resizeData ){
                $L( item ).enableResize( 'destroy' );
            }
            bindEvents( item, $L.extend( true, {}, obj ) );
        }) 
    }

    function bindEvents( item, obj ){
        item._resizeData = obj;

        if( obj.component == "table" ){
            item.addEventListener( 'mousedown', tableDown, true );
            item.addEventListener( 'touchdown', tableDown, true );
            item.addEventListener( 'mousemove', tableMove, true );
            item.addEventListener( 'mouseout', removeActive, true );
        }

        createResize( item );
    }

    function createResize( elem ){
            var obj = elem._resizeData,
            directions = obj.directions,
            rotation = obj.rotation,
            activeElems = {},
            dirs = { N : { height : true, top : true }, S : { height : true }, W : { left : true, width : true }, E : { width : true }, SW : { height : true, left : true, width : true }, SE : { height : true, width : true }, NW : { top : true, height : true, left : true, width : true }, NE : { top : true, height : true, width : true } },
            clone;
            $L( elem ).data( 'activeElems', activeElems ).addClass( 'lyteResizeElement' );
            if( obj.clonedShape ){
                clone = $L( document.createElement( 'div' ) ).addClass( 'lyteResizeClone' ).get( 0 );
            }
            for( var i = 0; i < directions.length; i++ ){
                var curDir = directions[ i ],
                newelem = $L( document.createElement( 'div' ) ).addClass( 'lyteResizeHandle', 'lyteResize' + curDir ).data( { directions : dirs[ curDir ], element : elem, value : curDir } ).get( 0 );
                activeElems[ curDir ] = newelem;
                ( clone || elem ).appendChild( newelem );
                newelem.addEventListener( 'mousedown', mousedown, true );
                newelem.addEventListener( 'touchstart', mousedown, true );
            }
            if( clone ){
                elem.appendChild( clone );
                clone._elem = elem;
                elem._clone = clone;
            }
        }


    function getCell( element, direction ){
        var data = this._resizeData;

        if( ( element.matches && element.matches( data.tags.th ) ) || ( !element.matches && getIndex( toArray( this.querySelectorAll( data.tags.th ) ), element ) != -1 ) ){
            return element;
        }
        var row = element.parentNode,
        cells = toArray( row.children ),
        tbody = row.parentNode,
        rows = toArray( tbody.children ),
        cellIndex = getIndex( cells, element ),
        rowIndex = getIndex( rows, row );

        if( direction ){
            var rowSpan = element.rowSpan;
            if( rowSpan == 1 ){
                return element;
            }
            var newrow = rows[ rowIndex + rowSpan - 1 ],
            newcells = newrow.children,
            new_length = newcells.length;

            for( var i = 0; i < new_length; i++ ){
                var cur = newcells[ i ];
                if( cur.style.display == "none" || cur.rowSpan != 1 ){
                    continue;
                }
                return cur;
            }

            new_length = cells.length;

            for( var i = 0; i < new_length; i++ ){
                var cur = cells[ i ];
                if( cur.style.display == "none" || cur.rowSpan != 1 ){
                    continue;
                }
                return cur;
            }
            return element;
        } else {
            return tbody.previousElementSibling.children[ 0 ].children[ cellIndex + element.colSpan - 1 ];
        }
    }

    function border( style, direction ){
        return ( direction ? 
                    parseFloat( style.borderTopWidth ) + parseFloat( style.borderBottomWidth ) : 
                    parseFloat( style.borderLeftWidth ) + parseFloat( style.borderRightWidth ) );
    }

    function padding( style, direction ){
        var width = 0;
        if( style.boxSizing == "content-box" ){
            width = direction ? 
                    parseFloat( style.paddingTop ) + parseFloat( style.paddingBottom ) : 
                    parseFloat( style.paddingLeft ) + parseFloat( style.paddingRight );

            width += border( style, direction );
        }   
        return width
    }

    function mousedown( ev ){
        var evt = ev,
        isTch = /touch/i.test( ev.type );
        if( isTch ){
            if( ev.touches.length > 1 ){
                return;
            }
            evt = ev.touches[ 0 ];
        }
        var elem = this,
        targetElem = $L( this ).data( 'element' ),
        data = targetElem._resizeData,
        directions = $L( elem ).data( 'directions' );
        if( data.onBeforeSelect && data.onBeforeSelect( elem, targetElem, ev, elem._clone ) == false ){
            return;
        }
        window._resizeelem = this;

        var width = targetElem.offsetWidth,
        height = targetElem.offsetHeight,
        bcr = getBcr( elem ),
        iw = window.innerWidth,
        style = getStyle( targetElem ),
        originalValue = {},
        clone = targetElem._clone;
        width -= padding( style );
        height -= padding( style, true );
        originalValue.height = directions.height ? targetElem.style.height = height + 'px' : void 0;
        originalValue.width = directions.width ? targetElem.style.width = width + 'px' : void 0;
        originalValue[ rtlfunc( 'left' ) ] = directions.left ? targetElem.style[ rtlfunc( 'left' ) ] = style[ rtlfunc( 'left' ) ] : void 0;
        originalValue.top = directions.top ? targetElem.style.top = style.top : void 0;

        this._clientX = rtlfunc( 'clientX', evt, iw ) - rtlfunc( 'right', bcr, iw );
        this._clientY = evt.clientY - bcr.bottom;
        this._original = originalValue;

        if( data.component == "table" ){
            var cells = $L( targetElem ).children().children().children( data.tags.td + ',' + data.tags.th );
            
            $L.each( cells, function( index, item ){
                directions.width ? item.style.width = '' : void 0;
                directions.height ? item.style.height = '' : void 0;
            });
        }

         targetElem._owidth =  targetElem.style.width;
         targetElem._oheight = targetElem.style.height;
         targetElem._mwidth = targetElem.style.maxWidth;
         targetElem.style.width = 0;
         targetElem.style.height = 0;
         targetElem.style.maxWidth = 0;
         $L.fastdom.measure( function(){
            targetElem._minWidth = targetElem.offsetWidth;
            targetElem._minHeight = targetElem.offsetHeight;
            if( clone ){
                clone._minHeight = targetElem._minHeight;
                clone._minWidth = targetElem._minWidth;
            }
         }.bind( this ) )
         $L.fastdom.mutate( function(){
            targetElem._tableDown = true;
            targetElem.style.width = targetElem._owidth;
            targetElem.style.height = targetElem._oheight;
            targetElem.style.maxWidth = targetElem._mwidth;
            if( clone ){
                clone.style.width = targetElem._owidth;
                clone.style.height = targetElem._oheight;
                clone.style[ rtlfunc( 'left' ) ] = 0;
                clone.style.top = 0;
            }
            delete targetElem._oheight; delete targetElem._owidth; delete targetElem._mwidth;

            document.addEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
            document.addEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
            data.onSelect && data.onSelect( elem, targetElem, ev, elem._clone );
            evt.stopPropagation();
         } )
    }

    function tableDown( ev ){
        var data = this._resizeData,
        isTch = /touch/i.test( ev.type ),
        evt = ev;

        if( isTch ){
            if( evt.touches.length > 1 ){
                return;
            } 
            evt = evt.touches[ 0 ];
            tableMove.call( this, evt );
        }
        var active = data.active;
        if( !active || ev.buttons == 2 ){
            return;
        }
        if( data.onBeforeSelect && data.onBeforeSelect( this, active.element, ev ) == false ){
            return;
        }
        var preventTable = data.preventTable,
        direction = active.direction == "vertical",
        element = getCell.call( this, active.element, direction ),
        winwidth = window.innerWidth,
        style = getStyle( element ),
        bcr = getBcr( element ),
        row = element.parentNode,
        table = row.parentNode.parentNode,
        tableStyle = getStyle( table ),
        tableBcr = getBcr( table ),
        next = !direction && preventTable ? element.nextElementSibling : void 0,
        nextstyle,
        cells = toArray( row.children ),
        final = [],
        allCells = toArray( $L( table ).children().children().children( data.tags.td + ',' + data.tags.th ) );

        element._next = next;

        if( !preventTable ){
            table._original = { width : table.style.width, height : table.style.height };
        }

        if( direction ){
            cells.forEach( function( item ){
                if( item.style.display == "none" ){
                    return;
                }
                var obj = {
                    node  : item,
                    style : getStyle( item ),
                    bcr : getBcr( item )
                }
                final.push( obj );
            } )
            table.style.height = ( tableBcr.height - padding( tableStyle, true ) ) + 'px';

            final.forEach( function( item ){
                item.node._original = { height : item.node.height, width : item.node.height };
                item.node.style.height = ( item.bcr.height - padding( item.style, true ) ) + 'px';
            } )

            allCells.forEach( function( item ){
                item._hgt = item.style.height;
                item.style.height = 0;
            } )
            table._hgt = table.style.height;
            table.style.height = 0;
        } else {
            element._original = { width : element.style.width, height : element.style.height };

            element.style.width = ( bcr.width -  padding( style ) ) + 'px';
            if( !preventTable ){
                table.style.width = ( tableBcr.width - padding( tableStyle ) ) + 'px';
            }
            if( next ){
                next._original = { width : next.style.width, height : next.style.height };
                var nextbcr = getBcr( next );
                nextstyle = getStyle( next );
                next.style.width = ( nextbcr.width - padding( nextstyle ) ) + 'px';
            }
            table.style.maxWidth = 0;
        }

        $L.fastdom.measure( function(){
                if( direction ){
                    final.forEach( function( item ){
                        item.node._minHeight = getBcr( item.node ).height - padding( item.style, true );
                    } )
                    if( !preventTable ){
                       table._minHeigth = getBcr( table ).height - padding( tableStyle, true );
                    }
                } else {
                    element._minWidth = getBcr( element ).width - padding( style );
                    if( next ){
                       next._minWidth = getBcr( next ).width - padding( nextstyle );
                    }
                    if( !preventTable ){
                       table._minWidth = getBcr( table ).width - padding( tableStyle );
                    }
                 }
            }.bind( this ) )

            $L.fastdom.mutate( function(){
                if( direction ){
                    allCells.forEach( function( item ){
                        if( item.parentNode == element.parentNode && element != item ){
                            item.style.height = "";
                        } else {
                            item.style.height = item._hgt;
                        }
                        delete item._hgt;
                    } )
                    table.style.height = table._hgt;
                    delete table._hgt;
                } else {
                   table.style.maxWidth = "";
                }
                element._clientX = rtlfunc( 'clientX', evt, winwidth ) - rtlfunc( 'right', bcr, winwidth );
                element._clientY = evt.clientY - bcr.bottom;
                window._resizeelem = element;
                $L( element ).data( 'element', this );
                $L( element ).data( 'directions', { width : !direction, height : direction } );

                document.addEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
                document.addEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
                data.onSelect && data.onSelect( this, element, ev );
                evt.stopPropagation();
                this._tableDown = true;
            }.bind( this ) )
    }

    function mousemove( ev ){
        var evt = ev,
        isTch = /touch/i.test( ev.type );
        if( isTch ){
            if( evt.touches.length > 1 ){
                return;
            }
            evt = evt.touches[ 0 ];
        }
        var elem = window._resizeelem,
        targetElem = $L( elem ).data( 'element' ) || elem,
        directions = $L( elem ).data( 'directions' ),
        data = targetElem._resizeData,
        winwidth = window.innerWidth,
        newX = rtlfunc( 'clientX', evt, winwidth ),
        newY = evt.clientY,
        newLeft,
        newTop,
        newWidth,
        newHeight,
        preventTable = data.preventTable,
        bcr = getBcr( elem ),
        isTable = targetElem._resizeData.component == 'table',
        next = elem._next,
        xIncr = newX - rtlfunc( 'right', bcr, winwidth ) - elem._clientX,
        yIncr = newY - bcr.bottom - elem._clientY,
        clone = targetElem._clone,
        x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( isRtl ? -1 : 1 ),
        y = window.pageYOffset || document.documentElement.scrollTop,
        xFact = directions.left ? -1 : 1,
        yFact = directions.top ? -1 : 1;

        targetElem = clone || targetElem;

        if( data.boundary && !next ){
            var bbcr;
            if( data.boundary.constructor == String ){
               var bcr1 = getBcr( $L( targetElem ).closest( data.boundary ).get( 0 ) );
               bbcr = {
                  left : bcr1[ rtlfunc( 'left' ) ],
                  right : bcr1[ rtlfunc( 'right' ) ],
                  top : bcr1.top,
                  bottom :bcr1.bottom
               }
            } else {
                bbcr = data.boundary;
            }
            if( newX > bbcr[ rtlfunc( 'right' ) ] || newX < bbcr[ rtlfunc( 'left' ) ] ){
                xIncr = 0;
            } 
            if( newY > bbcr.bottom || newY < bbcr.top ){
                yIncr = 0;
            } 
        }

        if( data.showInfo ){
            if( !elem._moved ){
                var infoDiv =  document.createElement( 'div' );
                infoDiv.classList.add( 'lyteResizeInfoDiv', data.infoClass );
                document.body.appendChild( infoDiv );
                elem._infoDiv = infoDiv;
            } 
        } 
        elem._moved = true;

        if( directions.width ){
            if( !preventTable ){
                var min = data.minWidth || targetElem._minWidth || 0,
                max = data.maxWidth || Infinity,
                originalWidth = parseFloat( targetElem.style.width ),
                modifiedWidth = originalWidth + xIncr * xFact,
                final = Math.min( max, Math.max( min, modifiedWidth ) );
                xIncr  = ( final - originalWidth ) * xFact;
            }

            if( isTable ){
                var originalWidth = parseFloat( elem.style.width ),
                modifiedWidth = originalWidth + xIncr,
                final = Math.max( elem._minWidth, modifiedWidth );
                xIncr = final - originalWidth;
                if( next ){
                    originalWidth = parseFloat( next.style.width );
                    modifiedWidth = originalWidth - xIncr;
                    final = Math.max( next._minWidth, modifiedWidth );
                    xIncr = originalWidth - final;
                }
            }
        }

        if( directions.height ){
            var min = data.minHeight || targetElem._minHeight || 0,
            max = data.maxHeight || Infinity,
            originalHeight = parseFloat( targetElem.style.height ),
            modifiedHeight = originalHeight + yIncr * yFact,
            final = Math.min( max, Math.max( min, modifiedHeight ) );
            yIncr  = ( final - originalHeight ) * yFact;
            
            if( isTable ){
                originalHeight = parseFloat( elem.style.height );
                modifiedHeight = originalHeight + yIncr;
                final = Math.max( elem._minHeight, modifiedHeight );
                yIncr = final - originalHeight;
            }
        }

        if( directions.left ){
            var left = parseFloat( targetElem.style[ rtlfunc( 'left' ) ] ),
            newLeft = left + xIncr,
            minLeft = data.minLeft || -Infinity,
            maxLeft = data.maxLeft || Infinity,
            finalLeft = Math.max( Math.min( maxLeft, newLeft ), minLeft );

            xIncr = finalLeft - left;
        }

        if( directions.top ){
            var tp = parseFloat( targetElem.style.top ),
            newTop = tp + yIncr,
            minTop = data.minTop || -Infinity,
            maxTop = data.maxTop || Infinity,
            finalTop = Math.max( Math.min( maxTop, newTop ), minTop );

            yIncr = finalTop - tp;
        }

        if( directions.width ){
            if( !preventTable ){
                targetElem.style.width = ( parseFloat( targetElem.style.width ) + xIncr * xFact ) + 'px';
            }
            if( isTable ){
                elem.style.width = ( parseFloat( elem.style.width ) + xIncr ) + 'px';
                if( next ){
                    next.style.width = ( parseFloat( next.style.width ) - xIncr ) + 'px';
                }
            }
        }

        if( directions.height ){
            targetElem.style.height = ( parseFloat( targetElem.style.height ) + yIncr * yFact ) + 'px';
            var cells = toArray( elem.parentNode.children );
            elem.style.height = ( parseFloat( elem.style.height ) + yIncr ) + 'px'
        }

        if( directions.left ) {
            targetElem.style.left = ( parseFloat( targetElem.style.left ) + xIncr ) + 'px';
        }

        if( directions.top ) {
            targetElem.style.top = ( parseFloat( targetElem.style.top ) + yIncr ) + 'px';
        }

        if( data.showInfo ){
            elem._infoDiv.innerHTML = data.getText ? data.getText( elem, Math.round( parseFloat( targetElem.style.width ) ), Math.round( parseFloat( targetElem.style.height ) ) ) : ( Math.round( parseFloat( targetElem.style.width ) ) + ' x ' + Math.round( parseFloat( targetElem.style.height ) ) );
            elem._infoDiv.style[ rtlfunc( 'left' ) ] = ( newX + x + 15 ) + 'px';
            elem._infoDiv.style.top = ( newY + y + 15 ) + 'px';
        }
        data.onMove && data.onMove( elem, $L( elem ).data( 'element' ), ev );
        evt.preventDefault();
    }

    function mouseup( evt, frm_remove ){
        var isTch = /touch/i.test( evt.type );
        document.removeEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
        document.removeEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
        var elem = window._resizeelem,
        targetElem = $L( elem ).data( 'element' ),
        data = targetElem._resizeData,
        next = elem._next,
        isTable = data.component == "table",
        directions = $L( elem ).data( 'directions' );

        if( elem._moved ){
            if( elem._infoDiv ){
                elem._infoDiv.remove();
                delete elem._infoDiv;
            }
            if( !frm_remove && data.onBeforeDrop && data.onBeforeDrop( elem, targetElem, evt, targetElem._clone ) == false ){
                $L( targetElem._clone || targetElem ).css( elem._original );
                delete elem._original;
                if( isTable ){
                    if( directions.width ){
                        $L( elem ).css( elem._original );
                        delete elem._original;
                        if( next ){
                            $L( next ).css( next._original );
                            delete next._original;
                        }
                    } else {
                        toArray( elem.parentNode.children ).forEach( function( item ){
                            $L( item ).css( item._original );
                            delete item._original;
                        } )
                    }
                }
            } else {
                if( targetElem._clone ){
                    var lft = rtlfunc( 'left' );
                    targetElem.style[ lft ] = ( parseFloat( targetElem.style[ lft ] ) + parseFloat( targetElem._clone.style[ lft ] ) ) + 'px';
                    targetElem.style.top = ( parseFloat( targetElem.style.top )  + parseFloat( targetElem._clone.style.top ) ) + 'px';
                    targetElem.style.width = targetElem._clone.style.width;
                    targetElem.style.height = targetElem._clone.style.height;
                    targetElem._clone.style[ rtlfunc( 'left' ) ] = 0;
                    targetElem._clone.style.top = 0;
                }
                !frm_remove && data.onDrop && data.onDrop( elem, targetElem, evt, elem._original, targetElem._clone );
            }
        } else {
            !frm_remove && data.onRelease && data.onRelease( elem, targetElem, evt, targetElem._clone );
        }
        delete window._resizeelem; delete elem._moved;

         if( targetElem._resizeData.component == 'table' ){
            if( elem._next ){
                delete elem._next._originalValue;
                delete elem._next;
            }
            if( !elem.classList.contains( 'lyteResizeHandle' ) ){
                $L( elem ).removeData( 'element' );
                $L( elem ).removeData( 'directions');
            }
            if( targetElem.contains( evt.target ) ){
                window._preventresizeClick = true;
                setTimeout( function(){
                    delete this._preventresizeClick;
                }, 0 )
            }
        }
    }

    function tableMove( evt ){
        if( window._resizeelem || evt.type == "mousemove" && evt.buttons ){
            return;
        }

        var data = this._resizeData,
        offset = data.offset,
        elementQuery = data.tags.td + ',' + data.tags.th,
        closest = $L( evt.target ).closest( elementQuery, this ).get( 0 ),
        winwidth = window.innerWidth,
        cx = rtlfunc( 'clientX', evt, winwidth ),
        cy = evt.clientY;
        if( !closest ){
            return;
        }

        var cells = closest.parentNode.children,
        index = getIndex( toArray( cells ), closest ),
        bcr = getBcr( closest ),
        isHori = cx > rtlfunc( 'right', bcr, winwidth ) - offset && cx < rtlfunc( 'right', bcr, winwidth ),
        isVert = cy > bcr.bottom - offset && cy < bcr.bottom,
        active = data.active,
        cursor,
        direction;

        if( data.preventTable && isHori ){
            if( index + closest.colSpan - 1 == cells.length - 1 ){
                return;
            }
        }

        if( ( isHori && !data.preventHorizontal ) || ( isVert && !data.preventVertical ) ){
                active && active.element != closest && removeActive.call( this );
                cursor = closest._cursor == undefined ? closest.style.cursor : closest._cursor;
                if( isVert ){
                    direction = 'vertical';
                    closest.style.cursor = data.rowResize;
                } else if( isHori ){
                    direction = 'horizontal';
                    closest.style.cursor = data.colResize;

                }   
                closest._cursor = cursor;
                data.active = { cursor : cursor, element : closest, direction : direction };
            } else {
                active && removeActive.call( this );       
            }
    }

    function removeActive(){
        var active = this._resizeData.active;
        if( active ){
            active.element.style.cursor = active.element._cursor;
            delete active.element._cursor;
            delete this._resizeData.active;
        }
    }

    function getIndex( array, elem ){
        return array.indexOf( elem );
    }

    function toArray( arr ){
        if( Array.from ){
            return Array.from( arr );
        }
        return Array.apply( Array, arr );
    }

    lyteDomObj.prototype.enableResize = function( obj ){
        if( obj == 'destroy' ){
            return destroy.call( this );
        }
        obj = obj || {};
        obj.directions = obj.directions || [ 'N', 'S', 'W', 'E', 'SW', 'SE', 'NW', 'NE' ];
        obj.rotation = obj.rotation == undefined ? true : obj.rotation;
        obj.tags = obj.tags || { td : "td", th : "th", tr : "tr", table : "table", thead : "thead", tbody : "tbody" };
        obj.rowResize = obj.rowResize || "row-resize";
        obj.colResize = obj.colResize || "col-resize";
        obj.offset = obj.offset || 10;
        bind.call( this, obj );
        return this;
    }

    document.addEventListener( 'click', function( evt ){
        var active = document.getElementsByClassName( 'lyteResizeSelected' ),
        _length = active.length;

        for( var i = 0; i < _length; i++ ){
            active[ i ].classList.remove( 'lyteResizeSelected' );
        }
        !window._preventresizeClick && $L( evt.target ).closest( '.lyteResizeElement' ).addClass( 'lyteResizeSelected' );
    }, true )

})(window);
;( function(){
	if( window.lyteDomObj ){

		var ExifTags, TiffTags, GPSTags, IFD1Tags, StringValues, debug = false;
		
		$L.exif = function(arg, setDebug){
			var object = arg || {};
			if(setDebug){
				debug = true;
			}
			if(!object.target){
				console.error("Target not provided for the retrieving the data!!");
				return false;
			}
	        if (!targetHasData(object.target)) {
	            fetchTargetExifData(object.target, object.getData);
	        } else {
	            if (object.getData) {
	                object.getData.call(null,{target : object.target, exifdata : object.target.exifdata});
	            }
	        }
	        return true;
		}

		ExifTags = $L.exif.Tags = {

	        // version tags
	        0x9000 : "ExifVersion",             // EXIF version
	        0xA000 : "FlashpixVersion",         // Flashpix format version

	        // colorspace tags
	        0xA001 : "ColorSpace",              // Color space information tag

	        // image configuration
	        0xA002 : "PixelXDimension",         // Valid width of meaningful image
	        0xA003 : "PixelYDimension",         // Valid height of meaningful image
	        0x9101 : "ComponentsConfiguration", // Information about channels
	        0x9102 : "CompressedBitsPerPixel",  // Compressed bits per pixel

	        // user information
	        0x927C : "MakerNote",               // Any desired information written by the manufacturer
	        0x9286 : "UserComment",             // Comments by user

	        // related file
	        0xA004 : "RelatedSoundFile",        // Name of related sound file

	        // date and time
	        0x9003 : "DateTimeOriginal",        // Date and time when the original image was generated
	        0x9004 : "DateTimeDigitized",       // Date and time when the image was stored digitally
	        0x9290 : "SubsecTime",              // Fractions of seconds for DateTime
	        0x9291 : "SubsecTimeOriginal",      // Fractions of seconds for DateTimeOriginal
	        0x9292 : "SubsecTimeDigitized",     // Fractions of seconds for DateTimeDigitized

	        // picture-taking conditions
	        0x829A : "ExposureTime",            // Exposure time (in seconds)
	        0x829D : "FNumber",                 // F number
	        0x8822 : "ExposureProgram",         // Exposure program
	        0x8824 : "SpectralSensitivity",     // Spectral sensitivity
	        0x8827 : "ISOSpeedRatings",         // ISO speed rating
	        0x8828 : "OECF",                    // Optoelectric conversion factor
	        0x9201 : "ShutterSpeedValue",       // Shutter speed
	        0x9202 : "ApertureValue",           // Lens aperture
	        0x9203 : "BrightnessValue",         // Value of brightness
	        0x9204 : "ExposureBias",            // Exposure bias
	        0x9205 : "MaxApertureValue",        // Smallest F number of lens
	        0x9206 : "SubjectDistance",         // Distance to subject in meters
	        0x9207 : "MeteringMode",            // Metering mode
	        0x9208 : "LightSource",             // Kind of light source
	        0x9209 : "Flash",                   // Flash status
	        0x9214 : "SubjectArea",             // Location and area of main subject
	        0x920A : "FocalLength",             // Focal length of the lens in mm
	        0xA20B : "FlashEnergy",             // Strobe energy in BCPS
	        0xA20C : "SpatialFrequencyResponse",    //
	        0xA20E : "FocalPlaneXResolution",   // Number of pixels in width direction per FocalPlaneResolutionUnit
	        0xA20F : "FocalPlaneYResolution",   // Number of pixels in height direction per FocalPlaneResolutionUnit
	        0xA210 : "FocalPlaneResolutionUnit",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
	        0xA214 : "SubjectLocation",         // Location of subject in image
	        0xA215 : "ExposureIndex",           // Exposure index selected on camera
	        0xA217 : "SensingMethod",           // Image sensor type
	        0xA300 : "FileSource",              // Image source (3 == DSC)
	        0xA301 : "SceneType",               // Scene type (1 == directly photographed)
	        0xA302 : "CFAPattern",              // Color filter array geometric pattern
	        0xA401 : "CustomRendered",          // Special processing
	        0xA402 : "ExposureMode",            // Exposure mode
	        0xA403 : "WhiteBalance",            // 1 = auto white balance, 2 = manual
	        0xA404 : "DigitalZoomRation",       // Digital zoom ratio
	        0xA405 : "FocalLengthIn35mmFilm",   // Equivalent foacl length assuming 35mm film camera (in mm)
	        0xA406 : "SceneCaptureType",        // Type of scene
	        0xA407 : "GainControl",             // Degree of overall image gain adjustment
	        0xA408 : "Contrast",                // Direction of contrast processing applied by camera
	        0xA409 : "Saturation",              // Direction of saturation processing applied by camera
	        0xA40A : "Sharpness",               // Direction of sharpness processing applied by camera
	        0xA40B : "DeviceSettingDescription",    //
	        0xA40C : "SubjectDistanceRange",    // Distance to subject

	        // other tags
	        0xA005 : "InteroperabilityIFDPointer",
	        0xA420 : "ImageUniqueID"            // Identifier assigned uniquely to each image
	    };

	    TiffTags = $L.exif.TiffTags = {
	        0x0100 : "ImageWidth",
	        0x0101 : "ImageHeight",
	        0x8769 : "ExifIFDPointer",
	        0x8825 : "GPSInfoIFDPointer",
	        0xA005 : "InteroperabilityIFDPointer",
	        0x0102 : "BitsPerSample",
	        0x0103 : "Compression",
	        0x0106 : "PhotometricInterpretation",
	        0x0112 : "Orientation",
	        0x0115 : "SamplesPerPixel",
	        0x011C : "PlanarConfiguration",
	        0x0212 : "YCbCrSubSampling",
	        0x0213 : "YCbCrPositioning",
	        0x011A : "XResolution",
	        0x011B : "YResolution",
	        0x0128 : "ResolutionUnit",
	        0x0111 : "StripOffsets",
	        0x0116 : "RowsPerStrip",
	        0x0117 : "StripByteCounts",
	        0x0201 : "JPEGInterchangeFormat",
	        0x0202 : "JPEGInterchangeFormatLength",
	        0x012D : "TransferFunction",
	        0x013E : "WhitePoint",
	        0x013F : "PrimaryChromaticities",
	        0x0211 : "YCbCrCoefficients",
	        0x0214 : "ReferenceBlackWhite",
	        0x0132 : "DateTime",
	        0x010E : "ImageDescription",
	        0x010F : "Make",
	        0x0110 : "Model",
	        0x0131 : "Software",
	        0x013B : "Artist",
	        0x8298 : "Copyright"
	    };

	    GPSTags = $L.exif.GPSTags = {
	        0x0000 : "GPSVersionID",
	        0x0001 : "GPSLatitudeRef",
	        0x0002 : "GPSLatitude",
	        0x0003 : "GPSLongitudeRef",
	        0x0004 : "GPSLongitude",
	        0x0005 : "GPSAltitudeRef",
	        0x0006 : "GPSAltitude",
	        0x0007 : "GPSTimeStamp",
	        0x0008 : "GPSSatellites",
	        0x0009 : "GPSStatus",
	        0x000A : "GPSMeasureMode",
	        0x000B : "GPSDOP",
	        0x000C : "GPSSpeedRef",
	        0x000D : "GPSSpeed",
	        0x000E : "GPSTrackRef",
	        0x000F : "GPSTrack",
	        0x0010 : "GPSImgDirectionRef",
	        0x0011 : "GPSImgDirection",
	        0x0012 : "GPSMapDatum",
	        0x0013 : "GPSDestLatitudeRef",
	        0x0014 : "GPSDestLatitude",
	        0x0015 : "GPSDestLongitudeRef",
	        0x0016 : "GPSDestLongitude",
	        0x0017 : "GPSDestBearingRef",
	        0x0018 : "GPSDestBearing",
	        0x0019 : "GPSDestDistanceRef",
	        0x001A : "GPSDestDistance",
	        0x001B : "GPSProcessingMethod",
	        0x001C : "GPSAreaInformation",
	        0x001D : "GPSDateStamp",
	        0x001E : "GPSDifferential"
	    };

	     // EXIF 2.3 Spec
	    IFD1Tags = $L.exif.IFD1Tags = {
	        0x0100: "ImageWidth",
	        0x0101: "ImageHeight",
	        0x0102: "BitsPerSample",
	        0x0103: "Compression",
	        0x0106: "PhotometricInterpretation",
	        0x0111: "StripOffsets",
	        0x0112: "Orientation",
	        0x0115: "SamplesPerPixel",
	        0x0116: "RowsPerStrip",
	        0x0117: "StripByteCounts",
	        0x011A: "XResolution",
	        0x011B: "YResolution",
	        0x011C: "PlanarConfiguration",
	        0x0128: "ResolutionUnit",
	        0x0201: "JpegIFOffset",    // When image format is JPEG, this value show offset to JPEG data stored.(aka "ThumbnailOffset" or "JPEGInterchangeFormat")
	        0x0202: "JpegIFByteCount", // When image format is JPEG, this value shows data size of JPEG image (aka "ThumbnailLength" or "JPEGInterchangeFormatLength")
	        0x0211: "YCbCrCoefficients",
	        0x0212: "YCbCrSubSampling",
	        0x0213: "YCbCrPositioning",
	        0x0214: "ReferenceBlackWhite"
	    };

	    StringValues = $L.exif.StringValues = {
	        ExposureProgram : {
	            0 : "Not defined",
	            1 : "Manual",
	            2 : "Normal program",
	            3 : "Aperture priority",
	            4 : "Shutter priority",
	            5 : "Creative program",
	            6 : "Action program",
	            7 : "Portrait mode",
	            8 : "Landscape mode"
	        },
	        MeteringMode : {
	            0 : "Unknown",
	            1 : "Average",
	            2 : "CenterWeightedAverage",
	            3 : "Spot",
	            4 : "MultiSpot",
	            5 : "Pattern",
	            6 : "Partial",
	            255 : "Other"
	        },
	        LightSource : {
	            0 : "Unknown",
	            1 : "Daylight",
	            2 : "Fluorescent",
	            3 : "Tungsten (incandescent light)",
	            4 : "Flash",
	            9 : "Fine weather",
	            10 : "Cloudy weather",
	            11 : "Shade",
	            12 : "Daylight fluorescent (D 5700 - 7100K)",
	            13 : "Day white fluorescent (N 4600 - 5400K)",
	            14 : "Cool white fluorescent (W 3900 - 4500K)",
	            15 : "White fluorescent (WW 3200 - 3700K)",
	            17 : "Standard light A",
	            18 : "Standard light B",
	            19 : "Standard light C",
	            20 : "D55",
	            21 : "D65",
	            22 : "D75",
	            23 : "D50",
	            24 : "ISO studio tungsten",
	            255 : "Other"
	        },
	        Flash : {
	            0x0000 : "Flash did not fire",
	            0x0001 : "Flash fired",
	            0x0005 : "Strobe return light not detected",
	            0x0007 : "Strobe return light detected",
	            0x0009 : "Flash fired, compulsory flash mode",
	            0x000D : "Flash fired, compulsory flash mode, return light not detected",
	            0x000F : "Flash fired, compulsory flash mode, return light detected",
	            0x0010 : "Flash did not fire, compulsory flash mode",
	            0x0018 : "Flash did not fire, auto mode",
	            0x0019 : "Flash fired, auto mode",
	            0x001D : "Flash fired, auto mode, return light not detected",
	            0x001F : "Flash fired, auto mode, return light detected",
	            0x0020 : "No flash function",
	            0x0041 : "Flash fired, red-eye reduction mode",
	            0x0045 : "Flash fired, red-eye reduction mode, return light not detected",
	            0x0047 : "Flash fired, red-eye reduction mode, return light detected",
	            0x0049 : "Flash fired, compulsory flash mode, red-eye reduction mode",
	            0x004D : "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
	            0x004F : "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
	            0x0059 : "Flash fired, auto mode, red-eye reduction mode",
	            0x005D : "Flash fired, auto mode, return light not detected, red-eye reduction mode",
	            0x005F : "Flash fired, auto mode, return light detected, red-eye reduction mode"
	        },
	        SensingMethod : {
	            1 : "Not defined",
	            2 : "One-chip color area sensor",
	            3 : "Two-chip color area sensor",
	            4 : "Three-chip color area sensor",
	            5 : "Color sequential area sensor",
	            7 : "Trilinear sensor",
	            8 : "Color sequential linear sensor"
	        },
	        SceneCaptureType : {
	            0 : "Standard",
	            1 : "Landscape",
	            2 : "Portrait",
	            3 : "Night scene"
	        },
	        SceneType : {
	            1 : "Directly photographed"
	        },
	        CustomRendered : {
	            0 : "Normal process",
	            1 : "Custom process"
	        },
	        WhiteBalance : {
	            0 : "Auto white balance",
	            1 : "Manual white balance"
	        },
	        GainControl : {
	            0 : "None",
	            1 : "Low gain up",
	            2 : "High gain up",
	            3 : "Low gain down",
	            4 : "High gain down"
	        },
	        Contrast : {
	            0 : "Normal",
	            1 : "Soft",
	            2 : "Hard"
	        },
	        Saturation : {
	            0 : "Normal",
	            1 : "Low saturation",
	            2 : "High saturation"
	        },
	        Sharpness : {
	            0 : "Normal",
	            1 : "Soft",
	            2 : "Hard"
	        },
	        SubjectDistanceRange : {
	            0 : "Unknown",
	            1 : "Macro",
	            2 : "Close view",
	            3 : "Distant view"
	        },
	        FileSource : {
	            3 : "DSC"
	        },

	        Components : {
	            0 : "",
	            1 : "Y",
	            2 : "Cb",
	            3 : "Cr",
	            4 : "R",
	            5 : "G",
	            6 : "B"
	        }
	    };

	    function targetHasData(target) {
	        return !!(typeof target === "object" && target.exifdata);
	    }

	    function base64ToArrayBuffer(base64, contentType) {
	        contentType = contentType || base64.match(/^data\:([^\;]+)\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'
	        base64 = base64.replace(/^data\:([^\;]+)\;base64,/gmi, '');
	        var binary = atob(base64);
	        var len = binary.length;
	        var buffer = new ArrayBuffer(len);
	        var view = new Uint8Array(buffer);
	        for (var i = 0; i < len; i++) {
	            view[i] = binary.charCodeAt(i);
	        }
	        return buffer;
	    }

	    function objectURLToBlob(url, callback) {
	        var http = new XMLHttpRequest();
	        http.open("GET", url, true);
	        http.responseType = "blob";
	        http.onload = function(e) {
	            if (this.status == 200 || this.status === 0) {
	                callback(this.response);
	            }
	        };
	        http.send();
	    }

	    function fetchTargetExifData(target, callback) {
	        function readDataFromBinaryFile(binFile) {
	            var data = getExifData(binFile);
	            if(typeof target === "object"){
	            	target.exifdata = data || {};
	            }
	            var obj = {
			            	target : target,
			            	exifdata : data || {}
			            }
	            if (callback) {
	                callback.call(null,obj);
	            }
	        }
	        var src = typeof target === "string" ? target : target.src;
	        if (src) {
	            if (/^data\:/i.test(src)) { // Data URI
	                var arrayBuffer = base64ToArrayBuffer(src);
	                readDataFromBinaryFile(arrayBuffer);

	            } else if (/^blob\:/i.test(src)) { // Object URL
	                var fileReader = new FileReader();
	                fileReader.onload = function(e) {
	                    readDataFromBinaryFile(e.target.result);
	                };
	                objectURLToBlob(src, function (blob) {
	                    fileReader.readAsArrayBuffer(blob);
	                });
	            } else {
	                var http = new XMLHttpRequest();
	                http.onload = function() {
	                    if (this.status == 200 || this.status === 0) {
	                        readDataFromBinaryFile(http.response);
	                    } else {
	                        throw "Could not load image";
	                    }
	                    http = null;
	                };
	                http.open("GET", src, true);
	                http.responseType = "arraybuffer";
	                http.send(null);
	            }
	        } else if (self.FileReader && (target instanceof self.Blob || target instanceof self.File)) {
	            var fileReader = new FileReader();
	            fileReader.onload = function(e) {
	                debug && console.log("Got file of length " + e.target.result.byteLength);
	                readDataFromBinaryFile(e.target.result);
	            };

	            fileReader.readAsArrayBuffer(target);
	        }
	    }

	    function getExifData(file) {
	        var dataView = new DataView(file);

	        debug && console.log("Got file of length " + file.byteLength);
	        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
	            debug && console.log("Not a valid JPEG");
	            return false; // not a valid jpeg
	        }

	        var offset = 2,
	            length = file.byteLength,
	            marker;

	        while (offset < length) {
	            if (dataView.getUint8(offset) != 0xFF) {
	                debug && console.log("Not a valid marker at offset " + offset + ", found: " + dataView.getUint8(offset));
	                return false; // not a valid marker, something is wrong
	            }

	            marker = dataView.getUint8(offset + 1);
	            debug && console.log(marker);

	            // we're only looking for 0xFFE1 for EXIF data
	            if (marker == 225) {
	                debug && console.log("Found 0xFFE1 marker");

	                return readExifData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);
	            } else {
	                offset += 2 + dataView.getUint16(offset+2);
	            }

	        }

	    }

	    function readTags(file, tiffStart, dirStart, strings, bigEnd) {
	        var entries = file.getUint16(dirStart, !bigEnd),
	            tags = {},
	            entryOffset, tag,
	            i;

	        for (i=0;i<entries;i++) {
	            entryOffset = dirStart + i*12 + 2;
	            tag = strings[file.getUint16(entryOffset, !bigEnd)];
	            !tag && debug && console.log("Unknown tag: " + file.getUint16(entryOffset, !bigEnd));
	            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
	        }
	        return tags;
	    }


	    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
	        var type = file.getUint16(entryOffset+2, !bigEnd),
	            numValues = file.getUint32(entryOffset+4, !bigEnd),
	            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,
	            offset,
	            vals, val, n,
	            numerator, denominator;

	        switch (type) {
	            case 1: // byte, 8-bit unsigned int
	            case 7: // undefined, 8-bit byte, value depending on field
	                if (numValues == 1) {
	                    return file.getUint8(entryOffset + 8, !bigEnd);
	                } else {
	                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        vals[n] = file.getUint8(offset + n);
	                    }
	                    return vals;
	                }

	            case 2: // ascii, 8-bit byte
	                offset = numValues > 4 ? valueOffset : (entryOffset + 8);
	                return getStringFromDB(file, offset, numValues-1);

	            case 3: // short, 16 bit int
	                if (numValues == 1) {
	                    return file.getUint16(entryOffset + 8, !bigEnd);
	                } else {
	                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);
	                    }
	                    return vals;
	                }

	            case 4: // long, 32 bit int
	                if (numValues == 1) {
	                    return file.getUint32(entryOffset + 8, !bigEnd);
	                } else {
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);
	                    }
	                    return vals;
	                }

	            case 5:    // rational = two long values, first is numerator, second is denominator
	                if (numValues == 1) {
	                    numerator = file.getUint32(valueOffset, !bigEnd);
	                    denominator = file.getUint32(valueOffset+4, !bigEnd);
	                    val = new Number(numerator / denominator);
	                    val.numerator = numerator;
	                    val.denominator = denominator;
	                    return val;
	                } else {
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);
	                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);
	                        vals[n] = new Number(numerator / denominator);
	                        vals[n].numerator = numerator;
	                        vals[n].denominator = denominator;
	                    }
	                    return vals;
	                }

	            case 9: // slong, 32 bit signed int
	                if (numValues == 1) {
	                    return file.getInt32(entryOffset + 8, !bigEnd);
	                } else {
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);
	                    }
	                    return vals;
	                }

	            case 10: // signed rational, two slongs, first is numerator, second is denominator
	                if (numValues == 1) {
	                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);
	                } else {
	                    vals = [];
	                    for (n=0;n<numValues;n++) {
	                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);
	                    }
	                    return vals;
	                }
	        }
	    }

	    function getNextIFDOffset(dataView, dirStart, bigEnd){
	        //the first 2bytes means the number of directory entries contains in this IFD
	        var entries = dataView.getUint16(dirStart, !bigEnd);

	        // After last directory entry, there is a 4bytes of data,
	        // it means an offset to next IFD.
	        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.

	        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long
	    }

	    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){
	        // get the IFD1 offset
	        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);

	        if (!IFD1OffsetPointer) {
	            debug && console.log('IFD1Offset is empty, image thumb not found');
	            return {};
	        }
	        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen
	            debug && console.log('IFD1Offset is outside the bounds of the DataView');
	            return {};
	        }
	        debug && console.log('thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);

	        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd),
	        compressionProp = 'Compression', pIProp = 'PhotometricInterpretation';

	        // EXIF 2.3 specification for JPEG format thumbnail

	        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.

	        if (thumbTags[compressionProp]) {
	            debug && console.log('Thumbnail image found!');

	            switch (thumbTags[compressionProp]) {
	                case 6:
	                    debug && console.log('Thumbnail image format is JPEG');
	                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {
	                    // extract the thumbnail
	                        var tOffset = tiffStart + thumbTags.JpegIFOffset;
	                        var tLength = thumbTags.JpegIFByteCount, blobProp = 'blob';
	                        thumbTags[blobProp] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {
	                            type: 'image/jpeg'
	                        });
	                    }
	                break;

	            case 1:
	                console.log("Thumbnail image format is TIFF, which is not implemented.");
	                break;
	            default:
	                console.log("Unknown thumbnail image format '%s'", thumbTags[compressionProp]);
	            }
	        }
	        else if (thumbTags[pIProp] == 2) {
	            console.log("Thumbnail image format is RGB, which is not implemented.");
	        }
	        return thumbTags;
	    }

	    function getStringFromDB(buffer, start, length) {
	        var outstr = "";
	        for (var n = start; n < start+length; n++) {
	            outstr += String.fromCharCode(buffer.getUint8(n));
	        }
	        return outstr;
	    }

	    function readExifData(file, start) {
	        if (getStringFromDB(file, start, 4) != "Exif") {
	            debug && console.log("Not valid EXIF data! " + getStringFromDB(file, start, 4));
	            return false;
	        }

	        var bigEnd,
	            tags, tag,
	            exifData, gpsData, thumbnailProp = 'thumbnail'
	            tiffOffset = start + 6;

	        // test for TIFF validity and endianness
	        if (file.getUint16(tiffOffset) == 0x4949) {
	            bigEnd = false;
	        } else if (file.getUint16(tiffOffset) == 0x4D4D) {
	            bigEnd = true;
	        } else {
	            debug && console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");
	            return false;
	        }

	        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {
	            debug && console.log("Not valid TIFF data! (no 0x002A)");
	            return false;
	        }

	        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);

	        if (firstIFDOffset < 0x00000008) {
	            debug && console.log("Not valid TIFF data! (First offset less than 8)", file.getUint32(tiffOffset+4, !bigEnd));
	            return false;
	        }

	        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);

	        if (tags.ExifIFDPointer) {
	            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);
	            for (tag in exifData) {
	                switch (tag) {
	                    case "LightSource" :
	                    case "Flash" :
	                    case "MeteringMode" :
	                    case "ExposureProgram" :
	                    case "SensingMethod" :
	                    case "SceneCaptureType" :
	                    case "SceneType" :
	                    case "CustomRendered" :
	                    case "WhiteBalance" :
	                    case "GainControl" :
	                    case "Contrast" :
	                    case "Saturation" :
	                    case "Sharpness" :
	                    case "SubjectDistanceRange" :
	                    case "FileSource" :
	                        exifData[tag] = StringValues[tag][exifData[tag]];
	                        break;

	                    case "ExifVersion" :
	                    case "FlashpixVersion" :
	                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
	                        break;

	                    case "ComponentsConfiguration" :
	                        exifData[tag] =
	                            StringValues.Components[exifData[tag][0]] +
	                            StringValues.Components[exifData[tag][1]] +
	                            StringValues.Components[exifData[tag][2]] +
	                            StringValues.Components[exifData[tag][3]];
	                        break;
	                }
	                tags[tag] = exifData[tag];
	            }
	        }

	        if (tags.GPSInfoIFDPointer) {
	            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);
	            for (tag in gpsData) {
	                switch (tag) {
	                    case "GPSVersionID" :
	                        gpsData[tag] = gpsData[tag][0] +
	                            "." + gpsData[tag][1] +
	                            "." + gpsData[tag][2] +
	                            "." + gpsData[tag][3];
	                        break;
	                }
	                tags[tag] = gpsData[tag];
	            }
	        }

	        // extract thumbnail
	        tags[thumbnailProp] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);

	        return tags;
	    }

	}
} )( window );
;( function(){
	if( window.lyteDomObj ){
		/*	Shorthand Lists for function names used here to reduc the file size
			ibr => isBrowser
			ibo => isBot
			sio => supportsIOBS
			st => stages
			hasES => hasEmptyStage
			hasLs => hasLoadingStage
			hasErS => hasErrorStage
			hasNS => hasNativeStage
			hasSL => hadStartedLoading
			fPS => forEachPictureSource
			el => element
			els => elements
			getSrcTags => getSourceTags
			srcTgs => sourceTags
			obs => observer
			cL => cancelLoading
			hasEvH => hasEventHandlers
			addEvh => addEventHandlers
			rmvEvH => removeEventHandlers
			H => Handler
			addEvL => addEventListenersAtOnce
			sUNat => shouldUseNative
			laN => loadAllNative
			fErEls => filterErrorElements
			setSrcFn => setSourcesFunctions
		*/
		//Sets to true if it is browser
		var ibr = typeof window !== "undefined";
		//Sets to true if it is a bot
		var ibo = ibr && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
		//Sets to true if IntersectionObserver is supported
		var sio = ibr && "IntersectionObserver" in window;
		//Stores different stages values
		var st = ["loading", "loaded", "applied", "entered", "error", "native"];

		var getData = function(el, attribute) {
			return el.getAttribute("data-" + attribute);
		};
		var setData = function(el, attribute, value) {
		    var attrName = "data-" + attribute;

		    if (value === null) {
		    	el.removeAttribute(attrName);
		    	return;
		    }

		    el.setAttribute(attrName, value);
		};

		var getStage = function(el) {
		    return getData(el, "lazyload-stage");
		};
		var setStage = function(el, stage) {
		    return setData(el, "lazyload-stage", stage);
		};
		var resetStage = function(el) {
		    return setStage(el, null);
		};
		//Checks if the element has no stage value
		var hasES = function(el) {
		    return getStage(el) === null;
		};
		//Checks if the element has loading as stage value
		var hasLs = function(el) {
		    return getStage(el) === st[0];
		};
		//Checks if the element has error as stage value
		var hasErS = function(el) {
		    return getStage(el) === st[4];
		};
		//Checks if the element has native as stage value
		var hasNS = function(el) {
		    return getStage(el) === st[5];
		};
		//Checks if the element has started loading
		var hasSL = function(el) {
			return ["loading", "loaded", "applied", "error"].indexOf(getStage(el)) >= 0;
		};

		var addClass = function(el, className) {
		    if (ibr && "classList" in el) {
		    	el.classList.add(className);
		    	return;
		    }

		    el.className += (el.className ? " " : "") + className;
		};
		var removeClass = function(el, className) {
		    if (ibr && "classList" in el) {
		    	el.classList.remove(className);
		    	return;
		    }

		    el.className = el.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
		};

		//Unobserve the given element
		var unobserve = function(el, obj) {
		    if (!obj) {
		    	return;
		    }
		    var obs = obj._obs;
		    if (!obs) {
		    	return;
		    }
		    obs.unobserve(el);
		};

		//get all the source tags from the element
		var getSrcTags = function(parentTag) {
		    var srcTgs = [];

		    for (var i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
			    if (childTag.tagName === "SOURCE") {
			        srcTgs.push(childTag);
			    }
		    }

		    return srcTgs;
		};

		var setAttr = function(el, attrName, value) {
		    if (!value) {
		    	return;
		    }

		    el.setAttribute(attrName, value);
		};
		//Check if the elements already has lazyAttrs property 
		var hasLazyAttrs = function(el) {
		    return !!el.lazyAttrs;
		};
		var elKeys = ["src", "srcset", "sizes", "error"];
		//Add lazyAttrs property to the element
		var addLazyAttrs = function(el) {
		    if (hasLazyAttrs(el)) {
		    	return;
		    }

		    var attrs = {};
		    attrs[elKeys[0]] = el.getAttribute(elKeys[0]);
		    attrs[elKeys[1]] = el.getAttribute(elKeys[1]);
		    attrs[elKeys[2]] = el.getAttribute(elKeys[2]);
		    el.lazyAttrs = attrs;
		};
		//sets the element's property values with values stored in lazyAttrs
		var setLazyAttrs = function(el) {
		    if (!hasLazyAttrs(el)) {
		    	return;
		    }

		    var attrs = el.lazyAttrs;
		    setAttr(el, elKeys[0], attrs[elKeys[0]]);
		    setAttr(el, elKeys[1], attrs[elKeys[1]]);
		    setAttr(el, elKeys[2], attrs[elKeys[2]]);
		};
		//sets the image's property values with values stored in lazyAttrs
		var setImgAttrs = function(el, props) {
		    setAttr(el, elKeys[2], getData(el, props.sizes));
		    setAttr(el, elKeys[1], getData(el, props.srcset));
		    setAttr(el, elKeys[0], getData(el, props.src));
		};
		//Removes the values of image properties
		var resetImgAttrs = function(el) {
		    el.removeAttribute(elKeys[0]);
		    el.removeAttribute(elKeys[1]);
		    el.removeAttribute(elKeys[2]);
		};
		//this function iterates over the source tags present inside the picture element
		var fPS = function(el, fn) {
		    var parent = el.parentNode;

		    if (!parent || parent.tagName !== "PICTURE") {
		    	return;
		    }

		    var srcTgs = getSrcTags(parent);
		    srcTgs.forEach(fn);
		};
		//this object contains the function that should exectue for loading the elements based on its type
		var setSrcFn = {
		    IMG: function(el, props) {
			    fPS(el, function (sourceTag) {
			    	addLazyAttrs(sourceTag);
			    	setImgAttrs(sourceTag, props);
			    });
			    addLazyAttrs(el);
			    setImgAttrs(el, props);
			},
		    IFRAME: function(el, props) {
			    setAttr(el, elKeys[0], getData(el, props.src));
			},
		    VIDEO: function(el, props) {
			    var srcTgs = getSrcTags(el);
			    srcTgs.forEach(function (sourceTag) {
			    	setAttr(sourceTag, elKeys[0], getData(sourceTag, props.src));
			    });
			    setAttr(el, "poster", getData(el, props.poster));
			    setAttr(el, elKeys[0], getData(el, props.src));
			    el.load();
			}
		};

		var setSources = function(el, props) {
		    var srcFn = setSrcFn[el.tagName];

		    if (!srcFn) {
		    	return;
		    }

		    srcFn(el, props);
		};
		var manageLoading = function(el, props, obj) {
		    if(obj){
		    	obj._count.loading += 1;
		    }
		    addClass(el, props.loadingClass);
		    setStage(el, st[0]);

		    if(props.onLoading){
		    	props.onLoading(el, obj);
		    }
		};

		var hasLoadEvent = function(el) {
		    return ["IMG", "IFRAME", "VIDEO"].indexOf(el.tagName) > -1;
		};
		var checkComplete = function(props, obj) {
		    if (obj && (obj._count.loading <= 0) && (obj._count.remaining <= 0) && props.onComplete) {
		      props.onComplete(obj);
		    }
		};
		//check if has event handlers
		var hasEvH = function(el) {
		    return !!el.lazyEvtHndlrs;
		};
		//add event handlers
		var addEvH = function(el, loadfn, errorfn) {
		    if (!hasEvH(el)) {
		    	el.lazyEvtHndlrs = {};
		    }
		    var loadEventName = el.tagName === "VIDEO" ? "loadeddata" : "load";
		    el.addEventListener(loadEventName, loadfn);
		    el.lazyEvtHndlrs[loadEventName] = loadfn;
		    el.addEventListener(elKeys[3], errorfn);
		    el.lazyEvtHndlrs[elKeys[3]] = errorfn;
		};
		//remove event handlers
		var rmvEvH = function(el) {
		    if (!hasEvH(el)) {
		    	return;
		    }
		    var eventListeners = el.lazyEvtHndlrs;
		    for (var eventName in eventListeners) {
		    	var handler = eventListeners[eventName];
		    	el.removeEventListener(eventName, handler);
		    }
		    delete el.lazyEvtHndlrs;
		};
		var doneH = function(el, props, obj) {
		    delete el.lazyTempImg;
		    if(obj && obj._count){
		    	obj._count.loading -= 1;
		    	obj._count.remaining -= 1;
		    }
		    removeClass(el, props.loadingClass);

		    if (props.removeOnComplete) {
		    	unobserve(el, obj);
		    }
		};
		var loadH = function(event, el, props, obj) {
		    var goingNative = hasNS(el);
		    doneH(el, props, obj);
		    addClass(el, props.loadedClass);
		    setStage(el, st[1]);

		    if(props.afterLoading){
		    	props.afterLoading(el, obj);
		    }
		    if (!goingNative) {
		    	checkComplete(props, obj);
		    }
		};
		var errorH = function(event, el, props, obj) {
		    var goingNative = hasNS(el);
		    doneH(el, props, obj);
		    addClass(el, props.errorClass);
		    setStage(el, st[4]);

		    if(props.onError){
		    	props.onError(el, obj);
		    }
		    if (!goingNative) {
		    	checkComplete(props, obj);
		    }
		};
		//adds both success and error event listeners
		var addEvL = function(el, props, obj) {
		    var elToListenTo = el.lazyTempImg || el;

		    if (hasEvH(elToListenTo)) {
		    	// This happens when loading is retried twice
		    	return;
		    }

		    var loadfn = function(event) {
		    	loadH(event, el, props, obj);
		    	rmvEvH(elToListenTo);
		    };
		    var errorfn = function(event) {
		    	errorH(event, el, props, obj);
		    	rmvEvH(elToListenTo);
		    };

		    addEvH(elToListenTo, loadfn, errorfn);
		};

		var load = function(el, props, obj) {
		    if (hasLoadEvent(el)) {
		    	addEvL(el, props, obj);
			    setSources(el, props);
			    manageLoading(el, props, obj);
		    } else {
		    	el.lazyTempImg = document.createElement("IMG");
			    addEvL(el, props, obj);

			    var bg1xValue = getData(el, props.bg);
			    var bgHiDpiValue = getData(el, props.hidpi);
			    var bgDataValue = (ibr && window.devicePixelRatio > 1 && bgHiDpiValue) ? bgHiDpiValue : bg1xValue;
			    
			    if (bgDataValue) {
			    	el.style.backgroundImage = "url(\"".concat(bgDataValue, "\")");
				    el.lazyTempImg.setAttribute(elKeys[0], bgDataValue);
				    manageLoading(el, props, obj);
			    }
			    
			    bg1xValue = getData(el, props.bgMulti);
			    bgHiDpiValue = getData(el, props.bgMultiHidpi);
			    bgDataValue = (ibr && window.devicePixelRatio > 1 && bgHiDpiValue) ? bgHiDpiValue : bg1xValue;

			    if (bgDataValue) {
			    	el.style.backgroundImage = bgDataValue;
			    	addClass(el, props.appliedClass);
				    setStage(el, st[2]);

				    if (props.removeOnComplete) {
				    	// Unobserve now because we can't do it on load
				    	unobserve(el, props);
				    }

				    if(props.afterApply){
				    	props.afterApply(el, obj);
				    }
			    }
			    //For elements which dont have load events like div, span
			    //enteredClass will be added in browsers that dont support IntersectionObserver
			    else{
			    	if(!(el.classList.contains(props.enteredClass))){
			    		// console.log("ELEMENTS WITHOUT LOAD EVENTS");
			    		addClass(el, props.enteredClass);
			    	}
			    }
		  	}
		};

		//cancel the loading of elements
		var cL = function(el, entry, props, obj) {
		    if (!props.cancelOnExit) {
		    	return;
		    }
		    if (!hasLs(el)) {
		    	return;
		    }
		    if (el.tagName !== "IMG") {
		    	return; //Works only on images
		    }

		    rmvEvH(el);
		    fPS(el, function (sourceTag) {
		    	resetImgAttrs(sourceTag);
		    	setLazyAttrs(sourceTag);
		    });
		    resetImgAttrs(el);
		    setLazyAttrs(el);
		    removeClass(el, props.loadingClass);
		    if(obj && obj._count){
		    	obj._count.loading -= 1;
		    }
		    resetStage(el);

		    if(props.onCancel){
		    	props.onCancel(el, entry, obj);
		    }
		};

		var onEnter = function(el, entry, props, obj) {
		    setStage(el, st[3]);
		    addClass(el, props.enteredClass);
		    removeClass(el, props.exitedClass);
		    if (props.removeOnEnter) {
		    	unobserve(el, obj);
		    }

		    if(props.onEnter){
		    	props.onEnter(el, entry, obj);
		    }
		    if (hasSL(el)) {
		    	return; //Prevent loading it again
		    }
		    load(el, props, obj);
		};
		var onExit = function(el, entry, props, obj) {
		    if (hasES(el)) {
		    	return; //Ignore the first pass, at landing
		    }
		    addClass(el, props.exitedClass);
		    cL(el, entry, props, obj);

		    if(props.onExit){
		    	props.onExit(el, entry, obj);
		    }
		};
		//check for usage of native lazyloading
		var sUNat = function(props) {
		    return props.useNative && "loading" in HTMLImageElement.prototype;
		};
		//load all elements using native lazyloading
		var laN = function(els, props, obj) {
		    els.forEach(function (el) {
		    	if (["IMG", "IFRAME"].indexOf(el.tagName) === -1) {
		        	return;
		    	}

		    	el.setAttribute("loading", "lazy");
		    	addEvL(el, props, obj);
			    setSources(el, props);
			    setStage(el, st[5]);
		    });
		    if(obj && obj._count){
		    	obj._count.remaining = 0;
		    }
		};
		// Initialize and set the observer and other properties
		var initialize = function(props, obj) {
			obj._count = {'loading' : 0};
		    if (!sio || sUNat(props)) {
		    	return;
		    }
		    var obsSets = {
		    	root: props.container === document ? null : props.container,
		    	rootMargin: props.thresholds || props.threshold + "px"
		    };
		    obj._obs = new IntersectionObserver(function (entries) {
		    	entries.forEach(function (entry) {
			    	if(entry.isIntersecting || entry.intersectionRatio > 0) {
			    		return onEnter(entry.target, entry, props, obj)
			    	} else {
			    		return onExit(entry.target, entry, props, obj);
			    	}
			    });
		    }, obsSets);
		};

		var getAllElements = function(props) {
		    return props.container.querySelectorAll(props.selector);
		};

		//filter error elements
		var fErEls = function(els) {
		    return Array.from(els).filter(hasErS);
		};
		var getElementsToLoad = function(els, props) {
			if(els){
				return Array.from(els).filter(hasES);
			}
			return Array.from(getAllElements(props)).filter(hasES);
		};

		var LyteLazyload = function(userProps, els) {
			var data = userProps ? userProps : {};

			data.selector = data.selector ? data.selector : ".lyteLazyload";
		    data.container = data.container ? $L(data.container)[0] : (ibo || ibr ? document : null);
		    data.threshold = data.threshold ? data.threshold : 300;
		    data.thresholds = data.thresholds ? data.thresholds : null;
		    data.src = data.src ? data.src : "src";
		    data.srcset = data.srcset ? data.srcset : "srcset";
		    data.sizes = data.sizes ? data.sizes : "sizes";
		    data.bg = data.bg ? data.bg : "bg";
		    data.hidpi = data.hidpi ? data.hidpi : "bg-hidpi";
		    data.bgMulti = data.bgMulti ? data.bgMulti : "bg-multi";
		    data.bgMultiHidpi = data.bgMultiHidpi ? data.bgMultiHidpi : "bg-multi-hidpi";
		    data.poster = data.poster ? data.poster : "poster";
		    data.appliedClass = data.appliedClass ? data.appliedClass : "lyteLazyApplied";
		    data.loadingClass = data.loadingClass ? data.loadingClass : "lyteLazyLoading";
		    data.loadedClass = data.loadedClass ? data.loadedClass : "lyteLazyLoaded";
		    data.errorClass = data.errorClass ? data.errorClass : "lyteLazyError";
		    data.enteredClass = data.enteredClass ? data.enteredClass : "lyteLazyEntered";
		    data.exitedClass = data.exitedClass ? data.exitedClass : "lyteLazyExited";
		    data.removeOnComplete = (data.removeOnComplete === undefined) ? true : data.removeOnComplete;
		    data.removeOnEnter = (data.removeOnEnter === true) ? data.removeOnEnter : false;
		    data.cancelOnExit = (data.cancelOnExit === undefined) ? true : data.cancelOnExit;
		    // data.onEnter = data.onEnter ? data.onEnter : null,
		    // data.onExit = data.onExit ? data.onExit : null,
		    // data.afterApply = data.afterApply ? data.afterApply : null,
		    // data.onLoading = data.onLoading ? data.onLoading : null,
		    // data.afterLoading = data.afterLoading ? data.afterLoading : null,
		    // data.onError = data.onError ? data.onError : null,
		    // data.onComplete = data.onComplete ? data.onComplete : null,
		    // data.onCancel = data.onCancel ? data.onCancel : null,
		    data.useNative = (data.useNative === true)? data.useNative : false;

		    this._props = data;
		    initialize(data, this);
		    if (ibr) {
		    	window.addEventListener("online", function () {
			    	// retryLazyLoad(props, this);
			    	var errorElements = fErEls(getAllElements(data));
				    errorElements.forEach(function (el) {
				    	removeClass(el, data.errorClass);
				    	resetStage(el);
				    });
				    this.update();
			    }.bind(this));
		    }
		    this.update(els);
		};

		LyteLazyload.prototype = {
		    update: function(els) {
		    	var props = this._props;
		    	var elsToLoad = getElementsToLoad(els, props);
		    	this._count.remaining = elsToLoad.length;

		    	if (ibo || !sio) {
		        	this.loadAll(elsToLoad);
		        	return;
		    	}

		    	if (sUNat(props)) {
		        	laN(elsToLoad, props, this);
		        	return;
		    	}

		    	var obs = this._obs;
		    	obs.disconnect();
		    	elsToLoad.forEach(function (el) {
			    	obs.observe(el);
				});
		    },
		    destroy: function() {
		    	// Observer
		    	if (this._obs) {
		        	this._obs.disconnect();
		    	} 

		    	// Clean custom elKeys from els
		    	getAllElements(this._props).forEach(function (el) {
		        	delete el.lazyAttrs;
		    	});

		    	// Delete all internal props
		    	delete this._obs;
		    	delete this._props;
		    	delete this._count;
		    },
		    loadAll: function(els) {
		      var _this = this;

		      var props = this._props;
		      var elsToLoad = getElementsToLoad(els, props);
		      elsToLoad.forEach(function (el) {
		        unobserve(el, _this);
		        load(el, props, _this);
		      });
		    }
		};

		// LyteLazyload.load = function (el, userProps) {
		//     var props = getAllProperties(userProps);
		//     // var props = getExtendedSettings(userProps);
		//     load(el, props);
		// };

		// LyteLazyload.resetStage = function (el) {
		//     resetStage(el);
		// };

		$L.lazyload = function(props, els, misc){
			if(typeof props === "string"){
				if(els){
					if(props === "destroy"){
						if(Array.isArray(els)){
							els.forEach(function(obj){
								if(obj instanceof LyteLazyload){
									obj.destroy();
								}
							})
						}
						else if(els instanceof LyteLazyload){
							els.destroy();
						}
					}
					else if(props === "update"){
						if(Array.isArray(els)){
							els.forEach(function(obj){
								if(obj instanceof LyteLazyload){
									obj.update(misc);
								}
							})
						}
						else if(els instanceof LyteLazyload){
							els.update(misc);
						}
					}
					else if(props === "loadAll"){
						if(Array.isArray(els)){
							els.forEach(function(obj){
								if(obj instanceof LyteLazyload){
									obj.loadAll(misc);
								}
							})
						}
						else if(els instanceof LyteLazyload){
							els.loadAll(misc);
						}
					}
				}
				return;
			}
			return new LyteLazyload(props, els);
		};

		$L.lazyload.LyteLazyload = LyteLazyload;
	}
} )( window );

/*
 *  Mainly wrote for downloading lyte-shape rendered shapes as image
 *  For SVG  ---> Finished but not perfectly( now svgs are converted to images. If svg has postions in its css it will make problem )
 *  For Iframes( not yet handled )

 $L.screenGrab({ 
 	getDimension : function(){
	    return {
	        width : width,
	        height : height
	    }
	}, 
	dom : $0, 
	attributes : ['viewbox', 'viewBox'], 
	attributes_replace : ['0 0 ' + width + ' ' + height,'0 0 ' + width + ' ' + height ], 
	styles : ['width','height'], 
	styles_replace : [ width + 'px', height + 'px']
}).then( function( arg ){
	document.body.appendChild( arg.image )
})
*/


;( function( window ){

	var request_mapping = {};

	function screenGrab( options, _window ){

		var defaultOptions = {
			scale : _window.devicePixelRatio,
			dom : _window.document.body,
			revokeUrl : true,
			style : "",
			processing : {},
			fontFaceString : '',
			externalImport : true,
			stylesToCheck : [ 'counter-increment', 'counter-reset' ],
			validate_request : ( font, is_font ) =>{
				if( !is_font ){
					return true;
				}
				return font.indexOf( '.woff2' ) != -1;
			}
		},
		options = this.options = $L.extend( true, defaultOptions, options || {} ),
		dom,
		arr;

		dom = options.dom = $L( options.dom, _window.document ).get( 0 );

		if( !dom ){
			return this.console( 'error', 'Provide valid dom element' );
		}

		arr = dom.__lytescreengrab;

		if( !arr ){
			arr = dom.__lytescreengrab = _window.Array();
		} 
		arr.push( this );

		return new _window.Promise( ( resolve, reject ) => {
			options.resolve = resolve;
			options.reject = reject;

			var arr = _window.Array(),
			font_family_array = _window.Array(),
			font_family = _window.Array();

			arr.push( this.convertUrls( dom, font_family ) );

			arr.push( this.downloadFonts( font_family ) );

			this.promiseAll( arr ).then( this.processGrabbing.bind( this, options ) );
		});

	};
	
	screenGrab.prototype = {

		promiseAll : function( arr ){
			var len = -1,
			_length = arr.length;

			return new Promise( ( res ) => {
				var fn = () => {
					if( ++len == _length ){
						res();
					}
				};
				arr.forEach( ( item ) => {
					item.then( fn, fn );
				});

				fn();
			})
		},

		destroy : function(){
			var options = this.options,
			keys = this.window().Object.keys( options );
			
			keys.forEach( item =>{
				delete options[ item ];
			}); 
		},

		removeInstance : function(){
			var dom = this.options.dom,
			arr = dom.__lytescreengrab,
			index = this.index( arr, this );
			if( index != -1 ){
				arr.splice( index, 1 );
			}
			this.destroy();
		},

		document : function(){
			return this.options.dom.ownerDocument;
		},

		window : function(){
			return this.document().defaultView;
		},

		console : function( type, message ){
			this.window().console[ type ]( message );
		},

		processGrabbing : function( options ){
			if( options.dom ){
				this.constructHTML( options.dom, options ).then( ( newdom ) => {
					this.convertToCanvas( newdom, options );
				}, () => {
					this.removeInstance();
					options.reject( 'stopped at dom processing' );
				});
			}
		},

		get : function( dom, selector ){
			var arr = this.window().Array.from( dom.querySelectorAll( selector ) );
			if( dom.tagName.toLowerCase() == selector ){
				arr.push( dom );
			}
			return arr;
		},

		pushIfNot : function( arr, value ){
			if( this.index( arr, value ) == -1 ){
				arr.push( value );
			}
		},

		pushIntoArray : function( arr, value ){
			if( value.constructor != Array ){
				value = [ value ];
			}
			arr.push.apply( arr, value );
		},

		index : function( arr, value ){
			return arr.indexOf( value );
		},

		downloadFonts : function( font_family ){
			var _window = this.window(),
			promiseArr = _window.Array();

			_window.Array.from( this.document().styleSheets ).forEach( ( item ) => {
				var rules;
				try{
					rules = item.rules;
				} catch( e ){
					// this.console( 'log', 'external import present ' + item.href );
					if( this.options.externalImport ){
						promiseArr.push( this.download_rules( item.href, font_family ) );
					}
					return;
				}
				this.construct_rules( rules, promiseArr, font_family );
			});

			return this.promiseAll( promiseArr );
		},

		single_font : function( rule, font_family ){
			var _window = this.window(),
			p_array = _window.Array(),
			style = rule.style,
			src = style.src || '',
			matched = src.match( /https?:\/\/[^ \'|\"\)]+/g ),
			__options = this.options;

			if( !matched ){
				matched = ( src.match( /url\([^\)]+/g ) || [] ).map( ( item ) => {
					return item.replace( /"/g, '' ).replace( /url\(/g, '' );
				});
			}

			// if( this.index( font_family, style.fontFamily ) == -1 ){
			// 	return new Promise( ( res ) => {
			// 		res();
			// 	});
			// }

			matched.forEach( ( url ) => {
				if( /^data\:/.test( url ) ){
					return src;
				}
				p_array.push( this.makeFontRequest( url, true ) );
			});

			return this.promiseAll( p_array ).then( () => {
				var options = _window.Array.from( style );
				__options.fontFaceString += '@font-face {\n';

				options.forEach( ( item ) => {
					var value = style.getPropertyValue( item ),
					map = request_mapping;
					if( item == 'src' ){
						matched.forEach( ( url ) => {
							if( map[ url ] ){
								value = value.replace( new _window.RegExp( url, 'g' ), map[ url ] );
							}
						});
					}
					__options.fontFaceString += ( item + ':' + value + ';\n' );
				});

				__options.fontFaceString += '}\n';
			});
		},

		download_rules : function( href, font_family ){ 
			var _window = this.window();
			return new _window.Promise( ( res, rej ) => {
				if( request_mapping[ href ] ){
					return res();
				}
				request_mapping[ href ] = true;

				var success = ( evt ) => {
					var _document = this.document(),
					style = _document.createElement( 'style' );
					style.innerHTML = evt.target.response;
					_document.body.appendChild( style );

					_window.requestAnimationFrame( () => {
						var arr = _window.Array();
						this.construct_rules( style.sheet.rules, arr, font_family );
						style.remove();
						this.promiseAll( arr ).then( res );
					});
				}, 
				failure = ( evt ) => {
					this.console( 'warn', 'Error in reading response at download_rules processing ' + href );
					rej();
				};

				this.ajax( href, 'text', success, failure );
			});
		},

		construct_rules : function( rules, promiseArr, font_family ){
			var _window = this.window();
			_window.Array.from( rules ).forEach( ( rule ) => {
				if( rule.constructor.name == 'CSSFontFaceRule' ){
					promiseArr.push( this.single_font( rule, font_family ) );
				} else if( rule.constructor.name == 'CSSImportRule' ){
					promiseArr.push( this.download_rules( rule.href, font_family ) );
				}
			});
		},

		makeFontRequest : function( url, is_font ){
			var _window = this.window(),
			options = this.options,
			urlMap = request_mapping,
			processing = options.processing;

			return new _window.Promise( ( res, rej ) => {

				if( urlMap[ url ] || processing[ url ] || ( options.validate_request && options.validate_request( url, is_font ) == false ) ){
					return res();
				}

				processing[ url ] = 'in_progress';

				var success = ( evt ) => {
					var response = evt.target.response;

					if( response ){
						var file = new _window.FileReader();

						file.addEventListener( 'loadend', () => {
							processing[ url ] = 'success';
							urlMap[ url ] = file.result;
							res();
						});
						file.addEventListener( 'error', () => {
							delete processing[ url ];
							this.console( 'warn', 'Error at reading response at font-face processing ' + url );
							rej();
						});

						file.readAsDataURL( response );
					} else {
						delete processing[ url ];
						this.console( 'warn', 'Empty response at font-face processing ' + url );
						rej();
					}
				},
				failure = () => {
					delete processing[ url ];
					this.console( 'warn', 'error at font-face processing ' + url );
					rej();
				}; 

				this.ajax( url, 'blob', success, failure );
			});
		},

		ajax : function( url, type, success, failure ){

			var _window = this.window(),
			xhr = new _window.XMLHttpRequest();
			xhr.open( 'GET', url );
			xhr.responseType = type;
			xhr.addEventListener( 'loadend', success );
			xhr.addEventListener( 'error', failure );
			xhr.send();
		},

		convertUrls : function( dom, font_family, ignore ){
			var _window = this.window();
			try{
				var image = this.get( dom, 'img' ),
				all = this.get( dom, '*' ),
				use = this.get( dom, 'use' ),
				getStyle = _window.getComputedStyle,
				imageArr = _window.Array(),
				promiseArr = _window.Array(),
				tag = dom.tagName.toLowerCase();
				all.push( dom ),
				svg_image = this.get( dom, 'image' );

				if( tag == 'img' ){
					image.push( dom );
				}

				if( tag  == 'image' ){
					svg_image.push( dom );
				}

				all.forEach( ( item ) => {
					var style = getStyle( item ),
					before = getStyle( item, ':before' ),
					after = getStyle( item, ':after' ),
					isBefore = this.isPseudo( before ),
					isAfter = this.isPseudo( after );

					item._screenstyle = style;
					item._screenBeforeStyle = before;
					item._screenAfterStyle = after;
					item._screenoffsetparent = !item.offsetParent && item != this.document().body;
					item._scrollLeft = item.scrollLeft;
					item._scrollTop = item.scrollTop;

					 if( style.display == "none" || item._screenoffsetparent || ignore ){
		               return false;
		             }

		             if(  style.backgroundImage ){
		             	this.pushIfNot( imageArr, style.backgroundImage );
		             }
		             if( before.backgroundImage ){
		             	this.pushIfNot( imageArr, before.backgroundImage );
		             }
		             if( after.backgroundImage ){
		             	this.pushIfNot( imageArr, after.backgroundImage );
		             }

		             this.pushIfNot( font_family, style.fontFamily );

		             if( isBefore ){
		             	this.pushIfNot( font_family, before.fontFamily );
		             }

		             if( isAfter ){
		             	this.pushIfNot( font_family, after.fontFamily );
		             }

				});

				if( !ignore ){
					image.forEach( ( item ) => {
						if( item._screenstyle.display == 'none' || item._screenoffsetparent ){
							return;
						}
						promiseArr.push( this.download_images( item ) );
					} );

					svg_image.forEach( ( item ) => {
						// if( item._screenstyle.display == 'none' ){
						// 	return;
						// }
						promiseArr.push( this.download_images( item ) );
					});

					imageArr.forEach( ( item ) => {
						if( /^none$/i.test( item ) ){
							return;
						}
						this.pushIntoArray( promiseArr, this.parseBgUrl( item ) );
					});

					use.forEach( ( item ) =>{
						this.pushIntoArray( promiseArr, this.useTagDownload( item ) );
					} )
				}

			} catch( e ){
				this.console( 'warn', 'catched error at image url processing ' + e.message );
			}

			return this.promiseAll( promiseArr );
		},

		download_images : function( item ){
			var src,
			tagName = item.tagName;
			if( item.complete || /image/i.test( tagName ) ){
				var _window = this.window()
				return new _window.Promise( ( res ) =>{
					if( /img/i.test( tagName ) ){
						src = item.src;
						try{
							request_mapping[ src ] = this.simple_canvas_draw( item );
							return res();
						}catch( e ){
						}
					} else {
						src = item.href || '';
						src = src.baseVal || src;
					}
					this.makeFontRequest( src ).then( res, res );
				})
			} 

			return this.makeFontRequest( item.src );
		},

		parseBgUrl : function( str ){
			var arr = this.window().Array();

			if( /url\("(.+?)"\)/.test( str ) ){
				arr.push( this.makeFontRequest( str.match( /url\("(.+?)"\)/ )[ 1 ] ) );
				str = str.replace( /url\("(.+?)"\)/ , '' );
				if( str ){
					this.pushIntoArray( arr, this.parseBgUrl( str ) );
				}
			}

			return arr;
		},

		constructHTML : function( node, options ){

		      var __options = options ||this.options;
		      if( !__options.dom ){
		      	return this.promiseAll();
		      }
		      var _window = this.window(),
		      _Array = _window.Array,
		      promiseArr = _Array(),
		      stringArr = _Array(),
		      children = options ? [ node ] : _Array.from( node.childNodes ),
		      len = 0;

		      children.forEach( ( item, index ) => {
		      	  try{
		      	  	 var tagName = ( item.tagName || '' ).toLowerCase(),
		      	  	 originalTagName = tagName,
		     	 	 _attributes = $L.extend( true, [], ( options || {} ).attributes || [] ),
		      		 _attributes_replace = $L.extend( true, [], ( options || {} ).attributes_replace || [] ),
		      		 _styles = $L.extend( true, [], ( options || {} ).styles || [] ),
		      		 _styles_replace = $L.extend( true, [], ( options || {} ).styles_replace || [] );

			          if( /^(template|style|script|link|head)$/i.test( tagName ) || [ "[object Comment]" ].indexOf( item.toString() ) != -1 ){
			             return;
			          } else if( /^(body|iframe)$/i.test( tagName ) || ( item.hasAttribute && item.hasAttribute( 'lyte-rendered' ) ) ){
			             tagName = "div";
			          }

			          if( tagName ){
			             var style = item._screenstyle,
			             psuedoBefore = item._screenBeforeStyle,
			             psuedoAfter = item._screenAfterStyle,
			             sleft = item._scrollLeft,
			             stop = item._scrollTop,
			             randomClass = ( this.isPseudo( psuedoBefore ) || this.isPseudo( psuedoAfter ) ) ? this.randomClass() : "",
			             offset = item._screenoffsetparent;

			             delete item._screenstyle;
			             delete item._screenBeforeStyle;
			             delete item._screenAfterStyle;
			             delete item._screenoffsetparent;

			             if( style && style.display == "none" ){
			               return;
			             }

			             if( offset ){
			             	var svg = $L( item ).closest( 'svg' ).get( 0 ),
			             	foreignObject = $L( item ).closest( 'foreignObject' ).get( 0 );
			             	if( style.position == 'fixed' ){
			             		svg = true;
			             	}
			             	if( ( foreignObject && tagName != 'foreignobject' ) || !svg ){
			             		return;
			             	}
			             }

			             if( tagName == 'svg' ){
			             	promiseArr.push( new _window.Promise( function( len, stringArr, res ){
			             		this.constructHTML( item ).then( function( len, stringArr, string ){

				     				window.requestAnimationFrame( () => {
				     					string = string.trim();
				     					var urlEncode = _window.URL || _window.webkitURL || _window,
				     					url =  "data:image/svg+xml;charset=utf-8," + _window.encodeURIComponent( new XMLSerializer().serializeToString( this.convertStringToDom( '<' + tagName + this.getAttributes( item, _attributes, _attributes_replace ) +' class =\'' + randomClass + '\'>' + string + '</' + tagName + '>' ) ) ),
				     					img = new Image();

				     					__options.useTag = '';

				     					img.onerror = img.onload = () => {
				     						stringArr[ len ] = ( '<img src=' + url + ' style = \'' + this.getStyle( style, _styles, _styles_replace )	 + '\'/>' );
				     						res();	
				     					};
				     					img.src = url;
				     				});
				             	}.bind( this, len, stringArr ) );

			             	}.bind( this, len, stringArr ) ) );
			             } else if( tagName == 'canvas' ){
			             	stringArr[ len ] = ( '<img' + this.getAttributes( item, _attributes, _attributes_replace ) + ' src=' + item.toDataURL() + ' style = \'' + this.getStyle( style, _styles, _styles_replace )	 + '\'/>' );
			             } else if( /^(video)$/i.test( tagName ) ){
			             	stringArr[ len ] = ( '<img src=' + this.simple_canvas_draw( item, style ) + ' style = \'' + this.getStyle( style, _styles, _styles_replace )	 + '\'/>' );
			             } else if( tagName == 'img' ){
			             	stringArr[ len ] = ( '<img src=' + ( request_mapping[ item.src ] || item.src ) + ' style = \'' + this.getStyle( style, _styles, _styles_replace )	 + '\'/>' );
			             } else if( tagName == 'use' ){
			             	var href = item.href.baseVal;

			             	if( /^#/.test( href ) ){
			             		var elem = document.querySelector( href ),
			             		random = this.randomClass();

			             		_attributes.push( 'xlink:href' );

			             		if( elem ){
				             		promiseArr.push( new _window.Promise( function( len, res, rej ) {
				             			this.constructHTML( elem ).then( ( string ) => {
				             				var inner_tag = elem.tagName.toLowerCase();
				             				_attributes_replace.push( '#' + random );
				             				stringArr[ len ] = '<' + tagName + this.getAttributes( item, _attributes, _attributes_replace ) + '>' + ( '<' + inner_tag + this.getAttributes( elem, 'id', random ) +' class =\'' + randomClass + '\'>' + string + '</' + inner_tag + '>' ) + '</' + tagName + '>';
				             				res();
				             			});
				             		}.bind( this, len ) ) );
				             	}
			             	} else { 
				             	_attributes_replace.push( '#' + item.__screengrabid );
			             		stringArr[ len ] = '<' + tagName + this.getAttributes( item, _attributes, _attributes_replace ) + '>' + request_mapping[ href ] + '</' + tagName + '>';
			             		delete item.__screengrabid;
			             	}
			             } else if( originalTagName == 'iframe' ){
			             	var lent = len;
			             	promiseArr.push( new _window.Promise( ( res ) =>{
			             		try{

			             			_styles.push( 'display' );
			             			_styles_replace.push( 'inline-block' );

			             			var itemDoc = item.contentDocument,
			             			dom = itemDoc.body,
			             			dsLeft = itemDoc.documentElement.scrollLeft,
			             			dsTop = itemDoc.documentElement.scrollTop,
			             			dsStyle = item.contentWindow.getComputedStyle( dom ),
			             			str = '<div style=\"' + this.getStyle( style, _styles, _styles_replace ).replace( /\"/g, '&quot;' ) + ';overflow:hidden;\">';

				             		$L.screenGrab( {
				             			dom
				             		} ).then( ( arg ) =>{
				             			stringArr[ lent ] = ( str + this.getScrollWrapper( '<img' + this.getAttributes( arg.image ) + ' src=' + arg.image.src + '/>', dsLeft, dsTop ) + '</div>' );
				             			res();
				             		}, res );
				             	} catch( e ){
				             		stringArr[ lent ] = str + '</div>';
				             		res();
				             	}
			             	} ) );
			             } else {
		             	 	promiseArr.push( this.constructHTML( item ).then( function( lent, stringArr, string ){
		             	 		var _str, 
		             	 		_style = this.getStyle( style, _styles, _styles_replace );
		             	 			
		             	 		_attributes.push( 'class' );
		             	 		_attributes_replace.push( randomClass || '' );

		             	 		_str = '<' + tagName + this.getAttributes( item, _attributes, _attributes_replace );

		             	 		if( _style ){
		             	 			_str += ( ' style =\"' + _style.replace( /\"/g, '&quot;' ) + '\"' );
		             	 		}	

		             	 		if( /foreignobject/i.test( tagName ) ){
		             	 			string += ( '<style>' + __options.style + '</style>' );
		             	 			string += ( '<style>' + __options.fontFaceString + '</style>' );
		             	 		}

		             	 		_str +=  ( '>' + this.getScrollWrapper( string, sleft, stop ) + '</' + tagName + '>' );

			                	return stringArr[ lent ] = _str; 
			             	}.bind( this, len, stringArr ) ) );

				             __options.style += ( this.constructPsuedo( psuedoBefore, randomClass, 'before' ) + this.constructPsuedo( psuedoAfter, randomClass, 'after' ) );
				             if( options ){
				            	options.background = options.background || style.getPropertyValue( 'background-color' );
				             }
				         }
			           } else {
			              stringArr[ len ] = item.nodeValue.replace( /</g, '&lt;' ).replace( />/g, '&gt;' );
			           }

			           len++;
		      	  } catch( e ){
		      	  	this.console( 'warn', "catched error at html construction " + e.message );
		      	  }
		      });

		      return this.promiseAll( promiseArr ).then( () => {
		      	if( options ){
		      		if( options.style ){
		        		stringArr.push( '<style>' + options.style + '</style>' );
		        	}
		        	if( options.fontFaceString ){
		        		stringArr.push( '<style>' + options.fontFaceString + '</style>' );
		        	}
		      	}
		        return stringArr.join( '' )
		      });
		},

		useTagDownload : function( item ){
			var href = item.href.baseVal,
			_window = this.window();

			return new _window.Promise( ( res ) => {

				if( /^#/.test( href ) ){
					return res();
				}

				var __options = this.options,
				rej = () =>{
					request_mapping[ href ] = '';
					res();
				},
				success = ( evt ) =>{
					var response = evt.target.response,
					dom = this.convertStringToDom( response ),
					random = this.randomClass();

					item.__screengrabid = random;

					this.convertUrls( dom, [] ).then( () =>{
						this.constructHTML( dom ).then( ( string ) => {
							var tagName = dom.tagName.toLowerCase();
							request_mapping[ href ] = '<' + tagName + this.getAttributes( item, 'id', random ) + '>' + string + '</' + tagName + '>';
							res();
						} );
					}, rej);
				};
				
				this.ajax( href, 'text', success, rej ); 
			} );
		},

		getScrollWrapper : function( string, sleft, stop ){
			if( sleft || stop ){
				string = '<div style=\'display:inherit;margin-left:-' + sleft + 'px;margin-top:-' + stop + 'px;\'>' + string + '</div>';
			}
			return string;
		},

		simple_canvas_draw : function( item, __style ){
			var canvas = this.document().createElement( 'canvas' ),
         	ctx = canvas.getContext( '2d' ),
         	style = item._screenstyle || __style;

         	canvas.width = item.naturalWidth || parseFloat( style.width );
         	canvas.height = item.naturalHeight || parseFloat( style.height );
         	ctx.fillRect( 0, 0, canvas.width, canvas.height );

         	$L( canvas ).css( {
         		width : style.width,
         		height : style.height
         	});

			ctx.drawImage( item, 0, 0 );
			try{
				return canvas.toDataURL();
			} catch( e ){
				this.console( 'warn', e.message );
				return "";
			}
		},

		getStyle : function( style, replace, replace_value ){

			if( !style ){
				return '';
			}

			var len = style.length,
			str = '',
			cons = replace ? replace.constructor : void 0;

			for( var i = 0; i < len; i++ ){
				var name = style[ i ], value = style[ name ];

				if( name == 'background-image' && !/^none$/i.test( value ) ){
					value = this.constructBGUrl( value );
				}

				if( cons == String ){
					if( name == replace ){
						value = replace_value;
					}
				} else if( cons == Array ){
					var indx = replace.indexOf( name );
					if( indx != -1 ){
						value = replace_value[ indx ];
					}
				}

				str += ( name + ':' + value + ';' );
			}

			( this.options.stylesToCheck || [] ).forEach( ( item ) => {
				str += ( item + ':' + style.getPropertyValue( item ) + ';' );
			} )

			return str;
		},

		constructBGUrl : function( value ){
			var map = request_mapping;

			if( /url\("(.+?)"\)/.test( value ) ){
				var match = value.match( /url\("(.+?)"\)/ )[ 1 ],
				index = value.indexOf( match );
				return value.slice( 0, index ) + ( map[ match ] || match ) + this.constructBGUrl( value.slice( index + match.length ) );
			}
			return value;
		},

		getAttributes : function( item, replace, replace_value ){
			var attr = item.attributes,
			len = attr.length,
			str = '',
			ignore_empty = [ 'viewBox' ],
			cons = replace ? replace.constructor : void 0;

			if( len == 0 && replace ){
				len = replace.length;
				attr = replace;
			}

			for( var i = 0; i < len; i++ ){
				var name = attr[ i ],
				attrName = name.nodeName || name,
				attrValue = name.nodeValue;

				if( /^(style)$/i.test( attrName ) ){
					continue;
				} else if( attrName == 'src' ){
					attrValue = request_mapping[ item.src ] || attrValue;
				} else if( attrName == 'href' ){
					var href = item.href;
					if( href.baseVal ){
						href = href.baseVal;
					}

					attrValue = request_mapping[ href ] || attrValue;
				}
				if( !attrValue ){
					if( this.index( ignore_empty, attrName ) != -1 ){
						continue;
					}
				}
				if( cons == String ){
					if( attrName == replace ){
						attrValue = replace_value;
					}
				} else if( cons == Array ){
					var indx = replace.indexOf( attrName );
					if( indx != -1 ){
						attrValue = replace_value[ indx ];
					}
				}

				str += ( ' ' + attrName + '=\'' + attrValue.replace( /\"|\'/g, '&quot;' ) + '\'' );
			}
			return str;
		},

		convertToCanvas : function( string, options ){
			try{
				var _window = this.window(),
				_document = this.document(),
				canvas = $L( _document.createElement('canvas') ).addClass( 'LyteScreenGrabberCanvas' ).get( 0 ),
				ctx = canvas.getContext( '2d' ),
				dom = options.dom,
				scale = options.scale,
				bcr = options.bcr = dom.getBoundingClientRect();

				if( options.getDimension ){
					bcr = options.getDimension.call( this, bcr, dom ) || bcr;
				}

				var data   = '<svg width=\'' + bcr.width + '\' height=\'' + bcr.height + '\'>' +
			               '<foreignObject x = \'0\' y = \'0\' width=\'100%\' height=\'100%\' externalResourcesRequired = \'true\'>' +
			                 	string +
			               '</foreignObject>' +
			             '</svg>',
			    urlEncode = _window.URL || _window.webkitURL || _window,
			    svg = this.callBeforeCallback( this.convertStringToDom( data ), options ),
	    		img = new _window.Image(),
				// url = urlEncode.createObjectURL( new _window.Blob( [ data ], { type: "image/svg+xml" } ) );
				url = "data:image/svg+xml;charset=utf-8," + _window.encodeURIComponent( new XMLSerializer().serializeToString( svg ) ),

				fn = () => {
					img.onload = () => {
						canvas.width = bcr.width * scale;
						canvas.height = bcr.height * scale;
						ctx.fillStyle = options.background;
						ctx.fillRect( 0, 0, canvas.width, canvas.height );
						$L( canvas ).css( {
							width : bcr.width,
							height : bcr.height
						} );
						ctx.scale(  scale, scale );
						ctx.drawImage( img, 0, 0 );
						if( options.revokeUrl ){
							urlEncode.revokeObjectURL( url );
							for( var key in options.url ){
								urlEncode.revokeObjectURL( options.url[ key ] );
							}
						}
						options.done = true;
						options.resolve( { 
							canvas : canvas, 
							image : img, 
							svg : svg, 
							html : data 
						} );
					};

					img.onerror = () => {
						options.reject( 'failed at final image processing' );
					}

					img.src = url;
				};

				fn();

			} catch( e ){
				options.reject( 'stopped at canvas conversion error :' + e.message );
				this.removeInstance();
			}
		},

		convertStringToDom : function( string ){
			var div = this.document().createElement( 'div' );
			div.innerHTML = string;
			return div.children[ 0 ];
		},

		constructPsuedo : function( style, className, name ){
			if( !this.isPseudo( style ) ){
				return "";
			}
			var str = '.' + className + ':' + name + '{' + this.getStyle( style ) + '}';

			return str;
		},

		isPseudo : function( style ){
			if( style ){
				return style.getPropertyValue( 'content' ) != "none";
			}
			return false;
		},

		randomClass : function( ns ){
			var string = [], random,
			len = 20,
			namespace = ns || "LyteScreen";

			for( var i = 0; i < len; i++ ){
				random = 0 | Math.random() * 42;
				string[ i ] = String.fromCharCode( 48 + ( ( random > 9 && random < 18 ) ? ( 18 + random ) : random ) );
			}
			return namespace + string.join( '' );
		},

		callBeforeCallback : function( dom, options ){
			if( options.onBeforeConstruct ){
				options.onBeforeConstruct.call( this, dom );
			}	
			return dom;
		}
	}

	$L.screenGrab = function( options, _window ){
		return new screenGrab( options, _window || window );
	}

	lyteDomObj.prototype.screenGrab = function( arg, key ){

		switch( arg ){
			case 'stop' : {
				var len = this.length,
				fn = item => {
					if( !item.options.done ){
						item.options.reject( 'stopped from code' );
					}
					item.removeInstance();
				};
				for( var i = 0; i < len; i++ ){
					var instance = this.get( i ).__lytescreengrab || [];
					instance.forEach( fn );
				}
			}
			break;
			case 'isActive' : {
				return !!( this.get( 0 ).__lytescreengrab || [] ).length;
			}
			break;
			case 'remove' : {
				if( key ){
					delete request_mapping[ key ];
				} else {
					request_mapping = {};
				}
			}
			break;
		}
		return this;
	}

} )( window );