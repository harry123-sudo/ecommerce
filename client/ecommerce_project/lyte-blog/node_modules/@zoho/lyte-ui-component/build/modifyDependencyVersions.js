const fs = require('fs');
const path = require('path');
const option = process.argv[2];
// Variables
const PACKAGES_TO_WATCH = [

]
const pathFor = {
  package: path.join(__dirname, '../package.json'),
  packageLock: path.join(__dirname, '../package-lock.json'),
  tempPackage: path.join(__dirname, './package.temp.json')
}
const package = {};
const packageLock = {};

// Actual Code

switch (option) {
  case 'uncap': {
    if (fs.existsSync(pathFor.package)) {
      Object.assign(package, require(pathFor.package));
    }
    if (fs.existsSync(pathFor.packageLock)) {
      Object.assign(packageLock, require(pathFor.packageLock));
    }

    fs.copyFileSync(pathFor.package, pathFor.tempPackage);

    PACKAGES_TO_WATCH.forEach(function (pkg) {
      if (package.dependencies && package.dependencies[pkg]) {
        if (packageLock.dependencies[pkg]) {
          package.dependencies[pkg] = packageLock.dependencies[pkg].version
        } else {
          throw new Error("Entry for package " + pkg + " is not found in package-lock.json. Do npm install");
        }
      }
      if (package.devDependencies && package.devDependencies[pkg]) {
        if (packageLock.dependencies[pkg]) {
          package.devDependencies[pkg] = packageLock.dependencies[pkg].version
        } else {
          throw new Error("Entry for package " + pkg + " is not found in package-lock.json. Do npm install");
        }
      }
    })

    fs.writeFileSync(pathFor.package, JSON.stringify(package, null, 2));
  }
    break;
  case 'reset': {
    if (fs.existsSync(pathFor.tempPackage)) {
      fs.copyFileSync(pathFor.tempPackage, pathFor.package);
      fs.unlinkSync(pathFor.tempPackage);
    }
  }
    break;
}

